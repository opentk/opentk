// This file is auto generated, do not edit.
using System;
using System.Runtime.InteropServices;
using OpenTK.Graphics;

namespace OpenTK.Graphics.OpenGL.Compatibility
{
    public static unsafe partial class GL
    {
        /// <summary> <b>[requires: v1.0] [glCullFace]</b> Specify whether front- or back-facing facets can be culled. </summary>
        /// <param name="mode"> Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCullFace.xhtml" /></remarks>
        public static void CullFace(TriangleFace mode) => GLPointers._glCullFace_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glFrontFace]</b> Define front- and back-facing polygons. </summary>
        /// <param name="mode"> Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFrontFace.xhtml" /></remarks>
        public static void FrontFace(FrontFaceDirection mode) => GLPointers._glFrontFace_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glHint]</b> Specify implementation-specific hints. </summary>
        /// <param name="target"> Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted. </param>
        /// <param name="mode"> Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glHint.xhtml" /></remarks>
        public static void Hint(HintTarget target, HintMode mode) => GLPointers._glHint_fnptr((uint)target, (uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glLineWidth]</b> Specify the width of rasterized lines. </summary>
        /// <param name="width"> Specifies the width of rasterized lines. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLineWidth.xhtml" /></remarks>
        public static void LineWidth(float width) => GLPointers._glLineWidth_fnptr(width);
        
        /// <summary> <b>[requires: v1.0] [glPointSize]</b> Specify the diameter of rasterized points. </summary>
        /// <param name="size"> Specifies the diameter of rasterized points. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointSize.xhtml" /></remarks>
        public static void PointSize(float size) => GLPointers._glPointSize_fnptr(size);
        
        /// <summary> <b>[requires: v1.0] [glPolygonMode]</b> Select a polygon rasterization mode. </summary>
        /// <param name="face"> Specifies the polygons that mode applies to. Must be GL_FRONT_AND_BACK for front- and back-facing polygons. </param>
        /// <param name="mode"> Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The initial value is GL_FILL for both front- and back-facing polygons. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonMode.xhtml" /></remarks>
        public static void PolygonMode(TriangleFace face, PolygonMode mode) => GLPointers._glPolygonMode_fnptr((uint)face, (uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glScissor]</b> Define the scissor box. </summary>
        /// <param name="x"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="y"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="width"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissor.xhtml" /></remarks>
        public static void Scissor(int x, int y, int width, int height) => GLPointers._glScissor_fnptr(x, y, width, height);
        
        /// <summary> <b>[requires: v1.0] [glTexParameterf]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterf(TextureTarget target, TextureParameterName pname, float param) => GLPointers._glTexParameterf_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glTexParameterfv]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterfv(TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers._glTexParameterfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glTexParameteri]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameteri(TextureTarget target, TextureParameterName pname, int param) => GLPointers._glTexParameteri_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glTexParameteriv]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameteriv(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTexParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glTexImage1D]</b> Specify a one-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage1D.xhtml" /></remarks>
        public static void TexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage1D_fnptr((uint)target, level, (int)internalformat, width, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0] [glTexImage2D]</b> Specify a two-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml" /></remarks>
        public static void TexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage2D_fnptr((uint)target, level, (int)internalformat, width, height, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0] [glDrawBuffer]</b> Specify which color buffers are to be drawn into. </summary>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
        public static void DrawBuffer(DrawBufferMode buf) => GLPointers._glDrawBuffer_fnptr((uint)buf);
        
        /// <summary> <b>[requires: v1.0] [glClear]</b> Clear buffers to preset values. </summary>
        /// <param name="mask"> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml" /></remarks>
        public static void Clear(ClearBufferMask mask) => GLPointers._glClear_fnptr((uint)mask);
        
        /// <summary> <b>[requires: v1.0] [glClearColor]</b> Specify clear values for the color buffers. </summary>
        /// <param name="red"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="green"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="blue"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="alpha"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml" /></remarks>
        public static void ClearColor(float red, float green, float blue, float alpha) => GLPointers._glClearColor_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glClearStencil]</b> Specify the clear value for the stencil buffer. </summary>
        /// <param name="s"> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearStencil.xhtml" /></remarks>
        public static void ClearStencil(int s) => GLPointers._glClearStencil_fnptr(s);
        
        /// <summary> <b>[requires: v1.0] [glClearDepth]</b> Specify the clear value for the depth buffer. </summary>
        /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
        public static void ClearDepth(double depth) => GLPointers._glClearDepth_fnptr(depth);
        
        /// <summary> <b>[requires: v1.0] [glStencilMask]</b> Control the front and back writing of individual bits in the stencil planes. </summary>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMask.xhtml" /></remarks>
        public static void StencilMask(uint mask) => GLPointers._glStencilMask_fnptr(mask);
        
        /// <summary> <b>[requires: v1.0] [glColorMask]</b> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="red"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="green"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="blue"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="alpha"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml" /></remarks>
        public static void ColorMask(bool red, bool green, bool blue, bool alpha) => GLPointers._glColorMask_fnptr((byte)(red ? 1 : 0), (byte)(green ? 1 : 0), (byte)(blue ? 1 : 0), (byte)(alpha ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0] [glDepthMask]</b> Enable or disable writing into the depth buffer. </summary>
        /// <param name="flag"> Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthMask.xhtml" /></remarks>
        public static void DepthMask(bool flag) => GLPointers._glDepthMask_fnptr((byte)(flag ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0] [glDisable]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Disable(EnableCap cap) => GLPointers._glDisable_fnptr((uint)cap);
        
        /// <summary> <b>[requires: v1.0] [glEnable]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Enable(EnableCap cap) => GLPointers._glEnable_fnptr((uint)cap);
        
        /// <summary> <b>[requires: v1.0] [glFinish]</b> Block until all GL execution is complete. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFinish.xhtml" /></remarks>
        public static void Finish() => GLPointers._glFinish_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glFlush]</b> Force execution of GL commands in finite time. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlush.xhtml" /></remarks>
        public static void Flush() => GLPointers._glFlush_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glBlendFunc]</b> Specify pixel arithmetic. </summary>
        /// <param name="sfactor"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactor"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" /></remarks>
        public static void BlendFunc(BlendingFactor sfactor, BlendingFactor dfactor) => GLPointers._glBlendFunc_fnptr((uint)sfactor, (uint)dfactor);
        
        /// <summary> <b>[requires: v1.0] [glLogicOp]</b> Specify a logical pixel operation for rendering. </summary>
        /// <param name="opcode"> Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLogicOp.xhtml" /></remarks>
        public static void LogicOp(LogicOp opcode) => GLPointers._glLogicOp_fnptr((uint)opcode);
        
        /// <summary> <b>[requires: v1.0] [glStencilFunc]</b> Set front and back function and reference value for stencil testing. </summary>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml" /></remarks>
        public static void StencilFunc(StencilFunction func, int reference, uint mask) => GLPointers._glStencilFunc_fnptr((uint)func, reference, mask);
        
        /// <summary> <b>[requires: v1.0] [glStencilOp]</b> Set front and back stencil test actions. </summary>
        /// <param name="sfail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="dpfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="dppass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOp.xhtml" /></remarks>
        public static void StencilOp(StencilOp fail, StencilOp zfail, StencilOp zpass) => GLPointers._glStencilOp_fnptr((uint)fail, (uint)zfail, (uint)zpass);
        
        /// <summary> <b>[requires: v1.0] [glDepthFunc]</b> Specify the value used for depth buffer comparisons. </summary>
        /// <param name="func"> Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml" /></remarks>
        public static void DepthFunc(DepthFunction func) => GLPointers._glDepthFunc_fnptr((uint)func);
        
        /// <summary> <b>[requires: v1.0] [glPixelStoref]</b> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml" /></remarks>
        public static void PixelStoref(PixelStoreParameter pname, float param) => GLPointers._glPixelStoref_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glPixelStorei]</b> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml" /></remarks>
        public static void PixelStorei(PixelStoreParameter pname, int param) => GLPointers._glPixelStorei_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glReadBuffer]</b> Select a color buffer source for pixels. </summary>
        /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
        public static void ReadBuffer(ReadBufferMode src) => GLPointers._glReadBuffer_fnptr((uint)src);
        
        /// <summary> <b>[requires: v1.0] [glReadPixels]</b> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="data">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
        public static void ReadPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glReadPixels_fnptr(x, y, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0] [glGetBooleanv]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetBooleanv(GetPName pname, bool* data) => GLPointers._glGetBooleanv_fnptr((uint)pname, (byte*)data);
        
        /// <summary> <b>[requires: v1.0] [glGetDoublev]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetDoublev(GetPName pname, double* data) => GLPointers._glGetDoublev_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v1.0] [glGetError]</b> Return error information. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetError.xhtml" /></remarks>
        public static ErrorCode GetError() => (ErrorCode) GLPointers._glGetError_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glGetFloatv]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetFloatv(GetPName pname, float* data) => GLPointers._glGetFloatv_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v1.0] [glGetIntegerv]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetIntegerv(GetPName pname, int* data) => GLPointers._glGetIntegerv_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v1.0] [glGetString]</b> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml" /></remarks>
        public static byte* GetString_(StringName name) => GLPointers._glGetString_fnptr((uint)name);
        
        /// <summary> <b>[requires: v1.0] [glGetTexImage]</b> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers._glGetTexImage_fnptr((uint)target, level, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0] [glGetTexParameterfv]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterfv(TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers._glGetTexParameterfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetTexParameteriv]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameteriv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetTexLevelParameterfv]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTexLevelParameterfv(TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetTexLevelParameterfv_fnptr((uint)target, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetTexLevelParameteriv]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTexLevelParameteriv(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexLevelParameteriv_fnptr((uint)target, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glIsEnabled]</b> Test whether a capability is enabled. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml" /></remarks>
        public static bool IsEnabled(EnableCap cap) => GLPointers._glIsEnabled_fnptr((uint)cap) != 0;
        
        /// <summary> <b>[requires: v1.0] [glDepthRange]</b> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
        public static void DepthRange(double n, double f) => GLPointers._glDepthRange_fnptr(n, f);
        
        /// <summary> <b>[requires: v1.0] [glViewport]</b> Set the viewport. </summary>
        /// <param name="x"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="width"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml" /></remarks>
        public static void Viewport(int x, int y, int width, int height) => GLPointers._glViewport_fnptr(x, y, width, height);
        
        /// <summary> <b>[requires: v1.0] [glNewList]</b> Create or replace a display list. </summary>
        /// <param name="list"> Specifies the display-list name. </param>
        /// <param name="mode"> Specifies the compilation mode, which can be GL_COMPILE or GL_COMPILE_AND_EXECUTE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNewList.xml" /></remarks>
        public static void NewList(int list, ListMode mode) => GLPointers._glNewList_fnptr(list, (uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glEndList]</b>  </summary>
        public static void EndList() => GLPointers._glEndList_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glCallList]</b> Execute a display list. </summary>
        /// <param name="list"> Specifies the integer name of the display list to be executed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCallList.xml" /></remarks>
        public static void CallList(int list) => GLPointers._glCallList_fnptr(list);
        
        /// <summary> <b>[requires: v1.0] [glCallLists]</b> Execute a list of display lists. </summary>
        /// <param name="n"> Specifies the number of display lists to be executed. </param>
        /// <param name="type"> Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted. </param>
        /// <param name="lists"> Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCallLists.xml" /></remarks>
        public static void CallLists(int n, ListNameType type, void* lists) => GLPointers._glCallLists_fnptr(n, (uint)type, lists);
        
        /// <summary> <b>[requires: v1.0] [glDeleteLists]</b> Delete a contiguous group of display lists. </summary>
        /// <param name="list"> Specifies the integer name of the first display list to delete. </param>
        /// <param name="range"> Specifies the number of display lists to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDeleteLists.xml" /></remarks>
        public static void DeleteLists(int list, int range) => GLPointers._glDeleteLists_fnptr(list, range);
        
        /// <summary> <b>[requires: v1.0] [glGenLists]</b> Generate a contiguous set of empty display lists. </summary>
        /// <param name="range"> Specifies the number of contiguous empty display lists to be generated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGenLists.xml" /></remarks>
        public static int GenLists(int range) => GLPointers._glGenLists_fnptr(range);
        
        /// <summary> <b>[requires: v1.0] [glListBase]</b> Set the display-list base for glCallLists. </summary>
        /// <param name="@base"> Specifies an integer offset that will be added to glCallLists offsets to generate display-list names. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glListBase.xml" /></remarks>
        public static void ListBase(int @base) => GLPointers._glListBase_fnptr(@base);
        
        /// <summary> <b>[requires: v1.0] [glBegin]</b> Delimit the vertices of a primitive or a group of like primitives. </summary>
        /// <param name="mode"> Specifies the primitive or primitives that will be created from vertices presented between glBegin and the subsequent glEnd. Ten symbolic constants are accepted: GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml" /></remarks>
        public static void Begin(PrimitiveType mode) => GLPointers._glBegin_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glBitmap]</b> Draw a bitmap. </summary>
        /// <param name="width"> Specify the pixel width and height of the bitmap image. </param>
        /// <param name="height"> Specify the pixel width and height of the bitmap image. </param>
        /// <param name="xorig"> Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes. </param>
        /// <param name="yorig"> Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes. </param>
        /// <param name="xmove"> Specify the x and y offsets to be added to the current raster position after the bitmap is drawn. </param>
        /// <param name="ymove"> Specify the x and y offsets to be added to the current raster position after the bitmap is drawn. </param>
        /// <param name="bitmap"> Specifies the address of the bitmap image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBitmap.xml" /></remarks>
        public static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte* bitmap) => GLPointers._glBitmap_fnptr(width, height, xorig, yorig, xmove, ymove, bitmap);
        
        /// <summary> <b>[requires: v1.0] [glColor3b]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3b(sbyte red, sbyte green, sbyte blue) => GLPointers._glColor3b_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0] [glColor3bv]</b>  </summary>
        public static void Color3bv(sbyte* v) => GLPointers._glColor3bv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor3d]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3d(double red, double green, double blue) => GLPointers._glColor3d_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0] [glColor3dv]</b>  </summary>
        public static void Color3dv(double* v) => GLPointers._glColor3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor3f]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3f(float red, float green, float blue) => GLPointers._glColor3f_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0] [glColor3fv]</b>  </summary>
        public static void Color3fv(float* v) => GLPointers._glColor3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor3i]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3i(int red, int green, int blue) => GLPointers._glColor3i_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0] [glColor3iv]</b>  </summary>
        public static void Color3iv(int* v) => GLPointers._glColor3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor3s]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3s(short red, short green, short blue) => GLPointers._glColor3s_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0] [glColor3sv]</b>  </summary>
        public static void Color3sv(short* v) => GLPointers._glColor3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor3ub]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3ub(byte red, byte green, byte blue) => GLPointers._glColor3ub_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0] [glColor3ubv]</b>  </summary>
        public static void Color3ubv(byte* v) => GLPointers._glColor3ubv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor3ui]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3ui(uint red, uint green, uint blue) => GLPointers._glColor3ui_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0] [glColor3uiv]</b>  </summary>
        public static void Color3uiv(uint* v) => GLPointers._glColor3uiv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor3us]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3us(ushort red, ushort green, ushort blue) => GLPointers._glColor3us_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0] [glColor3usv]</b>  </summary>
        public static void Color3usv(ushort* v) => GLPointers._glColor3usv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor4b]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4b(sbyte red, sbyte green, sbyte blue, sbyte alpha) => GLPointers._glColor4b_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glColor4bv]</b>  </summary>
        public static void Color4bv(sbyte* v) => GLPointers._glColor4bv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor4d]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4d(double red, double green, double blue, double alpha) => GLPointers._glColor4d_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glColor4dv]</b>  </summary>
        public static void Color4dv(double* v) => GLPointers._glColor4dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor4f]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4f(float red, float green, float blue, float alpha) => GLPointers._glColor4f_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glColor4fv]</b>  </summary>
        public static void Color4fv(float* v) => GLPointers._glColor4fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor4i]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4i(int red, int green, int blue, int alpha) => GLPointers._glColor4i_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glColor4iv]</b>  </summary>
        public static void Color4iv(int* v) => GLPointers._glColor4iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor4s]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4s(short red, short green, short blue, short alpha) => GLPointers._glColor4s_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glColor4sv]</b>  </summary>
        public static void Color4sv(short* v) => GLPointers._glColor4sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor4ub]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4ub(byte red, byte green, byte blue, byte alpha) => GLPointers._glColor4ub_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glColor4ubv]</b>  </summary>
        public static void Color4ubv(byte* v) => GLPointers._glColor4ubv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor4ui]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4ui(uint red, uint green, uint blue, uint alpha) => GLPointers._glColor4ui_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glColor4uiv]</b>  </summary>
        public static void Color4uiv(uint* v) => GLPointers._glColor4uiv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glColor4us]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4us(ushort red, ushort green, ushort blue, ushort alpha) => GLPointers._glColor4us_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glColor4usv]</b>  </summary>
        public static void Color4usv(ushort* v) => GLPointers._glColor4usv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glEdgeFlag]</b> Flag edges as either boundary or nonboundary. </summary>
        /// <param name="flag"> Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEdgeFlag.xml" /></remarks>
        public static void EdgeFlag(bool flag) => GLPointers._glEdgeFlag_fnptr((byte)(flag ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0] [glEdgeFlagv]</b>  </summary>
        public static void EdgeFlagv(bool* flag) => GLPointers._glEdgeFlagv_fnptr((byte*)flag);
        
        /// <summary> <b>[requires: v1.0] [glEnd]</b>  </summary>
        public static void End() => GLPointers._glEnd_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glIndexd]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexd(double c) => GLPointers._glIndexd_fnptr(c);
        
        /// <summary> <b>[requires: v1.0] [glIndexdv]</b>  </summary>
        public static void Indexdv(double* c) => GLPointers._glIndexdv_fnptr(c);
        
        /// <summary> <b>[requires: v1.0] [glIndexf]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexf(float c) => GLPointers._glIndexf_fnptr(c);
        
        /// <summary> <b>[requires: v1.0] [glIndexfv]</b>  </summary>
        public static void Indexfv(float* c) => GLPointers._glIndexfv_fnptr(c);
        
        /// <summary> <b>[requires: v1.0] [glIndexi]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexi(int c) => GLPointers._glIndexi_fnptr(c);
        
        /// <summary> <b>[requires: v1.0] [glIndexiv]</b>  </summary>
        public static void Indexiv(int* c) => GLPointers._glIndexiv_fnptr(c);
        
        /// <summary> <b>[requires: v1.0] [glIndexs]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexs(short c) => GLPointers._glIndexs_fnptr(c);
        
        /// <summary> <b>[requires: v1.0] [glIndexsv]</b>  </summary>
        public static void Indexsv(short* c) => GLPointers._glIndexsv_fnptr(c);
        
        /// <summary> <b>[requires: v1.0] [glNormal3b]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3b(sbyte nx, sbyte ny, sbyte nz) => GLPointers._glNormal3b_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0] [glNormal3bv]</b>  </summary>
        public static void Normal3bv(sbyte* v) => GLPointers._glNormal3bv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glNormal3d]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3d(double nx, double ny, double nz) => GLPointers._glNormal3d_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0] [glNormal3dv]</b>  </summary>
        public static void Normal3dv(double* v) => GLPointers._glNormal3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glNormal3f]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3f(float nx, float ny, float nz) => GLPointers._glNormal3f_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0] [glNormal3fv]</b>  </summary>
        public static void Normal3fv(float* v) => GLPointers._glNormal3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glNormal3i]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3i(int nx, int ny, int nz) => GLPointers._glNormal3i_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0] [glNormal3iv]</b>  </summary>
        public static void Normal3iv(int* v) => GLPointers._glNormal3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glNormal3s]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3s(short nx, short ny, short nz) => GLPointers._glNormal3s_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0] [glNormal3sv]</b>  </summary>
        public static void Normal3sv(short* v) => GLPointers._glNormal3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos2d]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2d(double x, double y) => GLPointers._glRasterPos2d_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos2dv]</b>  </summary>
        public static void RasterPos2dv(double* v) => GLPointers._glRasterPos2dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos2f]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2f(float x, float y) => GLPointers._glRasterPos2f_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos2fv]</b>  </summary>
        public static void RasterPos2fv(float* v) => GLPointers._glRasterPos2fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos2i]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2i(int x, int y) => GLPointers._glRasterPos2i_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos2iv]</b>  </summary>
        public static void RasterPos2iv(int* v) => GLPointers._glRasterPos2iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos2s]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2s(short x, short y) => GLPointers._glRasterPos2s_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos2sv]</b>  </summary>
        public static void RasterPos2sv(short* v) => GLPointers._glRasterPos2sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos3d]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3d(double x, double y, double z) => GLPointers._glRasterPos3d_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos3dv]</b>  </summary>
        public static void RasterPos3dv(double* v) => GLPointers._glRasterPos3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos3f]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3f(float x, float y, float z) => GLPointers._glRasterPos3f_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos3fv]</b>  </summary>
        public static void RasterPos3fv(float* v) => GLPointers._glRasterPos3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos3i]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3i(int x, int y, int z) => GLPointers._glRasterPos3i_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos3iv]</b>  </summary>
        public static void RasterPos3iv(int* v) => GLPointers._glRasterPos3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos3s]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3s(short x, short y, short z) => GLPointers._glRasterPos3s_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos3sv]</b>  </summary>
        public static void RasterPos3sv(short* v) => GLPointers._glRasterPos3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos4d]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4d(double x, double y, double z, double w) => GLPointers._glRasterPos4d_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos4dv]</b>  </summary>
        public static void RasterPos4dv(double* v) => GLPointers._glRasterPos4dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos4f]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4f(float x, float y, float z, float w) => GLPointers._glRasterPos4f_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos4fv]</b>  </summary>
        public static void RasterPos4fv(float* v) => GLPointers._glRasterPos4fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos4i]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4i(int x, int y, int z, int w) => GLPointers._glRasterPos4i_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos4iv]</b>  </summary>
        public static void RasterPos4iv(int* v) => GLPointers._glRasterPos4iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos4s]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4s(short x, short y, short z, short w) => GLPointers._glRasterPos4s_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0] [glRasterPos4sv]</b>  </summary>
        public static void RasterPos4sv(short* v) => GLPointers._glRasterPos4sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glRectd]</b> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Rectd(double x1, double y1, double x2, double y2) => GLPointers._glRectd_fnptr(x1, y1, x2, y2);
        
        /// <summary> <b>[requires: v1.0] [glRectdv]</b>  </summary>
        public static void Rectdv(double* v1, double* v2) => GLPointers._glRectdv_fnptr(v1, v2);
        
        /// <summary> <b>[requires: v1.0] [glRectf]</b> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Rectf(float x1, float y1, float x2, float y2) => GLPointers._glRectf_fnptr(x1, y1, x2, y2);
        
        /// <summary> <b>[requires: v1.0] [glRectfv]</b>  </summary>
        public static void Rectfv(float* v1, float* v2) => GLPointers._glRectfv_fnptr(v1, v2);
        
        /// <summary> <b>[requires: v1.0] [glRecti]</b> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Recti(int x1, int y1, int x2, int y2) => GLPointers._glRecti_fnptr(x1, y1, x2, y2);
        
        /// <summary> <b>[requires: v1.0] [glRectiv]</b>  </summary>
        public static void Rectiv(int* v1, int* v2) => GLPointers._glRectiv_fnptr(v1, v2);
        
        /// <summary> <b>[requires: v1.0] [glRects]</b> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Rects(short x1, short y1, short x2, short y2) => GLPointers._glRects_fnptr(x1, y1, x2, y2);
        
        /// <summary> <b>[requires: v1.0] [glRectsv]</b>  </summary>
        public static void Rectsv(short* v1, short* v2) => GLPointers._glRectsv_fnptr(v1, v2);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord1d]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1d(double s) => GLPointers._glTexCoord1d_fnptr(s);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord1dv]</b>  </summary>
        public static void TexCoord1dv(double* v) => GLPointers._glTexCoord1dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord1f]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1f(float s) => GLPointers._glTexCoord1f_fnptr(s);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord1fv]</b>  </summary>
        public static void TexCoord1fv(float* v) => GLPointers._glTexCoord1fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord1i]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1i(int s) => GLPointers._glTexCoord1i_fnptr(s);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord1iv]</b>  </summary>
        public static void TexCoord1iv(int* v) => GLPointers._glTexCoord1iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord1s]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1s(short s) => GLPointers._glTexCoord1s_fnptr(s);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord1sv]</b>  </summary>
        public static void TexCoord1sv(short* v) => GLPointers._glTexCoord1sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord2d]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2d(double s, double t) => GLPointers._glTexCoord2d_fnptr(s, t);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord2dv]</b>  </summary>
        public static void TexCoord2dv(double* v) => GLPointers._glTexCoord2dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord2f]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2f(float s, float t) => GLPointers._glTexCoord2f_fnptr(s, t);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord2fv]</b>  </summary>
        public static void TexCoord2fv(float* v) => GLPointers._glTexCoord2fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord2i]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2i(int s, int t) => GLPointers._glTexCoord2i_fnptr(s, t);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord2iv]</b>  </summary>
        public static void TexCoord2iv(int* v) => GLPointers._glTexCoord2iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord2s]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2s(short s, short t) => GLPointers._glTexCoord2s_fnptr(s, t);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord2sv]</b>  </summary>
        public static void TexCoord2sv(short* v) => GLPointers._glTexCoord2sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord3d]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3d(double s, double t, double r) => GLPointers._glTexCoord3d_fnptr(s, t, r);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord3dv]</b>  </summary>
        public static void TexCoord3dv(double* v) => GLPointers._glTexCoord3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord3f]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3f(float s, float t, float r) => GLPointers._glTexCoord3f_fnptr(s, t, r);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord3fv]</b>  </summary>
        public static void TexCoord3fv(float* v) => GLPointers._glTexCoord3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord3i]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3i(int s, int t, int r) => GLPointers._glTexCoord3i_fnptr(s, t, r);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord3iv]</b>  </summary>
        public static void TexCoord3iv(int* v) => GLPointers._glTexCoord3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord3s]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3s(short s, short t, short r) => GLPointers._glTexCoord3s_fnptr(s, t, r);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord3sv]</b>  </summary>
        public static void TexCoord3sv(short* v) => GLPointers._glTexCoord3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord4d]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4d(double s, double t, double r, double q) => GLPointers._glTexCoord4d_fnptr(s, t, r, q);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord4dv]</b>  </summary>
        public static void TexCoord4dv(double* v) => GLPointers._glTexCoord4dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord4f]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4f(float s, float t, float r, float q) => GLPointers._glTexCoord4f_fnptr(s, t, r, q);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord4fv]</b>  </summary>
        public static void TexCoord4fv(float* v) => GLPointers._glTexCoord4fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord4i]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4i(int s, int t, int r, int q) => GLPointers._glTexCoord4i_fnptr(s, t, r, q);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord4iv]</b>  </summary>
        public static void TexCoord4iv(int* v) => GLPointers._glTexCoord4iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord4s]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4s(short s, short t, short r, short q) => GLPointers._glTexCoord4s_fnptr(s, t, r, q);
        
        /// <summary> <b>[requires: v1.0] [glTexCoord4sv]</b>  </summary>
        public static void TexCoord4sv(short* v) => GLPointers._glTexCoord4sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex2d]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2d(double x, double y) => GLPointers._glVertex2d_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0] [glVertex2dv]</b>  </summary>
        public static void Vertex2dv(double* v) => GLPointers._glVertex2dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex2f]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2f(float x, float y) => GLPointers._glVertex2f_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0] [glVertex2fv]</b>  </summary>
        public static void Vertex2fv(float* v) => GLPointers._glVertex2fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex2i]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2i(int x, int y) => GLPointers._glVertex2i_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0] [glVertex2iv]</b>  </summary>
        public static void Vertex2iv(int* v) => GLPointers._glVertex2iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex2s]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2s(short x, short y) => GLPointers._glVertex2s_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0] [glVertex2sv]</b>  </summary>
        public static void Vertex2sv(short* v) => GLPointers._glVertex2sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex3d]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3d(double x, double y, double z) => GLPointers._glVertex3d_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glVertex3dv]</b>  </summary>
        public static void Vertex3dv(double* v) => GLPointers._glVertex3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex3f]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3f(float x, float y, float z) => GLPointers._glVertex3f_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glVertex3fv]</b>  </summary>
        public static void Vertex3fv(float* v) => GLPointers._glVertex3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex3i]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3i(int x, int y, int z) => GLPointers._glVertex3i_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glVertex3iv]</b>  </summary>
        public static void Vertex3iv(int* v) => GLPointers._glVertex3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex3s]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3s(short x, short y, short z) => GLPointers._glVertex3s_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glVertex3sv]</b>  </summary>
        public static void Vertex3sv(short* v) => GLPointers._glVertex3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex4d]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4d(double x, double y, double z, double w) => GLPointers._glVertex4d_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0] [glVertex4dv]</b>  </summary>
        public static void Vertex4dv(double* v) => GLPointers._glVertex4dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex4f]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4f(float x, float y, float z, float w) => GLPointers._glVertex4f_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0] [glVertex4fv]</b>  </summary>
        public static void Vertex4fv(float* v) => GLPointers._glVertex4fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex4i]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4i(int x, int y, int z, int w) => GLPointers._glVertex4i_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0] [glVertex4iv]</b>  </summary>
        public static void Vertex4iv(int* v) => GLPointers._glVertex4iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glVertex4s]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4s(short x, short y, short z, short w) => GLPointers._glVertex4s_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0] [glVertex4sv]</b>  </summary>
        public static void Vertex4sv(short* v) => GLPointers._glVertex4sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0] [glClipPlane]</b> Specify a plane against which all geometry is clipped. </summary>
        /// <param name="plane"> Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES -1 , are accepted. </param>
        /// <param name="equation"> Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClipPlane.xml" /></remarks>
        public static void ClipPlane(ClipPlaneName plane, double* equation) => GLPointers._glClipPlane_fnptr((uint)plane, equation);
        
        /// <summary> <b>[requires: v1.0] [glColorMaterial]</b> Cause a material color to track the current color. </summary>
        /// <param name="face"> Specifies whether front, back, or both front and back material parameters should track the current color. Accepted values are GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. The initial value is GL_FRONT_AND_BACK. </param>
        /// <param name="mode"> Specifies which of several material parameters track the current color. Accepted values are GL_EMISSION, GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, and GL_AMBIENT_AND_DIFFUSE. The initial value is GL_AMBIENT_AND_DIFFUSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorMaterial.xml" /></remarks>
        public static void ColorMaterial(TriangleFace face, ColorMaterialParameter mode) => GLPointers._glColorMaterial_fnptr((uint)face, (uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glFogf]</b> Specify fog parameters. </summary>
        /// <param name="pname"> Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted. </param>
        /// <param name="param"> Specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFog.xml" /></remarks>
        public static void Fogf(FogParameter pname, float param) => GLPointers._glFogf_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glFogfv]</b>  </summary>
        public static void Fogfv(FogParameter pname, float* parameters) => GLPointers._glFogfv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glFogi]</b> Specify fog parameters. </summary>
        /// <param name="pname"> Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted. </param>
        /// <param name="param"> Specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFog.xml" /></remarks>
        public static void Fogi(FogParameter pname, int param) => GLPointers._glFogi_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glFogiv]</b>  </summary>
        public static void Fogiv(FogParameter pname, int* parameters) => GLPointers._glFogiv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glLightf]</b> Set light source parameters. </summary>
        /// <param name="light"> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted. </param>
        /// <param name="param"> Specifies the value that parameter pname of light source light will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLight.xml" /></remarks>
        public static void Lightf(LightName light, LightParameter pname, float param) => GLPointers._glLightf_fnptr((uint)light, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glLightfv]</b>  </summary>
        public static void Lightfv(LightName light, LightParameter pname, float* parameters) => GLPointers._glLightfv_fnptr((uint)light, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glLighti]</b> Set light source parameters. </summary>
        /// <param name="light"> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted. </param>
        /// <param name="param"> Specifies the value that parameter pname of light source light will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLight.xml" /></remarks>
        public static void Lighti(LightName light, LightParameter pname, int param) => GLPointers._glLighti_fnptr((uint)light, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glLightiv]</b>  </summary>
        public static void Lightiv(LightName light, LightParameter pname, int* parameters) => GLPointers._glLightiv_fnptr((uint)light, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glLightModelf]</b> Set the lighting model parameters. </summary>
        /// <param name="pname"> Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted. </param>
        /// <param name="param"> Specifies the value that param will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLightModel.xml" /></remarks>
        public static void LightModelf(LightModelParameter pname, float param) => GLPointers._glLightModelf_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glLightModelfv]</b>  </summary>
        public static void LightModelfv(LightModelParameter pname, float* parameters) => GLPointers._glLightModelfv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glLightModeli]</b> Set the lighting model parameters. </summary>
        /// <param name="pname"> Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted. </param>
        /// <param name="param"> Specifies the value that param will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLightModel.xml" /></remarks>
        public static void LightModeli(LightModelParameter pname, int param) => GLPointers._glLightModeli_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glLightModeliv]</b>  </summary>
        public static void LightModeliv(LightModelParameter pname, int* parameters) => GLPointers._glLightModeliv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glLineStipple]</b> Specify the line stipple pattern. </summary>
        /// <param name="factor"> Specifies a multiplier for each bit in the line stipple pattern. If factor is 3, for example, each bit in the pattern is used three times before the next bit in the pattern is used. factor is clamped to the range [1, 256] and defaults to 1. </param>
        /// <param name="pattern"> Specifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized. Bit zero is used first; the default pattern is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLineStipple.xml" /></remarks>
        public static void LineStipple(int factor, ushort pattern) => GLPointers._glLineStipple_fnptr(factor, pattern);
        
        /// <summary> <b>[requires: v1.0] [glMaterialf]</b> Specify material parameters for the lighting model. </summary>
        /// <param name="face"> Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. </param>
        /// <param name="pname"> Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS. </param>
        /// <param name="param"> Specifies the value that parameter GL_SHININESS will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMaterial.xml" /></remarks>
        public static void Materialf(TriangleFace face, MaterialParameter pname, float param) => GLPointers._glMaterialf_fnptr((uint)face, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glMaterialfv]</b>  </summary>
        public static void Materialfv(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers._glMaterialfv_fnptr((uint)face, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glMateriali]</b> Specify material parameters for the lighting model. </summary>
        /// <param name="face"> Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. </param>
        /// <param name="pname"> Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS. </param>
        /// <param name="param"> Specifies the value that parameter GL_SHININESS will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMaterial.xml" /></remarks>
        public static void Materiali(TriangleFace face, MaterialParameter pname, int param) => GLPointers._glMateriali_fnptr((uint)face, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glMaterialiv]</b>  </summary>
        public static void Materialiv(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glMaterialiv_fnptr((uint)face, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glPolygonStipple]</b> Set the polygon stippling pattern. </summary>
        /// <param name="pattern"> Specifies a pointer to a 32 32 stipple pattern that will be unpacked from memory in the same way that glDrawPixels unpacks pixels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPolygonStipple.xml" /></remarks>
        public static void PolygonStipple(byte* mask) => GLPointers._glPolygonStipple_fnptr(mask);
        
        /// <summary> <b>[requires: v1.0] [glShadeModel]</b> Select flat or smooth shading. </summary>
        /// <param name="mode"> Specifies a symbolic value representing a shading technique. Accepted values are GL_FLAT and GL_SMOOTH. The initial value is GL_SMOOTH. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glShadeModel.xml" /></remarks>
        public static void ShadeModel(ShadingModel mode) => GLPointers._glShadeModel_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glTexEnvf]</b> Set texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="param"> Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml" /></remarks>
        public static void TexEnvf(TextureEnvTarget target, TextureEnvParameter pname, float param) => GLPointers._glTexEnvf_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glTexEnvfv]</b>  </summary>
        public static void TexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._glTexEnvfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glTexEnvi]</b> Set texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="param"> Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml" /></remarks>
        public static void TexEnvi(TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers._glTexEnvi_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glTexEnviv]</b>  </summary>
        public static void TexEnviv(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glTexEnviv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glTexGend]</b> Control the generation of texture coordinates. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE. </param>
        /// <param name="param"> Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexGen.xml" /></remarks>
        public static void TexGend(TextureCoordName coord, TextureGenParameter pname, double param) => GLPointers._glTexGend_fnptr((uint)coord, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glTexGendv]</b>  </summary>
        public static void TexGendv(TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._glTexGendv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glTexGenf]</b> Control the generation of texture coordinates. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE. </param>
        /// <param name="param"> Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexGen.xml" /></remarks>
        public static void TexGenf(TextureCoordName coord, TextureGenParameter pname, float param) => GLPointers._glTexGenf_fnptr((uint)coord, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glTexGenfv]</b>  </summary>
        public static void TexGenfv(TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._glTexGenfv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glTexGeni]</b> Control the generation of texture coordinates. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE. </param>
        /// <param name="param"> Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexGen.xml" /></remarks>
        public static void TexGeni(TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers._glTexGeni_fnptr((uint)coord, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glTexGeniv]</b>  </summary>
        public static void TexGeniv(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glTexGeniv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glFeedbackBuffer]</b> Controls feedback mode. </summary>
        /// <param name="size"> Specifies the maximum number of values that can be written into buffer. </param>
        /// <param name="type"> Specifies a symbolic constant that describes the information that will be returned for each vertex. GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted. </param>
        /// <param name="buffer"> Returns the feedback data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFeedbackBuffer.xml" /></remarks>
        public static void FeedbackBuffer(int size, FeedbackType type, float* buffer) => GLPointers._glFeedbackBuffer_fnptr(size, (uint)type, buffer);
        
        /// <summary> <b>[requires: v1.0] [glSelectBuffer]</b> Establish a buffer for selection mode values. </summary>
        /// <param name="size"> Specifies the size of buffer. </param>
        /// <param name="buffer"> Returns the selection data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSelectBuffer.xml" /></remarks>
        public static void SelectBuffer(int size, uint* buffer) => GLPointers._glSelectBuffer_fnptr(size, buffer);
        
        /// <summary> <b>[requires: v1.0] [glRenderMode]</b> Set rasterization mode. </summary>
        /// <param name="mode"> Specifies the rasterization mode. Three values are accepted: GL_RENDER, GL_SELECT, and GL_FEEDBACK. The initial value is GL_RENDER. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRenderMode.xml" /></remarks>
        public static int RenderMode(RenderingMode mode) => GLPointers._glRenderMode_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glInitNames]</b> Initialize the name stack. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glInitNames.xml" /></remarks>
        public static void InitNames() => GLPointers._glInitNames_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glLoadName]</b> Load a name onto the name stack. </summary>
        /// <param name="name"> Specifies a name that will replace the top value on the name stack. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadName.xml" /></remarks>
        public static void LoadName(uint name) => GLPointers._glLoadName_fnptr(name);
        
        /// <summary> <b>[requires: v1.0] [glPassThrough]</b> Place a marker in the feedback buffer. </summary>
        /// <param name="token"> Specifies a marker value to be placed in the feedback buffer following a GL_PASS_THROUGH_TOKEN. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPassThrough.xml" /></remarks>
        public static void PassThrough(float token) => GLPointers._glPassThrough_fnptr(token);
        
        /// <summary> <b>[requires: v1.0] [glPopName]</b>  </summary>
        public static void PopName() => GLPointers._glPopName_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glPushName]</b> Push and pop the name stack. </summary>
        /// <param name="name"> Specifies a name that will be pushed onto the name stack. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushName.xml" /></remarks>
        public static void PushName(uint name) => GLPointers._glPushName_fnptr(name);
        
        /// <summary> <b>[requires: v1.0] [glClearAccum]</b> Specify clear values for the accumulation buffer. </summary>
        /// <param name="red"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <param name="green"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <param name="blue"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <param name="alpha"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearAccum.xml" /></remarks>
        public static void ClearAccum(float red, float green, float blue, float alpha) => GLPointers._glClearAccum_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0] [glClearIndex]</b> Specify the clear value for the color index buffers. </summary>
        /// <param name="c"> Specifies the index used when the color index buffers are cleared. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearIndex.xml" /></remarks>
        public static void ClearIndex(float c) => GLPointers._glClearIndex_fnptr(c);
        
        /// <summary> <b>[requires: v1.0] [glIndexMask]</b> Control the writing of individual bits in the color index buffers. </summary>
        /// <param name="mask"> Specifies a bit mask to enable and disable the writing of individual bits in the color index buffers. Initially, the mask is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndexMask.xml" /></remarks>
        public static void IndexMask(uint mask) => GLPointers._glIndexMask_fnptr(mask);
        
        /// <summary> <b>[requires: v1.0] [glAccum]</b> Operate on the accumulation buffer. </summary>
        /// <param name="op"> Specifies the accumulation buffer operation. Symbolic constants GL_ACCUM, GL_LOAD, GL_ADD, GL_MULT, and GL_RETURN are accepted. </param>
        /// <param name="value"> Specifies a floating-point value used in the accumulation buffer operation. op determines how value is used. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glAccum.xml" /></remarks>
        public static void Accum(AccumOp op, float value) => GLPointers._glAccum_fnptr((uint)op, value);
        
        /// <summary> <b>[requires: v1.0] [glPopAttrib]</b>  </summary>
        public static void PopAttrib() => GLPointers._glPopAttrib_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glPushAttrib]</b> Push and pop the server attribute stack. </summary>
        /// <param name="mask"> Specifies a mask that indicates which attributes to save. Values for mask are listed below. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushAttrib.xml" /></remarks>
        public static void PushAttrib(AttribMask mask) => GLPointers._glPushAttrib_fnptr((uint)mask);
        
        /// <summary> <b>[requires: v1.0] [glMap1d]</b> Define a one-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="stride"> Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. </param>
        /// <param name="order"> Specifies the number of control points. Must be positive. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap1.xml" /></remarks>
        public static void Map1d(MapTarget target, double u1, double u2, int stride, int order, double* points) => GLPointers._glMap1d_fnptr((uint)target, u1, u2, stride, order, points);
        
        /// <summary> <b>[requires: v1.0] [glMap1f]</b> Define a one-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="stride"> Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. </param>
        /// <param name="order"> Specifies the number of control points. Must be positive. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap1.xml" /></remarks>
        public static void Map1f(MapTarget target, float u1, float u2, int stride, int order, float* points) => GLPointers._glMap1f_fnptr((uint)target, u1, u2, stride, order, points);
        
        /// <summary> <b>[requires: v1.0] [glMap2d]</b> Define a two-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="ustride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i + 1 j , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0. </param>
        /// <param name="uorder"> Specifies the dimension of the control point array in the u axis. Must be positive. The initial value is 1. </param>
        /// <param name="v1"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="v2"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="vstride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i j + 1 , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0. </param>
        /// <param name="vorder"> Specifies the dimension of the control point array in the v axis. Must be positive. The initial value is 1. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap2.xml" /></remarks>
        public static void Map2d(MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) => GLPointers._glMap2d_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        
        /// <summary> <b>[requires: v1.0] [glMap2f]</b> Define a two-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="ustride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i + 1 j , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0. </param>
        /// <param name="uorder"> Specifies the dimension of the control point array in the u axis. Must be positive. The initial value is 1. </param>
        /// <param name="v1"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="v2"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="vstride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i j + 1 , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0. </param>
        /// <param name="vorder"> Specifies the dimension of the control point array in the v axis. Must be positive. The initial value is 1. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap2.xml" /></remarks>
        public static void Map2f(MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) => GLPointers._glMap2f_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        
        /// <summary> <b>[requires: v1.0] [glMapGrid1d]</b> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid1d(int un, double u1, double u2) => GLPointers._glMapGrid1d_fnptr(un, u1, u2);
        
        /// <summary> <b>[requires: v1.0] [glMapGrid1f]</b> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid1f(int un, float u1, float u2) => GLPointers._glMapGrid1f_fnptr(un, u1, u2);
        
        /// <summary> <b>[requires: v1.0] [glMapGrid2d]</b> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="vn"> Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only). </param>
        /// <param name="v1"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <param name="v2"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) => GLPointers._glMapGrid2d_fnptr(un, u1, u2, vn, v1, v2);
        
        /// <summary> <b>[requires: v1.0] [glMapGrid2f]</b> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="vn"> Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only). </param>
        /// <param name="v1"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <param name="v2"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) => GLPointers._glMapGrid2f_fnptr(un, u1, u2, vn, v1, v2);
        
        /// <summary> <b>[requires: v1.0] [glEvalCoord1d]</b> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord1d(double u) => GLPointers._glEvalCoord1d_fnptr(u);
        
        /// <summary> <b>[requires: v1.0] [glEvalCoord1dv]</b>  </summary>
        public static void EvalCoord1dv(double* u) => GLPointers._glEvalCoord1dv_fnptr(u);
        
        /// <summary> <b>[requires: v1.0] [glEvalCoord1f]</b> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord1f(float u) => GLPointers._glEvalCoord1f_fnptr(u);
        
        /// <summary> <b>[requires: v1.0] [glEvalCoord1fv]</b>  </summary>
        public static void EvalCoord1fv(float* u) => GLPointers._glEvalCoord1fv_fnptr(u);
        
        /// <summary> <b>[requires: v1.0] [glEvalCoord2d]</b> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <param name="v"> Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord2d(double u, double v) => GLPointers._glEvalCoord2d_fnptr(u, v);
        
        /// <summary> <b>[requires: v1.0] [glEvalCoord2dv]</b>  </summary>
        public static void EvalCoord2dv(double* u) => GLPointers._glEvalCoord2dv_fnptr(u);
        
        /// <summary> <b>[requires: v1.0] [glEvalCoord2f]</b> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <param name="v"> Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord2f(float u, float v) => GLPointers._glEvalCoord2f_fnptr(u, v);
        
        /// <summary> <b>[requires: v1.0] [glEvalCoord2fv]</b>  </summary>
        public static void EvalCoord2fv(float* u) => GLPointers._glEvalCoord2fv_fnptr(u);
        
        /// <summary> <b>[requires: v1.0] [glEvalMesh1]</b> Compute a one- or two-dimensional grid of points or lines. </summary>
        /// <param name="mode"> In glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants GL_POINT and GL_LINE are accepted. </param>
        /// <param name="i1"> Specify the first and last integer values for grid domain variable i. </param>
        /// <param name="i2"> Specify the first and last integer values for grid domain variable i. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalMesh.xml" /></remarks>
        public static void EvalMesh1(MeshMode1 mode, int i1, int i2) => GLPointers._glEvalMesh1_fnptr((uint)mode, i1, i2);
        
        /// <summary> <b>[requires: v1.0] [glEvalPoint1]</b> Generate and evaluate a single point in a mesh. </summary>
        /// <param name="i"> Specifies the integer value for grid domain variable i. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalPoint.xml" /></remarks>
        public static void EvalPoint1(int i) => GLPointers._glEvalPoint1_fnptr(i);
        
        /// <summary> <b>[requires: v1.0] [glEvalMesh2]</b>  </summary>
        public static void EvalMesh2(MeshMode2 mode, int i1, int i2, int j1, int j2) => GLPointers._glEvalMesh2_fnptr((uint)mode, i1, i2, j1, j2);
        
        /// <summary> <b>[requires: v1.0] [glEvalPoint2]</b> Generate and evaluate a single point in a mesh. </summary>
        /// <param name="i"> Specifies the integer value for grid domain variable i. </param>
        /// <param name="j"> Specifies the integer value for grid domain variable j (glEvalPoint2 only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalPoint.xml" /></remarks>
        public static void EvalPoint2(int i, int j) => GLPointers._glEvalPoint2_fnptr(i, j);
        
        /// <summary> <b>[requires: v1.0] [glAlphaFunc]</b> Specify the alpha test function. </summary>
        /// <param name="func"> Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range 0 1 , where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glAlphaFunc.xml" /></remarks>
        public static void AlphaFunc(AlphaFunction func, float reference) => GLPointers._glAlphaFunc_fnptr((uint)func, reference);
        
        /// <summary> <b>[requires: v1.0] [glPixelZoom]</b> Specify the pixel zoom factors. </summary>
        /// <param name="xfactor"> Specify the x and y zoom factors for pixel write operations. </param>
        /// <param name="yfactor"> Specify the x and y zoom factors for pixel write operations. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelZoom.xml" /></remarks>
        public static void PixelZoom(float xfactor, float yfactor) => GLPointers._glPixelZoom_fnptr(xfactor, yfactor);
        
        /// <summary> <b>[requires: v1.0] [glPixelTransferf]</b> Set pixel transfer modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelTransfer.xml" /></remarks>
        public static void PixelTransferf(PixelTransferParameter pname, float param) => GLPointers._glPixelTransferf_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glPixelTransferi]</b> Set pixel transfer modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelTransfer.xml" /></remarks>
        public static void PixelTransferi(PixelTransferParameter pname, int param) => GLPointers._glPixelTransferi_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0] [glPixelMapfv]</b> Set up pixel transfer maps. </summary>
        /// <param name="map"> Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="mapsize"> Specifies the size of the map being defined. </param>
        /// <param name="values"> Specifies an array of mapsize values. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelMap.xml" /></remarks>
        public static void PixelMapfv(PixelMap map, int mapsize, float* values) => GLPointers._glPixelMapfv_fnptr((uint)map, mapsize, values);
        
        /// <summary> <b>[requires: v1.0] [glPixelMapuiv]</b> Set up pixel transfer maps. </summary>
        /// <param name="map"> Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="mapsize"> Specifies the size of the map being defined. </param>
        /// <param name="values"> Specifies an array of mapsize values. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelMap.xml" /></remarks>
        public static void PixelMapuiv(PixelMap map, int mapsize, uint* values) => GLPointers._glPixelMapuiv_fnptr((uint)map, mapsize, values);
        
        /// <summary> <b>[requires: v1.0] [glPixelMapusv]</b> Set up pixel transfer maps. </summary>
        /// <param name="map"> Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="mapsize"> Specifies the size of the map being defined. </param>
        /// <param name="values"> Specifies an array of mapsize values. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelMap.xml" /></remarks>
        public static void PixelMapusv(PixelMap map, int mapsize, ushort* values) => GLPointers._glPixelMapusv_fnptr((uint)map, mapsize, values);
        
        /// <summary> <b>[requires: v1.0] [glCopyPixels]</b> Copy pixels in the frame buffer. </summary>
        /// <param name="x"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="width"> Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative. </param>
        /// <param name="height"> Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative. </param>
        /// <param name="type"> Specifies whether color values, depth values, or stencil values are to be copied. Symbolic constants GL_COLOR, GL_DEPTH, and GL_STENCIL are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyPixels.xml" /></remarks>
        public static void CopyPixels(int x, int y, int width, int height, PixelCopyType type) => GLPointers._glCopyPixels_fnptr(x, y, width, height, (uint)type);
        
        /// <summary> <b>[requires: v1.0] [glDrawPixels]</b> Write a block of pixels to the frame buffer. </summary>
        /// <param name="width"> Specify the dimensions of the pixel rectangle to be written into the frame buffer. </param>
        /// <param name="height"> Specify the dimensions of the pixel rectangle to be written into the frame buffer. </param>
        /// <param name="format"> Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted. </param>
        /// <param name="type"> Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
        /// <param name="data"> Specifies a pointer to the pixel data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDrawPixels.xml" /></remarks>
        public static void DrawPixels(int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glDrawPixels_fnptr(width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0] [glGetClipPlane]</b> Return the coefficients of the specified clipping plane. </summary>
        /// <param name="plane"> Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE i where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1. </param>
        /// <param name="equation"> Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetClipPlane.xml" /></remarks>
        public static void GetClipPlane(ClipPlaneName plane, double* equation) => GLPointers._glGetClipPlane_fnptr((uint)plane, equation);
        
        /// <summary> <b>[requires: v1.0] [glGetLightfv]</b> Return light source parameter values. </summary>
        /// <param name="light"> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetLight.xml" /></remarks>
        public static void GetLightfv(LightName light, LightParameter pname, float* parameters) => GLPointers._glGetLightfv_fnptr((uint)light, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetLightiv]</b> Return light source parameter values. </summary>
        /// <param name="light"> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetLight.xml" /></remarks>
        public static void GetLightiv(LightName light, LightParameter pname, int* parameters) => GLPointers._glGetLightiv_fnptr((uint)light, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetMapdv]</b> Return evaluator parameters. </summary>
        /// <param name="target"> Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4. </param>
        /// <param name="query"> Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted. </param>
        /// <param name="v"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMap.xml" /></remarks>
        public static void GetMapdv(MapTarget target, GetMapQuery query, double* v) => GLPointers._glGetMapdv_fnptr((uint)target, (uint)query, v);
        
        /// <summary> <b>[requires: v1.0] [glGetMapfv]</b> Return evaluator parameters. </summary>
        /// <param name="target"> Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4. </param>
        /// <param name="query"> Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted. </param>
        /// <param name="v"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMap.xml" /></remarks>
        public static void GetMapfv(MapTarget target, GetMapQuery query, float* v) => GLPointers._glGetMapfv_fnptr((uint)target, (uint)query, v);
        
        /// <summary> <b>[requires: v1.0] [glGetMapiv]</b> Return evaluator parameters. </summary>
        /// <param name="target"> Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4. </param>
        /// <param name="query"> Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted. </param>
        /// <param name="v"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMap.xml" /></remarks>
        public static void GetMapiv(MapTarget target, GetMapQuery query, int* v) => GLPointers._glGetMapiv_fnptr((uint)target, (uint)query, v);
        
        /// <summary> <b>[requires: v1.0] [glGetMaterialfv]</b> Return material parameters. </summary>
        /// <param name="face"> Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively. </param>
        /// <param name="pname"> Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMaterial.xml" /></remarks>
        public static void GetMaterialfv(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers._glGetMaterialfv_fnptr((uint)face, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetMaterialiv]</b> Return material parameters. </summary>
        /// <param name="face"> Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively. </param>
        /// <param name="pname"> Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMaterial.xml" /></remarks>
        public static void GetMaterialiv(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glGetMaterialiv_fnptr((uint)face, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetPixelMapfv]</b> Return the specified pixel map. </summary>
        /// <param name="map"> Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="data"> Returns the pixel map contents. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPixelMap.xml" /></remarks>
        public static void GetPixelMapfv(PixelMap map, float* values) => GLPointers._glGetPixelMapfv_fnptr((uint)map, values);
        
        /// <summary> <b>[requires: v1.0] [glGetPixelMapuiv]</b> Return the specified pixel map. </summary>
        /// <param name="map"> Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="data"> Returns the pixel map contents. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPixelMap.xml" /></remarks>
        public static void GetPixelMapuiv(PixelMap map, uint* values) => GLPointers._glGetPixelMapuiv_fnptr((uint)map, values);
        
        /// <summary> <b>[requires: v1.0] [glGetPixelMapusv]</b> Return the specified pixel map. </summary>
        /// <param name="map"> Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="data"> Returns the pixel map contents. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPixelMap.xml" /></remarks>
        public static void GetPixelMapusv(PixelMap map, ushort* values) => GLPointers._glGetPixelMapusv_fnptr((uint)map, values);
        
        /// <summary> <b>[requires: v1.0] [glGetPolygonStipple]</b> Return the polygon stipple pattern. </summary>
        /// <param name="pattern"> Returns the stipple pattern. The initial value is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPolygonStipple.xml" /></remarks>
        public static void GetPolygonStipple(byte* mask) => GLPointers._glGetPolygonStipple_fnptr(mask);
        
        /// <summary> <b>[requires: v1.0] [glGetTexEnvfv]</b> Return texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml" /></remarks>
        public static void GetTexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._glGetTexEnvfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetTexEnviv]</b> Return texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml" /></remarks>
        public static void GetTexEnviv(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glGetTexEnviv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetTexGendv]</b> Return texture coordinate generation parameters. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexGen.xml" /></remarks>
        public static void GetTexGendv(TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._glGetTexGendv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetTexGenfv]</b> Return texture coordinate generation parameters. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexGen.xml" /></remarks>
        public static void GetTexGenfv(TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._glGetTexGenfv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glGetTexGeniv]</b> Return texture coordinate generation parameters. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexGen.xml" /></remarks>
        public static void GetTexGeniv(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glGetTexGeniv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0] [glIsList]</b> Determine if a name corresponds to a display list. </summary>
        /// <param name="list"> Specifies a potential display list name. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIsList.xml" /></remarks>
        public static bool IsList(int list) => GLPointers._glIsList_fnptr(list) != 0;
        
        /// <summary> <b>[requires: v1.0] [glFrustum]</b> Multiply the current matrix by a perspective matrix. </summary>
        /// <param name="left"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="right"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="bottom"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="top"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="nearVal"> Specify the distances to the near and far depth clipping planes. Both distances must be positive. </param>
        /// <param name="farVal"> Specify the distances to the near and far depth clipping planes. Both distances must be positive. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml" /></remarks>
        public static void Frustum(double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glFrustum_fnptr(left, right, bottom, top, zNear, zFar);
        
        /// <summary> <b>[requires: v1.0] [glLoadIdentity]</b> Replace the current matrix with the identity matrix. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml" /></remarks>
        public static void LoadIdentity() => GLPointers._glLoadIdentity_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glLoadMatrixf]</b> Replace the current matrix with the specified matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadMatrix.xml" /></remarks>
        public static void LoadMatrixf(float* m) => GLPointers._glLoadMatrixf_fnptr(m);
        
        /// <summary> <b>[requires: v1.0] [glLoadMatrixd]</b> Replace the current matrix with the specified matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadMatrix.xml" /></remarks>
        public static void LoadMatrixd(double* m) => GLPointers._glLoadMatrixd_fnptr(m);
        
        /// <summary> <b>[requires: v1.0] [glMatrixMode]</b> Specify which matrix is the current matrix. </summary>
        /// <param name="mode"> Specifies which matrix stack is the target for subsequent matrix operations. Three values are accepted: GL_MODELVIEW, GL_PROJECTION, and GL_TEXTURE. The initial value is GL_MODELVIEW. Additionally, if the ARB_imaging extension is supported, GL_COLOR is also accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml" /></remarks>
        public static void MatrixMode(MatrixMode mode) => GLPointers._glMatrixMode_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0] [glMultMatrixf]</b> Multiply the current matrix with the specified matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultMatrix.xml" /></remarks>
        public static void MultMatrixf(float* m) => GLPointers._glMultMatrixf_fnptr(m);
        
        /// <summary> <b>[requires: v1.0] [glMultMatrixd]</b> Multiply the current matrix with the specified matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultMatrix.xml" /></remarks>
        public static void MultMatrixd(double* m) => GLPointers._glMultMatrixd_fnptr(m);
        
        /// <summary> <b>[requires: v1.0] [glOrtho]</b> Multiply the current matrix with an orthographic matrix. </summary>
        /// <param name="left"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="right"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="bottom"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="top"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="nearVal"> Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer. </param>
        /// <param name="farVal"> Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml" /></remarks>
        public static void Ortho(double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glOrtho_fnptr(left, right, bottom, top, zNear, zFar);
        
        /// <summary> <b>[requires: v1.0] [glPopMatrix]</b>  </summary>
        public static void PopMatrix() => GLPointers._glPopMatrix_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glPushMatrix]</b> Push and pop the current matrix stack. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushMatrix.xml" /></remarks>
        public static void PushMatrix() => GLPointers._glPushMatrix_fnptr();
        
        /// <summary> <b>[requires: v1.0] [glRotated]</b> Multiply the current matrix by a rotation matrix. </summary>
        /// <param name="angle"> Specifies the angle of rotation, in degrees. </param>
        /// <param name="x"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml" /></remarks>
        public static void Rotated(double angle, double x, double y, double z) => GLPointers._glRotated_fnptr(angle, x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glRotatef]</b> Multiply the current matrix by a rotation matrix. </summary>
        /// <param name="angle"> Specifies the angle of rotation, in degrees. </param>
        /// <param name="x"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml" /></remarks>
        public static void Rotatef(float angle, float x, float y, float z) => GLPointers._glRotatef_fnptr(angle, x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glScaled]</b> Multiply the current matrix by a general scaling matrix. </summary>
        /// <param name="x"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="y"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="z"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glScale.xml" /></remarks>
        public static void Scaled(double x, double y, double z) => GLPointers._glScaled_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glScalef]</b> Multiply the current matrix by a general scaling matrix. </summary>
        /// <param name="x"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="y"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="z"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glScale.xml" /></remarks>
        public static void Scalef(float x, float y, float z) => GLPointers._glScalef_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glTranslated]</b> Multiply the current matrix by a translation matrix. </summary>
        /// <param name="x"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTranslate.xml" /></remarks>
        public static void Translated(double x, double y, double z) => GLPointers._glTranslated_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0] [glTranslatef]</b> Multiply the current matrix by a translation matrix. </summary>
        /// <param name="x"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTranslate.xml" /></remarks>
        public static void Translatef(float x, float y, float z) => GLPointers._glTranslatef_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.1] [glDrawArrays]</b> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml" /></remarks>
        public static void DrawArrays(PrimitiveType mode, int first, int count) => GLPointers._glDrawArrays_fnptr((uint)mode, first, count);
        
        /// <summary> <b>[requires: v1.1] [glDrawElements]</b> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElements.xhtml" /></remarks>
        public static void DrawElements(PrimitiveType mode, int count, DrawElementsType type, void* indices) => GLPointers._glDrawElements_fnptr((uint)mode, count, (uint)type, indices);
        
        /// <summary> <b>[requires: v1.1 | v4.3 | GL_KHR_debug] [glGetPointerv]</b> Return the address of the specified pointer. </summary>
        /// <param name="pname"> Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or GL_DEBUG_CALLBACK_USER_PARAM. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml" /></remarks>
        public static void GetPointerv(GetPointervPName pname, void** parameters) => GLPointers._glGetPointerv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.1] [glPolygonOffset]</b> Set the scale and units used to calculate depth values. </summary>
        /// <param name="factor"> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </param>
        /// <param name="units"> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml" /></remarks>
        public static void PolygonOffset(float factor, float units) => GLPointers._glPolygonOffset_fnptr(factor, units);
        
        /// <summary> <b>[requires: v1.1] [glCopyTexImage1D]</b> Copy pixels into a 1D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. The height of the texture image is 1. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage1D.xhtml" /></remarks>
        public static void CopyTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._glCopyTexImage1D_fnptr((uint)target, level, (uint)internalformat, x, y, width, border);
        
        /// <summary> <b>[requires: v1.1] [glCopyTexImage2D]</b> Copy pixels into a 2D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. </param>
        /// <param name="height"> Specifies the height of the texture image. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage2D.xhtml" /></remarks>
        public static void CopyTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._glCopyTexImage2D_fnptr((uint)target, level, (uint)internalformat, x, y, width, height, border);
        
        /// <summary> <b>[requires: v1.1] [glCopyTexSubImage1D]</b> Copy a one-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
        public static void CopyTexSubImage1D(TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTexSubImage1D_fnptr((uint)target, level, xoffset, x, y, width);
        
        /// <summary> <b>[requires: v1.1] [glCopyTexSubImage2D]</b> Copy a two-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
        public static void CopyTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTexSubImage2D_fnptr((uint)target, level, xoffset, yoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v1.1] [glTexSubImage1D]</b> Specify a one-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage1D. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
        public static void TexSubImage1D(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage1D_fnptr((uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.1] [glTexSubImage2D]</b> Specify a two-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage2D. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
        public static void TexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage2D_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.1] [glBindTexture]</b> Bind a named texture to a texturing target. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="texture"> Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTexture.xhtml" /></remarks>
        public static void BindTexture(TextureTarget target, int texture) => GLPointers._glBindTexture_fnptr((uint)target, texture);
        
        /// <summary> <b>[requires: v1.1] [glDeleteTextures]</b> Delete named textures. </summary>
        /// <param name="n"> Specifies the number of textures to be deleted. </param>
        /// <param name="textures"> Specifies an array of textures to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTextures.xhtml" /></remarks>
        public static void DeleteTextures(int n, int* textures) => GLPointers._glDeleteTextures_fnptr(n, textures);
        
        /// <summary> <b>[requires: v1.1] [glGenTextures]</b> Generate texture names. </summary>
        /// <param name="n"> Specifies the number of texture names to be generated. </param>
        /// <param name="textures"> Specifies an array in which the generated texture names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTextures.xhtml" /></remarks>
        public static void GenTextures(int n, int* textures) => GLPointers._glGenTextures_fnptr(n, textures);
        
        /// <summary> <b>[requires: v1.1] [glIsTexture]</b> Determine if a name corresponds to a texture. </summary>
        /// <param name="texture"> Specifies a value that may be the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTexture.xhtml" /></remarks>
        public static bool IsTexture(int texture) => GLPointers._glIsTexture_fnptr(texture) != 0;
        
        /// <summary> <b>[requires: v1.1] [glArrayElement]</b> Render a vertex using the specified vertex array element. </summary>
        /// <param name="i"> Specifies an index into the enabled vertex data arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glArrayElement.xml" /></remarks>
        public static void ArrayElement(int i) => GLPointers._glArrayElement_fnptr(i);
        
        /// <summary> <b>[requires: v1.1] [glColorPointer]</b> Define an array of colors. </summary>
        /// <param name="size"> Specifies the number of components per color. Must be 3 or 4. The initial value is 4. </param>
        /// <param name="type"> Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first component of the first color element in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorPointer.xml" /></remarks>
        public static void ColorPointer(int size, ColorPointerType type, int stride, void* pointer) => GLPointers._glColorPointer_fnptr(size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.1] [glDisableClientState]</b>  </summary>
        public static void DisableClientState(EnableCap array) => GLPointers._glDisableClientState_fnptr((uint)array);
        
        /// <summary> <b>[requires: v1.1] [glEdgeFlagPointer]</b> Define an array of edge flags. </summary>
        /// <param name="stride"> Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first edge flag in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEdgeFlagPointer.xml" /></remarks>
        public static void EdgeFlagPointer(int stride, void* pointer) => GLPointers._glEdgeFlagPointer_fnptr(stride, pointer);
        
        /// <summary> <b>[requires: v1.1] [glEnableClientState]</b> Enable or disable client-side capability. </summary>
        /// <param name="cap"> Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnableClientState.xml" /></remarks>
        public static void EnableClientState(EnableCap array) => GLPointers._glEnableClientState_fnptr((uint)array);
        
        /// <summary> <b>[requires: v1.1] [glIndexPointer]</b> Define an array of color indexes. </summary>
        /// <param name="type"> Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first index in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndexPointer.xml" /></remarks>
        public static void IndexPointer(IndexPointerType type, int stride, void* pointer) => GLPointers._glIndexPointer_fnptr((uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.1] [glInterleavedArrays]</b> Simultaneously specify and enable several interleaved arrays. </summary>
        /// <param name="format"> Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted. </param>
        /// <param name="stride"> Specifies the offset in bytes between each aggregate array element. </param>
        /// <param name="pointer">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glInterleavedArrays.xml" /></remarks>
        public static void InterleavedArrays(InterleavedArrayFormat format, int stride, void* pointer) => GLPointers._glInterleavedArrays_fnptr((uint)format, stride, pointer);
        
        /// <summary> <b>[requires: v1.1] [glNormalPointer]</b> Define an array of normals. </summary>
        /// <param name="type"> Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormalPointer.xml" /></remarks>
        public static void NormalPointer(NormalPointerType type, int stride, void* pointer) => GLPointers._glNormalPointer_fnptr((uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.1] [glTexCoordPointer]</b> Define an array of texture coordinates. </summary>
        /// <param name="size"> Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4. </param>
        /// <param name="type"> Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoordPointer.xml" /></remarks>
        public static void TexCoordPointer(int size, TexCoordPointerType type, int stride, void* pointer) => GLPointers._glTexCoordPointer_fnptr(size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.1] [glVertexPointer]</b> Define an array of vertex data. </summary>
        /// <param name="size"> Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4. </param>
        /// <param name="type"> Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertexPointer.xml" /></remarks>
        public static void VertexPointer(int size, VertexPointerType type, int stride, void* pointer) => GLPointers._glVertexPointer_fnptr(size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.1] [glAreTexturesResident]</b> Determine if textures are loaded in texture memory. </summary>
        /// <param name="n"> Specifies the number of textures to be queried. </param>
        /// <param name="textures"> Specifies an array containing the names of the textures to be queried. </param>
        /// <param name="residences"> Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glAreTexturesResident.xml" /></remarks>
        public static bool AreTexturesResident(int n, int* textures, bool* residences) => GLPointers._glAreTexturesResident_fnptr(n, textures, (byte*)residences) != 0;
        
        /// <summary> <b>[requires: v1.1] [glPrioritizeTextures]</b> Set texture residence priority. </summary>
        /// <param name="n"> Specifies the number of textures to be prioritized. </param>
        /// <param name="textures"> Specifies an array containing the names of the textures to be prioritized. </param>
        /// <param name="priorities"> Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPrioritizeTextures.xml" /></remarks>
        public static void PrioritizeTextures(int n, int* textures, float* priorities) => GLPointers._glPrioritizeTextures_fnptr(n, textures, priorities);
        
        /// <summary> <b>[requires: v1.1] [glIndexub]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexub(byte c) => GLPointers._glIndexub_fnptr(c);
        
        /// <summary> <b>[requires: v1.1] [glIndexubv]</b>  </summary>
        public static void Indexubv(byte* c) => GLPointers._glIndexubv_fnptr(c);
        
        /// <summary> <b>[requires: v1.1] [glPopClientAttrib]</b>  </summary>
        public static void PopClientAttrib() => GLPointers._glPopClientAttrib_fnptr();
        
        /// <summary> <b>[requires: v1.1] [glPushClientAttrib]</b> Push and pop the client attribute stack. </summary>
        /// <param name="mask"> Specifies a mask that indicates which attributes to save. Values for mask are listed below. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushClientAttrib.xml" /></remarks>
        public static void PushClientAttrib(ClientAttribMask mask) => GLPointers._glPushClientAttrib_fnptr((uint)mask);
        
        /// <summary> <b>[requires: v1.2] [glDrawRangeElements]</b> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElements.xhtml" /></remarks>
        public static void DrawRangeElements(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => GLPointers._glDrawRangeElements_fnptr((uint)mode, start, end, count, (uint)type, indices);
        
        /// <summary> <b>[requires: v1.2] [glTexImage3D]</b> Specify a three-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3D.xhtml" /></remarks>
        public static void TexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage3D_fnptr((uint)target, level, (int)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.2] [glTexSubImage3D]</b> Specify a three-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage3D. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
        public static void TexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage3D_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.2] [glCopyTexSubImage3D]</b> Copy a three-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage3D function. Must be GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
        public static void CopyTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTexSubImage3D_fnptr((uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v1.3] [glActiveTexture]</b> Select active texture unit. </summary>
        /// <param name="texture"> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from zero to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS minus one. The initial value is GL_TEXTURE0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveTexture.xhtml" /></remarks>
        public static void ActiveTexture(TextureUnit texture) => GLPointers._glActiveTexture_fnptr((uint)texture);
        
        /// <summary> <b>[requires: v1.3] [glSampleCoverage]</b> Specify multisample coverage parameters. </summary>
        /// <param name="value"> Specify a single floating-point sample coverage value. The value is clamped to the range 0 1 . The initial value is 1.0. </param>
        /// <param name="invert"> Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleCoverage.xhtml" /></remarks>
        public static void SampleCoverage(float value, bool invert) => GLPointers._glSampleCoverage_fnptr(value, (byte)(invert ? 1 : 0));
        
        /// <summary> <b>[requires: v1.3] [glCompressedTexImage3D]</b> Specify a three-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage3D.xhtml" /></remarks>
        public static void CompressedTexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage3D_fnptr((uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3] [glCompressedTexImage2D]</b> Specify a two-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage2D.xhtml" /></remarks>
        public static void CompressedTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage2D_fnptr((uint)target, level, (uint)internalformat, width, height, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3] [glCompressedTexImage1D]</b> Specify a one-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage1D.xhtml" /></remarks>
        public static void CompressedTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage1D_fnptr((uint)target, level, (uint)internalformat, width, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3] [glCompressedTexSubImage3D]</b> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage3D function. Must be GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
        public static void CompressedTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage3D_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3] [glCompressedTexSubImage2D]</b> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
        public static void CompressedTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage2D_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3] [glCompressedTexSubImage1D]</b> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="target">Specifies the target, to which the texture is bound, for glCompressedTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
        public static void CompressedTexSubImage1D(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage1D_fnptr((uint)target, level, xoffset, width, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3] [glGetCompressedTexImage]</b> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetCompressedTexImage(TextureTarget target, int level, void* img) => GLPointers._glGetCompressedTexImage_fnptr((uint)target, level, img);
        
        /// <summary> <b>[requires: v1.3] [glClientActiveTexture]</b> Select active texture unit. </summary>
        /// <param name="texture"> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to the value of GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. The initial value is GL_TEXTURE0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClientActiveTexture.xml" /></remarks>
        public static void ClientActiveTexture(TextureUnit texture) => GLPointers._glClientActiveTexture_fnptr((uint)texture);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord1d]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1d(TextureUnit target, double s) => GLPointers._glMultiTexCoord1d_fnptr((uint)target, s);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord1dv]</b>  </summary>
        public static void MultiTexCoord1dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord1dv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord1f]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1f(TextureUnit target, float s) => GLPointers._glMultiTexCoord1f_fnptr((uint)target, s);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord1fv]</b>  </summary>
        public static void MultiTexCoord1fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord1fv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord1i]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1i(TextureUnit target, int s) => GLPointers._glMultiTexCoord1i_fnptr((uint)target, s);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord1iv]</b>  </summary>
        public static void MultiTexCoord1iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord1iv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord1s]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1s(TextureUnit target, short s) => GLPointers._glMultiTexCoord1s_fnptr((uint)target, s);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord1sv]</b>  </summary>
        public static void MultiTexCoord1sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord1sv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord2d]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2d(TextureUnit target, double s, double t) => GLPointers._glMultiTexCoord2d_fnptr((uint)target, s, t);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord2dv]</b>  </summary>
        public static void MultiTexCoord2dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord2dv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord2f]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2f(TextureUnit target, float s, float t) => GLPointers._glMultiTexCoord2f_fnptr((uint)target, s, t);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord2fv]</b>  </summary>
        public static void MultiTexCoord2fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord2fv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord2i]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2i(TextureUnit target, int s, int t) => GLPointers._glMultiTexCoord2i_fnptr((uint)target, s, t);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord2iv]</b>  </summary>
        public static void MultiTexCoord2iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord2iv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord2s]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2s(TextureUnit target, short s, short t) => GLPointers._glMultiTexCoord2s_fnptr((uint)target, s, t);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord2sv]</b>  </summary>
        public static void MultiTexCoord2sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord2sv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord3d]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3d(TextureUnit target, double s, double t, double r) => GLPointers._glMultiTexCoord3d_fnptr((uint)target, s, t, r);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord3dv]</b>  </summary>
        public static void MultiTexCoord3dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord3dv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord3f]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3f(TextureUnit target, float s, float t, float r) => GLPointers._glMultiTexCoord3f_fnptr((uint)target, s, t, r);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord3fv]</b>  </summary>
        public static void MultiTexCoord3fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord3fv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord3i]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3i(TextureUnit target, int s, int t, int r) => GLPointers._glMultiTexCoord3i_fnptr((uint)target, s, t, r);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord3iv]</b>  </summary>
        public static void MultiTexCoord3iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord3iv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord3s]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3s(TextureUnit target, short s, short t, short r) => GLPointers._glMultiTexCoord3s_fnptr((uint)target, s, t, r);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord3sv]</b>  </summary>
        public static void MultiTexCoord3sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord3sv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord4d]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4d(TextureUnit target, double s, double t, double r, double q) => GLPointers._glMultiTexCoord4d_fnptr((uint)target, s, t, r, q);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord4dv]</b>  </summary>
        public static void MultiTexCoord4dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord4dv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord4f]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4f(TextureUnit target, float s, float t, float r, float q) => GLPointers._glMultiTexCoord4f_fnptr((uint)target, s, t, r, q);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord4fv]</b>  </summary>
        public static void MultiTexCoord4fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord4fv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord4i]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4i(TextureUnit target, int s, int t, int r, int q) => GLPointers._glMultiTexCoord4i_fnptr((uint)target, s, t, r, q);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord4iv]</b>  </summary>
        public static void MultiTexCoord4iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord4iv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord4s]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4s(TextureUnit target, short s, short t, short r, short q) => GLPointers._glMultiTexCoord4s_fnptr((uint)target, s, t, r, q);
        
        /// <summary> <b>[requires: v1.3] [glMultiTexCoord4sv]</b>  </summary>
        public static void MultiTexCoord4sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord4sv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3] [glLoadTransposeMatrixf]</b> Replace the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadTransposeMatrix.xml" /></remarks>
        public static void LoadTransposeMatrixf(float* m) => GLPointers._glLoadTransposeMatrixf_fnptr(m);
        
        /// <summary> <b>[requires: v1.3] [glLoadTransposeMatrixd]</b> Replace the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadTransposeMatrix.xml" /></remarks>
        public static void LoadTransposeMatrixd(double* m) => GLPointers._glLoadTransposeMatrixd_fnptr(m);
        
        /// <summary> <b>[requires: v1.3] [glMultTransposeMatrixf]</b> Multiply the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultTransposeMatrix.xml" /></remarks>
        public static void MultTransposeMatrixf(float* m) => GLPointers._glMultTransposeMatrixf_fnptr(m);
        
        /// <summary> <b>[requires: v1.3] [glMultTransposeMatrixd]</b> Multiply the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultTransposeMatrix.xml" /></remarks>
        public static void MultTransposeMatrixd(double* m) => GLPointers._glMultTransposeMatrixd_fnptr(m);
        
        /// <summary> <b>[requires: v1.4] [glBlendFuncSeparate]</b> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="srcRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dstRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="srcAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dstAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml" /></remarks>
        public static void BlendFuncSeparate(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers._glBlendFuncSeparate_fnptr((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
        
        /// <summary> <b>[requires: v1.4] [glMultiDrawArrays]</b> Render multiple sets of primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Points to an array of starting indices in the enabled arrays. </param>
        /// <param name="count"> Points to an array of the number of indices to be rendered. </param>
        /// <param name="drawcount"> Specifies the size of the first and count </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArrays.xhtml" /></remarks>
        public static void MultiDrawArrays(PrimitiveType mode, int* first, int* count, int drawcount) => GLPointers._glMultiDrawArrays_fnptr((uint)mode, first, count, drawcount);
        
        /// <summary> <b>[requires: v1.4] [glMultiDrawElements]</b> Render multiple sets of primitives by specifying indices of array data elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count and indices arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElements.xhtml" /></remarks>
        public static void MultiDrawElements(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount) => GLPointers._glMultiDrawElements_fnptr((uint)mode, count, (uint)type, indices, drawcount);
        
        /// <summary> <b>[requires: v1.4] [glPointParameterf]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameterf(PointParameterNameARB pname, float param) => GLPointers._glPointParameterf_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.4] [glPointParameterfv]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameterfv(PointParameterNameARB pname, float* parameters) => GLPointers._glPointParameterfv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.4] [glPointParameteri]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameteri(PointParameterNameARB pname, int param) => GLPointers._glPointParameteri_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.4] [glPointParameteriv]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameteriv(PointParameterNameARB pname, int* parameters) => GLPointers._glPointParameteriv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.4] [glFogCoordf]</b> Set the current fog coordinates. </summary>
        /// <param name="coord"> Specify the fog distance. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFogCoord.xml" /></remarks>
        public static void FogCoordf(float coord) => GLPointers._glFogCoordf_fnptr(coord);
        
        /// <summary> <b>[requires: v1.4] [glFogCoordfv]</b>  </summary>
        public static void FogCoordfv(float* coord) => GLPointers._glFogCoordfv_fnptr(coord);
        
        /// <summary> <b>[requires: v1.4] [glFogCoordd]</b> Set the current fog coordinates. </summary>
        /// <param name="coord"> Specify the fog distance. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFogCoord.xml" /></remarks>
        public static void FogCoordd(double coord) => GLPointers._glFogCoordd_fnptr(coord);
        
        /// <summary> <b>[requires: v1.4] [glFogCoorddv]</b>  </summary>
        public static void FogCoorddv(double* coord) => GLPointers._glFogCoorddv_fnptr(coord);
        
        /// <summary> <b>[requires: v1.4] [glFogCoordPointer]</b> Define an array of fog coordinates. </summary>
        /// <param name="type"> Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFogCoordPointer.xml" /></remarks>
        public static void FogCoordPointer(FogPointerTypeEXT type, int stride, void* pointer) => GLPointers._glFogCoordPointer_fnptr((uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3b]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3b(sbyte red, sbyte green, sbyte blue) => GLPointers._glSecondaryColor3b_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3bv]</b>  </summary>
        public static void SecondaryColor3bv(sbyte* v) => GLPointers._glSecondaryColor3bv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3d]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3d(double red, double green, double blue) => GLPointers._glSecondaryColor3d_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3dv]</b>  </summary>
        public static void SecondaryColor3dv(double* v) => GLPointers._glSecondaryColor3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3f]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3f(float red, float green, float blue) => GLPointers._glSecondaryColor3f_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3fv]</b>  </summary>
        public static void SecondaryColor3fv(float* v) => GLPointers._glSecondaryColor3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3i]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3i(int red, int green, int blue) => GLPointers._glSecondaryColor3i_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3iv]</b>  </summary>
        public static void SecondaryColor3iv(int* v) => GLPointers._glSecondaryColor3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3s]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3s(short red, short green, short blue) => GLPointers._glSecondaryColor3s_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3sv]</b>  </summary>
        public static void SecondaryColor3sv(short* v) => GLPointers._glSecondaryColor3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3ub]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3ub(byte red, byte green, byte blue) => GLPointers._glSecondaryColor3ub_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3ubv]</b>  </summary>
        public static void SecondaryColor3ubv(byte* v) => GLPointers._glSecondaryColor3ubv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3ui]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3ui(uint red, uint green, uint blue) => GLPointers._glSecondaryColor3ui_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3uiv]</b>  </summary>
        public static void SecondaryColor3uiv(uint* v) => GLPointers._glSecondaryColor3uiv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3us]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3us(ushort red, ushort green, ushort blue) => GLPointers._glSecondaryColor3us_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColor3usv]</b>  </summary>
        public static void SecondaryColor3usv(ushort* v) => GLPointers._glSecondaryColor3usv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glSecondaryColorPointer]</b> Define an array of secondary colors. </summary>
        /// <param name="size"> Specifies the number of components per color. Must be 3. </param>
        /// <param name="type"> Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first component of the first color element in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColorPointer.xml" /></remarks>
        public static void SecondaryColorPointer(int size, ColorPointerType type, int stride, void* pointer) => GLPointers._glSecondaryColorPointer_fnptr(size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos2d]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2d(double x, double y) => GLPointers._glWindowPos2d_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos2dv]</b>  </summary>
        public static void WindowPos2dv(double* v) => GLPointers._glWindowPos2dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos2f]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2f(float x, float y) => GLPointers._glWindowPos2f_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos2fv]</b>  </summary>
        public static void WindowPos2fv(float* v) => GLPointers._glWindowPos2fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos2i]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2i(int x, int y) => GLPointers._glWindowPos2i_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos2iv]</b>  </summary>
        public static void WindowPos2iv(int* v) => GLPointers._glWindowPos2iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos2s]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2s(short x, short y) => GLPointers._glWindowPos2s_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos2sv]</b>  </summary>
        public static void WindowPos2sv(short* v) => GLPointers._glWindowPos2sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos3d]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3d(double x, double y, double z) => GLPointers._glWindowPos3d_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos3dv]</b>  </summary>
        public static void WindowPos3dv(double* v) => GLPointers._glWindowPos3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos3f]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3f(float x, float y, float z) => GLPointers._glWindowPos3f_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos3fv]</b>  </summary>
        public static void WindowPos3fv(float* v) => GLPointers._glWindowPos3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos3i]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3i(int x, int y, int z) => GLPointers._glWindowPos3i_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos3iv]</b>  </summary>
        public static void WindowPos3iv(int* v) => GLPointers._glWindowPos3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos3s]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3s(short x, short y, short z) => GLPointers._glWindowPos3s_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.4] [glWindowPos3sv]</b>  </summary>
        public static void WindowPos3sv(short* v) => GLPointers._glWindowPos3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging] [glBlendColor]</b> Set the blend color. </summary>
        /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml" /></remarks>
        public static void BlendColor(float red, float green, float blue, float alpha) => GLPointers._glBlendColor_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging] [glBlendEquation]</b> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
        public static void BlendEquation(BlendEquationModeEXT mode) => GLPointers._glBlendEquation_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.5] [glGenQueries]</b> Generate query object names. </summary>
        /// <param name="n"> Specifies the number of query object names to be generated. </param>
        /// <param name="ids"> Specifies an array in which the generated query object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenQueries.xhtml" /></remarks>
        public static void GenQueries(int n, int* ids) => GLPointers._glGenQueries_fnptr(n, ids);
        
        /// <summary> <b>[requires: v1.5] [glDeleteQueries]</b> Delete named query objects. </summary>
        /// <param name="n"> Specifies the number of query objects to be deleted. </param>
        /// <param name="ids"> Specifies an array of query objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteQueries.xhtml" /></remarks>
        public static void DeleteQueries(int n, int* ids) => GLPointers._glDeleteQueries_fnptr(n, ids);
        
        /// <summary> <b>[requires: v1.5] [glIsQuery]</b> Determine if a name corresponds to a query object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsQuery.xhtml" /></remarks>
        public static bool IsQuery(int id) => GLPointers._glIsQuery_fnptr(id) != 0;
        
        /// <summary> <b>[requires: v1.5] [glBeginQuery]</b> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml" /></remarks>
        public static void BeginQuery(QueryTarget target, int id) => GLPointers._glBeginQuery_fnptr((uint)target, id);
        
        /// <summary> <b>[requires: v1.5] [glEndQuery]</b> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml" /></remarks>
        public static void EndQuery(QueryTarget target) => GLPointers._glEndQuery_fnptr((uint)target);
        
        /// <summary> <b>[requires: v1.5] [glGetQueryiv]</b> Return parameters of a query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryiv.xhtml" /></remarks>
        public static void GetQueryiv(QueryTarget target, QueryParameterName pname, int* parameters) => GLPointers._glGetQueryiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5] [glGetQueryObjectiv]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectiv(int id, QueryObjectParameterName pname, int* parameters) => GLPointers._glGetQueryObjectiv_fnptr(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5] [glGetQueryObjectuiv]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectuiv(int id, QueryObjectParameterName pname, uint* parameters) => GLPointers._glGetQueryObjectuiv_fnptr(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5] [glBindBuffer]</b> Bind a named buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml" /></remarks>
        public static void BindBuffer(BufferTargetARB target, int buffer) => GLPointers._glBindBuffer_fnptr((uint)target, buffer);
        
        /// <summary> <b>[requires: v1.5] [glDeleteBuffers]</b> Delete named buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to be deleted. </param>
        /// <param name="buffers"> Specifies an array of buffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml" /></remarks>
        public static void DeleteBuffers(int n, int* buffers) => GLPointers._glDeleteBuffers_fnptr(n, buffers);
        
        /// <summary> <b>[requires: v1.5] [glGenBuffers]</b> Generate buffer object names. </summary>
        /// <param name="n"> Specifies the number of buffer object names to be generated. </param>
        /// <param name="buffers"> Specifies an array in which the generated buffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml" /></remarks>
        public static void GenBuffers(int n, int* buffers) => GLPointers._glGenBuffers_fnptr(n, buffers);
        
        /// <summary> <b>[requires: v1.5] [glIsBuffer]</b> Determine if a name corresponds to a buffer object. </summary>
        /// <param name="buffer"> Specifies a value that may be the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsBuffer.xhtml" /></remarks>
        public static bool IsBuffer(int buffer) => GLPointers._glIsBuffer_fnptr(buffer) != 0;
        
        /// <summary> <b>[requires: v1.5] [glBufferData]</b> Creates and initializes a buffer object&apos;s data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
        public static void BufferData(BufferTargetARB target, nint size, void* data, BufferUsageARB usage) => GLPointers._glBufferData_fnptr((uint)target, size, data, (uint)usage);
        
        /// <summary> <b>[requires: v1.5] [glBufferSubData]</b> Updates a subset of a buffer object&apos;s data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
        public static void BufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._glBufferSubData_fnptr((uint)target, offset, size, data);
        
        /// <summary> <b>[requires: v1.5] [glGetBufferSubData]</b> Returns a subset of a buffer object&apos;s data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
        public static void GetBufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._glGetBufferSubData_fnptr((uint)target, offset, size, data);
        
        /// <summary> <b>[requires: v1.5] [glMapBuffer]</b> Map all of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object&apos;s mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
        public static void* MapBuffer(BufferTargetARB target, BufferAccessARB access) => GLPointers._glMapBuffer_fnptr((uint)target, (uint)access);
        
        /// <summary> <b>[requires: v1.5] [glUnmapBuffer]</b> Release the mapping of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glUnmapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
        public static bool UnmapBuffer(BufferTargetARB target) => GLPointers._glUnmapBuffer_fnptr((uint)target) != 0;
        
        /// <summary> <b>[requires: v1.5] [glGetBufferParameteriv]</b> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="value"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="data"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetBufferParameteriv(BufferTargetARB target, BufferPNameARB pname, int* parameters) => GLPointers._glGetBufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5] [glGetBufferPointerv]</b> Return the pointer to a mapped buffer object&apos;s data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
        public static void GetBufferPointerv(BufferTargetARB target, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetBufferPointerv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0] [glBlendEquationSeparate]</b> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml" /></remarks>
        public static void BlendEquationSeparate(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparate_fnptr((uint)modeRGB, (uint)modeAlpha);
        
        /// <summary> <b>[requires: v2.0] [glDrawBuffers]</b> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
        public static void DrawBuffers(int n, DrawBufferMode* bufs) => GLPointers._glDrawBuffers_fnptr(n, (uint*)bufs);
        
        /// <summary> <b>[requires: v2.0] [glStencilOpSeparate]</b> Set front and/or back stencil test actions. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="sfail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="dpfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="dppass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOpSeparate.xhtml" /></remarks>
        public static void StencilOpSeparate(TriangleFace face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => GLPointers._glStencilOpSeparate_fnptr((uint)face, (uint)sfail, (uint)dpfail, (uint)dppass);
        
        /// <summary> <b>[requires: v2.0] [glStencilFuncSeparate]</b> Set front and/or back function and reference value for stencil testing. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFuncSeparate.xhtml" /></remarks>
        public static void StencilFuncSeparate(TriangleFace face, StencilFunction func, int reference, uint mask) => GLPointers._glStencilFuncSeparate_fnptr((uint)face, (uint)func, reference, mask);
        
        /// <summary> <b>[requires: v2.0] [glStencilMaskSeparate]</b> Control the front and/or back writing of individual bits in the stencil planes. </summary>
        /// <param name="face"> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMaskSeparate.xhtml" /></remarks>
        public static void StencilMaskSeparate(TriangleFace face, uint mask) => GLPointers._glStencilMaskSeparate_fnptr((uint)face, mask);
        
        /// <summary> <b>[requires: v2.0] [glAttachShader]</b> Attaches a shader object to a program object. </summary>
        /// <param name="program">Specifies the program object to which a shader object will be attached.</param>
        /// <param name="shader">Specifies the shader object that is to be attached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glAttachShader.xhtml" /></remarks>
        public static void AttachShader(int program, int shader) => GLPointers._glAttachShader_fnptr(program, shader);
        
        /// <summary> <b>[requires: v2.0] [glBindAttribLocation]</b> Associates a generic vertex attribute index with a named attribute variable. </summary>
        /// <param name="program">Specifies the handle of the program object in which the association is to be made.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be bound.</param>
        /// <param name="name">Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindAttribLocation.xhtml" /></remarks>
        public static void BindAttribLocation(int program, uint index, byte* name) => GLPointers._glBindAttribLocation_fnptr(program, index, name);
        
        /// <summary> <b>[requires: v2.0] [glCompileShader]</b> Compiles a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be compiled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompileShader.xhtml" /></remarks>
        public static void CompileShader(int shader) => GLPointers._glCompileShader_fnptr(shader);
        
        /// <summary> <b>[requires: v2.0] [glCreateProgram]</b> Creates a program object. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml" /></remarks>
        public static int CreateProgram() => GLPointers._glCreateProgram_fnptr();
        
        /// <summary> <b>[requires: v2.0] [glCreateShader]</b> Creates a shader object. </summary>
        /// <param name="shaderType">Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml" /></remarks>
        public static int CreateShader(ShaderType type) => GLPointers._glCreateShader_fnptr((uint)type);
        
        /// <summary> <b>[requires: v2.0] [glDeleteProgram]</b> Deletes a program object. </summary>
        /// <param name="program">Specifies the program object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml" /></remarks>
        public static void DeleteProgram(int program) => GLPointers._glDeleteProgram_fnptr(program);
        
        /// <summary> <b>[requires: v2.0] [glDeleteShader]</b> Deletes a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml" /></remarks>
        public static void DeleteShader(int shader) => GLPointers._glDeleteShader_fnptr(shader);
        
        /// <summary> <b>[requires: v2.0] [glDetachShader]</b> Detaches a shader object from a program object to which it is attached. </summary>
        /// <param name="program">Specifies the program object from which to detach the shader object.</param>
        /// <param name="shader">Specifies the shader object to be detached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDetachShader.xhtml" /></remarks>
        public static void DetachShader(int program, int shader) => GLPointers._glDetachShader_fnptr(program, shader);
        
        /// <summary> <b>[requires: v2.0] [glDisableVertexAttribArray]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void DisableVertexAttribArray(uint index) => GLPointers._glDisableVertexAttribArray_fnptr(index);
        
        /// <summary> <b>[requires: v2.0] [glEnableVertexAttribArray]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void EnableVertexAttribArray(uint index) => GLPointers._glEnableVertexAttribArray_fnptr(index);
        
        /// <summary> <b>[requires: v2.0] [glGetActiveAttrib]</b> Returns information about an active attribute variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the attribute variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute variable.</param>
        /// <param name="type">Returns the data type of the attribute variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the attribute variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAttrib.xhtml" /></remarks>
        public static void GetActiveAttrib(int program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers._glGetActiveAttrib_fnptr(program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v2.0] [glGetActiveUniform]</b> Returns information about an active uniform variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform variable.</param>
        /// <param name="type">Returns the data type of the uniform variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniform.xhtml" /></remarks>
        public static void GetActiveUniform(int program, uint index, int bufSize, int* length, int* size, UniformType* type, byte* name) => GLPointers._glGetActiveUniform_fnptr(program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v2.0] [glGetAttachedShaders]</b> Returns the handles of the shader objects attached to a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned in shaders.</param>
        /// <param name="shaders">Specifies an array that is used to return the names of attached shader objects.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml" /></remarks>
        public static void GetAttachedShaders(int program, int maxCount, int* count, int* shaders) => GLPointers._glGetAttachedShaders_fnptr(program, maxCount, count, shaders);
        
        /// <summary> <b>[requires: v2.0] [glGetAttribLocation]</b> Returns the location of an attribute variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttribLocation.xhtml" /></remarks>
        public static int GetAttribLocation(int program, byte* name) => GLPointers._glGetAttribLocation_fnptr(program, name);
        
        /// <summary> <b>[requires: v2.0] [glGetProgramiv]</b> Returns a parameter from a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgram.xhtml" /></remarks>
        public static void GetProgramiv(int program, ProgramPropertyARB pname, int* parameters) => GLPointers._glGetProgramiv_fnptr(program, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0] [glGetProgramInfoLog]</b> Returns the information log for a program object. </summary>
        /// <param name="program">Specifies the program object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml" /></remarks>
        public static void GetProgramInfoLog(int program, int bufSize, int* length, byte* infoLog) => GLPointers._glGetProgramInfoLog_fnptr(program, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v2.0] [glGetShaderiv]</b> Returns a parameter from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShader.xhtml" /></remarks>
        public static void GetShaderiv(int shader, ShaderParameterName pname, int* parameters) => GLPointers._glGetShaderiv_fnptr(shader, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0] [glGetShaderInfoLog]</b> Returns the information log for a shader object. </summary>
        /// <param name="shader">Specifies the shader object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml" /></remarks>
        public static void GetShaderInfoLog(int shader, int bufSize, int* length, byte* infoLog) => GLPointers._glGetShaderInfoLog_fnptr(shader, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v2.0] [glGetShaderSource]</b> Returns the source code string from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in source (excluding the null terminator).</param>
        /// <param name="source">Specifies an array of characters that is used to return the source code string.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderSource.xhtml" /></remarks>
        public static void GetShaderSource(int shader, int bufSize, int* length, byte* source) => GLPointers._glGetShaderSource_fnptr(shader, bufSize, length, source);
        
        /// <summary> <b>[requires: v2.0] [glGetUniformLocation]</b> Returns the location of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml" /></remarks>
        public static int GetUniformLocation(int program, byte* name) => GLPointers._glGetUniformLocation_fnptr(program, name);
        
        /// <summary> <b>[requires: v2.0] [glGetUniformfv]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformfv(int program, int location, float* parameters) => GLPointers._glGetUniformfv_fnptr(program, location, parameters);
        
        /// <summary> <b>[requires: v2.0] [glGetUniformiv]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformiv(int program, int location, int* parameters) => GLPointers._glGetUniformiv_fnptr(program, location, parameters);
        
        /// <summary> <b>[requires: v2.0] [glGetVertexAttribdv]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribdv(uint index, VertexAttribPropertyARB pname, double* parameters) => GLPointers._glGetVertexAttribdv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0] [glGetVertexAttribfv]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribfv(uint index, VertexAttribPropertyARB pname, float* parameters) => GLPointers._glGetVertexAttribfv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0] [glGetVertexAttribiv]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribiv(uint index, VertexAttribPropertyARB pname, int* parameters) => GLPointers._glGetVertexAttribiv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0] [glGetVertexAttribPointerv]</b> Return the address of the specified generic vertex attribute pointer. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be returned.</param>
        /// <param name="pname">Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.</param>
        /// <param name="pointer">Returns the pointer value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttribPointerv.xhtml" /></remarks>
        public static void GetVertexAttribPointerv(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => GLPointers._glGetVertexAttribPointerv_fnptr(index, (uint)pname, pointer);
        
        /// <summary> <b>[requires: v2.0] [glIsProgram]</b> Determines if a name corresponds to a program object. </summary>
        /// <param name="program">Specifies a potential program object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgram.xhtml" /></remarks>
        public static bool IsProgram(int program) => GLPointers._glIsProgram_fnptr(program) != 0;
        
        /// <summary> <b>[requires: v2.0] [glIsShader]</b> Determines if a name corresponds to a shader object. </summary>
        /// <param name="shader">Specifies a potential shader object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsShader.xhtml" /></remarks>
        public static bool IsShader(int shader) => GLPointers._glIsShader_fnptr(shader) != 0;
        
        /// <summary> <b>[requires: v2.0] [glLinkProgram]</b> Links a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be linked.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml" /></remarks>
        public static void LinkProgram(int program) => GLPointers._glLinkProgram_fnptr(program);
        
        /// <summary> <b>[requires: v2.0] [glShaderSource]</b> Replaces the source code in a shader object. </summary>
        /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the string and length arrays.</param>
        /// <param name="str">Specifies an array of pointers to strings containing the source code to be loaded into the shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderSource.xhtml" /></remarks>
        public static void ShaderSource(int shader, int count, byte** str, int* length) => GLPointers._glShaderSource_fnptr(shader, count, str, length);
        
        /// <summary> <b>[requires: v2.0] [glUseProgram]</b> Installs a program object as part of current rendering state. </summary>
        /// <param name="program">Specifies the handle of the program object whose executables are to be used as part of current rendering state.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgram.xhtml" /></remarks>
        public static void UseProgram(int program) => GLPointers._glUseProgram_fnptr(program);
        
        /// <summary> <b>[requires: v2.0] [glUniform1f]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1f(int location, float v0) => GLPointers._glUniform1f_fnptr(location, v0);
        
        /// <summary> <b>[requires: v2.0] [glUniform2f]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2f(int location, float v0, float v1) => GLPointers._glUniform2f_fnptr(location, v0, v1);
        
        /// <summary> <b>[requires: v2.0] [glUniform3f]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3f(int location, float v0, float v1, float v2) => GLPointers._glUniform3f_fnptr(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v2.0] [glUniform4f]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4f(int location, float v0, float v1, float v2, float v3) => GLPointers._glUniform4f_fnptr(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v2.0] [glUniform1i]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1i(int location, int v0) => GLPointers._glUniform1i_fnptr(location, v0);
        
        /// <summary> <b>[requires: v2.0] [glUniform2i]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2i(int location, int v0, int v1) => GLPointers._glUniform2i_fnptr(location, v0, v1);
        
        /// <summary> <b>[requires: v2.0] [glUniform3i]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3i(int location, int v0, int v1, int v2) => GLPointers._glUniform3i_fnptr(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v2.0] [glUniform4i]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4i(int location, int v0, int v1, int v2, int v3) => GLPointers._glUniform4i_fnptr(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v2.0] [glUniform1fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1fv(int location, int count, float* value) => GLPointers._glUniform1fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0] [glUniform2fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2fv(int location, int count, float* value) => GLPointers._glUniform2fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0] [glUniform3fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3fv(int location, int count, float* value) => GLPointers._glUniform3fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0] [glUniform4fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4fv(int location, int count, float* value) => GLPointers._glUniform4fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0] [glUniform1iv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1iv(int location, int count, int* value) => GLPointers._glUniform1iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0] [glUniform2iv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2iv(int location, int count, int* value) => GLPointers._glUniform2iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0] [glUniform3iv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3iv(int location, int count, int* value) => GLPointers._glUniform3iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0] [glUniform4iv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4iv(int location, int count, int* value) => GLPointers._glUniform4iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0] [glUniformMatrix2fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix2fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0] [glUniformMatrix3fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix3fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0] [glUniformMatrix4fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix4fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0] [glValidateProgram]</b> Validates a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be validated.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgram.xhtml" /></remarks>
        public static void ValidateProgram(int program) => GLPointers._glValidateProgram_fnptr(program);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib1d]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1d(uint index, double x) => GLPointers._glVertexAttrib1d_fnptr(index, x);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib1dv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1dv(uint index, double* v) => GLPointers._glVertexAttrib1dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib1f]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1f(uint index, float x) => GLPointers._glVertexAttrib1f_fnptr(index, x);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib1fv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1fv(uint index, float* v) => GLPointers._glVertexAttrib1fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib1s]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1s(uint index, short x) => GLPointers._glVertexAttrib1s_fnptr(index, x);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib1sv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1sv(uint index, short* v) => GLPointers._glVertexAttrib1sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib2d]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2d(uint index, double x, double y) => GLPointers._glVertexAttrib2d_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib2dv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2dv(uint index, double* v) => GLPointers._glVertexAttrib2dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib2f]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2f(uint index, float x, float y) => GLPointers._glVertexAttrib2f_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib2fv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2fv(uint index, float* v) => GLPointers._glVertexAttrib2fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib2s]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2s(uint index, short x, short y) => GLPointers._glVertexAttrib2s_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib2sv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2sv(uint index, short* v) => GLPointers._glVertexAttrib2sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib3d]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3d(uint index, double x, double y, double z) => GLPointers._glVertexAttrib3d_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib3dv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3dv(uint index, double* v) => GLPointers._glVertexAttrib3dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib3f]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3f(uint index, float x, float y, float z) => GLPointers._glVertexAttrib3f_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib3fv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3fv(uint index, float* v) => GLPointers._glVertexAttrib3fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib3s]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3s(uint index, short x, short y, short z) => GLPointers._glVertexAttrib3s_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib3sv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3sv(uint index, short* v) => GLPointers._glVertexAttrib3sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4Nbv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nbv(uint index, sbyte* v) => GLPointers._glVertexAttrib4Nbv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4Niv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Niv(uint index, int* v) => GLPointers._glVertexAttrib4Niv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4Nsv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nsv(uint index, short* v) => GLPointers._glVertexAttrib4Nsv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4Nub]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nub(uint index, byte x, byte y, byte z, byte w) => GLPointers._glVertexAttrib4Nub_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4Nubv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nubv(uint index, byte* v) => GLPointers._glVertexAttrib4Nubv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4Nuiv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nuiv(uint index, uint* v) => GLPointers._glVertexAttrib4Nuiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4Nusv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nusv(uint index, ushort* v) => GLPointers._glVertexAttrib4Nusv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4bv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4bv(uint index, sbyte* v) => GLPointers._glVertexAttrib4bv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4d]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4d(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttrib4d_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4dv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4dv(uint index, double* v) => GLPointers._glVertexAttrib4dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4f]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4f(uint index, float x, float y, float z, float w) => GLPointers._glVertexAttrib4f_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4fv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4fv(uint index, float* v) => GLPointers._glVertexAttrib4fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4iv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4iv(uint index, int* v) => GLPointers._glVertexAttrib4iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4s]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4s(uint index, short x, short y, short z, short w) => GLPointers._glVertexAttrib4s_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4sv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4sv(uint index, short* v) => GLPointers._glVertexAttrib4sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4ubv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4ubv(uint index, byte* v) => GLPointers._glVertexAttrib4ubv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4uiv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4uiv(uint index, uint* v) => GLPointers._glVertexAttrib4uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttrib4usv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4usv(uint index, ushort* v) => GLPointers._glVertexAttrib4usv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0] [glVertexAttribPointer]</b> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribPointer(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, void* pointer) => GLPointers._glVertexAttribPointer_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, pointer);
        
        /// <summary> <b>[requires: v2.1] [glUniformMatrix2x3fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2x3fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix2x3fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1] [glUniformMatrix3x2fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3x2fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix3x2fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1] [glUniformMatrix2x4fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2x4fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix2x4fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1] [glUniformMatrix4x2fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4x2fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix4x2fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1] [glUniformMatrix3x4fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3x4fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix3x4fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1] [glUniformMatrix4x3fv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4x3fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix4x3fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.0] [glColorMaski]</b> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="buf"> For glColorMaski, specifies the index of the draw buffer whose color mask to set. </param>
        /// <param name="red"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="green"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="blue"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="alpha"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml" /></remarks>
        public static void ColorMaski(uint index, bool r, bool g, bool b, bool a) => GLPointers._glColorMaski_fnptr(index, (byte)(r ? 1 : 0), (byte)(g ? 1 : 0), (byte)(b ? 1 : 0), (byte)(a ? 1 : 0));
        
        /// <summary> <b>[requires: v3.0] [glGetBooleani_v]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetBooleani_v(BufferTargetARB target, uint index, bool* data) => GLPointers._glGetBooleani_v_fnptr((uint)target, index, (byte*)data);
        
        /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object] [glGetIntegeri_v]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetIntegeri_v(GetPName target, uint index, int* data) => GLPointers._glGetIntegeri_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v3.0] [glEnablei]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Enablei(EnableCap target, uint index) => GLPointers._glEnablei_fnptr((uint)target, index);
        
        /// <summary> <b>[requires: v3.0] [glDisablei]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Disablei(EnableCap target, uint index) => GLPointers._glDisablei_fnptr((uint)target, index);
        
        /// <summary> <b>[requires: v3.0] [glIsEnabledi]</b> Test whether a capability is enabled. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml" /></remarks>
        public static bool IsEnabledi(EnableCap target, uint index) => GLPointers._glIsEnabledi_fnptr((uint)target, index) != 0;
        
        /// <summary> <b>[requires: v3.0] [glBeginTransformFeedback]</b> Start transform feedback operation. </summary>
        /// <param name="primitiveMode"> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml" /></remarks>
        public static void BeginTransformFeedback(PrimitiveType primitiveMode) => GLPointers._glBeginTransformFeedback_fnptr((uint)primitiveMode);
        
        /// <summary> <b>[requires: v3.0] [glEndTransformFeedback]</b> Start transform feedback operation. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml" /></remarks>
        public static void EndTransformFeedback() => GLPointers._glEndTransformFeedback_fnptr();
        
        /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object] [glBindBufferRange]</b> Bind a range within a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
        /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml" /></remarks>
        public static void BindBufferRange(BufferTargetARB target, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glBindBufferRange_fnptr((uint)target, index, buffer, offset, size);
        
        /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object] [glBindBufferBase]</b> Bind a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml" /></remarks>
        public static void BindBufferBase(BufferTargetARB target, uint index, int buffer) => GLPointers._glBindBufferBase_fnptr((uint)target, index, buffer);
        
        /// <summary> <b>[requires: v3.0] [glTransformFeedbackVaryings]</b> Specify values to record in transform feedback buffers. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="count"> The number of varying variables used for transform feedback. </param>
        /// <param name="varyings"> An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback. </param>
        /// <param name="bufferMode"> Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackVaryings.xhtml" /></remarks>
        public static void TransformFeedbackVaryings(int program, int count, byte** varyings, TransformFeedbackBufferMode bufferMode) => GLPointers._glTransformFeedbackVaryings_fnptr(program, count, varyings, (uint)bufferMode);
        
        /// <summary> <b>[requires: v3.0] [glGetTransformFeedbackVarying]</b> Retrieve information about varying variables selected for transform feedback. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="index"> The index of the varying variable whose information to retrieve. </param>
        /// <param name="bufSize"> The maximum number of characters, including the null terminator, that may be written into name. </param>
        /// <param name="length"> The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned. </param>
        /// <param name="size"> The address of a variable that will receive the size of the varying. </param>
        /// <param name="type"> The address of a variable that will receive the type of the varying. </param>
        /// <param name="name"> The address of a buffer into which will be written the name of the varying. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedbackVarying.xhtml" /></remarks>
        public static void GetTransformFeedbackVarying(int program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers._glGetTransformFeedbackVarying_fnptr(program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v3.0] [glClampColor]</b> Specify whether data read via glReadPixels should be clamped. </summary>
        /// <param name="target"> Target for color clamping. target must be GL_CLAMP_READ_COLOR. </param>
        /// <param name="clamp"> Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClampColor.xhtml" /></remarks>
        public static void ClampColor(ClampColorTargetARB target, ClampColorModeARB clamp) => GLPointers._glClampColor_fnptr((uint)target, (uint)clamp);
        
        /// <summary> <b>[requires: v3.0] [glBeginConditionalRender]</b> Start conditional rendering. </summary>
        /// <param name="id"> Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded. </param>
        /// <param name="mode"> Specifies how glBeginConditionalRender interprets the results of the occlusion query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml" /></remarks>
        public static void BeginConditionalRender(uint id, ConditionalRenderMode mode) => GLPointers._glBeginConditionalRender_fnptr(id, (uint)mode);
        
        /// <summary> <b>[requires: v3.0] [glEndConditionalRender]</b> Start conditional rendering. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml" /></remarks>
        public static void EndConditionalRender() => GLPointers._glEndConditionalRender_fnptr();
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribIPointer]</b> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribIPointer(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers._glVertexAttribIPointer_fnptr(index, size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v3.0] [glGetVertexAttribIiv]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribIiv(uint index, VertexAttribEnum pname, int* parameters) => GLPointers._glGetVertexAttribIiv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0] [glGetVertexAttribIuiv]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribIuiv(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers._glGetVertexAttribIuiv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI1i]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1i(uint index, int x) => GLPointers._glVertexAttribI1i_fnptr(index, x);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI2i]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2i(uint index, int x, int y) => GLPointers._glVertexAttribI2i_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI3i]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3i(uint index, int x, int y, int z) => GLPointers._glVertexAttribI3i_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI4i]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4i(uint index, int x, int y, int z, int w) => GLPointers._glVertexAttribI4i_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI1ui]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1ui(uint index, uint x) => GLPointers._glVertexAttribI1ui_fnptr(index, x);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI2ui]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2ui(uint index, uint x, uint y) => GLPointers._glVertexAttribI2ui_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI3ui]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3ui(uint index, uint x, uint y, uint z) => GLPointers._glVertexAttribI3ui_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI4ui]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w) => GLPointers._glVertexAttribI4ui_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI1iv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1iv(uint index, int* v) => GLPointers._glVertexAttribI1iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI2iv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2iv(uint index, int* v) => GLPointers._glVertexAttribI2iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI3iv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3iv(uint index, int* v) => GLPointers._glVertexAttribI3iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI4iv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4iv(uint index, int* v) => GLPointers._glVertexAttribI4iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI1uiv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1uiv(uint index, uint* v) => GLPointers._glVertexAttribI1uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI2uiv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2uiv(uint index, uint* v) => GLPointers._glVertexAttribI2uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI3uiv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3uiv(uint index, uint* v) => GLPointers._glVertexAttribI3uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI4uiv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4uiv(uint index, uint* v) => GLPointers._glVertexAttribI4uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI4bv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4bv(uint index, sbyte* v) => GLPointers._glVertexAttribI4bv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI4sv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4sv(uint index, short* v) => GLPointers._glVertexAttribI4sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI4ubv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4ubv(uint index, byte* v) => GLPointers._glVertexAttribI4ubv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glVertexAttribI4usv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4usv(uint index, ushort* v) => GLPointers._glVertexAttribI4usv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0] [glGetUniformuiv]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformuiv(int program, int location, uint* parameters) => GLPointers._glGetUniformuiv_fnptr(program, location, parameters);
        
        /// <summary> <b>[requires: v3.0] [glBindFragDataLocation]</b> Bind a user-defined varying out variable to a fragment shader color number. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocation.xhtml" /></remarks>
        public static void BindFragDataLocation(int program, uint color, byte* name) => GLPointers._glBindFragDataLocation_fnptr(program, color, name);
        
        /// <summary> <b>[requires: v3.0] [glGetFragDataLocation]</b> Query the bindings of color numbers to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataLocation.xhtml" /></remarks>
        public static int GetFragDataLocation(int program, byte* name) => GLPointers._glGetFragDataLocation_fnptr(program, name);
        
        /// <summary> <b>[requires: v3.0] [glUniform1ui]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1ui(int location, uint v0) => GLPointers._glUniform1ui_fnptr(location, v0);
        
        /// <summary> <b>[requires: v3.0] [glUniform2ui]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2ui(int location, uint v0, uint v1) => GLPointers._glUniform2ui_fnptr(location, v0, v1);
        
        /// <summary> <b>[requires: v3.0] [glUniform3ui]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3ui(int location, uint v0, uint v1, uint v2) => GLPointers._glUniform3ui_fnptr(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v3.0] [glUniform4ui]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glUniform4ui_fnptr(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v3.0] [glUniform1uiv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1uiv(int location, int count, uint* value) => GLPointers._glUniform1uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0] [glUniform2uiv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2uiv(int location, int count, uint* value) => GLPointers._glUniform2uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0] [glUniform3uiv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3uiv(int location, int count, uint* value) => GLPointers._glUniform3uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0] [glUniform4uiv]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4uiv(int location, int count, uint* value) => GLPointers._glUniform4uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0] [glTexParameterIiv]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterIiv(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTexParameterIiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0] [glTexParameterIuiv]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterIuiv(TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._glTexParameterIuiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0] [glGetTexParameterIiv]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterIiv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexParameterIiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0] [glGetTexParameterIuiv]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterIuiv(TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTexParameterIuiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0] [glClearBufferiv]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferiv(Buffer buffer, int drawbuffer, int* value) => GLPointers._glClearBufferiv_fnptr((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v3.0] [glClearBufferuiv]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferuiv(Buffer buffer, int drawbuffer, uint* value) => GLPointers._glClearBufferuiv_fnptr((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v3.0] [glClearBufferfv]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferfv(Buffer buffer, int drawbuffer, float* value) => GLPointers._glClearBufferfv_fnptr((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v3.0] [glClearBufferfi]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferfi(Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers._glClearBufferfi_fnptr((uint)buffer, drawbuffer, depth, stencil);
        
        /// <summary> <b>[requires: v3.0] [glGetStringi]</b> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <param name="index"> For glGetStringi, specifies the index of the string to return. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml" /></remarks>
        public static byte* GetStringi_(StringName name, uint index) => GLPointers._glGetStringi_fnptr((uint)name, index);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glIsRenderbuffer]</b> Determine if a name corresponds to a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml" /></remarks>
        public static bool IsRenderbuffer(int renderbuffer) => GLPointers._glIsRenderbuffer_fnptr(renderbuffer) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glBindRenderbuffer]</b> Bind a renderbuffer to a renderbuffer target. </summary>
        /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml" /></remarks>
        public static void BindRenderbuffer(RenderbufferTarget target, int renderbuffer) => GLPointers._glBindRenderbuffer_fnptr((uint)target, renderbuffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glDeleteRenderbuffers]</b> Delete renderbuffer objects. </summary>
        /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
        /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml" /></remarks>
        public static void DeleteRenderbuffers(int n, int* renderbuffers) => GLPointers._glDeleteRenderbuffers_fnptr(n, renderbuffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGenRenderbuffers]</b> Generate renderbuffer object names. </summary>
        /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
        /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml" /></remarks>
        public static void GenRenderbuffers(int n, int* renderbuffers) => GLPointers._glGenRenderbuffers_fnptr(n, renderbuffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glRenderbufferStorage]</b> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
        public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorage_fnptr((uint)target, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGetRenderbufferParameteriv]</b> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
        public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetRenderbufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glIsFramebuffer]</b> Determine if a name corresponds to a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml" /></remarks>
        public static bool IsFramebuffer(int framebuffer) => GLPointers._glIsFramebuffer_fnptr(framebuffer) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glBindFramebuffer]</b> Bind a framebuffer to a framebuffer target. </summary>
        /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml" /></remarks>
        public static void BindFramebuffer(FramebufferTarget target, int framebuffer) => GLPointers._glBindFramebuffer_fnptr((uint)target, framebuffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glDeleteFramebuffers]</b> Delete framebuffer objects. </summary>
        /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
        /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml" /></remarks>
        public static void DeleteFramebuffers(int n, int* framebuffers) => GLPointers._glDeleteFramebuffers_fnptr(n, framebuffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGenFramebuffers]</b> Generate framebuffer object names. </summary>
        /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
        /// <param name="ids"> Specifies an array in which the generated framebuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml" /></remarks>
        public static void GenFramebuffers(int n, int* framebuffers) => GLPointers._glGenFramebuffers_fnptr(n, framebuffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glCheckFramebufferStatus]</b> Check the completeness status of a framebuffer. </summary>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
        public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckFramebufferStatus_fnptr((uint)target);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferTexture1D]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture1D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferTexture2D]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture2D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferTexture3D]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers._glFramebufferTexture3D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level, zoffset);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferRenderbuffer]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
        public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glFramebufferRenderbuffer_fnptr((uint)target, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGetFramebufferAttachmentParameteriv]</b> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
        public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferAttachmentParameteriv_fnptr((uint)target, (uint)attachment, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGenerateMipmap]</b> Generate mipmaps for a specified texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
        public static void GenerateMipmap(TextureTarget target) => GLPointers._glGenerateMipmap_fnptr((uint)target);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glBlitFramebuffer]</b> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
        public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glRenderbufferStorageMultisample]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
        public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferTextureLayer]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
        public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayer_fnptr((uint)target, (uint)attachment, texture, level, layer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range] [glMapBufferRange]</b> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
        public static void* MapBufferRange(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapBufferRange_fnptr((uint)target, offset, length, (uint)access);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range] [glFlushMappedBufferRange]</b> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
        public static void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, nint length) => GLPointers._glFlushMappedBufferRange_fnptr((uint)target, offset, length);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object] [glBindVertexArray]</b> Bind a vertex array object. </summary>
        /// <param name="array"> Specifies the name of the vertex array to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" /></remarks>
        public static void BindVertexArray(int array) => GLPointers._glBindVertexArray_fnptr(array);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object] [glDeleteVertexArrays]</b> Delete vertex array objects. </summary>
        /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
        /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml" /></remarks>
        public static void DeleteVertexArrays(int n, int* arrays) => GLPointers._glDeleteVertexArrays_fnptr(n, arrays);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object] [glGenVertexArrays]</b> Generate vertex array object names. </summary>
        /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
        /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" /></remarks>
        public static void GenVertexArrays(int n, int* arrays) => GLPointers._glGenVertexArrays_fnptr(n, arrays);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object] [glIsVertexArray]</b> Determine if a name corresponds to a vertex array object. </summary>
        /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml" /></remarks>
        public static bool IsVertexArray(int array) => GLPointers._glIsVertexArray_fnptr(array) != 0;
        
        /// <summary> <b>[requires: v3.1] [glDrawArraysInstanced]</b> Draw multiple instances of a range of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstanced.xhtml" /></remarks>
        public static void DrawArraysInstanced(PrimitiveType mode, int first, int count, int instancecount) => GLPointers._glDrawArraysInstanced_fnptr((uint)mode, first, count, instancecount);
        
        /// <summary> <b>[requires: v3.1] [glDrawElementsInstanced]</b> Draw multiple instances of a set of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstanced.xhtml" /></remarks>
        public static void DrawElementsInstanced(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount) => GLPointers._glDrawElementsInstanced_fnptr((uint)mode, count, (uint)type, indices, instancecount);
        
        /// <summary> <b>[requires: v3.1] [glTexBuffer]</b> Attach a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
        public static void TexBuffer(TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers._glTexBuffer_fnptr((uint)target, (uint)internalformat, buffer);
        
        /// <summary> <b>[requires: v3.1] [glPrimitiveRestartIndex]</b> Specify the primitive restart index. </summary>
        /// <param name="index"> Specifies the value to be interpreted as the primitive restart index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPrimitiveRestartIndex.xhtml" /></remarks>
        public static void PrimitiveRestartIndex(uint index) => GLPointers._glPrimitiveRestartIndex_fnptr(index);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer] [glCopyBufferSubData]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
        /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
        public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glCopyBufferSubData_fnptr((uint)readTarget, (uint)writeTarget, readOffset, writeOffset, size);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetUniformIndices]</b> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
        /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
        /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
        /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml" /></remarks>
        public static void GetUniformIndices(int program, int uniformCount, byte** uniformNames, uint* uniformIndices) => GLPointers._glGetUniformIndices_fnptr(program, uniformCount, uniformNames, uniformIndices);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetActiveUniformsiv]</b> Returns information about several active uniform variables for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
        /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
        /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
        /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml" /></remarks>
        public static void GetActiveUniformsiv(int program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => GLPointers._glGetActiveUniformsiv_fnptr(program, uniformCount, uniformIndices, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetActiveUniformName]</b> Query the name of an active uniform. </summary>
        /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
        /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
        /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
        /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
        /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml" /></remarks>
        public static void GetActiveUniformName(int program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => GLPointers._glGetActiveUniformName_fnptr(program, uniformIndex, bufSize, length, uniformName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetUniformBlockIndex]</b> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml" /></remarks>
        public static uint GetUniformBlockIndex(int program, byte* uniformBlockName) => GLPointers._glGetUniformBlockIndex_fnptr(program, uniformBlockName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetActiveUniformBlockiv]</b> Query information about an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="pname"> Specifies the name of the parameter to query. </param>
        /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml" /></remarks>
        public static void GetActiveUniformBlockiv(int program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => GLPointers._glGetActiveUniformBlockiv_fnptr(program, uniformBlockIndex, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetActiveUniformBlockName]</b> Retrieve the name of an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml" /></remarks>
        public static void GetActiveUniformBlockName(int program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => GLPointers._glGetActiveUniformBlockName_fnptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glUniformBlockBinding]</b> Assign a binding point to an active uniform block. </summary>
        /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
        /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
        /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml" /></remarks>
        public static void UniformBlockBinding(int program, uint uniformBlockIndex, uint uniformBlockBinding) => GLPointers._glUniformBlockBinding_fnptr(program, uniformBlockIndex, uniformBlockBinding);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex] [glDrawElementsBaseVertex]</b> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml" /></remarks>
        public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._glDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, basevertex);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex] [glDrawRangeElementsBaseVertex]</b> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml" /></remarks>
        public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._glDrawRangeElementsBaseVertex_fnptr((uint)mode, start, end, count, (uint)type, indices, basevertex);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex] [glDrawElementsInstancedBaseVertex]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => GLPointers._glDrawElementsInstancedBaseVertex_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex] [glMultiDrawElementsBaseVertex]</b> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
        /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml" /></remarks>
        public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => GLPointers._glMultiDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, drawcount, basevertex);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex] [glProvokingVertex]</b> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
        /// <param name="provokeMode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml" /></remarks>
        public static void ProvokingVertex(VertexProvokingMode mode) => GLPointers._glProvokingVertex_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glFenceSync]</b> Create a new sync object and insert it into the GL command stream. </summary>
        /// <param name="condition"> Specifies the condition that must be met to set the sync object&apos;s state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
        /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml" /></remarks>
        public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) GLPointers._glFenceSync_fnptr((uint)condition, (uint)flags);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glIsSync]</b> Determine if a name corresponds to a sync object. </summary>
        /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml" /></remarks>
        public static bool IsSync(GLSync sync) => GLPointers._glIsSync_fnptr((IntPtr)sync) != 0;
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glDeleteSync]</b> Delete a sync object. </summary>
        /// <param name="sync"> The sync object to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml" /></remarks>
        public static void DeleteSync(GLSync sync) => GLPointers._glDeleteSync_fnptr((IntPtr)sync);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glClientWaitSync]</b> Block and wait for a sync object to become signaled. </summary>
        /// <param name="sync"> The sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
        /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml" /></remarks>
        public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => (SyncStatus) GLPointers._glClientWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glWaitSync]</b> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
        /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
        /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml" /></remarks>
        public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => GLPointers._glWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glGetInteger64v]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetInteger64v(GetPName pname, long* data) => GLPointers._glGetInteger64v_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glGetSynciv]</b> Query the properties of a sync object. </summary>
        /// <param name="sync"> Specifies the sync object whose properties to query. </param>
        /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in values. </param>
        /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
        /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml" /></remarks>
        public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => GLPointers._glGetSynciv_fnptr((IntPtr)sync, (uint)pname, count, length, values);
        
        /// <summary> <b>[requires: v3.2] [glGetInteger64i_v]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetInteger64i_v(GetPName target, uint index, long* data) => GLPointers._glGetInteger64i_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v3.2] [glGetBufferParameteri64v]</b> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="value"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="data"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetBufferParameteri64v(BufferTargetARB target, BufferPNameARB pname, long* parameters) => GLPointers._glGetBufferParameteri64v_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.2] [glFramebufferTexture]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level) => GLPointers._glFramebufferTexture_fnptr((uint)target, (uint)attachment, texture, level);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample] [glTexImage2DMultisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
        /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml" /></remarks>
        public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTexImage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample] [glTexImage3DMultisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
        /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
        /// <param name="depth">!!missing documentation!!</param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml" /></remarks>
        public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTexImage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample] [glGetMultisamplefv]</b> Retrieve the location of a sample. </summary>
        /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
        /// <param name="index"> Specifies the index of the sample whose position to query. </param>
        /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml" /></remarks>
        public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers._glGetMultisamplefv_fnptr((uint)pname, index, val);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample] [glSampleMaski]</b> Set the value of a sub-word of the sample mask. </summary>
        /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
        /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml" /></remarks>
        public static void SampleMaski(uint maskNumber, uint mask) => GLPointers._glSampleMaski_fnptr(maskNumber, mask);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended] [glBindFragDataLocationIndexed]</b> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml" /></remarks>
        public static void BindFragDataLocationIndexed(int program, uint colorNumber, uint index, byte* name) => GLPointers._glBindFragDataLocationIndexed_fnptr(program, colorNumber, index, name);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended] [glGetFragDataIndex]</b> Query the bindings of color indices to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml" /></remarks>
        public static int GetFragDataIndex(int program, byte* name) => GLPointers._glGetFragDataIndex_fnptr(program, name);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGenSamplers]</b> Generate sampler object names. </summary>
        /// <param name="n"> Specifies the number of sampler object names to generate. </param>
        /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml" /></remarks>
        public static void GenSamplers(int count, int* samplers) => GLPointers._glGenSamplers_fnptr(count, samplers);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glDeleteSamplers]</b> Delete named sampler objects. </summary>
        /// <param name="n"> Specifies the number of sampler objects to be deleted. </param>
        /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml" /></remarks>
        public static void DeleteSamplers(int count, int* samplers) => GLPointers._glDeleteSamplers_fnptr(count, samplers);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glIsSampler]</b> Determine if a name corresponds to a sampler object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a sampler object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml" /></remarks>
        public static bool IsSampler(int sampler) => GLPointers._glIsSampler_fnptr(sampler) != 0;
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glBindSampler]</b> Bind a named sampler to a texturing target. </summary>
        /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
        /// <param name="sampler"> Specifies the name of a sampler. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml" /></remarks>
        public static void BindSampler(uint unit, int sampler) => GLPointers._glBindSampler_fnptr(unit, sampler);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameteri]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameteri(int sampler, SamplerParameterI pname, int param) => GLPointers._glSamplerParameteri_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameteriv]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameteriv(int sampler, SamplerParameterI pname, int* param) => GLPointers._glSamplerParameteriv_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameterf]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterf(int sampler, SamplerParameterF pname, float param) => GLPointers._glSamplerParameterf_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameterfv]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterfv(int sampler, SamplerParameterF pname, float* param) => GLPointers._glSamplerParameterfv_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameterIiv]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterIiv(int sampler, SamplerParameterI pname, int* param) => GLPointers._glSamplerParameterIiv_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameterIuiv]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* param) => GLPointers._glSamplerParameterIuiv_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGetSamplerParameteriv]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameteriv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers._glGetSamplerParameteriv_fnptr(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGetSamplerParameterIiv]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterIiv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers._glGetSamplerParameterIiv_fnptr(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGetSamplerParameterfv]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterfv(int sampler, SamplerParameterF pname, float* parameters) => GLPointers._glGetSamplerParameterfv_fnptr(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGetSamplerParameterIuiv]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* parameters) => GLPointers._glGetSamplerParameterIuiv_fnptr(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query] [glQueryCounter]</b> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
        /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
        /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml" /></remarks>
        public static void QueryCounter(int id, QueryCounterTarget target) => GLPointers._glQueryCounter_fnptr(id, (uint)target);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query] [glGetQueryObjecti64v]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjecti64v(int id, QueryObjectParameterName pname, long* parameters) => GLPointers._glGetQueryObjecti64v_fnptr(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query] [glGetQueryObjectui64v]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectui64v(int id, QueryObjectParameterName pname, ulong* parameters) => GLPointers._glGetQueryObjectui64v_fnptr(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3] [glVertexAttribDivisor]</b> Modify the rate at which generic vertex attributes advance during instanced rendering. </summary>
        /// <param name="index"> Specify the index of the generic vertex attribute. </param>
        /// <param name="divisor"> Specify the number of instances that will pass between updates of the generic attribute at slot index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribDivisor.xhtml" /></remarks>
        public static void VertexAttribDivisor(uint index, uint divisor) => GLPointers._glVertexAttribDivisor_fnptr(index, divisor);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP1ui]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP1ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP1uiv]</b>  </summary>
        public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP1uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP2ui]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP2ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP2uiv]</b>  </summary>
        public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP2uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP3ui]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP3ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP3uiv]</b>  </summary>
        public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP3uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP4ui]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP4ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP4uiv]</b>  </summary>
        public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP4uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP2ui]</b>  </summary>
        public static void VertexP2ui(VertexPointerType type, uint value) => GLPointers._glVertexP2ui_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP2uiv]</b>  </summary>
        public static void VertexP2uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP2uiv_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP3ui]</b>  </summary>
        public static void VertexP3ui(VertexPointerType type, uint value) => GLPointers._glVertexP3ui_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP3uiv]</b>  </summary>
        public static void VertexP3uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP3uiv_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP4ui]</b>  </summary>
        public static void VertexP4ui(VertexPointerType type, uint value) => GLPointers._glVertexP4ui_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP4uiv]</b>  </summary>
        public static void VertexP4uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP4uiv_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP1ui]</b>  </summary>
        public static void TexCoordP1ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP1ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP1uiv]</b>  </summary>
        public static void TexCoordP1uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP1uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP2ui]</b>  </summary>
        public static void TexCoordP2ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP2ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP2uiv]</b>  </summary>
        public static void TexCoordP2uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP2uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP3ui]</b>  </summary>
        public static void TexCoordP3ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP3ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP3uiv]</b>  </summary>
        public static void TexCoordP3uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP3uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP4ui]</b>  </summary>
        public static void TexCoordP4ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP4ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP4uiv]</b>  </summary>
        public static void TexCoordP4uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP4uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP1ui]</b>  </summary>
        public static void MultiTexCoordP1ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP1ui_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP1uiv]</b>  </summary>
        public static void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP1uiv_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP2ui]</b>  </summary>
        public static void MultiTexCoordP2ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP2ui_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP2uiv]</b>  </summary>
        public static void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP2uiv_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP3ui]</b>  </summary>
        public static void MultiTexCoordP3ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP3ui_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP3uiv]</b>  </summary>
        public static void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP3uiv_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP4ui]</b>  </summary>
        public static void MultiTexCoordP4ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP4ui_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP4uiv]</b>  </summary>
        public static void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP4uiv_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glNormalP3ui]</b>  </summary>
        public static void NormalP3ui(NormalPointerType type, uint coords) => GLPointers._glNormalP3ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glNormalP3uiv]</b>  </summary>
        public static void NormalP3uiv(NormalPointerType type, uint* coords) => GLPointers._glNormalP3uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glColorP3ui]</b>  </summary>
        public static void ColorP3ui(ColorPointerType type, uint color) => GLPointers._glColorP3ui_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glColorP3uiv]</b>  </summary>
        public static void ColorP3uiv(ColorPointerType type, uint* color) => GLPointers._glColorP3uiv_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glColorP4ui]</b>  </summary>
        public static void ColorP4ui(ColorPointerType type, uint color) => GLPointers._glColorP4ui_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glColorP4uiv]</b>  </summary>
        public static void ColorP4uiv(ColorPointerType type, uint* color) => GLPointers._glColorP4uiv_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glSecondaryColorP3ui]</b>  </summary>
        public static void SecondaryColorP3ui(ColorPointerType type, uint color) => GLPointers._glSecondaryColorP3ui_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glSecondaryColorP3uiv]</b>  </summary>
        public static void SecondaryColorP3uiv(ColorPointerType type, uint* color) => GLPointers._glSecondaryColorP3uiv_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v4.0] [glMinSampleShading]</b> Specifies minimum rate at which sample shading takes place. </summary>
        /// <param name="value"> Specifies the rate at which samples are shaded within each covered pixel. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMinSampleShading.xhtml" /></remarks>
        public static void MinSampleShading(float value) => GLPointers._glMinSampleShading_fnptr(value);
        
        /// <summary> <b>[requires: v4.0] [glBlendEquationi]</b> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="buf"> for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation. </param>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
        public static void BlendEquationi(uint buf, BlendEquationModeEXT mode) => GLPointers._glBlendEquationi_fnptr(buf, (uint)mode);
        
        /// <summary> <b>[requires: v4.0] [glBlendEquationSeparatei]</b> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="buf"> for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations. </param>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml" /></remarks>
        public static void BlendEquationSeparatei(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparatei_fnptr(buf, (uint)modeRGB, (uint)modeAlpha);
        
        /// <summary> <b>[requires: v4.0] [glBlendFunci]</b> Specify pixel arithmetic. </summary>
        /// <param name="buf"> For glBlendFunci, specifies the index of the draw buffer for which to set the blend function. </param>
        /// <param name="sfactor"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactor"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" /></remarks>
        public static void BlendFunci(uint buf, BlendingFactor src, BlendingFactor dst) => GLPointers._glBlendFunci_fnptr(buf, (uint)src, (uint)dst);
        
        /// <summary> <b>[requires: v4.0] [glBlendFuncSeparatei]</b> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="buf"> For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions. </param>
        /// <param name="srcRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dstRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="srcAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dstAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml" /></remarks>
        public static void BlendFuncSeparatei(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers._glBlendFuncSeparatei_fnptr(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect] [glDrawArraysIndirect]</b> Render primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml" /></remarks>
        public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => GLPointers._glDrawArraysIndirect_fnptr((uint)mode, indirect);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect] [glDrawElementsIndirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml" /></remarks>
        public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => GLPointers._glDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform1d]</b>  </summary>
        public static void Uniform1d(int location, double x) => GLPointers._glUniform1d_fnptr(location, x);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform2d]</b>  </summary>
        public static void Uniform2d(int location, double x, double y) => GLPointers._glUniform2d_fnptr(location, x, y);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform3d]</b>  </summary>
        public static void Uniform3d(int location, double x, double y, double z) => GLPointers._glUniform3d_fnptr(location, x, y, z);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform4d]</b>  </summary>
        public static void Uniform4d(int location, double x, double y, double z, double w) => GLPointers._glUniform4d_fnptr(location, x, y, z, w);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform1dv]</b>  </summary>
        public static void Uniform1dv(int location, int count, double* value) => GLPointers._glUniform1dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform2dv]</b>  </summary>
        public static void Uniform2dv(int location, int count, double* value) => GLPointers._glUniform2dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform3dv]</b>  </summary>
        public static void Uniform3dv(int location, int count, double* value) => GLPointers._glUniform3dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform4dv]</b>  </summary>
        public static void Uniform4dv(int location, int count, double* value) => GLPointers._glUniform4dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix2dv]</b>  </summary>
        public static void UniformMatrix2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix3dv]</b>  </summary>
        public static void UniformMatrix3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix4dv]</b>  </summary>
        public static void UniformMatrix4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix2x3dv]</b>  </summary>
        public static void UniformMatrix2x3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix2x4dv]</b>  </summary>
        public static void UniformMatrix2x4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix3x2dv]</b>  </summary>
        public static void UniformMatrix3x2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix3x4dv]</b>  </summary>
        public static void UniformMatrix3x4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix4x2dv]</b>  </summary>
        public static void UniformMatrix4x2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix4x3dv]</b>  </summary>
        public static void UniformMatrix4x3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glGetUniformdv]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformdv(int program, int location, double* parameters) => GLPointers._glGetUniformdv_fnptr(program, location, parameters);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetSubroutineUniformLocation]</b> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml" /></remarks>
        public static int GetSubroutineUniformLocation(int program, ShaderType shadertype, byte* name) => GLPointers._glGetSubroutineUniformLocation_fnptr(program, (uint)shadertype, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetSubroutineIndex]</b> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml" /></remarks>
        public static uint GetSubroutineIndex(int program, ShaderType shadertype, byte* name) => GLPointers._glGetSubroutineIndex_fnptr(program, (uint)shadertype, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetActiveSubroutineUniformiv]</b> Query a property of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
        /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml" /></remarks>
        public static void GetActiveSubroutineUniformiv(int program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => GLPointers._glGetActiveSubroutineUniformiv_fnptr(program, (uint)shadertype, index, (uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetActiveSubroutineUniformName]</b> Query the name of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
        /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml" /></remarks>
        public static void GetActiveSubroutineUniformName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetActiveSubroutineUniformName_fnptr(program, (uint)shadertype, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetActiveSubroutineName]</b> Query the name of an active shader subroutine. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
        /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml" /></remarks>
        public static void GetActiveSubroutineName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetActiveSubroutineName_fnptr(program, (uint)shadertype, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glUniformSubroutinesuiv]</b> Load active subroutine uniforms. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
        /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml" /></remarks>
        public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => GLPointers._glUniformSubroutinesuiv_fnptr((uint)shadertype, count, indices);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetUniformSubroutineuiv]</b> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="location"> Specifies the location of the subroutine uniform. </param>
        /// <param name="values"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml" /></remarks>
        public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => GLPointers._glGetUniformSubroutineuiv_fnptr((uint)shadertype, location, parameters);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetProgramStageiv]</b> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
        /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml" /></remarks>
        public static void GetProgramStageiv(int program, ShaderType shadertype, ProgramStagePName pname, int* values) => GLPointers._glGetProgramStageiv_fnptr(program, (uint)shadertype, (uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader] [glPatchParameteri]</b> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
        public static void PatchParameteri(PatchParameterName pname, int value) => GLPointers._glPatchParameteri_fnptr((uint)pname, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader] [glPatchParameterfv]</b> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
        public static void PatchParameterfv(PatchParameterName pname, float* values) => GLPointers._glPatchParameterfv_fnptr((uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glBindTransformFeedback]</b> Bind a transform feedback object. </summary>
        /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
        /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml" /></remarks>
        public static void BindTransformFeedback(BindTransformFeedbackTarget target, int id) => GLPointers._glBindTransformFeedback_fnptr((uint)target, id);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glDeleteTransformFeedbacks]</b> Delete transform feedback objects. </summary>
        /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
        /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml" /></remarks>
        public static void DeleteTransformFeedbacks(int n, int* ids) => GLPointers._glDeleteTransformFeedbacks_fnptr(n, ids);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glGenTransformFeedbacks]</b> Reserve transform feedback object names. </summary>
        /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
        /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml" /></remarks>
        public static void GenTransformFeedbacks(int n, int* ids) => GLPointers._glGenTransformFeedbacks_fnptr(n, ids);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glIsTransformFeedback]</b> Determine if a name corresponds to a transform feedback object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml" /></remarks>
        public static bool IsTransformFeedback(int id) => GLPointers._glIsTransformFeedback_fnptr(id) != 0;
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glPauseTransformFeedback]</b> Pause transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml" /></remarks>
        public static void PauseTransformFeedback() => GLPointers._glPauseTransformFeedback_fnptr();
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glResumeTransformFeedback]</b> Resume transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml" /></remarks>
        public static void ResumeTransformFeedback() => GLPointers._glResumeTransformFeedback_fnptr();
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glDrawTransformFeedback]</b> Render primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml" /></remarks>
        public static void DrawTransformFeedback(PrimitiveType mode, int id) => GLPointers._glDrawTransformFeedback_fnptr((uint)mode, id);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3] [glDrawTransformFeedbackStream]</b> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml" /></remarks>
        public static void DrawTransformFeedbackStream(PrimitiveType mode, int id, uint stream) => GLPointers._glDrawTransformFeedbackStream_fnptr((uint)mode, id, stream);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3] [glBeginQueryIndexed]</b> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
        public static void BeginQueryIndexed(QueryTarget target, uint index, int id) => GLPointers._glBeginQueryIndexed_fnptr((uint)target, index, id);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3] [glEndQueryIndexed]</b> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
        public static void EndQueryIndexed(QueryTarget target, uint index) => GLPointers._glEndQueryIndexed_fnptr((uint)target, index);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3] [glGetQueryIndexediv]</b> Return parameters of an indexed query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="index"> Specifies the index of the query object target. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml" /></remarks>
        public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => GLPointers._glGetQueryIndexediv_fnptr((uint)target, index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glReleaseShaderCompiler]</b> Release resources consumed by the implementation&apos;s shader compiler. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml" /></remarks>
        public static void ReleaseShaderCompiler() => GLPointers._glReleaseShaderCompiler_fnptr();
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glShaderBinary]</b> Load pre-compiled shader binaries. </summary>
        /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
        /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
        /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
        /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
        /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml" /></remarks>
        public static void ShaderBinary(int count, int* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => GLPointers._glShaderBinary_fnptr(count, shaders, (uint)binaryFormat, binary, length);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glGetShaderPrecisionFormat]</b> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
        /// <param name="shaderType"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="precisionType"> Specifies the numeric format whose precision and range to query. </param>
        /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation&apos;s numeric range are returned. </param>
        /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml" /></remarks>
        public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => GLPointers._glGetShaderPrecisionFormat_fnptr((uint)shadertype, (uint)precisiontype, range, precision);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glDepthRangef]</b> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
        public static void DepthRangef(float n, float f) => GLPointers._glDepthRangef_fnptr(n, f);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glClearDepthf]</b> Specify the clear value for the depth buffer. </summary>
        /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
        public static void ClearDepthf(float d) => GLPointers._glClearDepthf_fnptr(d);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary] [glGetProgramBinary]</b> Return a binary representation of a program object&apos;s compiled and linked executable source. </summary>
        /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
        /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
        /// <param name="binary"> Specifies the address an array into which the GL will return program&apos;s binary representation. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml" /></remarks>
        public static void GetProgramBinary(int program, int bufSize, int* length, All* binaryFormat, void* binary) => GLPointers._glGetProgramBinary_fnptr(program, bufSize, length, (uint*)binaryFormat, binary);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary] [glProgramBinary]</b> Load a program object with a program binary. </summary>
        /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
        /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
        /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
        /// <param name="length"> Specifies the number of bytes contained in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml" /></remarks>
        public static void ProgramBinary(int program, All binaryFormat, void* binary, int length) => GLPointers._glProgramBinary_fnptr(program, (uint)binaryFormat, binary, length);
        
        /// <summary> <b>[requires: v4.1 | v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects] [glProgramParameteri]</b> Specify a parameter for a program object. </summary>
        /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the name of the parameter to modify. </param>
        /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml" /></remarks>
        public static void ProgramParameteri(int program, ProgramParameterPName pname, int value) => GLPointers._glProgramParameteri_fnptr(program, (uint)pname, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glUseProgramStages]</b> Bind stages of a program object to a program pipeline. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
        /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
        /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml" /></remarks>
        public static void UseProgramStages(int pipeline, UseProgramStageMask stages, int program) => GLPointers._glUseProgramStages_fnptr(pipeline, (uint)stages, program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glActiveShaderProgram]</b> Set the active program object for a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
        /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml" /></remarks>
        public static void ActiveShaderProgram(int pipeline, int program) => GLPointers._glActiveShaderProgram_fnptr(pipeline, program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glCreateShaderProgramv]</b> Create a stand-alone program from an array of null-terminated source code strings. </summary>
        /// <param name="type"> Specifies the type of shader to create. </param>
        /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
        /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml" /></remarks>
        public static int CreateShaderProgramv(ShaderType type, int count, byte** strings) => GLPointers._glCreateShaderProgramv_fnptr((uint)type, count, strings);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glBindProgramPipeline]</b> Bind a program pipeline to the current context. </summary>
        /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml" /></remarks>
        public static void BindProgramPipeline(int pipeline) => GLPointers._glBindProgramPipeline_fnptr(pipeline);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glDeleteProgramPipelines]</b> Delete program pipeline objects. </summary>
        /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
        /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml" /></remarks>
        public static void DeleteProgramPipelines(int n, int* pipelines) => GLPointers._glDeleteProgramPipelines_fnptr(n, pipelines);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glGenProgramPipelines]</b> Reserve program pipeline object names. </summary>
        /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
        /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml" /></remarks>
        public static void GenProgramPipelines(int n, int* pipelines) => GLPointers._glGenProgramPipelines_fnptr(n, pipelines);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glIsProgramPipeline]</b> Determine if a name corresponds to a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml" /></remarks>
        public static bool IsProgramPipeline(int pipeline) => GLPointers._glIsProgramPipeline_fnptr(pipeline) != 0;
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glGetProgramPipelineiv]</b> Retrieve properties of a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
        /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml" /></remarks>
        public static void GetProgramPipelineiv(int pipeline, PipelineParameterName pname, int* parameters) => GLPointers._glGetProgramPipelineiv_fnptr(pipeline, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1i]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1i(int program, int location, int v0) => GLPointers._glProgramUniform1i_fnptr(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1iv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform1iv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1f]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1f(int program, int location, float v0) => GLPointers._glProgramUniform1f_fnptr(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform1fv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1d]</b>  </summary>
        public static void ProgramUniform1d(int program, int location, double v0) => GLPointers._glProgramUniform1d_fnptr(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1dv]</b>  </summary>
        public static void ProgramUniform1dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform1dv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1ui]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1ui(int program, int location, uint v0) => GLPointers._glProgramUniform1ui_fnptr(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1uiv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform1uiv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2i]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2i(int program, int location, int v0, int v1) => GLPointers._glProgramUniform2i_fnptr(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2iv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform2iv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2f]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2f(int program, int location, float v0, float v1) => GLPointers._glProgramUniform2f_fnptr(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform2fv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2d]</b>  </summary>
        public static void ProgramUniform2d(int program, int location, double v0, double v1) => GLPointers._glProgramUniform2d_fnptr(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2dv]</b>  </summary>
        public static void ProgramUniform2dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform2dv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2ui]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2ui(int program, int location, uint v0, uint v1) => GLPointers._glProgramUniform2ui_fnptr(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2uiv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform2uiv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3i]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3i(int program, int location, int v0, int v1, int v2) => GLPointers._glProgramUniform3i_fnptr(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3iv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform3iv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3f]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3f(int program, int location, float v0, float v1, float v2) => GLPointers._glProgramUniform3f_fnptr(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform3fv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3d]</b>  </summary>
        public static void ProgramUniform3d(int program, int location, double v0, double v1, double v2) => GLPointers._glProgramUniform3d_fnptr(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3dv]</b>  </summary>
        public static void ProgramUniform3dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform3dv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3ui]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3ui(int program, int location, uint v0, uint v1, uint v2) => GLPointers._glProgramUniform3ui_fnptr(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3uiv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform3uiv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4i]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3) => GLPointers._glProgramUniform4i_fnptr(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4iv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform4iv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4f]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3) => GLPointers._glProgramUniform4f_fnptr(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform4fv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4d]</b>  </summary>
        public static void ProgramUniform4d(int program, int location, double v0, double v1, double v2, double v3) => GLPointers._glProgramUniform4d_fnptr(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4dv]</b>  </summary>
        public static void ProgramUniform4dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform4dv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4ui]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4ui(int program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glProgramUniform4ui_fnptr(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4uiv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform4uiv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2dv]</b>  </summary>
        public static void ProgramUniformMatrix2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3dv]</b>  </summary>
        public static void ProgramUniformMatrix3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4dv]</b>  </summary>
        public static void ProgramUniformMatrix4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2x3fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3x2fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2x4fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4x2fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3x4fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4x3fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2x3dv]</b>  </summary>
        public static void ProgramUniformMatrix2x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3x2dv]</b>  </summary>
        public static void ProgramUniformMatrix3x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2x4dv]</b>  </summary>
        public static void ProgramUniformMatrix2x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4x2dv]</b>  </summary>
        public static void ProgramUniformMatrix4x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3x4dv]</b>  </summary>
        public static void ProgramUniformMatrix3x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4x3dv]</b>  </summary>
        public static void ProgramUniformMatrix4x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glValidateProgramPipeline]</b> Validate a program pipeline object against current GL state. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml" /></remarks>
        public static void ValidateProgramPipeline(int pipeline) => GLPointers._glValidateProgramPipeline_fnptr(pipeline);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glGetProgramPipelineInfoLog]</b> Retrieve the info log string from a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
        /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
        /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
        /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml" /></remarks>
        public static void GetProgramPipelineInfoLog(int pipeline, int bufSize, int* length, byte* infoLog) => GLPointers._glGetProgramPipelineInfoLog_fnptr(pipeline, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL1d]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL1d(uint index, double x) => GLPointers._glVertexAttribL1d_fnptr(index, x);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL2d]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL2d(uint index, double x, double y) => GLPointers._glVertexAttribL2d_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL3d]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL3d(uint index, double x, double y, double z) => GLPointers._glVertexAttribL3d_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL4d]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttribL4d_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL1dv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL1dv(uint index, double* v) => GLPointers._glVertexAttribL1dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL2dv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL2dv(uint index, double* v) => GLPointers._glVertexAttribL2dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL3dv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL3dv(uint index, double* v) => GLPointers._glVertexAttribL3dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL4dv]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL4dv(uint index, double* v) => GLPointers._glVertexAttribL4dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribLPointer]</b> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers._glVertexAttribLPointer_fnptr(index, size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glGetVertexAttribLdv]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => GLPointers._glGetVertexAttribLdv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glViewportArrayv]</b> Set multiple viewports. </summary>
        /// <param name="first"> Specify the first viewport to set. </param>
        /// <param name="count"> Specify the number of viewports to set. </param>
        /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml" /></remarks>
        public static void ViewportArrayv(uint first, int count, float* v) => GLPointers._glViewportArrayv_fnptr(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glViewportIndexedf]</b> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
        public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => GLPointers._glViewportIndexedf_fnptr(index, x, y, w, h);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glViewportIndexedfv]</b> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
        public static void ViewportIndexedfv(uint index, float* v) => GLPointers._glViewportIndexedfv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glScissorArrayv]</b> Define the scissor box for multiple viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
        /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
        /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml" /></remarks>
        public static void ScissorArrayv(uint first, int count, int* v) => GLPointers._glScissorArrayv_fnptr(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glScissorIndexed]</b> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
        public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => GLPointers._glScissorIndexed_fnptr(index, left, bottom, width, height);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glScissorIndexedv]</b> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
        public static void ScissorIndexedv(uint index, int* v) => GLPointers._glScissorIndexedv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glDepthRangeArrayv]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
        /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
        /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml" /></remarks>
        public static void DepthRangeArrayv(uint first, int count, double* v) => GLPointers._glDepthRangeArrayv_fnptr(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glDepthRangeIndexed]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml" /></remarks>
        public static void DepthRangeIndexed(uint index, double n, double f) => GLPointers._glDepthRangeIndexed_fnptr(index, n, f);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glGetFloati_v]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetFloati_v(GetPName target, uint index, float* data) => GLPointers._glGetFloati_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glGetDoublei_v]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetDoublei_v(GetPName target, uint index, double* data) => GLPointers._glGetDoublei_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance] [glDrawArraysInstancedBaseInstance]</b> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml" /></remarks>
        public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => GLPointers._glDrawArraysInstancedBaseInstance_fnptr((uint)mode, first, count, instancecount, baseinstance);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance] [glDrawElementsInstancedBaseInstance]</b> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, uint baseinstance) => GLPointers._glDrawElementsInstancedBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, baseinstance);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance] [glDrawElementsInstancedBaseVertexBaseInstance]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => GLPointers._glDrawElementsInstancedBaseVertexBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex, baseinstance);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query] [glGetInternalformativ]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
        public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => GLPointers._glGetInternalformativ_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters] [glGetActiveAtomicCounterBufferiv]</b> Retrieve information about the set of active atomic counter buffers for a program. </summary>
        /// <param name="program"> The name of a program object from which to retrieve information. </param>
        /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
        /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml" /></remarks>
        public static void GetActiveAtomicCounterBufferiv(int program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => GLPointers._glGetActiveAtomicCounterBufferiv_fnptr(program, bufferIndex, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store] [glBindImageTexture]</b> Bind a level of a texture to an image unit. </summary>
        /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
        /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
        /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
        /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
        /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
        /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
        /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml" /></remarks>
        public static void BindImageTexture(uint unit, int texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format) => GLPointers._glBindImageTexture_fnptr(unit, texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, (uint)format);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store] [glMemoryBarrier]</b> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
        public static void MemoryBarrier(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrier_fnptr((uint)barriers);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage] [glTexStorage1D]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
        public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTexStorage1D_fnptr((uint)target, levels, (uint)internalformat, width);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage] [glTexStorage2D]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
        public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTexStorage2D_fnptr((uint)target, levels, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage] [glTexStorage3D]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
        public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTexStorage3D_fnptr((uint)target, levels, (uint)internalformat, width, height, depth);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced] [glDrawTransformFeedbackInstanced]</b> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml" /></remarks>
        public static void DrawTransformFeedbackInstanced(PrimitiveType mode, int id, int instancecount) => GLPointers._glDrawTransformFeedbackInstanced_fnptr((uint)mode, id, instancecount);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced] [glDrawTransformFeedbackStreamInstanced]</b> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml" /></remarks>
        public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, int id, uint stream, int instancecount) => GLPointers._glDrawTransformFeedbackStreamInstanced_fnptr((uint)mode, id, stream, instancecount);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object] [glClearBufferData]</b> Fill a buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
        public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearBufferData_fnptr((uint)target, (uint)internalformat, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object] [glClearBufferSubData]</b> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
        public static void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearBufferSubData_fnptr((uint)target, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader] [glDispatchCompute]</b> Launch one or more compute work groups. </summary>
        /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
        /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
        /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml" /></remarks>
        public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => GLPointers._glDispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader] [glDispatchComputeIndirect]</b> Launch one or more compute work groups using parameters stored in a buffer. </summary>
        /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml" /></remarks>
        public static void DispatchComputeIndirect(IntPtr indirect) => GLPointers._glDispatchComputeIndirect_fnptr(indirect);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image] [glCopyImageSubData]</b> Perform a raw data copy between two images. </summary>
        /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
        /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
        /// <param name="srcLevel"> The mipmap level to read from the source. </param>
        /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
        /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
        /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
        /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
        /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
        /// <param name="dstLevel">!!missing documentation!!</param>
        /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
        /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
        /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
        /// <param name="srcWidth"> The width of the region to be copied. </param>
        /// <param name="srcHeight"> The height of the region to be copied. </param>
        /// <param name="srcDepth"> The depth of the region to be copied. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml" /></remarks>
        public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers._glCopyImageSubData_fnptr(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments] [glFramebufferParameteri]</b> Set a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
        public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers._glFramebufferParameteri_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments] [glGetFramebufferParameteriv]</b> Query a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
        public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2] [glGetInternalformati64v]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
        public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => GLPointers._glGetInternalformati64v_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateTexSubImage]</b> Invalidate a region of a texture image. </summary>
        /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
        /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
        /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
        /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
        /// <param name="width"> The width of the region to be invalidated. </param>
        /// <param name="height"> The height of the region to be invalidated. </param>
        /// <param name="depth"> The depth of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml" /></remarks>
        public static void InvalidateTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => GLPointers._glInvalidateTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateTexImage]</b> Invalidate the entirety a texture image. </summary>
        /// <param name="texture"> The name of a texture object to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml" /></remarks>
        public static void InvalidateTexImage(int texture, int level) => GLPointers._glInvalidateTexImage_fnptr(texture, level);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateBufferSubData]</b> Invalidate a region of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
        /// <param name="offset"> The offset within the buffer&apos;s data store of the start of the range to be invalidated. </param>
        /// <param name="length"> The length of the range within the buffer&apos;s data store to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml" /></remarks>
        public static void InvalidateBufferSubData(int buffer, IntPtr offset, nint length) => GLPointers._glInvalidateBufferSubData_fnptr(buffer, offset, length);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateBufferData]</b> Invalidate the content of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml" /></remarks>
        public static void InvalidateBufferData(int buffer) => GLPointers._glInvalidateBufferData_fnptr(buffer);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateFramebuffer]</b> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
        public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => GLPointers._glInvalidateFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateSubFramebuffer]</b> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
        public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._glInvalidateSubFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments, x, y, width, height);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect] [glMultiDrawArraysIndirect]</b> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml" /></remarks>
        public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => GLPointers._glMultiDrawArraysIndirect_fnptr((uint)mode, indirect, drawcount, stride);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect] [glMultiDrawElementsIndirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml" /></remarks>
        public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => GLPointers._glMultiDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect, drawcount, stride);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramInterfaceiv]</b> Query a property of an interface in a program. </summary>
        /// <param name="program"> The name of a program object whose interface to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program to query. </param>
        /// <param name="pname"> The name of the parameter within programInterface to query. </param>
        /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml" /></remarks>
        public static void GetProgramInterfaceiv(int program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => GLPointers._glGetProgramInterfaceiv_fnptr(program, (uint)programInterface, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceIndex]</b> Query the index of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the index of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml" /></remarks>
        public static uint GetProgramResourceIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceIndex_fnptr(program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceName]</b> Query the name of an indexed resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
        /// <param name="index"> The index of the resource within programInterface of program. </param>
        /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
        /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
        /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml" /></remarks>
        public static void GetProgramResourceName(int program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetProgramResourceName_fnptr(program, (uint)programInterface, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceiv]</b> Retrieve values for multiple properties of a single active resource within a program object. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="index">!!missing documentation!!</param>
        /// <param name="propCount">!!missing documentation!!</param>
        /// <param name="props">!!missing documentation!!</param>
        /// <param name="bufSize">!!missing documentation!!</param>
        /// <param name="length">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml" /></remarks>
        public static void GetProgramResourceiv(int program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => GLPointers._glGetProgramResourceiv_fnptr(program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceLocation]</b> Query the location of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml" /></remarks>
        public static int GetProgramResourceLocation(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceLocation_fnptr(program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceLocationIndex]</b> Query the fragment color index of a named variable within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml" /></remarks>
        public static int GetProgramResourceLocationIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceLocationIndex_fnptr(program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object] [glShaderStorageBlockBinding]</b> Change an active shader storage block binding. </summary>
        /// <param name="program"> The name of the program containing the block whose binding to change. </param>
        /// <param name="storageBlockIndex"> The index storage block within the program. </param>
        /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml" /></remarks>
        public static void ShaderStorageBlockBinding(int program, uint storageBlockIndex, uint storageBlockBinding) => GLPointers._glShaderStorageBlockBinding_fnptr(program, storageBlockIndex, storageBlockBinding);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range] [glTexBufferRange]</b> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
        public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTexBufferRange_fnptr((uint)target, (uint)internalformat, buffer, offset, size);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample] [glTexStorage2DMultisample]</b> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
        public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTexStorage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample] [glTexStorage3DMultisample]</b> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
        public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTexStorage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view] [glTextureView]</b> Initialize a texture as a data alias of another texture&apos;s data store. </summary>
        /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
        /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
        /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
        /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
        /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
        /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
        /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
        /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml" /></remarks>
        public static void TextureView(int texture, TextureTarget target, int origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => GLPointers._glTextureView_fnptr(texture, (uint)target, origtexture, (uint)internalformat, minlevel, numlevels, minlayer, numlayers);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glBindVertexBuffer]</b> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
        public static void BindVertexBuffer(uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glBindVertexBuffer_fnptr(bindingindex, buffer, offset, stride);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexAttribFormat]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexAttribFormat_fnptr(attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexAttribIFormat]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexAttribIFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexAttribLFormat]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexAttribLFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexAttribBinding]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
        public static void VertexAttribBinding(uint attribindex, uint bindingindex) => GLPointers._glVertexAttribBinding_fnptr(attribindex, bindingindex);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexBindingDivisor]</b> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
        public static void VertexBindingDivisor(uint bindingindex, uint divisor) => GLPointers._glVertexBindingDivisor_fnptr(bindingindex, divisor);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glDebugMessageControl]</b> Control the reporting of debug messages in a debug context. </summary>
        /// <param name="source"> The source of debug messages to enable or disable. </param>
        /// <param name="type"> The type of debug messages to enable or disable. </param>
        /// <param name="severity"> The severity of debug messages to enable or disable. </param>
        /// <param name="count"> The length of the array ids. </param>
        /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
        /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml" /></remarks>
        public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageControl_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glDebugMessageInsert]</b> Inject an application-supplied message into the debug message queue. </summary>
        /// <param name="source"> The source of the debug message to insert. </param>
        /// <param name="type"> The type of the debug message insert. </param>
        /// <param name="id"> The user-supplied identifier of the message to insert. </param>
        /// <param name="severity"> The severity of the debug messages to insert. </param>
        /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
        /// <param name="message"> The address of a character array containing the message to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml" /></remarks>
        public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._glDebugMessageInsert_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glDebugMessageCallback]</b> Specify a callback to receive debugging messages from the GL. </summary>
        /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
        /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml" /></remarks>
        public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallback_fnptr(callback, userParam);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glGetDebugMessageLog]</b> Retrieve messages from the debug message log. </summary>
        /// <param name="count"> The number of debug messages to retrieve from the log. </param>
        /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
        /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
        /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
        /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
        /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
        /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
        /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml" /></remarks>
        public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._glGetDebugMessageLog_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glPushDebugGroup]</b> Push a named debug group into the command stream. </summary>
        /// <param name="source"> The source of the debug message. </param>
        /// <param name="id"> The identifier of the message. </param>
        /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
        /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml" /></remarks>
        public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => GLPointers._glPushDebugGroup_fnptr((uint)source, id, length, message);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glPopDebugGroup]</b> Pop the active debug group. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml" /></remarks>
        public static void PopDebugGroup() => GLPointers._glPopDebugGroup_fnptr();
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glObjectLabel]</b> Label a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object to label. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml" /></remarks>
        public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers._glObjectLabel_fnptr((uint)identifier, name, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glGetObjectLabel]</b> Retrieve the label of a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml" /></remarks>
        public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => GLPointers._glGetObjectLabel_fnptr((uint)identifier, name, bufSize, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glObjectPtrLabel]</b> Label a sync object identified by a pointer. </summary>
        /// <param name="ptr"> A pointer identifying a sync object. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml" /></remarks>
        public static void ObjectPtrLabel(void* ptr, int length, byte* label) => GLPointers._glObjectPtrLabel_fnptr(ptr, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glGetObjectPtrLabel]</b> Retrieve the label of a sync object identified by a pointer. </summary>
        /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml" /></remarks>
        public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => GLPointers._glGetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage] [glBufferStorage]</b> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
        public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => GLPointers._glBufferStorage_fnptr((uint)target, size, data, (uint)flags);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture] [glClearTexImage]</b> Fills all a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml" /></remarks>
        public static void ClearTexImage(int texture, int level, PixelFormat format, PixelType type, void* data) => GLPointers._glClearTexImage_fnptr(texture, level, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture] [glClearTexSubImage]</b> Fills all or part of a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
        /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
        /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
        /// <param name="width"> The width of the region to be cleared. </param>
        /// <param name="height"> The height of the region to be cleared. </param>
        /// <param name="depth"> The depth of the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml" /></remarks>
        public static void ClearTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => GLPointers._glClearTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindBuffersBase]</b> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml" /></remarks>
        public static void BindBuffersBase(BufferTargetARB target, uint first, int count, int* buffers) => GLPointers._glBindBuffersBase_fnptr((uint)target, first, count, buffers);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindBuffersRange]</b> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml" /></remarks>
        public static void BindBuffersRange(BufferTargetARB target, uint first, int count, int* buffers, IntPtr* offsets, nint* sizes) => GLPointers._glBindBuffersRange_fnptr((uint)target, first, count, buffers, offsets, sizes);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindTextures]</b> Bind one or more named textures to a sequence of consecutive texture units. </summary>
        /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml" /></remarks>
        public static void BindTextures(uint first, int count, int* textures) => GLPointers._glBindTextures_fnptr(first, count, textures);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindSamplers]</b> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
        /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
        /// <param name="count"> Specifies the number of samplers to bind. </param>
        /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml" /></remarks>
        public static void BindSamplers(uint first, int count, int* samplers) => GLPointers._glBindSamplers_fnptr(first, count, samplers);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindImageTextures]</b> Bind one or more named texture images to a sequence of consecutive image units. </summary>
        /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml" /></remarks>
        public static void BindImageTextures(uint first, int count, int* textures) => GLPointers._glBindImageTextures_fnptr(first, count, textures);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindVertexBuffers]</b> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
        public static void BindVertexBuffers(uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers._glBindVertexBuffers_fnptr(first, count, buffers, offsets, strides);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control] [glClipControl]</b> Control clip coordinate to window coordinate behavior. </summary>
        /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
        /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml" /></remarks>
        public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => GLPointers._glClipControl_fnptr((uint)origin, (uint)depth);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateTransformFeedbacks]</b> Create transform feedback objects. </summary>
        /// <param name="n"> Number of transform feedback objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml" /></remarks>
        public static void CreateTransformFeedbacks(int n, int* ids) => GLPointers._glCreateTransformFeedbacks_fnptr(n, ids);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTransformFeedbackBufferBase]</b> Bind a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml" /></remarks>
        public static void TransformFeedbackBufferBase(int xfb, uint index, int buffer) => GLPointers._glTransformFeedbackBufferBase_fnptr(xfb, index, buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTransformFeedbackBufferRange]</b> Bind a range within a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
        /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml" /></remarks>
        public static void TransformFeedbackBufferRange(int xfb, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glTransformFeedbackBufferRange_fnptr(xfb, index, buffer, offset, size);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTransformFeedbackiv]</b> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbackiv(int xfb, TransformFeedbackPName pname, int* param) => GLPointers._glGetTransformFeedbackiv_fnptr(xfb, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTransformFeedbacki_v]</b> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbacki_v(int xfb, TransformFeedbackPName pname, uint index, int* param) => GLPointers._glGetTransformFeedbacki_v_fnptr(xfb, (uint)pname, index, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTransformFeedbacki64_v]</b> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbacki64_v(int xfb, TransformFeedbackPName pname, uint index, long* param) => GLPointers._glGetTransformFeedbacki64_v_fnptr(xfb, (uint)pname, index, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateBuffers]</b> Create buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to create. </param>
        /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml" /></remarks>
        public static void CreateBuffers(int n, int* buffers) => GLPointers._glCreateBuffers_fnptr(n, buffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedBufferStorage]</b> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
        public static void NamedBufferStorage(int buffer, nint size, void* data, BufferStorageMask flags) => GLPointers._glNamedBufferStorage_fnptr(buffer, size, data, (uint)flags);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedBufferData]</b> Creates and initializes a buffer object&apos;s data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
        public static void NamedBufferData(int buffer, nint size, void* data, VertexBufferObjectUsage usage) => GLPointers._glNamedBufferData_fnptr(buffer, size, data, (uint)usage);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedBufferSubData]</b> Updates a subset of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
        public static void NamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glNamedBufferSubData_fnptr(buffer, offset, size, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCopyNamedBufferSubData]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
        public static void CopyNamedBufferSubData(int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glCopyNamedBufferSubData_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedBufferData]</b> Fill a buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
        public static void ClearNamedBufferData(int buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferData_fnptr(buffer, (uint)internalformat, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedBufferSubData]</b> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
        public static void ClearNamedBufferSubData(int buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferSubData_fnptr(buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glMapNamedBuffer]</b> Map all of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object&apos;s mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
        public static void* MapNamedBuffer(int buffer, BufferAccessARB access) => GLPointers._glMapNamedBuffer_fnptr(buffer, (uint)access);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glMapNamedBufferRange]</b> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
        public static void* MapNamedBufferRange(int buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapNamedBufferRange_fnptr(buffer, offset, length, (uint)access);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glUnmapNamedBuffer]</b> Release the mapping of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
        public static bool UnmapNamedBuffer(int buffer) => GLPointers._glUnmapNamedBuffer_fnptr(buffer) != 0;
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glFlushMappedNamedBufferRange]</b> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
        public static void FlushMappedNamedBufferRange(int buffer, IntPtr offset, nint length) => GLPointers._glFlushMappedNamedBufferRange_fnptr(buffer, offset, length);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedBufferParameteriv]</b> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetNamedBufferParameteriv(int buffer, BufferPNameARB pname, int* parameters) => GLPointers._glGetNamedBufferParameteriv_fnptr(buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedBufferParameteri64v]</b> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetNamedBufferParameteri64v(int buffer, BufferPNameARB pname, long* parameters) => GLPointers._glGetNamedBufferParameteri64v_fnptr(buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedBufferPointerv]</b> Return the pointer to a mapped buffer object&apos;s data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
        public static void GetNamedBufferPointerv(int buffer, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetNamedBufferPointerv_fnptr(buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedBufferSubData]</b> Returns a subset of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
        public static void GetNamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glGetNamedBufferSubData_fnptr(buffer, offset, size, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateFramebuffers]</b> Create framebuffer objects. </summary>
        /// <param name="n"> Number of framebuffer objects to create. </param>
        /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml" /></remarks>
        public static void CreateFramebuffers(int n, int* framebuffers) => GLPointers._glCreateFramebuffers_fnptr(n, framebuffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferRenderbuffer]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
        public static void NamedFramebufferRenderbuffer(int framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glNamedFramebufferRenderbuffer_fnptr(framebuffer, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferParameteri]</b> Set a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
        public static void NamedFramebufferParameteri(int framebuffer, FramebufferParameterName pname, int param) => GLPointers._glNamedFramebufferParameteri_fnptr(framebuffer, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferTexture]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void NamedFramebufferTexture(int framebuffer, FramebufferAttachment attachment, int texture, int level) => GLPointers._glNamedFramebufferTexture_fnptr(framebuffer, (uint)attachment, texture, level);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferTextureLayer]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
        public static void NamedFramebufferTextureLayer(int framebuffer, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glNamedFramebufferTextureLayer_fnptr(framebuffer, (uint)attachment, texture, level, layer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferDrawBuffer]</b> Specify which color buffers are to be drawn into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
        public static void NamedFramebufferDrawBuffer(int framebuffer, ColorBuffer buf) => GLPointers._glNamedFramebufferDrawBuffer_fnptr(framebuffer, (uint)buf);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferDrawBuffers]</b> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
        public static void NamedFramebufferDrawBuffers(int framebuffer, int n, ColorBuffer* bufs) => GLPointers._glNamedFramebufferDrawBuffers_fnptr(framebuffer, n, (uint*)bufs);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferReadBuffer]</b> Select a color buffer source for pixels. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
        /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
        public static void NamedFramebufferReadBuffer(int framebuffer, ColorBuffer src) => GLPointers._glNamedFramebufferReadBuffer_fnptr(framebuffer, (uint)src);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glInvalidateNamedFramebufferData]</b> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
        public static void InvalidateNamedFramebufferData(int framebuffer, int numAttachments, FramebufferAttachment* attachments) => GLPointers._glInvalidateNamedFramebufferData_fnptr(framebuffer, numAttachments, (uint*)attachments);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glInvalidateNamedFramebufferSubData]</b> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
        public static void InvalidateNamedFramebufferSubData(int framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._glInvalidateNamedFramebufferSubData_fnptr(framebuffer, numAttachments, (uint*)attachments, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedFramebufferiv]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferiv(int framebuffer, Buffer buffer, int drawbuffer, int* value) => GLPointers._glClearNamedFramebufferiv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedFramebufferuiv]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferuiv(int framebuffer, Buffer buffer, int drawbuffer, uint* value) => GLPointers._glClearNamedFramebufferuiv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedFramebufferfv]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferfv(int framebuffer, Buffer buffer, int drawbuffer, float* value) => GLPointers._glClearNamedFramebufferfv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedFramebufferfi]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferfi(int framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers._glClearNamedFramebufferfi_fnptr(framebuffer, (uint)buffer, drawbuffer, depth, stencil);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glBlitNamedFramebuffer]</b> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
        public static void BlitNamedFramebuffer(int readFramebuffer, int drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitNamedFramebuffer_fnptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCheckNamedFramebufferStatus]</b> Check the completeness status of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
        public static FramebufferStatus CheckNamedFramebufferStatus(int framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckNamedFramebufferStatus_fnptr(framebuffer, (uint)target);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedFramebufferParameteriv]</b> Query a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="param">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
        public static void GetNamedFramebufferParameteriv(int framebuffer, GetFramebufferParameter pname, int* param) => GLPointers._glGetNamedFramebufferParameteriv_fnptr(framebuffer, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedFramebufferAttachmentParameteriv]</b> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
        public static void GetNamedFramebufferAttachmentParameteriv(int framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetNamedFramebufferAttachmentParameteriv_fnptr(framebuffer, (uint)attachment, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateRenderbuffers]</b> Create renderbuffer objects. </summary>
        /// <param name="n"> Number of renderbuffer objects to create. </param>
        /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml" /></remarks>
        public static void CreateRenderbuffers(int n, int* renderbuffers) => GLPointers._glCreateRenderbuffers_fnptr(n, renderbuffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedRenderbufferStorage]</b> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
        public static void NamedRenderbufferStorage(int renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorage_fnptr(renderbuffer, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedRenderbufferStorageMultisample]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
        public static void NamedRenderbufferStorageMultisample(int renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisample_fnptr(renderbuffer, samples, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedRenderbufferParameteriv]</b> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
        public static void GetNamedRenderbufferParameteriv(int renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetNamedRenderbufferParameteriv_fnptr(renderbuffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateTextures]</b> Create texture objects. </summary>
        /// <param name="target"> Specifies the effective texture target of each created texture. </param>
        /// <param name="n"> Number of texture objects to create. </param>
        /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml" /></remarks>
        public static void CreateTextures(TextureTarget target, int n, int* textures) => GLPointers._glCreateTextures_fnptr((uint)target, n, textures);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureBuffer]</b> Attach a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
        public static void TextureBuffer(int texture, SizedInternalFormat internalformat, int buffer) => GLPointers._glTextureBuffer_fnptr(texture, (uint)internalformat, buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureBufferRange]</b> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
        public static void TextureBufferRange(int texture, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTextureBufferRange_fnptr(texture, (uint)internalformat, buffer, offset, size);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage1D]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
        public static void TextureStorage1D(int texture, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTextureStorage1D_fnptr(texture, levels, (uint)internalformat, width);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage2D]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
        public static void TextureStorage2D(int texture, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTextureStorage2D_fnptr(texture, levels, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage3D]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
        public static void TextureStorage3D(int texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTextureStorage3D_fnptr(texture, levels, (uint)internalformat, width, height, depth);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage2DMultisample]</b> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
        public static void TextureStorage2DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTextureStorage2DMultisample_fnptr(texture, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage3DMultisample]</b> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
        public static void TextureStorage3DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTextureStorage3DMultisample_fnptr(texture, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureSubImage1D]</b> Specify a one-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
        public static void TextureSubImage1D(int texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage1D_fnptr(texture, level, xoffset, width, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureSubImage2D]</b> Specify a two-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
        public static void TextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureSubImage3D]</b> Specify a three-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
        public static void TextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCompressedTextureSubImage1D]</b> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
        public static void CompressedTextureSubImage1D(int texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage1D_fnptr(texture, level, xoffset, width, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCompressedTextureSubImage2D]</b> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
        public static void CompressedTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCompressedTextureSubImage3D]</b> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
        public static void CompressedTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCopyTextureSubImage1D]</b> Copy a one-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
        public static void CopyTextureSubImage1D(int texture, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTextureSubImage1D_fnptr(texture, level, xoffset, x, y, width);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCopyTextureSubImage2D]</b> Copy a two-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
        public static void CopyTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCopyTextureSubImage3D]</b> Copy a three-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
        public static void CopyTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameterf]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterf(int texture, TextureParameterName pname, float param) => GLPointers._glTextureParameterf_fnptr(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameterfv]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterfv(int texture, TextureParameterName pname, float* param) => GLPointers._glTextureParameterfv_fnptr(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameteri]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameteri(int texture, TextureParameterName pname, int param) => GLPointers._glTextureParameteri_fnptr(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameterIiv]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterIiv(int texture, TextureParameterName pname, int* parameters) => GLPointers._glTextureParameterIiv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameterIuiv]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterIuiv(int texture, TextureParameterName pname, uint* parameters) => GLPointers._glTextureParameterIuiv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameteriv]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameteriv(int texture, TextureParameterName pname, int* param) => GLPointers._glTextureParameteriv_fnptr(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGenerateTextureMipmap]</b> Generate mipmaps for a specified texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
        public static void GenerateTextureMipmap(int texture) => GLPointers._glGenerateTextureMipmap_fnptr(texture);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glBindTextureUnit]</b> Bind an existing texture object to the specified texture unit . </summary>
        /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
        /// <param name="texture">Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml" /></remarks>
        public static void BindTextureUnit(uint unit, int texture) => GLPointers._glBindTextureUnit_fnptr(unit, texture);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureImage]</b> Return a texture image. </summary>
        /// <param name="texture"> Specifies the texture object name. </param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetTextureImage(int texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetTextureImage_fnptr(texture, level, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetCompressedTextureImage]</b> Return a compressed texture image. </summary>
        /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetCompressedTextureImage(int texture, int level, int bufSize, void* pixels) => GLPointers._glGetCompressedTextureImage_fnptr(texture, level, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureLevelParameterfv]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTextureLevelParameterfv(int texture, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureLevelParameterfv_fnptr(texture, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureLevelParameteriv]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTextureLevelParameteriv(int texture, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureLevelParameteriv_fnptr(texture, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureParameterfv]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterfv(int texture, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureParameterfv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureParameterIiv]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterIiv(int texture, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameterIiv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureParameterIuiv]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterIuiv(int texture, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTextureParameterIuiv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureParameteriv]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameteriv(int texture, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameteriv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateVertexArrays]</b> Create vertex array objects. </summary>
        /// <param name="n"> Number of vertex array objects to create. </param>
        /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml" /></remarks>
        public static void CreateVertexArrays(int n, int* arrays) => GLPointers._glCreateVertexArrays_fnptr(n, arrays);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glDisableVertexArrayAttrib]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void DisableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glDisableVertexArrayAttrib_fnptr(vaobj, index);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glEnableVertexArrayAttrib]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void EnableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glEnableVertexArrayAttrib_fnptr(vaobj, index);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayElementBuffer]</b> Configures element array buffer binding of a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
        /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml" /></remarks>
        public static void VertexArrayElementBuffer(int vaobj, int buffer) => GLPointers._glVertexArrayElementBuffer_fnptr(vaobj, buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayVertexBuffer]</b> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
        public static void VertexArrayVertexBuffer(int vaobj, uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glVertexArrayVertexBuffer_fnptr(vaobj, bindingindex, buffer, offset, stride);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayVertexBuffers]</b> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
        public static void VertexArrayVertexBuffers(int vaobj, uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers._glVertexArrayVertexBuffers_fnptr(vaobj, first, count, buffers, offsets, strides);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayAttribBinding]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
        public static void VertexArrayAttribBinding(int vaobj, uint attribindex, uint bindingindex) => GLPointers._glVertexArrayAttribBinding_fnptr(vaobj, attribindex, bindingindex);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayAttribFormat]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribFormat(int vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexArrayAttribFormat_fnptr(vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayAttribIFormat]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribIFormat(int vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexArrayAttribIFormat_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayAttribLFormat]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribLFormat(int vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexArrayAttribLFormat_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayBindingDivisor]</b> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
        public static void VertexArrayBindingDivisor(int vaobj, uint bindingindex, uint divisor) => GLPointers._glVertexArrayBindingDivisor_fnptr(vaobj, bindingindex, divisor);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetVertexArrayiv]</b> Retrieve parameters of a vertex array object. </summary>
        /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
        /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml" /></remarks>
        public static void GetVertexArrayiv(int vaobj, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayiv_fnptr(vaobj, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetVertexArrayIndexediv]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
        public static void GetVertexArrayIndexediv(int vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayIndexediv_fnptr(vaobj, index, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetVertexArrayIndexed64iv]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
        public static void GetVertexArrayIndexed64iv(int vaobj, uint index, VertexArrayPName pname, long* param) => GLPointers._glGetVertexArrayIndexed64iv_fnptr(vaobj, index, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateSamplers]</b> Create sampler objects. </summary>
        /// <param name="n"> Number of sampler objects to create. </param>
        /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml" /></remarks>
        public static void CreateSamplers(int n, int* samplers) => GLPointers._glCreateSamplers_fnptr(n, samplers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateProgramPipelines]</b> Create program pipeline objects. </summary>
        /// <param name="n"> Number of program pipeline objects to create. </param>
        /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml" /></remarks>
        public static void CreateProgramPipelines(int n, int* pipelines) => GLPointers._glCreateProgramPipelines_fnptr(n, pipelines);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateQueries]</b> Create query objects. </summary>
        /// <param name="target"> Specifies the target of each created query object. </param>
        /// <param name="n"> Number of query objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml" /></remarks>
        public static void CreateQueries(QueryTarget target, int n, int* ids) => GLPointers._glCreateQueries_fnptr((uint)target, n, ids);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetQueryBufferObjecti64v]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjecti64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjecti64v_fnptr(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetQueryBufferObjectiv]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectiv_fnptr(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetQueryBufferObjectui64v]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectui64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectui64v_fnptr(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetQueryBufferObjectuiv]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectuiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectuiv_fnptr(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility] [glMemoryBarrierByRegion]</b> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
        public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrierByRegion_fnptr((uint)barriers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image] [glGetTextureSubImage]</b> Retrieve a sub-region of a texture image from a texture    object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml" /></remarks>
        public static void GetTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image] [glGetCompressedTextureSubImage]</b> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block&apos;s width, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block&apos;s height, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block&apos;s depth, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml" /></remarks>
        public static void GetCompressedTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => GLPointers._glGetCompressedTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glGetGraphicsResetStatus]</b> Check if the rendering context has not been lost due to software or hardware issues. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml" /></remarks>
        public static GraphicsResetStatus GetGraphicsResetStatus() => (GraphicsResetStatus) GLPointers._glGetGraphicsResetStatus_fnptr();
        
        /// <summary> <b>[requires: v4.5] [glGetnCompressedTexImage]</b> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetnCompressedTexImage(TextureTarget target, int lod, int bufSize, void* pixels) => GLPointers._glGetnCompressedTexImage_fnptr((uint)target, lod, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5] [glGetnTexImage]</b> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetnTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetnTexImage_fnptr((uint)target, level, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5] [glGetnUniformdv]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformdv(int program, int location, int bufSize, double* parameters) => GLPointers._glGetnUniformdv_fnptr(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glGetnUniformfv]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformfv(int program, int location, int bufSize, float* parameters) => GLPointers._glGetnUniformfv_fnptr(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glGetnUniformiv]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformiv(int program, int location, int bufSize, int* parameters) => GLPointers._glGetnUniformiv_fnptr(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glGetnUniformuiv]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformuiv(int program, int location, int bufSize, uint* parameters) => GLPointers._glGetnUniformuiv_fnptr(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glReadnPixels]</b> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
        /// <param name="data">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
        public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._glReadnPixels_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
        
        /// <summary> <b>[requires: v4.5] [glGetnMapdv]</b>  </summary>
        public static void GetnMapdv(MapTarget target, MapQuery query, int bufSize, double* v) => GLPointers._glGetnMapdv_fnptr((uint)target, (uint)query, bufSize, v);
        
        /// <summary> <b>[requires: v4.5] [glGetnMapfv]</b>  </summary>
        public static void GetnMapfv(MapTarget target, MapQuery query, int bufSize, float* v) => GLPointers._glGetnMapfv_fnptr((uint)target, (uint)query, bufSize, v);
        
        /// <summary> <b>[requires: v4.5] [glGetnMapiv]</b>  </summary>
        public static void GetnMapiv(MapTarget target, MapQuery query, int bufSize, int* v) => GLPointers._glGetnMapiv_fnptr((uint)target, (uint)query, bufSize, v);
        
        /// <summary> <b>[requires: v4.5] [glGetnPixelMapfv]</b>  </summary>
        public static void GetnPixelMapfv(PixelMap map, int bufSize, float* values) => GLPointers._glGetnPixelMapfv_fnptr((uint)map, bufSize, values);
        
        /// <summary> <b>[requires: v4.5] [glGetnPixelMapuiv]</b>  </summary>
        public static void GetnPixelMapuiv(PixelMap map, int bufSize, uint* values) => GLPointers._glGetnPixelMapuiv_fnptr((uint)map, bufSize, values);
        
        /// <summary> <b>[requires: v4.5] [glGetnPixelMapusv]</b>  </summary>
        public static void GetnPixelMapusv(PixelMap map, int bufSize, ushort* values) => GLPointers._glGetnPixelMapusv_fnptr((uint)map, bufSize, values);
        
        /// <summary> <b>[requires: v4.5] [glGetnPolygonStipple]</b>  </summary>
        public static void GetnPolygonStipple(int bufSize, byte* pattern) => GLPointers._glGetnPolygonStipple_fnptr(bufSize, pattern);
        
        /// <summary> <b>[requires: v4.5] [glGetnColorTable]</b>  </summary>
        public static void GetnColorTable(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, void* table) => GLPointers._glGetnColorTable_fnptr((uint)target, (uint)format, (uint)type, bufSize, table);
        
        /// <summary> <b>[requires: v4.5] [glGetnConvolutionFilter]</b>  </summary>
        public static void GetnConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, void* image) => GLPointers._glGetnConvolutionFilter_fnptr((uint)target, (uint)format, (uint)type, bufSize, image);
        
        /// <summary> <b>[requires: v4.5] [glGetnSeparableFilter]</b>  </summary>
        public static void GetnSeparableFilter(SeparableTarget target, PixelFormat format, PixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span) => GLPointers._glGetnSeparableFilter_fnptr((uint)target, (uint)format, (uint)type, rowBufSize, row, columnBufSize, column, span);
        
        /// <summary> <b>[requires: v4.5] [glGetnHistogram]</b>  </summary>
        public static void GetnHistogram(HistogramTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers._glGetnHistogram_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
        
        /// <summary> <b>[requires: v4.5] [glGetnMinmax]</b>  </summary>
        public static void GetnMinmax(MinmaxTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers._glGetnMinmax_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier] [glTextureBarrier]</b> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml" /></remarks>
        public static void TextureBarrier() => GLPointers._glTextureBarrier_fnptr();
        
        /// <summary> <b>[requires: v4.6] [glSpecializeShader]</b>  </summary>
        public static void SpecializeShader(int shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => GLPointers._glSpecializeShader_fnptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        
        /// <summary> <b>[requires: v4.6] [glMultiDrawArraysIndirectCount]</b>  </summary>
        public static void MultiDrawArraysIndirectCount(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawArraysIndirectCount_fnptr((uint)mode, indirect, drawcount, maxdrawcount, stride);
        
        /// <summary> <b>[requires: v4.6] [glMultiDrawElementsIndirectCount]</b>  </summary>
        public static void MultiDrawElementsIndirectCount(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawElementsIndirectCount_fnptr((uint)mode, (uint)type, indirect, drawcount, maxdrawcount, stride);
        
        /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp] [glPolygonOffsetClamp]</b>  </summary>
        public static void PolygonOffsetClamp(float factor, float units, float clamp) => GLPointers._glPolygonOffsetClamp_fnptr(factor, units, clamp);
        
        /// <summary>_3DFX extensions.</summary>
        public static unsafe partial class _3DFX
        {
            /// <summary> <b>[requires: GL_3DFX_tbuffer] [glTbufferMask3DFX]</b>  </summary>
            public static void TbufferMask3DFX(uint mask) => GLPointers._glTbufferMask3DFX_fnptr(mask);
            
        }
        /// <summary>AMD extensions.</summary>
        public static unsafe partial class AMD
        {
            /// <summary> <b>[requires: GL_AMD_debug_output] [glDebugMessageEnableAMD]</b>  </summary>
            public static void DebugMessageEnable(All category, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageEnableAMD_fnptr((uint)category, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_AMD_debug_output] [glDebugMessageInsertAMD]</b>  </summary>
            public static void DebugMessageInsert(All category, DebugSeverity severity, uint id, int length, byte* buf) => GLPointers._glDebugMessageInsertAMD_fnptr((uint)category, (uint)severity, id, length, buf);
            
            /// <summary> <b>[requires: GL_AMD_debug_output] [glDebugMessageCallbackAMD]</b>  </summary>
            public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallbackAMD_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: GL_AMD_debug_output] [glGetDebugMessageLogAMD]</b>  </summary>
            public static uint GetDebugMessageLog(uint count, int bufSize, All* categories, DebugSeverity* severities, uint* ids, int* lengths, byte* message) => GLPointers._glGetDebugMessageLogAMD_fnptr(count, bufSize, (uint*)categories, (uint*)severities, ids, lengths, message);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend] [glBlendFuncIndexedAMD]</b>  </summary>
            public static void BlendFuncIndexed(uint buf, All src, All dst) => GLPointers._glBlendFuncIndexedAMD_fnptr(buf, (uint)src, (uint)dst);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend] [glBlendFuncSeparateIndexedAMD]</b>  </summary>
            public static void BlendFuncSeparateIndexed(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers._glBlendFuncSeparateIndexedAMD_fnptr(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend] [glBlendEquationIndexedAMD]</b>  </summary>
            public static void BlendEquationIndexed(uint buf, BlendEquationModeEXT mode) => GLPointers._glBlendEquationIndexedAMD_fnptr(buf, (uint)mode);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend] [glBlendEquationSeparateIndexedAMD]</b>  </summary>
            public static void BlendEquationSeparateIndexed(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparateIndexedAMD_fnptr(buf, (uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced] [glRenderbufferStorageMultisampleAdvancedAMD]</b>  </summary>
            public static void RenderbufferStorageMultisampleAdvanced(RenderbufferTarget target, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisampleAdvancedAMD_fnptr((uint)target, samples, storageSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced] [glNamedRenderbufferStorageMultisampleAdvancedAMD]</b>  </summary>
            public static void NamedRenderbufferStorageMultisampleAdvanced(int renderbuffer, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisampleAdvancedAMD_fnptr(renderbuffer, samples, storageSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions] [glFramebufferSamplePositionsfvAMD]</b>  </summary>
            public static void FramebufferSamplePositionsfv(FramebufferTarget target, uint numsamples, uint pixelindex, float* values) => GLPointers._glFramebufferSamplePositionsfvAMD_fnptr((uint)target, numsamples, pixelindex, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions] [glNamedFramebufferSamplePositionsfvAMD]</b>  </summary>
            public static void NamedFramebufferSamplePositionsfv(int framebuffer, uint numsamples, uint pixelindex, float* values) => GLPointers._glNamedFramebufferSamplePositionsfvAMD_fnptr(framebuffer, numsamples, pixelindex, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions] [glGetFramebufferParameterfvAMD]</b>  </summary>
            public static void GetFramebufferParameterfv(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, float* values) => GLPointers._glGetFramebufferParameterfvAMD_fnptr((uint)target, (uint)pname, numsamples, pixelindex, size, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions] [glGetNamedFramebufferParameterfvAMD]</b>  </summary>
            public static void GetNamedFramebufferParameterfv(int framebuffer, All pname, uint numsamples, uint pixelindex, int size, float* values) => GLPointers._glGetNamedFramebufferParameterfvAMD_fnptr(framebuffer, (uint)pname, numsamples, pixelindex, size, values);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform1i64NV]</b>  </summary>
            public static void Uniform1i64NV(int location, long x) => GLPointers._glUniform1i64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform2i64NV]</b>  </summary>
            public static void Uniform2i64NV(int location, long x, long y) => GLPointers._glUniform2i64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform3i64NV]</b>  </summary>
            public static void Uniform3i64NV(int location, long x, long y, long z) => GLPointers._glUniform3i64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform4i64NV]</b>  </summary>
            public static void Uniform4i64NV(int location, long x, long y, long z, long w) => GLPointers._glUniform4i64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform1i64vNV]</b>  </summary>
            public static void Uniform1i64vNV(int location, int count, long* value) => GLPointers._glUniform1i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform2i64vNV]</b>  </summary>
            public static void Uniform2i64vNV(int location, int count, long* value) => GLPointers._glUniform2i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform3i64vNV]</b>  </summary>
            public static void Uniform3i64vNV(int location, int count, long* value) => GLPointers._glUniform3i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform4i64vNV]</b>  </summary>
            public static void Uniform4i64vNV(int location, int count, long* value) => GLPointers._glUniform4i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform1ui64NV]</b>  </summary>
            public static void Uniform1ui64NV(int location, ulong x) => GLPointers._glUniform1ui64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform2ui64NV]</b>  </summary>
            public static void Uniform2ui64NV(int location, ulong x, ulong y) => GLPointers._glUniform2ui64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform3ui64NV]</b>  </summary>
            public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z) => GLPointers._glUniform3ui64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform4ui64NV]</b>  </summary>
            public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glUniform4ui64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform1ui64vNV]</b>  </summary>
            public static void Uniform1ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform1ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform2ui64vNV]</b>  </summary>
            public static void Uniform2ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform2ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform3ui64vNV]</b>  </summary>
            public static void Uniform3ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform3ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform4ui64vNV]</b>  </summary>
            public static void Uniform4ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform4ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glGetUniformi64vNV]</b>  </summary>
            public static void GetUniformi64vNV(int program, int location, long* parameters) => GLPointers._glGetUniformi64vNV_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load] [glGetUniformui64vNV]</b>  </summary>
            public static void GetUniformui64vNV(int program, int location, ulong* parameters) => GLPointers._glGetUniformui64vNV_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform1i64NV]</b>  </summary>
            public static void ProgramUniform1i64NV(int program, int location, long x) => GLPointers._glProgramUniform1i64NV_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform2i64NV]</b>  </summary>
            public static void ProgramUniform2i64NV(int program, int location, long x, long y) => GLPointers._glProgramUniform2i64NV_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform3i64NV]</b>  </summary>
            public static void ProgramUniform3i64NV(int program, int location, long x, long y, long z) => GLPointers._glProgramUniform3i64NV_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform4i64NV]</b>  </summary>
            public static void ProgramUniform4i64NV(int program, int location, long x, long y, long z, long w) => GLPointers._glProgramUniform4i64NV_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform1i64vNV]</b>  </summary>
            public static void ProgramUniform1i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform1i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform2i64vNV]</b>  </summary>
            public static void ProgramUniform2i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform2i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform3i64vNV]</b>  </summary>
            public static void ProgramUniform3i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform3i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform4i64vNV]</b>  </summary>
            public static void ProgramUniform4i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform4i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform1ui64NV]</b>  </summary>
            public static void ProgramUniform1ui64NV(int program, int location, ulong x) => GLPointers._glProgramUniform1ui64NV_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform2ui64NV]</b>  </summary>
            public static void ProgramUniform2ui64NV(int program, int location, ulong x, ulong y) => GLPointers._glProgramUniform2ui64NV_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform3ui64NV]</b>  </summary>
            public static void ProgramUniform3ui64NV(int program, int location, ulong x, ulong y, ulong z) => GLPointers._glProgramUniform3ui64NV_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform4ui64NV]</b>  </summary>
            public static void ProgramUniform4ui64NV(int program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glProgramUniform4ui64NV_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform1ui64vNV]</b>  </summary>
            public static void ProgramUniform1ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform1ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform2ui64vNV]</b>  </summary>
            public static void ProgramUniform2ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform2ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform3ui64vNV]</b>  </summary>
            public static void ProgramUniform3ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform3ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform4ui64vNV]</b>  </summary>
            public static void ProgramUniform4ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform4ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_interleaved_elements] [glVertexAttribParameteriAMD]</b>  </summary>
            public static void VertexAttribParameteri(uint index, All pname, int param) => GLPointers._glVertexAttribParameteriAMD_fnptr(index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect] [glMultiDrawArraysIndirectAMD]</b>  </summary>
            public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int primcount, int stride) => GLPointers._glMultiDrawArraysIndirectAMD_fnptr((uint)mode, indirect, primcount, stride);
            
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect] [glMultiDrawElementsIndirectAMD]</b>  </summary>
            public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int primcount, int stride) => GLPointers._glMultiDrawElementsIndirectAMD_fnptr((uint)mode, (uint)type, indirect, primcount, stride);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete] [glGenNamesAMD]</b>  </summary>
            public static void GenNames(All identifier, uint num, uint* names) => GLPointers._glGenNamesAMD_fnptr((uint)identifier, num, names);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete] [glDeleteNamesAMD]</b>  </summary>
            public static void DeleteNames(All identifier, uint num, uint* names) => GLPointers._glDeleteNamesAMD_fnptr((uint)identifier, num, names);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete] [glIsNameAMD]</b>  </summary>
            public static bool IsName(All identifier, uint name) => GLPointers._glIsNameAMD_fnptr((uint)identifier, name) != 0;
            
            /// <summary> <b>[requires: GL_AMD_occlusion_query_event] [glQueryObjectParameteruiAMD]</b>  </summary>
            public static void QueryObjectParameterui(QueryTarget target, int id, All pname, OcclusionQueryEventMaskAMD param) => GLPointers._glQueryObjectParameteruiAMD_fnptr((uint)target, id, (uint)pname, (uint)param);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glGetPerfMonitorGroupsAMD]</b>  </summary>
            public static void GetPerfMonitorGroups(int* numGroups, int groupsSize, uint* groups) => GLPointers._glGetPerfMonitorGroupsAMD_fnptr(numGroups, groupsSize, groups);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glGetPerfMonitorCountersAMD]</b>  </summary>
            public static void GetPerfMonitorCounters(uint group, int* numCounters, int* maxActiveCounters, int counterSize, uint* counters) => GLPointers._glGetPerfMonitorCountersAMD_fnptr(group, numCounters, maxActiveCounters, counterSize, counters);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glGetPerfMonitorGroupStringAMD]</b>  </summary>
            public static void GetPerfMonitorGroupString(uint group, int bufSize, int* length, byte* groupString) => GLPointers._glGetPerfMonitorGroupStringAMD_fnptr(group, bufSize, length, groupString);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glGetPerfMonitorCounterStringAMD]</b>  </summary>
            public static void GetPerfMonitorCounterString(uint group, uint counter, int bufSize, int* length, byte* counterString) => GLPointers._glGetPerfMonitorCounterStringAMD_fnptr(group, counter, bufSize, length, counterString);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glGetPerfMonitorCounterInfoAMD]</b>  </summary>
            public static void GetPerfMonitorCounterInfo(uint group, uint counter, All pname, void* data) => GLPointers._glGetPerfMonitorCounterInfoAMD_fnptr(group, counter, (uint)pname, data);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glGenPerfMonitorsAMD]</b>  </summary>
            public static void GenPerfMonitors(int n, uint* monitors) => GLPointers._glGenPerfMonitorsAMD_fnptr(n, monitors);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glDeletePerfMonitorsAMD]</b>  </summary>
            public static void DeletePerfMonitors(int n, uint* monitors) => GLPointers._glDeletePerfMonitorsAMD_fnptr(n, monitors);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glSelectPerfMonitorCountersAMD]</b>  </summary>
            public static void SelectPerfMonitorCounters(uint monitor, bool enable, uint group, int numCounters, uint* counterList) => GLPointers._glSelectPerfMonitorCountersAMD_fnptr(monitor, (byte)(enable ? 1 : 0), group, numCounters, counterList);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glBeginPerfMonitorAMD]</b>  </summary>
            public static void BeginPerfMonitor(uint monitor) => GLPointers._glBeginPerfMonitorAMD_fnptr(monitor);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glEndPerfMonitorAMD]</b>  </summary>
            public static void EndPerfMonitor(uint monitor) => GLPointers._glEndPerfMonitorAMD_fnptr(monitor);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor] [glGetPerfMonitorCounterDataAMD]</b>  </summary>
            public static void GetPerfMonitorCounterData(uint monitor, All pname, int dataSize, uint* data, int* bytesWritten) => GLPointers._glGetPerfMonitorCounterDataAMD_fnptr(monitor, (uint)pname, dataSize, data, bytesWritten);
            
            /// <summary> <b>[requires: GL_AMD_sample_positions] [glSetMultisamplefvAMD]</b>  </summary>
            public static void SetMultisamplefv(All pname, uint index, float* val) => GLPointers._glSetMultisamplefvAMD_fnptr((uint)pname, index, val);
            
            /// <summary> <b>[requires: GL_AMD_sparse_texture] [glTexStorageSparseAMD]</b>  </summary>
            public static void TexStorageSparse(TextureTarget target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => GLPointers._glTexStorageSparseAMD_fnptr((uint)target, (uint)internalFormat, width, height, depth, layers, (uint)flags);
            
            /// <summary> <b>[requires: GL_AMD_sparse_texture] [glTextureStorageSparseAMD]</b>  </summary>
            public static void TextureStorageSparse(int texture, All target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => GLPointers._glTextureStorageSparseAMD_fnptr(texture, (uint)target, (uint)internalFormat, width, height, depth, layers, (uint)flags);
            
            /// <summary> <b>[requires: GL_AMD_stencil_operation_extended] [glStencilOpValueAMD]</b>  </summary>
            public static void StencilOpValue(TriangleFace face, uint value) => GLPointers._glStencilOpValueAMD_fnptr((uint)face, value);
            
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator] [glTessellationFactorAMD]</b>  </summary>
            public static void TessellationFactor(float factor) => GLPointers._glTessellationFactorAMD_fnptr(factor);
            
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator] [glTessellationModeAMD]</b>  </summary>
            public static void TessellationMode(All mode) => GLPointers._glTessellationModeAMD_fnptr((uint)mode);
            
        }
        /// <summary>APPLE extensions.</summary>
        public static unsafe partial class APPLE
        {
            /// <summary> <b>[requires: GL_APPLE_element_array] [glElementPointerAPPLE]</b>  </summary>
            public static void ElementPointer(ElementPointerTypeATI type, void* pointer) => GLPointers._glElementPointerAPPLE_fnptr((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_element_array] [glDrawElementArrayAPPLE]</b>  </summary>
            public static void DrawElementArray(PrimitiveType mode, int first, int count) => GLPointers._glDrawElementArrayAPPLE_fnptr((uint)mode, first, count);
            
            /// <summary> <b>[requires: GL_APPLE_element_array] [glDrawRangeElementArrayAPPLE]</b>  </summary>
            public static void DrawRangeElementArray(PrimitiveType mode, uint start, uint end, int first, int count) => GLPointers._glDrawRangeElementArrayAPPLE_fnptr((uint)mode, start, end, first, count);
            
            /// <summary> <b>[requires: GL_APPLE_element_array] [glMultiDrawElementArrayAPPLE]</b>  </summary>
            public static void MultiDrawElementArray(PrimitiveType mode, int* first, int* count, int primcount) => GLPointers._glMultiDrawElementArrayAPPLE_fnptr((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_APPLE_element_array] [glMultiDrawRangeElementArrayAPPLE]</b>  </summary>
            public static void MultiDrawRangeElementArray(PrimitiveType mode, uint start, uint end, int* first, int* count, int primcount) => GLPointers._glMultiDrawRangeElementArrayAPPLE_fnptr((uint)mode, start, end, first, count, primcount);
            
            /// <summary> <b>[requires: GL_APPLE_fence] [glGenFencesAPPLE]</b>  </summary>
            public static void GenFences(int n, uint* fences) => GLPointers._glGenFencesAPPLE_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_APPLE_fence] [glDeleteFencesAPPLE]</b>  </summary>
            public static void DeleteFences(int n, uint* fences) => GLPointers._glDeleteFencesAPPLE_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_APPLE_fence] [glSetFenceAPPLE]</b>  </summary>
            public static void SetFence(uint fence) => GLPointers._glSetFenceAPPLE_fnptr(fence);
            
            /// <summary> <b>[requires: GL_APPLE_fence] [glIsFenceAPPLE]</b>  </summary>
            public static bool IsFence(uint fence) => GLPointers._glIsFenceAPPLE_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_fence] [glTestFenceAPPLE]</b>  </summary>
            public static bool TestFence(uint fence) => GLPointers._glTestFenceAPPLE_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_fence] [glFinishFenceAPPLE]</b>  </summary>
            public static void FinishFence(uint fence) => GLPointers._glFinishFenceAPPLE_fnptr(fence);
            
            /// <summary> <b>[requires: GL_APPLE_fence] [glTestObjectAPPLE]</b>  </summary>
            public static bool TestObject(ObjectTypeAPPLE obj, uint name) => GLPointers._glTestObjectAPPLE_fnptr((uint)obj, name) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_fence] [glFinishObjectAPPLE]</b>  </summary>
            public static void FinishObject(ObjectTypeAPPLE obj, int name) => GLPointers._glFinishObjectAPPLE_fnptr((uint)obj, name);
            
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range] [glBufferParameteriAPPLE]</b>  </summary>
            public static void BufferParameteri(All target, All pname, int param) => GLPointers._glBufferParameteriAPPLE_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range] [glFlushMappedBufferRangeAPPLE]</b>  </summary>
            public static void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, nint size) => GLPointers._glFlushMappedBufferRangeAPPLE_fnptr((uint)target, offset, size);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable] [glObjectPurgeableAPPLE]</b>  </summary>
            public static All ObjectPurgeable(All objectType, uint name, All option) => (All) GLPointers._glObjectPurgeableAPPLE_fnptr((uint)objectType, name, (uint)option);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable] [glObjectUnpurgeableAPPLE]</b>  </summary>
            public static All ObjectUnpurgeable(All objectType, uint name, All option) => (All) GLPointers._glObjectUnpurgeableAPPLE_fnptr((uint)objectType, name, (uint)option);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable] [glGetObjectParameterivAPPLE]</b>  </summary>
            public static void GetObjectParameteriv(All objectType, uint name, All pname, int* parameters) => GLPointers._glGetObjectParameterivAPPLE_fnptr((uint)objectType, name, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_APPLE_texture_range] [glTextureRangeAPPLE]</b>  </summary>
            public static void TextureRange(All target, int length, void* pointer) => GLPointers._glTextureRangeAPPLE_fnptr((uint)target, length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_texture_range] [glGetTexParameterPointervAPPLE]</b>  </summary>
            public static void GetTexParameterPointerv(All target, All pname, void** parameters) => GLPointers._glGetTexParameterPointervAPPLE_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object] [glBindVertexArrayAPPLE]</b>  </summary>
            public static void BindVertexArray(int array) => GLPointers._glBindVertexArrayAPPLE_fnptr(array);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object] [glDeleteVertexArraysAPPLE]</b>  </summary>
            public static void DeleteVertexArrays(int n, int* arrays) => GLPointers._glDeleteVertexArraysAPPLE_fnptr(n, arrays);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object] [glGenVertexArraysAPPLE]</b>  </summary>
            public static void GenVertexArrays(int n, int* arrays) => GLPointers._glGenVertexArraysAPPLE_fnptr(n, arrays);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object] [glIsVertexArrayAPPLE]</b>  </summary>
            public static bool IsVertexArray(int array) => GLPointers._glIsVertexArrayAPPLE_fnptr(array) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range] [glVertexArrayRangeAPPLE]</b>  </summary>
            public static void VertexArrayRange(int length, void* pointer) => GLPointers._glVertexArrayRangeAPPLE_fnptr(length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range] [glFlushVertexArrayRangeAPPLE]</b>  </summary>
            public static void FlushVertexArrayRange(int length, void* pointer) => GLPointers._glFlushVertexArrayRangeAPPLE_fnptr(length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range] [glVertexArrayParameteriAPPLE]</b>  </summary>
            public static void VertexArrayParameteri(VertexArrayPNameAPPLE pname, int param) => GLPointers._glVertexArrayParameteriAPPLE_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators] [glEnableVertexAttribAPPLE]</b>  </summary>
            public static void EnableVertexAttrib(uint index, All pname) => GLPointers._glEnableVertexAttribAPPLE_fnptr(index, (uint)pname);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators] [glDisableVertexAttribAPPLE]</b>  </summary>
            public static void DisableVertexAttrib(uint index, All pname) => GLPointers._glDisableVertexAttribAPPLE_fnptr(index, (uint)pname);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators] [glIsVertexAttribEnabledAPPLE]</b>  </summary>
            public static bool IsVertexAttribEnabled(uint index, All pname) => GLPointers._glIsVertexAttribEnabledAPPLE_fnptr(index, (uint)pname) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators] [glMapVertexAttrib1dAPPLE]</b>  </summary>
            public static void MapVertexAttrib1d(uint index, uint size, double u1, double u2, int stride, int order, double* points) => GLPointers._glMapVertexAttrib1dAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators] [glMapVertexAttrib1fAPPLE]</b>  </summary>
            public static void MapVertexAttrib1f(uint index, uint size, float u1, float u2, int stride, int order, float* points) => GLPointers._glMapVertexAttrib1fAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators] [glMapVertexAttrib2dAPPLE]</b>  </summary>
            public static void MapVertexAttrib2d(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) => GLPointers._glMapVertexAttrib2dAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators] [glMapVertexAttrib2fAPPLE]</b>  </summary>
            public static void MapVertexAttrib2f(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) => GLPointers._glMapVertexAttrib2fAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
        }
        /// <summary>ARB extensions.</summary>
        public static unsafe partial class ARB
        {
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glReleaseShaderCompiler]</b> Release resources consumed by the implementation&apos;s shader compiler. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml" /></remarks>
            public static void ReleaseShaderCompiler() => GLPointers._glReleaseShaderCompiler_fnptr();
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glShaderBinary]</b> Load pre-compiled shader binaries. </summary>
            /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
            /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
            /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
            /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
            /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml" /></remarks>
            public static void ShaderBinary(int count, int* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => GLPointers._glShaderBinary_fnptr(count, shaders, (uint)binaryFormat, binary, length);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glGetShaderPrecisionFormat]</b> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
            /// <param name="shaderType"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="precisionType"> Specifies the numeric format whose precision and range to query. </param>
            /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation&apos;s numeric range are returned. </param>
            /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml" /></remarks>
            public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => GLPointers._glGetShaderPrecisionFormat_fnptr((uint)shadertype, (uint)precisiontype, range, precision);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glDepthRangef]</b> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
            /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
            public static void DepthRangef(float n, float f) => GLPointers._glDepthRangef_fnptr(n, f);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility] [glClearDepthf]</b> Specify the clear value for the depth buffer. </summary>
            /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
            public static void ClearDepthf(float d) => GLPointers._glClearDepthf_fnptr(d);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility] [glMemoryBarrierByRegion]</b> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
            public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrierByRegion_fnptr((uint)barriers);
            
            /// <summary> <b>[requires: GL_ARB_ES3_2_compatibility] [glPrimitiveBoundingBoxARB]</b>  </summary>
            public static void PrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) => GLPointers._glPrimitiveBoundingBoxARB_fnptr(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance] [glDrawArraysInstancedBaseInstance]</b> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
            /// <param name="count"> Specifies the number of indices to be rendered. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml" /></remarks>
            public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => GLPointers._glDrawArraysInstancedBaseInstance_fnptr((uint)mode, first, count, instancecount, baseinstance);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance] [glDrawElementsInstancedBaseInstance]</b> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, uint baseinstance) => GLPointers._glDrawElementsInstancedBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, baseinstance);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance] [glDrawElementsInstancedBaseVertexBaseInstance]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => GLPointers._glDrawElementsInstancedBaseVertexBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex, baseinstance);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glGetTextureHandleARB]</b>  </summary>
            public static ulong GetTextureHandle(int texture) => GLPointers._glGetTextureHandleARB_fnptr(texture);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glGetTextureSamplerHandleARB]</b>  </summary>
            public static ulong GetTextureSamplerHandle(int texture, int sampler) => GLPointers._glGetTextureSamplerHandleARB_fnptr(texture, sampler);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glMakeTextureHandleResidentARB]</b>  </summary>
            public static void MakeTextureHandleResident(ulong handle) => GLPointers._glMakeTextureHandleResidentARB_fnptr(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glMakeTextureHandleNonResidentARB]</b>  </summary>
            public static void MakeTextureHandleNonResident(ulong handle) => GLPointers._glMakeTextureHandleNonResidentARB_fnptr(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glGetImageHandleARB]</b>  </summary>
            public static ulong GetImageHandle(int texture, int level, bool layered, int layer, PixelFormat format) => GLPointers._glGetImageHandleARB_fnptr(texture, level, (byte)(layered ? 1 : 0), layer, (uint)format);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glMakeImageHandleResidentARB]</b>  </summary>
            public static void MakeImageHandleResident(ulong handle, All access) => GLPointers._glMakeImageHandleResidentARB_fnptr(handle, (uint)access);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glMakeImageHandleNonResidentARB]</b>  </summary>
            public static void MakeImageHandleNonResident(ulong handle) => GLPointers._glMakeImageHandleNonResidentARB_fnptr(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glUniformHandleui64ARB]</b>  </summary>
            public static void UniformHandleui64(int location, ulong value) => GLPointers._glUniformHandleui64ARB_fnptr(location, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glUniformHandleui64vARB]</b>  </summary>
            public static void UniformHandleui64v(int location, int count, ulong* value) => GLPointers._glUniformHandleui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glProgramUniformHandleui64ARB]</b>  </summary>
            public static void ProgramUniformHandleui64(int program, int location, ulong value) => GLPointers._glProgramUniformHandleui64ARB_fnptr(program, location, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glProgramUniformHandleui64vARB]</b>  </summary>
            public static void ProgramUniformHandleui64v(int program, int location, int count, ulong* values) => GLPointers._glProgramUniformHandleui64vARB_fnptr(program, location, count, values);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glIsTextureHandleResidentARB]</b>  </summary>
            public static bool IsTextureHandleResident(ulong handle) => GLPointers._glIsTextureHandleResidentARB_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glIsImageHandleResidentARB]</b>  </summary>
            public static bool IsImageHandleResident(ulong handle) => GLPointers._glIsImageHandleResidentARB_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glVertexAttribL1ui64ARB]</b>  </summary>
            public static void VertexAttribL1ui64(uint index, ulong x) => GLPointers._glVertexAttribL1ui64ARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glVertexAttribL1ui64vARB]</b>  </summary>
            public static void VertexAttribL1ui64v(uint index, ulong* v) => GLPointers._glVertexAttribL1ui64vARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture] [glGetVertexAttribLui64vARB]</b>  </summary>
            public static void GetVertexAttribLui64v(uint index, VertexAttribEnum pname, ulong* parameters) => GLPointers._glGetVertexAttribLui64vARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended] [glBindFragDataLocationIndexed]</b> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
            /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
            /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
            /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml" /></remarks>
            public static void BindFragDataLocationIndexed(int program, uint colorNumber, uint index, byte* name) => GLPointers._glBindFragDataLocationIndexed_fnptr(program, colorNumber, index, name);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended] [glGetFragDataIndex]</b> Query the bindings of color indices to user-defined varying out variables. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
            /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml" /></remarks>
            public static int GetFragDataIndex(int program, byte* name) => GLPointers._glGetFragDataIndex_fnptr(program, name);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage] [glBufferStorage]</b> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
            public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => GLPointers._glBufferStorage_fnptr((uint)target, size, data, (uint)flags);
            
            /// <summary> <b>[requires: GL_ARB_cl_event] [glCreateSyncFromCLeventARB]</b>  </summary>
            public static GLSync CreateSyncFromCLevent(CLContext* context, CLEvent* @event, uint flags) => (GLSync) GLPointers._glCreateSyncFromCLeventARB_fnptr((IntPtr*)context, (IntPtr*)@event, flags);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object] [glClearBufferData]</b> Fill a buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
            public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearBufferData_fnptr((uint)target, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object] [glClearBufferSubData]</b> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
            public static void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearBufferSubData_fnptr((uint)target, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture] [glClearTexImage]</b> Fills all a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml" /></remarks>
            public static void ClearTexImage(int texture, int level, PixelFormat format, PixelType type, void* data) => GLPointers._glClearTexImage_fnptr(texture, level, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture] [glClearTexSubImage]</b> Fills all or part of a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
            /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
            /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
            /// <param name="width"> The width of the region to be cleared. </param>
            /// <param name="height"> The height of the region to be cleared. </param>
            /// <param name="depth"> The depth of the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml" /></remarks>
            public static void ClearTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => GLPointers._glClearTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control] [glClipControl]</b> Control clip coordinate to window coordinate behavior. </summary>
            /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
            /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml" /></remarks>
            public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => GLPointers._glClipControl_fnptr((uint)origin, (uint)depth);
            
            /// <summary> <b>[requires: GL_ARB_color_buffer_float] [glClampColorARB]</b>  </summary>
            public static void ClampColor(ClampColorTargetARB target, ClampColorModeARB clamp) => GLPointers._glClampColorARB_fnptr((uint)target, (uint)clamp);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader] [glDispatchCompute]</b> Launch one or more compute work groups. </summary>
            /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
            /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
            /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml" /></remarks>
            public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => GLPointers._glDispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader] [glDispatchComputeIndirect]</b> Launch one or more compute work groups using parameters stored in a buffer. </summary>
            /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml" /></remarks>
            public static void DispatchComputeIndirect(IntPtr indirect) => GLPointers._glDispatchComputeIndirect_fnptr(indirect);
            
            /// <summary> <b>[requires: GL_ARB_compute_variable_group_size] [glDispatchComputeGroupSizeARB]</b>  </summary>
            public static void DispatchComputeGroupSize(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z) => GLPointers._glDispatchComputeGroupSizeARB_fnptr(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer] [glCopyBufferSubData]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
            /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
            public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glCopyBufferSubData_fnptr((uint)readTarget, (uint)writeTarget, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image] [glCopyImageSubData]</b> Perform a raw data copy between two images. </summary>
            /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
            /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
            /// <param name="srcLevel"> The mipmap level to read from the source. </param>
            /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
            /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
            /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
            /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
            /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
            /// <param name="dstLevel">!!missing documentation!!</param>
            /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
            /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
            /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
            /// <param name="srcWidth"> The width of the region to be copied. </param>
            /// <param name="srcHeight"> The height of the region to be copied. </param>
            /// <param name="srcDepth"> The depth of the region to be copied. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml" /></remarks>
            public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers._glCopyImageSubData_fnptr(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            
            /// <summary> <b>[requires: GL_ARB_debug_output] [glDebugMessageControlARB]</b>  </summary>
            public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageControlARB_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_debug_output] [glDebugMessageInsertARB]</b>  </summary>
            public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._glDebugMessageInsertARB_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: GL_ARB_debug_output] [glDebugMessageCallbackARB]</b>  </summary>
            public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallbackARB_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: GL_ARB_debug_output] [glGetDebugMessageLogARB]</b>  </summary>
            public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._glGetDebugMessageLogARB_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateTransformFeedbacks]</b> Create transform feedback objects. </summary>
            /// <param name="n"> Number of transform feedback objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml" /></remarks>
            public static void CreateTransformFeedbacks(int n, int* ids) => GLPointers._glCreateTransformFeedbacks_fnptr(n, ids);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTransformFeedbackBufferBase]</b> Bind a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml" /></remarks>
            public static void TransformFeedbackBufferBase(int xfb, uint index, int buffer) => GLPointers._glTransformFeedbackBufferBase_fnptr(xfb, index, buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTransformFeedbackBufferRange]</b> Bind a range within a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
            /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml" /></remarks>
            public static void TransformFeedbackBufferRange(int xfb, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glTransformFeedbackBufferRange_fnptr(xfb, index, buffer, offset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTransformFeedbackiv]</b> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbackiv(int xfb, TransformFeedbackPName pname, int* param) => GLPointers._glGetTransformFeedbackiv_fnptr(xfb, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTransformFeedbacki_v]</b> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbacki_v(int xfb, TransformFeedbackPName pname, uint index, int* param) => GLPointers._glGetTransformFeedbacki_v_fnptr(xfb, (uint)pname, index, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTransformFeedbacki64_v]</b> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbacki64_v(int xfb, TransformFeedbackPName pname, uint index, long* param) => GLPointers._glGetTransformFeedbacki64_v_fnptr(xfb, (uint)pname, index, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateBuffers]</b> Create buffer objects. </summary>
            /// <param name="n"> Specifies the number of buffer objects to create. </param>
            /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml" /></remarks>
            public static void CreateBuffers(int n, int* buffers) => GLPointers._glCreateBuffers_fnptr(n, buffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedBufferStorage]</b> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
            public static void NamedBufferStorage(int buffer, nint size, void* data, BufferStorageMask flags) => GLPointers._glNamedBufferStorage_fnptr(buffer, size, data, (uint)flags);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedBufferData]</b> Creates and initializes a buffer object&apos;s data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
            public static void NamedBufferData(int buffer, nint size, void* data, VertexBufferObjectUsage usage) => GLPointers._glNamedBufferData_fnptr(buffer, size, data, (uint)usage);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedBufferSubData]</b> Updates a subset of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store where data replacement will begin, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
            /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
            public static void NamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glNamedBufferSubData_fnptr(buffer, offset, size, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCopyNamedBufferSubData]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
            public static void CopyNamedBufferSubData(int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glCopyNamedBufferSubData_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedBufferData]</b> Fill a buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
            public static void ClearNamedBufferData(int buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferData_fnptr(buffer, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedBufferSubData]</b> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
            public static void ClearNamedBufferSubData(int buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferSubData_fnptr(buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glMapNamedBuffer]</b> Map all of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
            /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object&apos;s mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
            public static void* MapNamedBuffer(int buffer, BufferAccessARB access) => GLPointers._glMapNamedBuffer_fnptr(buffer, (uint)access);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glMapNamedBufferRange]</b> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
            public static void* MapNamedBufferRange(int buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapNamedBufferRange_fnptr(buffer, offset, length, (uint)access);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glUnmapNamedBuffer]</b> Release the mapping of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
            public static bool UnmapNamedBuffer(int buffer) => GLPointers._glUnmapNamedBuffer_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glFlushMappedNamedBufferRange]</b> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
            public static void FlushMappedNamedBufferRange(int buffer, IntPtr offset, nint length) => GLPointers._glFlushMappedNamedBufferRange_fnptr(buffer, offset, length);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedBufferParameteriv]</b> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
            public static void GetNamedBufferParameteriv(int buffer, BufferPNameARB pname, int* parameters) => GLPointers._glGetNamedBufferParameteriv_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedBufferParameteri64v]</b> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
            public static void GetNamedBufferParameteri64v(int buffer, BufferPNameARB pname, long* parameters) => GLPointers._glGetNamedBufferParameteri64v_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedBufferPointerv]</b> Return the pointer to a mapped buffer object&apos;s data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
            /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
            /// <param name="parameters"> Returns the pointer value specified by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
            public static void GetNamedBufferPointerv(int buffer, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetNamedBufferPointerv_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedBufferSubData]</b> Returns a subset of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store from which data will be returned, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
            /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
            public static void GetNamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glGetNamedBufferSubData_fnptr(buffer, offset, size, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateFramebuffers]</b> Create framebuffer objects. </summary>
            /// <param name="n"> Number of framebuffer objects to create. </param>
            /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml" /></remarks>
            public static void CreateFramebuffers(int n, int* framebuffers) => GLPointers._glCreateFramebuffers_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferRenderbuffer]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
            public static void NamedFramebufferRenderbuffer(int framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glNamedFramebufferRenderbuffer_fnptr(framebuffer, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferParameteri]</b> Set a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
            public static void NamedFramebufferParameteri(int framebuffer, FramebufferParameterName pname, int param) => GLPointers._glNamedFramebufferParameteri_fnptr(framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferTexture]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void NamedFramebufferTexture(int framebuffer, FramebufferAttachment attachment, int texture, int level) => GLPointers._glNamedFramebufferTexture_fnptr(framebuffer, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferTextureLayer]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
            public static void NamedFramebufferTextureLayer(int framebuffer, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glNamedFramebufferTextureLayer_fnptr(framebuffer, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferDrawBuffer]</b> Specify which color buffers are to be drawn into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
            /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
            public static void NamedFramebufferDrawBuffer(int framebuffer, ColorBuffer buf) => GLPointers._glNamedFramebufferDrawBuffer_fnptr(framebuffer, (uint)buf);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferDrawBuffers]</b> Specifies a list of color buffers to be drawn    into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
            /// <param name="n">Specifies the number of buffers in bufs.</param>
            /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
            public static void NamedFramebufferDrawBuffers(int framebuffer, int n, ColorBuffer* bufs) => GLPointers._glNamedFramebufferDrawBuffers_fnptr(framebuffer, n, (uint*)bufs);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedFramebufferReadBuffer]</b> Select a color buffer source for pixels. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
            /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
            public static void NamedFramebufferReadBuffer(int framebuffer, ColorBuffer src) => GLPointers._glNamedFramebufferReadBuffer_fnptr(framebuffer, (uint)src);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glInvalidateNamedFramebufferData]</b> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
            public static void InvalidateNamedFramebufferData(int framebuffer, int numAttachments, FramebufferAttachment* attachments) => GLPointers._glInvalidateNamedFramebufferData_fnptr(framebuffer, numAttachments, (uint*)attachments);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glInvalidateNamedFramebufferSubData]</b> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
            public static void InvalidateNamedFramebufferSubData(int framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._glInvalidateNamedFramebufferSubData_fnptr(framebuffer, numAttachments, (uint*)attachments, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedFramebufferiv]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferiv(int framebuffer, Buffer buffer, int drawbuffer, int* value) => GLPointers._glClearNamedFramebufferiv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedFramebufferuiv]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferuiv(int framebuffer, Buffer buffer, int drawbuffer, uint* value) => GLPointers._glClearNamedFramebufferuiv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedFramebufferfv]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferfv(int framebuffer, Buffer buffer, int drawbuffer, float* value) => GLPointers._glClearNamedFramebufferfv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glClearNamedFramebufferfi]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="depth"> The value to clear the depth buffer to. </param>
            /// <param name="stencil"> The value to clear the stencil buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferfi(int framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers._glClearNamedFramebufferfi_fnptr(framebuffer, (uint)buffer, drawbuffer, depth, stencil);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glBlitNamedFramebuffer]</b> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
            public static void BlitNamedFramebuffer(int readFramebuffer, int drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitNamedFramebuffer_fnptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCheckNamedFramebufferStatus]</b> Check the completeness status of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
            public static FramebufferStatus CheckNamedFramebufferStatus(int framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckNamedFramebufferStatus_fnptr(framebuffer, (uint)target);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedFramebufferParameteriv]</b> Query a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="param">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
            public static void GetNamedFramebufferParameteriv(int framebuffer, GetFramebufferParameter pname, int* param) => GLPointers._glGetNamedFramebufferParameteriv_fnptr(framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedFramebufferAttachmentParameteriv]</b> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
            public static void GetNamedFramebufferAttachmentParameteriv(int framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetNamedFramebufferAttachmentParameteriv_fnptr(framebuffer, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateRenderbuffers]</b> Create renderbuffer objects. </summary>
            /// <param name="n"> Number of renderbuffer objects to create. </param>
            /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml" /></remarks>
            public static void CreateRenderbuffers(int n, int* renderbuffers) => GLPointers._glCreateRenderbuffers_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedRenderbufferStorage]</b> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
            public static void NamedRenderbufferStorage(int renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorage_fnptr(renderbuffer, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glNamedRenderbufferStorageMultisample]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
            public static void NamedRenderbufferStorageMultisample(int renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisample_fnptr(renderbuffer, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetNamedRenderbufferParameteriv]</b> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
            public static void GetNamedRenderbufferParameteriv(int renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetNamedRenderbufferParameteriv_fnptr(renderbuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateTextures]</b> Create texture objects. </summary>
            /// <param name="target"> Specifies the effective texture target of each created texture. </param>
            /// <param name="n"> Number of texture objects to create. </param>
            /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml" /></remarks>
            public static void CreateTextures(TextureTarget target, int n, int* textures) => GLPointers._glCreateTextures_fnptr((uint)target, n, textures);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureBuffer]</b> Attach a buffer object&apos;s data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
            public static void TextureBuffer(int texture, SizedInternalFormat internalformat, int buffer) => GLPointers._glTextureBuffer_fnptr(texture, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureBufferRange]</b> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
            public static void TextureBufferRange(int texture, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTextureBufferRange_fnptr(texture, (uint)internalformat, buffer, offset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage1D]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
            public static void TextureStorage1D(int texture, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTextureStorage1D_fnptr(texture, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage2D]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
            public static void TextureStorage2D(int texture, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTextureStorage2D_fnptr(texture, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage3D]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
            public static void TextureStorage3D(int texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTextureStorage3D_fnptr(texture, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage2DMultisample]</b> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
            public static void TextureStorage2DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTextureStorage2DMultisample_fnptr(texture, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureStorage3DMultisample]</b> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
            public static void TextureStorage3DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTextureStorage3DMultisample_fnptr(texture, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureSubImage1D]</b> Specify a one-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
            public static void TextureSubImage1D(int texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage1D_fnptr(texture, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureSubImage2D]</b> Specify a two-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
            public static void TextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureSubImage3D]</b> Specify a three-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="depth"> Specifies the depth of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
            public static void TextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCompressedTextureSubImage1D]</b> Specify a one-dimensional texture subimage in a compressed    format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
            public static void CompressedTextureSubImage1D(int texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage1D_fnptr(texture, level, xoffset, width, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCompressedTextureSubImage2D]</b> Specify a two-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
            public static void CompressedTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCompressedTextureSubImage3D]</b> Specify a three-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">!!missing documentation!!</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
            public static void CompressedTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCopyTextureSubImage1D]</b> Copy a one-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
            public static void CopyTextureSubImage1D(int texture, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTextureSubImage1D_fnptr(texture, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCopyTextureSubImage2D]</b> Copy a two-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
            public static void CopyTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCopyTextureSubImage3D]</b> Copy a three-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
            public static void CopyTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameterf]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterf(int texture, TextureParameterName pname, float param) => GLPointers._glTextureParameterf_fnptr(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameterfv]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterfv(int texture, TextureParameterName pname, float* param) => GLPointers._glTextureParameterfv_fnptr(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameteri]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameteri(int texture, TextureParameterName pname, int param) => GLPointers._glTextureParameteri_fnptr(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameterIiv]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterIiv(int texture, TextureParameterName pname, int* parameters) => GLPointers._glTextureParameterIiv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameterIuiv]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterIuiv(int texture, TextureParameterName pname, uint* parameters) => GLPointers._glTextureParameterIuiv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glTextureParameteriv]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameteriv(int texture, TextureParameterName pname, int* param) => GLPointers._glTextureParameteriv_fnptr(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGenerateTextureMipmap]</b> Generate mipmaps for a specified texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
            public static void GenerateTextureMipmap(int texture) => GLPointers._glGenerateTextureMipmap_fnptr(texture);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glBindTextureUnit]</b> Bind an existing texture object to the specified texture unit . </summary>
            /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
            /// <param name="texture">Specifies the name of a texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml" /></remarks>
            public static void BindTextureUnit(uint unit, int texture) => GLPointers._glBindTextureUnit_fnptr(unit, texture);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureImage]</b> Return a texture image. </summary>
            /// <param name="texture"> Specifies the texture object name. </param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
            /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
            /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
            public static void GetTextureImage(int texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetTextureImage_fnptr(texture, level, (uint)format, (uint)type, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetCompressedTextureImage]</b> Return a compressed texture image. </summary>
            /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
            /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
            /// <param name="pixels">Returns the compressed texture image.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
            public static void GetCompressedTextureImage(int texture, int level, int bufSize, void* pixels) => GLPointers._glGetCompressedTextureImage_fnptr(texture, level, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureLevelParameterfv]</b> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
            public static void GetTextureLevelParameterfv(int texture, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureLevelParameterfv_fnptr(texture, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureLevelParameteriv]</b> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
            public static void GetTextureLevelParameteriv(int texture, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureLevelParameteriv_fnptr(texture, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureParameterfv]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterfv(int texture, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureParameterfv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureParameterIiv]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterIiv(int texture, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameterIiv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureParameterIuiv]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterIuiv(int texture, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTextureParameterIuiv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetTextureParameteriv]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameteriv(int texture, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameteriv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateVertexArrays]</b> Create vertex array objects. </summary>
            /// <param name="n"> Number of vertex array objects to create. </param>
            /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml" /></remarks>
            public static void CreateVertexArrays(int n, int* arrays) => GLPointers._glCreateVertexArrays_fnptr(n, arrays);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glDisableVertexArrayAttrib]</b> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
            public static void DisableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glDisableVertexArrayAttrib_fnptr(vaobj, index);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glEnableVertexArrayAttrib]</b> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
            public static void EnableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glEnableVertexArrayAttrib_fnptr(vaobj, index);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayElementBuffer]</b> Configures element array buffer binding of a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
            /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml" /></remarks>
            public static void VertexArrayElementBuffer(int vaobj, int buffer) => GLPointers._glVertexArrayElementBuffer_fnptr(vaobj, buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayVertexBuffer]</b> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
            public static void VertexArrayVertexBuffer(int vaobj, uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glVertexArrayVertexBuffer_fnptr(vaobj, bindingindex, buffer, offset, stride);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayVertexBuffers]</b> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
            public static void VertexArrayVertexBuffers(int vaobj, uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers._glVertexArrayVertexBuffers_fnptr(vaobj, first, count, buffers, offsets, strides);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayAttribBinding]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
            public static void VertexArrayAttribBinding(int vaobj, uint attribindex, uint bindingindex) => GLPointers._glVertexArrayAttribBinding_fnptr(vaobj, attribindex, bindingindex);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayAttribFormat]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribFormat(int vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexArrayAttribFormat_fnptr(vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayAttribIFormat]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribIFormat(int vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexArrayAttribIFormat_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayAttribLFormat]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribLFormat(int vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexArrayAttribLFormat_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glVertexArrayBindingDivisor]</b> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
            public static void VertexArrayBindingDivisor(int vaobj, uint bindingindex, uint divisor) => GLPointers._glVertexArrayBindingDivisor_fnptr(vaobj, bindingindex, divisor);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetVertexArrayiv]</b> Retrieve parameters of a vertex array object. </summary>
            /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
            /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml" /></remarks>
            public static void GetVertexArrayiv(int vaobj, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayiv_fnptr(vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetVertexArrayIndexediv]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
            public static void GetVertexArrayIndexediv(int vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayIndexediv_fnptr(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetVertexArrayIndexed64iv]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
            public static void GetVertexArrayIndexed64iv(int vaobj, uint index, VertexArrayPName pname, long* param) => GLPointers._glGetVertexArrayIndexed64iv_fnptr(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateSamplers]</b> Create sampler objects. </summary>
            /// <param name="n"> Number of sampler objects to create. </param>
            /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml" /></remarks>
            public static void CreateSamplers(int n, int* samplers) => GLPointers._glCreateSamplers_fnptr(n, samplers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateProgramPipelines]</b> Create program pipeline objects. </summary>
            /// <param name="n"> Number of program pipeline objects to create. </param>
            /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml" /></remarks>
            public static void CreateProgramPipelines(int n, int* pipelines) => GLPointers._glCreateProgramPipelines_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glCreateQueries]</b> Create query objects. </summary>
            /// <param name="target"> Specifies the target of each created query object. </param>
            /// <param name="n"> Number of query objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml" /></remarks>
            public static void CreateQueries(QueryTarget target, int n, int* ids) => GLPointers._glCreateQueries_fnptr((uint)target, n, ids);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetQueryBufferObjecti64v]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjecti64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjecti64v_fnptr(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetQueryBufferObjectiv]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectiv_fnptr(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetQueryBufferObjectui64v]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectui64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectui64v_fnptr(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access] [glGetQueryBufferObjectuiv]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectuiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectuiv_fnptr(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers] [glDrawBuffersARB]</b>  </summary>
            public static void DrawBuffers(int n, DrawBufferMode* bufs) => GLPointers._glDrawBuffersARB_fnptr(n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend] [glBlendEquationiARB]</b>  </summary>
            public static void BlendEquationi(uint buf, BlendEquationModeEXT mode) => GLPointers._glBlendEquationiARB_fnptr(buf, (uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend] [glBlendEquationSeparateiARB]</b>  </summary>
            public static void BlendEquationSeparatei(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparateiARB_fnptr(buf, (uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend] [glBlendFunciARB]</b>  </summary>
            public static void BlendFunci(uint buf, BlendingFactor src, BlendingFactor dst) => GLPointers._glBlendFunciARB_fnptr(buf, (uint)src, (uint)dst);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend] [glBlendFuncSeparateiARB]</b>  </summary>
            public static void BlendFuncSeparatei(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers._glBlendFuncSeparateiARB_fnptr(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex] [glDrawElementsBaseVertex]</b> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml" /></remarks>
            public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._glDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, basevertex);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex] [glDrawRangeElementsBaseVertex]</b> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="start"> Specifies the minimum array index contained in indices. </param>
            /// <param name="end"> Specifies the maximum array index contained in indices. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml" /></remarks>
            public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._glDrawRangeElementsBaseVertex_fnptr((uint)mode, start, end, count, (uint)type, indices, basevertex);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex] [glDrawElementsInstancedBaseVertex]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => GLPointers._glDrawElementsInstancedBaseVertex_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex] [glMultiDrawElementsBaseVertex]</b> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Points to an array of the elements counts. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
            /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml" /></remarks>
            public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => GLPointers._glMultiDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, drawcount, basevertex);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect] [glDrawArraysIndirect]</b> Render primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml" /></remarks>
            public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => GLPointers._glDrawArraysIndirect_fnptr((uint)mode, indirect);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect] [glDrawElementsIndirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml" /></remarks>
            public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => GLPointers._glDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect);
            
            /// <summary> <b>[requires: GL_ARB_draw_instanced] [glDrawArraysInstancedARB]</b>  </summary>
            public static void DrawArraysInstanced(PrimitiveType mode, int first, int count, int primcount) => GLPointers._glDrawArraysInstancedARB_fnptr((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_ARB_draw_instanced] [glDrawElementsInstancedARB]</b>  </summary>
            public static void DrawElementsInstanced(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => GLPointers._glDrawElementsInstancedARB_fnptr((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glProgramStringARB]</b>  </summary>
            public static void ProgramString(ProgramTarget target, ProgramFormat format, int len, void* str) => GLPointers._glProgramStringARB_fnptr((uint)target, (uint)format, len, str);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glBindProgramARB]</b>  </summary>
            public static void BindProgram(ProgramTarget target, int program) => GLPointers._glBindProgramARB_fnptr((uint)target, program);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glDeleteProgramsARB]</b>  </summary>
            public static void DeletePrograms(int n, int* programs) => GLPointers._glDeleteProgramsARB_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glGenProgramsARB]</b>  </summary>
            public static void GenPrograms(int n, int* programs) => GLPointers._glGenProgramsARB_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glProgramEnvParameter4dARB]</b>  </summary>
            public static void ProgramEnvParameter4d(ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers._glProgramEnvParameter4dARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glProgramEnvParameter4dvARB]</b>  </summary>
            public static void ProgramEnvParameter4dv(ProgramTarget target, uint index, double* parameters) => GLPointers._glProgramEnvParameter4dvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glProgramEnvParameter4fARB]</b>  </summary>
            public static void ProgramEnvParameter4f(ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers._glProgramEnvParameter4fARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glProgramEnvParameter4fvARB]</b>  </summary>
            public static void ProgramEnvParameter4fv(ProgramTarget target, uint index, float* parameters) => GLPointers._glProgramEnvParameter4fvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glProgramLocalParameter4dARB]</b>  </summary>
            public static void ProgramLocalParameter4d(ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers._glProgramLocalParameter4dARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glProgramLocalParameter4dvARB]</b>  </summary>
            public static void ProgramLocalParameter4dv(ProgramTarget target, uint index, double* parameters) => GLPointers._glProgramLocalParameter4dvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glProgramLocalParameter4fARB]</b>  </summary>
            public static void ProgramLocalParameter4f(ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers._glProgramLocalParameter4fARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glProgramLocalParameter4fvARB]</b>  </summary>
            public static void ProgramLocalParameter4fv(ProgramTarget target, uint index, float* parameters) => GLPointers._glProgramLocalParameter4fvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glGetProgramEnvParameterdvARB]</b>  </summary>
            public static void GetProgramEnvParameterdv(ProgramTarget target, uint index, double* parameters) => GLPointers._glGetProgramEnvParameterdvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glGetProgramEnvParameterfvARB]</b>  </summary>
            public static void GetProgramEnvParameterfv(ProgramTarget target, uint index, float* parameters) => GLPointers._glGetProgramEnvParameterfvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glGetProgramLocalParameterdvARB]</b>  </summary>
            public static void GetProgramLocalParameterdv(ProgramTarget target, uint index, double* parameters) => GLPointers._glGetProgramLocalParameterdvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glGetProgramLocalParameterfvARB]</b>  </summary>
            public static void GetProgramLocalParameterfv(ProgramTarget target, uint index, float* parameters) => GLPointers._glGetProgramLocalParameterfvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glGetProgramivARB]</b>  </summary>
            public static void GetProgramiv(ProgramTarget target, ProgramPropertyARB pname, int* parameters) => GLPointers._glGetProgramivARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glGetProgramStringARB]</b>  </summary>
            public static void GetProgramString(ProgramTarget target, ProgramStringProperty pname, void* str) => GLPointers._glGetProgramStringARB_fnptr((uint)target, (uint)pname, str);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program] [glIsProgramARB]</b>  </summary>
            public static bool IsProgram(int program) => GLPointers._glIsProgramARB_fnptr(program) != 0;
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments] [glFramebufferParameteri]</b> Set a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
            public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers._glFramebufferParameteri_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments] [glGetFramebufferParameteriv]</b> Query a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
            public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glIsRenderbuffer]</b> Determine if a name corresponds to a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml" /></remarks>
            public static bool IsRenderbuffer(int renderbuffer) => GLPointers._glIsRenderbuffer_fnptr(renderbuffer) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glBindRenderbuffer]</b> Bind a renderbuffer to a renderbuffer target. </summary>
            /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml" /></remarks>
            public static void BindRenderbuffer(RenderbufferTarget target, int renderbuffer) => GLPointers._glBindRenderbuffer_fnptr((uint)target, renderbuffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glDeleteRenderbuffers]</b> Delete renderbuffer objects. </summary>
            /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
            /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml" /></remarks>
            public static void DeleteRenderbuffers(int n, int* renderbuffers) => GLPointers._glDeleteRenderbuffers_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGenRenderbuffers]</b> Generate renderbuffer object names. </summary>
            /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
            /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml" /></remarks>
            public static void GenRenderbuffers(int n, int* renderbuffers) => GLPointers._glGenRenderbuffers_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glRenderbufferStorage]</b> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
            public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorage_fnptr((uint)target, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGetRenderbufferParameteriv]</b> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
            public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetRenderbufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glIsFramebuffer]</b> Determine if a name corresponds to a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml" /></remarks>
            public static bool IsFramebuffer(int framebuffer) => GLPointers._glIsFramebuffer_fnptr(framebuffer) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glBindFramebuffer]</b> Bind a framebuffer to a framebuffer target. </summary>
            /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml" /></remarks>
            public static void BindFramebuffer(FramebufferTarget target, int framebuffer) => GLPointers._glBindFramebuffer_fnptr((uint)target, framebuffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glDeleteFramebuffers]</b> Delete framebuffer objects. </summary>
            /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
            /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml" /></remarks>
            public static void DeleteFramebuffers(int n, int* framebuffers) => GLPointers._glDeleteFramebuffers_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGenFramebuffers]</b> Generate framebuffer object names. </summary>
            /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
            /// <param name="ids"> Specifies an array in which the generated framebuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml" /></remarks>
            public static void GenFramebuffers(int n, int* framebuffers) => GLPointers._glGenFramebuffers_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glCheckFramebufferStatus]</b> Check the completeness status of a framebuffer. </summary>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
            public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckFramebufferStatus_fnptr((uint)target);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferTexture1D]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture1D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferTexture2D]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture2D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferTexture3D]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers._glFramebufferTexture3D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level, zoffset);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferRenderbuffer]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
            public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glFramebufferRenderbuffer_fnptr((uint)target, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGetFramebufferAttachmentParameteriv]</b> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
            public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferAttachmentParameteriv_fnptr((uint)target, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glGenerateMipmap]</b> Generate mipmaps for a specified texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
            public static void GenerateMipmap(TextureTarget target) => GLPointers._glGenerateMipmap_fnptr((uint)target);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glBlitFramebuffer]</b> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
            public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glRenderbufferStorageMultisample]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
            public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object] [glFramebufferTextureLayer]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
            public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayer_fnptr((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4] [glProgramParameteriARB]</b>  </summary>
            public static void ProgramParameteriARB(int program, ProgramParameterPName pname, int value) => GLPointers._glProgramParameteriARB_fnptr(program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4] [glFramebufferTextureARB]</b>  </summary>
            public static void FramebufferTexture(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level) => GLPointers._glFramebufferTextureARB_fnptr((uint)target, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4] [glFramebufferTextureLayerARB]</b>  </summary>
            public static void FramebufferTextureLayerARB(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayerARB_fnptr((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4] [glFramebufferTextureFaceARB]</b>  </summary>
            public static void FramebufferTextureFace(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, TextureTarget face) => GLPointers._glFramebufferTextureFaceARB_fnptr((uint)target, (uint)attachment, texture, level, (uint)face);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary] [glGetProgramBinary]</b> Return a binary representation of a program object&apos;s compiled and linked executable source. </summary>
            /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
            /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
            /// <param name="binary"> Specifies the address an array into which the GL will return program&apos;s binary representation. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml" /></remarks>
            public static void GetProgramBinary(int program, int bufSize, int* length, All* binaryFormat, void* binary) => GLPointers._glGetProgramBinary_fnptr(program, bufSize, length, (uint*)binaryFormat, binary);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary] [glProgramBinary]</b> Load a program object with a program binary. </summary>
            /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
            /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
            /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
            /// <param name="length"> Specifies the number of bytes contained in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml" /></remarks>
            public static void ProgramBinary(int program, All binaryFormat, void* binary, int length) => GLPointers._glProgramBinary_fnptr(program, (uint)binaryFormat, binary, length);
            
            /// <summary> <b>[requires: v4.1 | v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects] [glProgramParameteri]</b> Specify a parameter for a program object. </summary>
            /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the name of the parameter to modify. </param>
            /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml" /></remarks>
            public static void ProgramParameteri(int program, ProgramParameterPName pname, int value) => GLPointers._glProgramParameteri_fnptr(program, (uint)pname, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image] [glGetTextureSubImage]</b> Retrieve a sub-region of a texture image from a texture    object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
            /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml" /></remarks>
            public static void GetTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image] [glGetCompressedTextureSubImage]</b> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block&apos;s width, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block&apos;s height, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block&apos;s depth, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml" /></remarks>
            public static void GetCompressedTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => GLPointers._glGetCompressedTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
            
            /// <summary> <b>[requires: GL_ARB_gl_spirv] [glSpecializeShaderARB]</b>  </summary>
            public static void SpecializeShader(int shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => GLPointers._glSpecializeShaderARB_fnptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform1d]</b>  </summary>
            public static void Uniform1d(int location, double x) => GLPointers._glUniform1d_fnptr(location, x);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform2d]</b>  </summary>
            public static void Uniform2d(int location, double x, double y) => GLPointers._glUniform2d_fnptr(location, x, y);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform3d]</b>  </summary>
            public static void Uniform3d(int location, double x, double y, double z) => GLPointers._glUniform3d_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform4d]</b>  </summary>
            public static void Uniform4d(int location, double x, double y, double z, double w) => GLPointers._glUniform4d_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform1dv]</b>  </summary>
            public static void Uniform1dv(int location, int count, double* value) => GLPointers._glUniform1dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform2dv]</b>  </summary>
            public static void Uniform2dv(int location, int count, double* value) => GLPointers._glUniform2dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform3dv]</b>  </summary>
            public static void Uniform3dv(int location, int count, double* value) => GLPointers._glUniform3dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniform4dv]</b>  </summary>
            public static void Uniform4dv(int location, int count, double* value) => GLPointers._glUniform4dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix2dv]</b>  </summary>
            public static void UniformMatrix2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix3dv]</b>  </summary>
            public static void UniformMatrix3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix4dv]</b>  </summary>
            public static void UniformMatrix4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix2x3dv]</b>  </summary>
            public static void UniformMatrix2x3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix2x4dv]</b>  </summary>
            public static void UniformMatrix2x4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix3x2dv]</b>  </summary>
            public static void UniformMatrix3x2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix3x4dv]</b>  </summary>
            public static void UniformMatrix3x4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix4x2dv]</b>  </summary>
            public static void UniformMatrix4x2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glUniformMatrix4x3dv]</b>  </summary>
            public static void UniformMatrix4x3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64] [glGetUniformdv]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetUniformdv(int program, int location, double* parameters) => GLPointers._glGetUniformdv_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform1i64ARB]</b>  </summary>
            public static void Uniform1i64(int location, long x) => GLPointers._glUniform1i64ARB_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform2i64ARB]</b>  </summary>
            public static void Uniform2i64(int location, long x, long y) => GLPointers._glUniform2i64ARB_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform3i64ARB]</b>  </summary>
            public static void Uniform3i64(int location, long x, long y, long z) => GLPointers._glUniform3i64ARB_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform4i64ARB]</b>  </summary>
            public static void Uniform4i64(int location, long x, long y, long z, long w) => GLPointers._glUniform4i64ARB_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform1i64vARB]</b>  </summary>
            public static void Uniform1i64v(int location, int count, long* value) => GLPointers._glUniform1i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform2i64vARB]</b>  </summary>
            public static void Uniform2i64v(int location, int count, long* value) => GLPointers._glUniform2i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform3i64vARB]</b>  </summary>
            public static void Uniform3i64v(int location, int count, long* value) => GLPointers._glUniform3i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform4i64vARB]</b>  </summary>
            public static void Uniform4i64v(int location, int count, long* value) => GLPointers._glUniform4i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform1ui64ARB]</b>  </summary>
            public static void Uniform1ui64(int location, ulong x) => GLPointers._glUniform1ui64ARB_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform2ui64ARB]</b>  </summary>
            public static void Uniform2ui64(int location, ulong x, ulong y) => GLPointers._glUniform2ui64ARB_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform3ui64ARB]</b>  </summary>
            public static void Uniform3ui64(int location, ulong x, ulong y, ulong z) => GLPointers._glUniform3ui64ARB_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform4ui64ARB]</b>  </summary>
            public static void Uniform4ui64(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glUniform4ui64ARB_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform1ui64vARB]</b>  </summary>
            public static void Uniform1ui64v(int location, int count, ulong* value) => GLPointers._glUniform1ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform2ui64vARB]</b>  </summary>
            public static void Uniform2ui64v(int location, int count, ulong* value) => GLPointers._glUniform2ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform3ui64vARB]</b>  </summary>
            public static void Uniform3ui64v(int location, int count, ulong* value) => GLPointers._glUniform3ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glUniform4ui64vARB]</b>  </summary>
            public static void Uniform4ui64v(int location, int count, ulong* value) => GLPointers._glUniform4ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glGetUniformi64vARB]</b>  </summary>
            public static void GetUniformi64v(int program, int location, long* parameters) => GLPointers._glGetUniformi64vARB_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glGetUniformui64vARB]</b>  </summary>
            public static void GetUniformui64v(int program, int location, ulong* parameters) => GLPointers._glGetUniformui64vARB_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glGetnUniformi64vARB]</b>  </summary>
            public static void GetnUniformi64v(int program, int location, int bufSize, long* parameters) => GLPointers._glGetnUniformi64vARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glGetnUniformui64vARB]</b>  </summary>
            public static void GetnUniformui64v(int program, int location, int bufSize, ulong* parameters) => GLPointers._glGetnUniformui64vARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform1i64ARB]</b>  </summary>
            public static void ProgramUniform1i64(int program, int location, long x) => GLPointers._glProgramUniform1i64ARB_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform2i64ARB]</b>  </summary>
            public static void ProgramUniform2i64(int program, int location, long x, long y) => GLPointers._glProgramUniform2i64ARB_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform3i64ARB]</b>  </summary>
            public static void ProgramUniform3i64(int program, int location, long x, long y, long z) => GLPointers._glProgramUniform3i64ARB_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform4i64ARB]</b>  </summary>
            public static void ProgramUniform4i64(int program, int location, long x, long y, long z, long w) => GLPointers._glProgramUniform4i64ARB_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform1i64vARB]</b>  </summary>
            public static void ProgramUniform1i64v(int program, int location, int count, long* value) => GLPointers._glProgramUniform1i64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform2i64vARB]</b>  </summary>
            public static void ProgramUniform2i64v(int program, int location, int count, long* value) => GLPointers._glProgramUniform2i64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform3i64vARB]</b>  </summary>
            public static void ProgramUniform3i64v(int program, int location, int count, long* value) => GLPointers._glProgramUniform3i64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform4i64vARB]</b>  </summary>
            public static void ProgramUniform4i64v(int program, int location, int count, long* value) => GLPointers._glProgramUniform4i64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform1ui64ARB]</b>  </summary>
            public static void ProgramUniform1ui64(int program, int location, ulong x) => GLPointers._glProgramUniform1ui64ARB_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform2ui64ARB]</b>  </summary>
            public static void ProgramUniform2ui64(int program, int location, ulong x, ulong y) => GLPointers._glProgramUniform2ui64ARB_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform3ui64ARB]</b>  </summary>
            public static void ProgramUniform3ui64(int program, int location, ulong x, ulong y, ulong z) => GLPointers._glProgramUniform3ui64ARB_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform4ui64ARB]</b>  </summary>
            public static void ProgramUniform4ui64(int program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glProgramUniform4ui64ARB_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform1ui64vARB]</b>  </summary>
            public static void ProgramUniform1ui64v(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform1ui64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform2ui64vARB]</b>  </summary>
            public static void ProgramUniform2ui64v(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform2ui64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform3ui64vARB]</b>  </summary>
            public static void ProgramUniform3ui64v(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform3ui64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64] [glProgramUniform4ui64vARB]</b>  </summary>
            public static void ProgramUniform4ui64v(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform4ui64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging] [glBlendColor]</b> Set the blend color. </summary>
            /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml" /></remarks>
            public static void BlendColor(float red, float green, float blue, float alpha) => GLPointers._glBlendColor_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging] [glBlendEquation]</b> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
            /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
            public static void BlendEquation(BlendEquationModeEXT mode) => GLPointers._glBlendEquation_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glColorTable]</b> Define a color lookup table. </summary>
            /// <param name="target"> Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="internalformat"> The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16. </param>
            /// <param name="width"> The number of entries in the color lookup table specified by data. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA. </param>
            /// <param name="type"> The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="data"> Pointer to a one-dimensional array of pixel data that is processed to build the color table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorTable.xml" /></remarks>
            public static void ColorTable(ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table) => GLPointers._glColorTable_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glColorTableParameterfv]</b> Set color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorTableParameter.xml" /></remarks>
            public static void ColorTableParameterfv(ColorTableTarget target, ColorTableParameterPName pname, float* parameters) => GLPointers._glColorTableParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glColorTableParameteriv]</b> Set color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorTableParameter.xml" /></remarks>
            public static void ColorTableParameteriv(ColorTableTarget target, ColorTableParameterPName pname, int* parameters) => GLPointers._glColorTableParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glCopyColorTable]</b> Copy pixels into a color table. </summary>
            /// <param name="target"> The color table target. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="internalformat"> The internal storage format of the texture image. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="x"> The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table. </param>
            /// <param name="y"> The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table. </param>
            /// <param name="width"> The width of the pixel rectangle. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyColorTable.xml" /></remarks>
            public static void CopyColorTable(ColorTableTarget target, InternalFormat internalformat, int x, int y, int width) => GLPointers._glCopyColorTable_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetColorTable]</b> Retrieve contents of a color lookup table. </summary>
            /// <param name="target"> Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="format"> The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA. </param>
            /// <param name="type"> The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="table"> Pointer to a one-dimensional array of pixel data containing the contents of the color table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetColorTable.xml" /></remarks>
            public static void GetColorTable(ColorTableTarget target, PixelFormat format, PixelType type, void* table) => GLPointers._glGetColorTable_fnptr((uint)target, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetColorTableParameterfv]</b> Get color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameter will be stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetColorTableParameter.xml" /></remarks>
            public static void GetColorTableParameterfv(ColorTableTarget target, ColorTableParameterPName pname, float* parameters) => GLPointers._glGetColorTableParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetColorTableParameteriv]</b> Get color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameter will be stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetColorTableParameter.xml" /></remarks>
            public static void GetColorTableParameteriv(ColorTableTarget target, ColorTableParameterPName pname, int* parameters) => GLPointers._glGetColorTableParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glColorSubTable]</b> Respecify a portion of a color table. </summary>
            /// <param name="target"> Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="start"> The starting index of the portion of the color table to be replaced. </param>
            /// <param name="count"> The number of table entries to replace. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA. </param>
            /// <param name="type"> The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="data"> Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorSubTable.xml" /></remarks>
            public static void ColorSubTable(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data) => GLPointers._glColorSubTable_fnptr((uint)target, start, count, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glCopyColorSubTable]</b> Respecify a portion of a color table. </summary>
            /// <param name="target"> Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="start"> The starting index of the portion of the color table to be replaced. </param>
            /// <param name="x"> The window coordinates of the left corner of the row of pixels to be copied. </param>
            /// <param name="y"> The window coordinates of the left corner of the row of pixels to be copied. </param>
            /// <param name="width"> The number of table entries to replace. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyColorSubTable.xml" /></remarks>
            public static void CopyColorSubTable(ColorTableTarget target, int start, int x, int y, int width) => GLPointers._glCopyColorSubTable_fnptr((uint)target, start, x, y, width);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glConvolutionFilter1D]</b> Define a one-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_1D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="width"> The width of the pixel array referenced by data. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA. </param>
            /// <param name="type"> The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="data"> Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionFilter1D.xml" /></remarks>
            public static void ConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image) => GLPointers._glConvolutionFilter1D_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glConvolutionFilter2D]</b> Define a two-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_2D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="width"> The width of the pixel array referenced by data. </param>
            /// <param name="height"> The height of the pixel array referenced by data. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="data"> Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionFilter2D.xml" /></remarks>
            public static void ConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image) => GLPointers._glConvolutionFilter2D_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glConvolutionParameterf]</b> Set convolution parameters. </summary>
            /// <param name="target"> The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE. </param>
            /// <param name="parameters"> The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionParameter.xml" /></remarks>
            public static void ConvolutionParameterf(ConvolutionTarget target, ConvolutionParameter pname, float parameters) => GLPointers._glConvolutionParameterf_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glConvolutionParameterfv]</b>  </summary>
            public static void ConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameter pname, float* parameters) => GLPointers._glConvolutionParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glConvolutionParameteri]</b> Set convolution parameters. </summary>
            /// <param name="target"> The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE. </param>
            /// <param name="parameters"> The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionParameter.xml" /></remarks>
            public static void ConvolutionParameteri(ConvolutionTarget target, ConvolutionParameter pname, int parameters) => GLPointers._glConvolutionParameteri_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glConvolutionParameteriv]</b>  </summary>
            public static void ConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameter pname, int* parameters) => GLPointers._glConvolutionParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glCopyConvolutionFilter1D]</b> Copy pixels into a one-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_1D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="x"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="y"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="width"> The width of the pixel array to copy. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyConvolutionFilter1D.xml" /></remarks>
            public static void CopyConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width) => GLPointers._glCopyConvolutionFilter1D_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glCopyConvolutionFilter2D]</b> Copy pixels into a two-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_2D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="x"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="y"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="width"> The width of the pixel array to copy. </param>
            /// <param name="height"> The height of the pixel array to copy. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyConvolutionFilter2D.xml" /></remarks>
            public static void CopyConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width, int height) => GLPointers._glCopyConvolutionFilter2D_fnptr((uint)target, (uint)internalformat, x, y, width, height);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetConvolutionFilter]</b> Get current 1D or 2D convolution filter kernel. </summary>
            /// <param name="target"> The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D. </param>
            /// <param name="format"> Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="image"> Pointer to storage for the output image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetConvolutionFilter.xml" /></remarks>
            public static void GetConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, void* image) => GLPointers._glGetConvolutionFilter_fnptr((uint)target, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetConvolutionParameterfv]</b> Get convolution parameters. </summary>
            /// <param name="target"> The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT. </param>
            /// <param name="parameters"> Pointer to storage for the parameters to be retrieved. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetConvolutionParameter.xml" /></remarks>
            public static void GetConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameter pname, float* parameters) => GLPointers._glGetConvolutionParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetConvolutionParameteriv]</b> Get convolution parameters. </summary>
            /// <param name="target"> The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT. </param>
            /// <param name="parameters"> Pointer to storage for the parameters to be retrieved. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetConvolutionParameter.xml" /></remarks>
            public static void GetConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameter pname, int* parameters) => GLPointers._glGetConvolutionParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetSeparableFilter]</b> Get separable convolution filter kernel images. </summary>
            /// <param name="target"> The separable filter to be retrieved. Must be GL_SEPARABLE_2D. </param>
            /// <param name="format"> Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="row"> Pointer to storage for the row filter image. </param>
            /// <param name="column"> Pointer to storage for the column filter image. </param>
            /// <param name="span"> Pointer to storage for the span filter image (currently unused). </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetSeparableFilter.xml" /></remarks>
            public static void GetSeparableFilter(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span) => GLPointers._glGetSeparableFilter_fnptr((uint)target, (uint)format, (uint)type, row, column, span);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glSeparableFilter2D]</b> Define a separable two-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_SEPARABLE_2D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="width"> The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.) </param>
            /// <param name="height"> The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.) </param>
            /// <param name="format"> The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="row"> Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel. </param>
            /// <param name="column"> Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSeparableFilter2D.xml" /></remarks>
            public static void SeparableFilter2D(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column) => GLPointers._glSeparableFilter2D_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, row, column);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetHistogram]</b> Get histogram table. </summary>
            /// <param name="target"> Must be GL_HISTOGRAM. </param>
            /// <param name="reset"> If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified. </param>
            /// <param name="format"> The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="values"> A pointer to storage for the returned histogram table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetHistogram.xml" /></remarks>
            public static void GetHistogram(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._glGetHistogram_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetHistogramParameterfv]</b> Get histogram parameters. </summary>
            /// <param name="target"> Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM. </param>
            /// <param name="pname"> The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK. </param>
            /// <param name="parameters"> Pointer to storage for the returned values. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetHistogramParameter.xml" /></remarks>
            public static void GetHistogramParameterfv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters) => GLPointers._glGetHistogramParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetHistogramParameteriv]</b> Get histogram parameters. </summary>
            /// <param name="target"> Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM. </param>
            /// <param name="pname"> The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK. </param>
            /// <param name="parameters"> Pointer to storage for the returned values. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetHistogramParameter.xml" /></remarks>
            public static void GetHistogramParameteriv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers._glGetHistogramParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetMinmax]</b> Get minimum and maximum pixel values. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <param name="reset"> If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered. </param>
            /// <param name="format"> The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="types"> The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="values"> A pointer to storage for the returned values. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMinmax.xml" /></remarks>
            public static void GetMinmax(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._glGetMinmax_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetMinmaxParameterfv]</b> Get minmax parameters. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK. </param>
            /// <param name="parameters"> A pointer to storage for the retrieved parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMinmaxParameter.xml" /></remarks>
            public static void GetMinmaxParameterfv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters) => GLPointers._glGetMinmaxParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glGetMinmaxParameteriv]</b> Get minmax parameters. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK. </param>
            /// <param name="parameters"> A pointer to storage for the retrieved parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMinmaxParameter.xml" /></remarks>
            public static void GetMinmaxParameteriv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters) => GLPointers._glGetMinmaxParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glHistogram]</b> Define histogram table. </summary>
            /// <param name="target"> The histogram whose parameters are to be set. Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM. </param>
            /// <param name="width"> The number of entries in the histogram table. Must be a power of 2. </param>
            /// <param name="internalformat"> The format of entries in the histogram table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="sink"> If GL_TRUE, pixels will be consumed by the histogramming process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the minmax process after histogramming. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glHistogram.xml" /></remarks>
            public static void Histogram(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink) => GLPointers._glHistogram_fnptr((uint)target, width, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glMinmax]</b> Define minmax table. </summary>
            /// <param name="target"> The minmax table whose parameters are to be set. Must be GL_MINMAX. </param>
            /// <param name="internalformat"> The format of entries in the minmax table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="sink"> If GL_TRUE, pixels will be consumed by the minmax process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the final conversion process after minmax. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMinmax.xml" /></remarks>
            public static void Minmax(MinmaxTargetEXT target, InternalFormat internalformat, bool sink) => GLPointers._glMinmax_fnptr((uint)target, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glResetHistogram]</b> Reset histogram table entries to zero. </summary>
            /// <param name="target"> Must be GL_HISTOGRAM. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glResetHistogram.xml" /></remarks>
            public static void ResetHistogram(HistogramTargetEXT target) => GLPointers._glResetHistogram_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_ARB_imaging] [glResetMinmax]</b> Reset minmax table entries to initial values. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glResetMinmax.xml" /></remarks>
            public static void ResetMinmax(MinmaxTargetEXT target) => GLPointers._glResetMinmax_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_ARB_indirect_parameters] [glMultiDrawArraysIndirectCountARB]</b>  </summary>
            public static void MultiDrawArraysIndirectCount(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawArraysIndirectCountARB_fnptr((uint)mode, indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_indirect_parameters] [glMultiDrawElementsIndirectCountARB]</b>  </summary>
            public static void MultiDrawElementsIndirectCount(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawElementsIndirectCountARB_fnptr((uint)mode, (uint)type, indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_instanced_arrays] [glVertexAttribDivisorARB]</b>  </summary>
            public static void VertexAttribDivisor(uint index, uint divisor) => GLPointers._glVertexAttribDivisorARB_fnptr(index, divisor);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query] [glGetInternalformativ]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
            public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => GLPointers._glGetInternalformativ_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2] [glGetInternalformati64v]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
            public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => GLPointers._glGetInternalformati64v_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateTexSubImage]</b> Invalidate a region of a texture image. </summary>
            /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
            /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
            /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
            /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
            /// <param name="width"> The width of the region to be invalidated. </param>
            /// <param name="height"> The height of the region to be invalidated. </param>
            /// <param name="depth"> The depth of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml" /></remarks>
            public static void InvalidateTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => GLPointers._glInvalidateTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateTexImage]</b> Invalidate the entirety a texture image. </summary>
            /// <param name="texture"> The name of a texture object to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml" /></remarks>
            public static void InvalidateTexImage(int texture, int level) => GLPointers._glInvalidateTexImage_fnptr(texture, level);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateBufferSubData]</b> Invalidate a region of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
            /// <param name="offset"> The offset within the buffer&apos;s data store of the start of the range to be invalidated. </param>
            /// <param name="length"> The length of the range within the buffer&apos;s data store to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml" /></remarks>
            public static void InvalidateBufferSubData(int buffer, IntPtr offset, nint length) => GLPointers._glInvalidateBufferSubData_fnptr(buffer, offset, length);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateBufferData]</b> Invalidate the content of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml" /></remarks>
            public static void InvalidateBufferData(int buffer) => GLPointers._glInvalidateBufferData_fnptr(buffer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateFramebuffer]</b> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
            public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => GLPointers._glInvalidateFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata] [glInvalidateSubFramebuffer]</b> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
            public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._glInvalidateSubFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments, x, y, width, height);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range] [glMapBufferRange]</b> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
            public static void* MapBufferRange(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapBufferRange_fnptr((uint)target, offset, length, (uint)access);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range] [glFlushMappedBufferRange]</b> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
            public static void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, nint length) => GLPointers._glFlushMappedBufferRange_fnptr((uint)target, offset, length);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette] [glCurrentPaletteMatrixARB]</b>  </summary>
            public static void CurrentPaletteMatrix(int index) => GLPointers._glCurrentPaletteMatrixARB_fnptr(index);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette] [glMatrixIndexubvARB]</b>  </summary>
            public static void MatrixIndexubv(int size, byte* indices) => GLPointers._glMatrixIndexubvARB_fnptr(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette] [glMatrixIndexusvARB]</b>  </summary>
            public static void MatrixIndexusv(int size, ushort* indices) => GLPointers._glMatrixIndexusvARB_fnptr(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette] [glMatrixIndexuivARB]</b>  </summary>
            public static void MatrixIndexuiv(int size, uint* indices) => GLPointers._glMatrixIndexuivARB_fnptr(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette] [glMatrixIndexPointerARB]</b>  </summary>
            public static void MatrixIndexPointer(int size, MatrixIndexPointerTypeARB type, int stride, void* pointer) => GLPointers._glMatrixIndexPointerARB_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindBuffersBase]</b> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml" /></remarks>
            public static void BindBuffersBase(BufferTargetARB target, uint first, int count, int* buffers) => GLPointers._glBindBuffersBase_fnptr((uint)target, first, count, buffers);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindBuffersRange]</b> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml" /></remarks>
            public static void BindBuffersRange(BufferTargetARB target, uint first, int count, int* buffers, IntPtr* offsets, nint* sizes) => GLPointers._glBindBuffersRange_fnptr((uint)target, first, count, buffers, offsets, sizes);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindTextures]</b> Bind one or more named textures to a sequence of consecutive texture units. </summary>
            /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml" /></remarks>
            public static void BindTextures(uint first, int count, int* textures) => GLPointers._glBindTextures_fnptr(first, count, textures);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindSamplers]</b> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
            /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
            /// <param name="count"> Specifies the number of samplers to bind. </param>
            /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml" /></remarks>
            public static void BindSamplers(uint first, int count, int* samplers) => GLPointers._glBindSamplers_fnptr(first, count, samplers);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindImageTextures]</b> Bind one or more named texture images to a sequence of consecutive image units. </summary>
            /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml" /></remarks>
            public static void BindImageTextures(uint first, int count, int* textures) => GLPointers._glBindImageTextures_fnptr(first, count, textures);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind] [glBindVertexBuffers]</b> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
            public static void BindVertexBuffers(uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers._glBindVertexBuffers_fnptr(first, count, buffers, offsets, strides);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect] [glMultiDrawArraysIndirect]</b> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml" /></remarks>
            public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => GLPointers._glMultiDrawArraysIndirect_fnptr((uint)mode, indirect, drawcount, stride);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect] [glMultiDrawElementsIndirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml" /></remarks>
            public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => GLPointers._glMultiDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_multisample] [glSampleCoverageARB]</b>  </summary>
            public static void SampleCoverage(float value, bool invert) => GLPointers._glSampleCoverageARB_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glActiveTextureARB]</b>  </summary>
            public static void ActiveTexture(TextureUnit texture) => GLPointers._glActiveTextureARB_fnptr((uint)texture);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glClientActiveTextureARB]</b>  </summary>
            public static void ClientActiveTexture(TextureUnit texture) => GLPointers._glClientActiveTextureARB_fnptr((uint)texture);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord1dARB]</b>  </summary>
            public static void MultiTexCoord1d(TextureUnit target, double s) => GLPointers._glMultiTexCoord1dARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord1dvARB]</b>  </summary>
            public static void MultiTexCoord1dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord1dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord1fARB]</b>  </summary>
            public static void MultiTexCoord1f(TextureUnit target, float s) => GLPointers._glMultiTexCoord1fARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord1fvARB]</b>  </summary>
            public static void MultiTexCoord1fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord1fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord1iARB]</b>  </summary>
            public static void MultiTexCoord1i(TextureUnit target, int s) => GLPointers._glMultiTexCoord1iARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord1ivARB]</b>  </summary>
            public static void MultiTexCoord1iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord1ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord1sARB]</b>  </summary>
            public static void MultiTexCoord1s(TextureUnit target, short s) => GLPointers._glMultiTexCoord1sARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord1svARB]</b>  </summary>
            public static void MultiTexCoord1sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord1svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord2dARB]</b>  </summary>
            public static void MultiTexCoord2d(TextureUnit target, double s, double t) => GLPointers._glMultiTexCoord2dARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord2dvARB]</b>  </summary>
            public static void MultiTexCoord2dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord2dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord2fARB]</b>  </summary>
            public static void MultiTexCoord2f(TextureUnit target, float s, float t) => GLPointers._glMultiTexCoord2fARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord2fvARB]</b>  </summary>
            public static void MultiTexCoord2fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord2fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord2iARB]</b>  </summary>
            public static void MultiTexCoord2i(TextureUnit target, int s, int t) => GLPointers._glMultiTexCoord2iARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord2ivARB]</b>  </summary>
            public static void MultiTexCoord2iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord2ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord2sARB]</b>  </summary>
            public static void MultiTexCoord2s(TextureUnit target, short s, short t) => GLPointers._glMultiTexCoord2sARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord2svARB]</b>  </summary>
            public static void MultiTexCoord2sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord2svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord3dARB]</b>  </summary>
            public static void MultiTexCoord3d(TextureUnit target, double s, double t, double r) => GLPointers._glMultiTexCoord3dARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord3dvARB]</b>  </summary>
            public static void MultiTexCoord3dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord3dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord3fARB]</b>  </summary>
            public static void MultiTexCoord3f(TextureUnit target, float s, float t, float r) => GLPointers._glMultiTexCoord3fARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord3fvARB]</b>  </summary>
            public static void MultiTexCoord3fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord3fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord3iARB]</b>  </summary>
            public static void MultiTexCoord3i(TextureUnit target, int s, int t, int r) => GLPointers._glMultiTexCoord3iARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord3ivARB]</b>  </summary>
            public static void MultiTexCoord3iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord3ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord3sARB]</b>  </summary>
            public static void MultiTexCoord3s(TextureUnit target, short s, short t, short r) => GLPointers._glMultiTexCoord3sARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord3svARB]</b>  </summary>
            public static void MultiTexCoord3sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord3svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord4dARB]</b>  </summary>
            public static void MultiTexCoord4d(TextureUnit target, double s, double t, double r, double q) => GLPointers._glMultiTexCoord4dARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord4dvARB]</b>  </summary>
            public static void MultiTexCoord4dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord4dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord4fARB]</b>  </summary>
            public static void MultiTexCoord4f(TextureUnit target, float s, float t, float r, float q) => GLPointers._glMultiTexCoord4fARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord4fvARB]</b>  </summary>
            public static void MultiTexCoord4fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord4fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord4iARB]</b>  </summary>
            public static void MultiTexCoord4i(TextureUnit target, int s, int t, int r, int q) => GLPointers._glMultiTexCoord4iARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord4ivARB]</b>  </summary>
            public static void MultiTexCoord4iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord4ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord4sARB]</b>  </summary>
            public static void MultiTexCoord4s(TextureUnit target, short s, short t, short r, short q) => GLPointers._glMultiTexCoord4sARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture] [glMultiTexCoord4svARB]</b>  </summary>
            public static void MultiTexCoord4sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord4svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query] [glGenQueriesARB]</b>  </summary>
            public static void GenQueries(int n, int* ids) => GLPointers._glGenQueriesARB_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query] [glDeleteQueriesARB]</b>  </summary>
            public static void DeleteQueries(int n, int* ids) => GLPointers._glDeleteQueriesARB_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query] [glIsQueryARB]</b>  </summary>
            public static bool IsQuery(int id) => GLPointers._glIsQueryARB_fnptr(id) != 0;
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query] [glBeginQueryARB]</b>  </summary>
            public static void BeginQuery(QueryTarget target, int id) => GLPointers._glBeginQueryARB_fnptr((uint)target, id);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query] [glEndQueryARB]</b>  </summary>
            public static void EndQuery(QueryTarget target) => GLPointers._glEndQueryARB_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query] [glGetQueryivARB]</b>  </summary>
            public static void GetQueryiv(QueryTarget target, QueryParameterName pname, int* parameters) => GLPointers._glGetQueryivARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query] [glGetQueryObjectivARB]</b>  </summary>
            public static void GetQueryObjectiv(int id, QueryObjectParameterName pname, int* parameters) => GLPointers._glGetQueryObjectivARB_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query] [glGetQueryObjectuivARB]</b>  </summary>
            public static void GetQueryObjectuiv(int id, QueryObjectParameterName pname, uint* parameters) => GLPointers._glGetQueryObjectuivARB_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_parallel_shader_compile] [glMaxShaderCompilerThreadsARB]</b>  </summary>
            public static void MaxShaderCompilerThreads(uint count) => GLPointers._glMaxShaderCompilerThreadsARB_fnptr(count);
            
            /// <summary> <b>[requires: GL_ARB_point_parameters] [glPointParameterfARB]</b>  </summary>
            public static void PointParameterf(PointParameterNameARB pname, float param) => GLPointers._glPointParameterfARB_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ARB_point_parameters] [glPointParameterfvARB]</b>  </summary>
            public static void PointParameterfv(PointParameterNameARB pname, float* parameters) => GLPointers._glPointParameterfvARB_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp] [glPolygonOffsetClamp]</b>  </summary>
            public static void PolygonOffsetClamp(float factor, float units, float clamp) => GLPointers._glPolygonOffsetClamp_fnptr(factor, units, clamp);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramInterfaceiv]</b> Query a property of an interface in a program. </summary>
            /// <param name="program"> The name of a program object whose interface to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program to query. </param>
            /// <param name="pname"> The name of the parameter within programInterface to query. </param>
            /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml" /></remarks>
            public static void GetProgramInterfaceiv(int program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => GLPointers._glGetProgramInterfaceiv_fnptr(program, (uint)programInterface, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceIndex]</b> Query the index of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the index of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml" /></remarks>
            public static uint GetProgramResourceIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceIndex_fnptr(program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceName]</b> Query the name of an indexed resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
            /// <param name="index"> The index of the resource within programInterface of program. </param>
            /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
            /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
            /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml" /></remarks>
            public static void GetProgramResourceName(int program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetProgramResourceName_fnptr(program, (uint)programInterface, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceiv]</b> Retrieve values for multiple properties of a single active resource within a program object. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="index">!!missing documentation!!</param>
            /// <param name="propCount">!!missing documentation!!</param>
            /// <param name="props">!!missing documentation!!</param>
            /// <param name="bufSize">!!missing documentation!!</param>
            /// <param name="length">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml" /></remarks>
            public static void GetProgramResourceiv(int program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => GLPointers._glGetProgramResourceiv_fnptr(program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceLocation]</b> Query the location of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml" /></remarks>
            public static int GetProgramResourceLocation(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceLocation_fnptr(program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query] [glGetProgramResourceLocationIndex]</b> Query the fragment color index of a named variable within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml" /></remarks>
            public static int GetProgramResourceLocationIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceLocationIndex_fnptr(program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex] [glProvokingVertex]</b> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
            /// <param name="provokeMode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml" /></remarks>
            public static void ProvokingVertex(VertexProvokingMode mode) => GLPointers._glProvokingVertex_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetGraphicsResetStatusARB]</b>  </summary>
            public static GraphicsResetStatus GetGraphicsResetStatus() => (GraphicsResetStatus) GLPointers._glGetGraphicsResetStatusARB_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnTexImageARB]</b>  </summary>
            public static void GetnTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* img) => GLPointers._glGetnTexImageARB_fnptr((uint)target, level, (uint)format, (uint)type, bufSize, img);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glReadnPixelsARB]</b>  </summary>
            public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._glReadnPixelsARB_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnCompressedTexImageARB]</b>  </summary>
            public static void GetnCompressedTexImage(TextureTarget target, int lod, int bufSize, void* img) => GLPointers._glGetnCompressedTexImageARB_fnptr((uint)target, lod, bufSize, img);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnUniformfvARB]</b>  </summary>
            public static void GetnUniformfv(int program, int location, int bufSize, float* parameters) => GLPointers._glGetnUniformfvARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnUniformivARB]</b>  </summary>
            public static void GetnUniformiv(int program, int location, int bufSize, int* parameters) => GLPointers._glGetnUniformivARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnUniformuivARB]</b>  </summary>
            public static void GetnUniformuiv(int program, int location, int bufSize, uint* parameters) => GLPointers._glGetnUniformuivARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnUniformdvARB]</b>  </summary>
            public static void GetnUniformdv(int program, int location, int bufSize, double* parameters) => GLPointers._glGetnUniformdvARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnMapdvARB]</b>  </summary>
            public static void GetnMapdv(MapTarget target, MapQuery query, int bufSize, double* v) => GLPointers._glGetnMapdvARB_fnptr((uint)target, (uint)query, bufSize, v);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnMapfvARB]</b>  </summary>
            public static void GetnMapfv(MapTarget target, MapQuery query, int bufSize, float* v) => GLPointers._glGetnMapfvARB_fnptr((uint)target, (uint)query, bufSize, v);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnMapivARB]</b>  </summary>
            public static void GetnMapiv(MapTarget target, MapQuery query, int bufSize, int* v) => GLPointers._glGetnMapivARB_fnptr((uint)target, (uint)query, bufSize, v);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnPixelMapfvARB]</b>  </summary>
            public static void GetnPixelMapfv(PixelMap map, int bufSize, float* values) => GLPointers._glGetnPixelMapfvARB_fnptr((uint)map, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnPixelMapuivARB]</b>  </summary>
            public static void GetnPixelMapuiv(PixelMap map, int bufSize, uint* values) => GLPointers._glGetnPixelMapuivARB_fnptr((uint)map, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnPixelMapusvARB]</b>  </summary>
            public static void GetnPixelMapusv(PixelMap map, int bufSize, ushort* values) => GLPointers._glGetnPixelMapusvARB_fnptr((uint)map, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnPolygonStippleARB]</b>  </summary>
            public static void GetnPolygonStipple(int bufSize, byte* pattern) => GLPointers._glGetnPolygonStippleARB_fnptr(bufSize, pattern);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnColorTableARB]</b>  </summary>
            public static void GetnColorTable(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, void* table) => GLPointers._glGetnColorTableARB_fnptr((uint)target, (uint)format, (uint)type, bufSize, table);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnConvolutionFilterARB]</b>  </summary>
            public static void GetnConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, void* image) => GLPointers._glGetnConvolutionFilterARB_fnptr((uint)target, (uint)format, (uint)type, bufSize, image);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnSeparableFilterARB]</b>  </summary>
            public static void GetnSeparableFilter(SeparableTargetEXT target, PixelFormat format, PixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span) => GLPointers._glGetnSeparableFilterARB_fnptr((uint)target, (uint)format, (uint)type, rowBufSize, row, columnBufSize, column, span);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnHistogramARB]</b>  </summary>
            public static void GetnHistogram(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers._glGetnHistogramARB_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness] [glGetnMinmaxARB]</b>  </summary>
            public static void GetnMinmax(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers._glGetnMinmaxARB_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations] [glFramebufferSampleLocationsfvARB]</b>  </summary>
            public static void FramebufferSampleLocationsfv(FramebufferTarget target, uint start, int count, float* v) => GLPointers._glFramebufferSampleLocationsfvARB_fnptr((uint)target, start, count, v);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations] [glNamedFramebufferSampleLocationsfvARB]</b>  </summary>
            public static void NamedFramebufferSampleLocationsfv(int framebuffer, uint start, int count, float* v) => GLPointers._glNamedFramebufferSampleLocationsfvARB_fnptr(framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations] [glEvaluateDepthValuesARB]</b>  </summary>
            public static void EvaluateDepthValues() => GLPointers._glEvaluateDepthValuesARB_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_sample_shading] [glMinSampleShadingARB]</b>  </summary>
            public static void MinSampleShading(float value) => GLPointers._glMinSampleShadingARB_fnptr(value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGenSamplers]</b> Generate sampler object names. </summary>
            /// <param name="n"> Specifies the number of sampler object names to generate. </param>
            /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml" /></remarks>
            public static void GenSamplers(int count, int* samplers) => GLPointers._glGenSamplers_fnptr(count, samplers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glDeleteSamplers]</b> Delete named sampler objects. </summary>
            /// <param name="n"> Specifies the number of sampler objects to be deleted. </param>
            /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml" /></remarks>
            public static void DeleteSamplers(int count, int* samplers) => GLPointers._glDeleteSamplers_fnptr(count, samplers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glIsSampler]</b> Determine if a name corresponds to a sampler object. </summary>
            /// <param name="id"> Specifies a value that may be the name of a sampler object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml" /></remarks>
            public static bool IsSampler(int sampler) => GLPointers._glIsSampler_fnptr(sampler) != 0;
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glBindSampler]</b> Bind a named sampler to a texturing target. </summary>
            /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
            /// <param name="sampler"> Specifies the name of a sampler. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml" /></remarks>
            public static void BindSampler(uint unit, int sampler) => GLPointers._glBindSampler_fnptr(unit, sampler);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameteri]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameteri(int sampler, SamplerParameterI pname, int param) => GLPointers._glSamplerParameteri_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameteriv]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameteriv(int sampler, SamplerParameterI pname, int* param) => GLPointers._glSamplerParameteriv_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameterf]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterf(int sampler, SamplerParameterF pname, float param) => GLPointers._glSamplerParameterf_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameterfv]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterfv(int sampler, SamplerParameterF pname, float* param) => GLPointers._glSamplerParameterfv_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameterIiv]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterIiv(int sampler, SamplerParameterI pname, int* param) => GLPointers._glSamplerParameterIiv_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glSamplerParameterIuiv]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* param) => GLPointers._glSamplerParameterIuiv_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGetSamplerParameteriv]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameteriv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers._glGetSamplerParameteriv_fnptr(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGetSamplerParameterIiv]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterIiv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers._glGetSamplerParameterIiv_fnptr(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGetSamplerParameterfv]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterfv(int sampler, SamplerParameterF pname, float* parameters) => GLPointers._glGetSamplerParameterfv_fnptr(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects] [glGetSamplerParameterIuiv]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* parameters) => GLPointers._glGetSamplerParameterIuiv_fnptr(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glUseProgramStages]</b> Bind stages of a program object to a program pipeline. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
            /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
            /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml" /></remarks>
            public static void UseProgramStages(int pipeline, UseProgramStageMask stages, int program) => GLPointers._glUseProgramStages_fnptr(pipeline, (uint)stages, program);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glActiveShaderProgram]</b> Set the active program object for a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
            /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml" /></remarks>
            public static void ActiveShaderProgram(int pipeline, int program) => GLPointers._glActiveShaderProgram_fnptr(pipeline, program);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glCreateShaderProgramv]</b> Create a stand-alone program from an array of null-terminated source code strings. </summary>
            /// <param name="type"> Specifies the type of shader to create. </param>
            /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
            /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml" /></remarks>
            public static int CreateShaderProgramv(ShaderType type, int count, byte** strings) => GLPointers._glCreateShaderProgramv_fnptr((uint)type, count, strings);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glBindProgramPipeline]</b> Bind a program pipeline to the current context. </summary>
            /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml" /></remarks>
            public static void BindProgramPipeline(int pipeline) => GLPointers._glBindProgramPipeline_fnptr(pipeline);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glDeleteProgramPipelines]</b> Delete program pipeline objects. </summary>
            /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
            /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml" /></remarks>
            public static void DeleteProgramPipelines(int n, int* pipelines) => GLPointers._glDeleteProgramPipelines_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glGenProgramPipelines]</b> Reserve program pipeline object names. </summary>
            /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
            /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml" /></remarks>
            public static void GenProgramPipelines(int n, int* pipelines) => GLPointers._glGenProgramPipelines_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glIsProgramPipeline]</b> Determine if a name corresponds to a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml" /></remarks>
            public static bool IsProgramPipeline(int pipeline) => GLPointers._glIsProgramPipeline_fnptr(pipeline) != 0;
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glGetProgramPipelineiv]</b> Retrieve properties of a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
            /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml" /></remarks>
            public static void GetProgramPipelineiv(int pipeline, PipelineParameterName pname, int* parameters) => GLPointers._glGetProgramPipelineiv_fnptr(pipeline, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1i]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1i(int program, int location, int v0) => GLPointers._glProgramUniform1i_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1iv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform1iv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1f]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1f(int program, int location, float v0) => GLPointers._glProgramUniform1f_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform1fv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1d]</b>  </summary>
            public static void ProgramUniform1d(int program, int location, double v0) => GLPointers._glProgramUniform1d_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1dv]</b>  </summary>
            public static void ProgramUniform1dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform1dv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1ui]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1ui(int program, int location, uint v0) => GLPointers._glProgramUniform1ui_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform1uiv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform1uiv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2i]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2i(int program, int location, int v0, int v1) => GLPointers._glProgramUniform2i_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2iv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform2iv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2f]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2f(int program, int location, float v0, float v1) => GLPointers._glProgramUniform2f_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform2fv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2d]</b>  </summary>
            public static void ProgramUniform2d(int program, int location, double v0, double v1) => GLPointers._glProgramUniform2d_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2dv]</b>  </summary>
            public static void ProgramUniform2dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform2dv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2ui]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2ui(int program, int location, uint v0, uint v1) => GLPointers._glProgramUniform2ui_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform2uiv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform2uiv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3i]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3i(int program, int location, int v0, int v1, int v2) => GLPointers._glProgramUniform3i_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3iv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform3iv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3f]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3f(int program, int location, float v0, float v1, float v2) => GLPointers._glProgramUniform3f_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform3fv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3d]</b>  </summary>
            public static void ProgramUniform3d(int program, int location, double v0, double v1, double v2) => GLPointers._glProgramUniform3d_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3dv]</b>  </summary>
            public static void ProgramUniform3dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform3dv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3ui]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3ui(int program, int location, uint v0, uint v1, uint v2) => GLPointers._glProgramUniform3ui_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform3uiv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform3uiv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4i]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3) => GLPointers._glProgramUniform4i_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4iv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform4iv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4f]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3) => GLPointers._glProgramUniform4f_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform4fv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4d]</b>  </summary>
            public static void ProgramUniform4d(int program, int location, double v0, double v1, double v2, double v3) => GLPointers._glProgramUniform4d_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4dv]</b>  </summary>
            public static void ProgramUniform4dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform4dv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4ui]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4ui(int program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glProgramUniform4ui_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniform4uiv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform4uiv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2dv]</b>  </summary>
            public static void ProgramUniformMatrix2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3dv]</b>  </summary>
            public static void ProgramUniformMatrix3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4dv]</b>  </summary>
            public static void ProgramUniformMatrix4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2x3fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3x2fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2x4fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4x2fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3x4fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4x3fv]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2x3dv]</b>  </summary>
            public static void ProgramUniformMatrix2x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3x2dv]</b>  </summary>
            public static void ProgramUniformMatrix3x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix2x4dv]</b>  </summary>
            public static void ProgramUniformMatrix2x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4x2dv]</b>  </summary>
            public static void ProgramUniformMatrix4x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix3x4dv]</b>  </summary>
            public static void ProgramUniformMatrix3x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glProgramUniformMatrix4x3dv]</b>  </summary>
            public static void ProgramUniformMatrix4x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glValidateProgramPipeline]</b> Validate a program pipeline object against current GL state. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml" /></remarks>
            public static void ValidateProgramPipeline(int pipeline) => GLPointers._glValidateProgramPipeline_fnptr(pipeline);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects] [glGetProgramPipelineInfoLog]</b> Retrieve the info log string from a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
            /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
            /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
            /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml" /></remarks>
            public static void GetProgramPipelineInfoLog(int pipeline, int bufSize, int* length, byte* infoLog) => GLPointers._glGetProgramPipelineInfoLog_fnptr(pipeline, bufSize, length, infoLog);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters] [glGetActiveAtomicCounterBufferiv]</b> Retrieve information about the set of active atomic counter buffers for a program. </summary>
            /// <param name="program"> The name of a program object from which to retrieve information. </param>
            /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
            /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml" /></remarks>
            public static void GetActiveAtomicCounterBufferiv(int program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => GLPointers._glGetActiveAtomicCounterBufferiv_fnptr(program, bufferIndex, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store] [glBindImageTexture]</b> Bind a level of a texture to an image unit. </summary>
            /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
            /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
            /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
            /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
            /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
            /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
            /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml" /></remarks>
            public static void BindImageTexture(uint unit, int texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format) => GLPointers._glBindImageTexture_fnptr(unit, texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, (uint)format);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store] [glMemoryBarrier]</b> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
            public static void MemoryBarrier(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrier_fnptr((uint)barriers);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glDeleteObjectARB]</b>  </summary>
            public static void DeleteObject(GLHandleARB obj) => GLPointers._glDeleteObjectARB_fnptr((IntPtr)obj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetHandleARB]</b>  </summary>
            public static GLHandleARB GetHandle(ContainerType pname) => (GLHandleARB) GLPointers._glGetHandleARB_fnptr((uint)pname);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glDetachObjectARB]</b>  </summary>
            public static void DetachObject(GLHandleARB containerObj, GLHandleARB attachedObj) => GLPointers._glDetachObjectARB_fnptr((IntPtr)containerObj, (IntPtr)attachedObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glCreateShaderObjectARB]</b>  </summary>
            public static GLHandleARB CreateShaderObject(ShaderType shaderType) => (GLHandleARB) GLPointers._glCreateShaderObjectARB_fnptr((uint)shaderType);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glShaderSourceARB]</b>  </summary>
            public static void ShaderSource(GLHandleARB shaderObj, int count, byte** str, int* length) => GLPointers._glShaderSourceARB_fnptr((IntPtr)shaderObj, count, str, length);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glCompileShaderARB]</b>  </summary>
            public static void CompileShader(GLHandleARB shaderObj) => GLPointers._glCompileShaderARB_fnptr((IntPtr)shaderObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glCreateProgramObjectARB]</b>  </summary>
            public static GLHandleARB CreateProgramObject() => (GLHandleARB) GLPointers._glCreateProgramObjectARB_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glAttachObjectARB]</b>  </summary>
            public static void AttachObject(GLHandleARB containerObj, GLHandleARB obj) => GLPointers._glAttachObjectARB_fnptr((IntPtr)containerObj, (IntPtr)obj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glLinkProgramARB]</b>  </summary>
            public static void LinkProgram(GLHandleARB programObj) => GLPointers._glLinkProgramARB_fnptr((IntPtr)programObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUseProgramObjectARB]</b>  </summary>
            public static void UseProgramObject(GLHandleARB programObj) => GLPointers._glUseProgramObjectARB_fnptr((IntPtr)programObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glValidateProgramARB]</b>  </summary>
            public static void ValidateProgram(GLHandleARB programObj) => GLPointers._glValidateProgramARB_fnptr((IntPtr)programObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform1fARB]</b>  </summary>
            public static void Uniform1f(int location, float v0) => GLPointers._glUniform1fARB_fnptr(location, v0);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform2fARB]</b>  </summary>
            public static void Uniform2f(int location, float v0, float v1) => GLPointers._glUniform2fARB_fnptr(location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform3fARB]</b>  </summary>
            public static void Uniform3f(int location, float v0, float v1, float v2) => GLPointers._glUniform3fARB_fnptr(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform4fARB]</b>  </summary>
            public static void Uniform4f(int location, float v0, float v1, float v2, float v3) => GLPointers._glUniform4fARB_fnptr(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform1iARB]</b>  </summary>
            public static void Uniform1i(int location, int v0) => GLPointers._glUniform1iARB_fnptr(location, v0);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform2iARB]</b>  </summary>
            public static void Uniform2i(int location, int v0, int v1) => GLPointers._glUniform2iARB_fnptr(location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform3iARB]</b>  </summary>
            public static void Uniform3i(int location, int v0, int v1, int v2) => GLPointers._glUniform3iARB_fnptr(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform4iARB]</b>  </summary>
            public static void Uniform4i(int location, int v0, int v1, int v2, int v3) => GLPointers._glUniform4iARB_fnptr(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform1fvARB]</b>  </summary>
            public static void Uniform1fv(int location, int count, float* value) => GLPointers._glUniform1fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform2fvARB]</b>  </summary>
            public static void Uniform2fv(int location, int count, float* value) => GLPointers._glUniform2fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform3fvARB]</b>  </summary>
            public static void Uniform3fv(int location, int count, float* value) => GLPointers._glUniform3fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform4fvARB]</b>  </summary>
            public static void Uniform4fv(int location, int count, float* value) => GLPointers._glUniform4fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform1ivARB]</b>  </summary>
            public static void Uniform1iv(int location, int count, int* value) => GLPointers._glUniform1ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform2ivARB]</b>  </summary>
            public static void Uniform2iv(int location, int count, int* value) => GLPointers._glUniform2ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform3ivARB]</b>  </summary>
            public static void Uniform3iv(int location, int count, int* value) => GLPointers._glUniform3ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniform4ivARB]</b>  </summary>
            public static void Uniform4iv(int location, int count, int* value) => GLPointers._glUniform4ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniformMatrix2fvARB]</b>  </summary>
            public static void UniformMatrix2fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix2fvARB_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniformMatrix3fvARB]</b>  </summary>
            public static void UniformMatrix3fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix3fvARB_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glUniformMatrix4fvARB]</b>  </summary>
            public static void UniformMatrix4fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix4fvARB_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetObjectParameterfvARB]</b>  </summary>
            public static void GetObjectParameterfv(GLHandleARB obj, All pname, float* parameters) => GLPointers._glGetObjectParameterfvARB_fnptr((IntPtr)obj, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetObjectParameterivARB]</b>  </summary>
            public static void GetObjectParameteriv(GLHandleARB obj, All pname, int* parameters) => GLPointers._glGetObjectParameterivARB_fnptr((IntPtr)obj, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetInfoLogARB]</b>  </summary>
            public static void GetInfoLog(GLHandleARB obj, int maxLength, int* length, byte* infoLog) => GLPointers._glGetInfoLogARB_fnptr((IntPtr)obj, maxLength, length, infoLog);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetAttachedObjectsARB]</b>  </summary>
            public static void GetAttachedObjects(GLHandleARB containerObj, int maxCount, int* count, GLHandleARB* obj) => GLPointers._glGetAttachedObjectsARB_fnptr((IntPtr)containerObj, maxCount, count, (IntPtr*)obj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetUniformLocationARB]</b>  </summary>
            public static int GetUniformLocation(GLHandleARB programObj, byte* name) => GLPointers._glGetUniformLocationARB_fnptr((IntPtr)programObj, name);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetActiveUniformARB]</b>  </summary>
            public static void GetActiveUniform(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, UniformType* type, byte* name) => GLPointers._glGetActiveUniformARB_fnptr((IntPtr)programObj, index, maxLength, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetUniformfvARB]</b>  </summary>
            public static void GetUniformfv(GLHandleARB programObj, int location, float* parameters) => GLPointers._glGetUniformfvARB_fnptr((IntPtr)programObj, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetUniformivARB]</b>  </summary>
            public static void GetUniformiv(GLHandleARB programObj, int location, int* parameters) => GLPointers._glGetUniformivARB_fnptr((IntPtr)programObj, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects] [glGetShaderSourceARB]</b>  </summary>
            public static void GetShaderSource(GLHandleARB obj, int maxLength, int* length, byte* source) => GLPointers._glGetShaderSourceARB_fnptr((IntPtr)obj, maxLength, length, source);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object] [glShaderStorageBlockBinding]</b> Change an active shader storage block binding. </summary>
            /// <param name="program"> The name of the program containing the block whose binding to change. </param>
            /// <param name="storageBlockIndex"> The index storage block within the program. </param>
            /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml" /></remarks>
            public static void ShaderStorageBlockBinding(int program, uint storageBlockIndex, uint storageBlockBinding) => GLPointers._glShaderStorageBlockBinding_fnptr(program, storageBlockIndex, storageBlockBinding);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetSubroutineUniformLocation]</b> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml" /></remarks>
            public static int GetSubroutineUniformLocation(int program, ShaderType shadertype, byte* name) => GLPointers._glGetSubroutineUniformLocation_fnptr(program, (uint)shadertype, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetSubroutineIndex]</b> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml" /></remarks>
            public static uint GetSubroutineIndex(int program, ShaderType shadertype, byte* name) => GLPointers._glGetSubroutineIndex_fnptr(program, (uint)shadertype, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetActiveSubroutineUniformiv]</b> Query a property of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
            /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml" /></remarks>
            public static void GetActiveSubroutineUniformiv(int program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => GLPointers._glGetActiveSubroutineUniformiv_fnptr(program, (uint)shadertype, index, (uint)pname, values);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetActiveSubroutineUniformName]</b> Query the name of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
            /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml" /></remarks>
            public static void GetActiveSubroutineUniformName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetActiveSubroutineUniformName_fnptr(program, (uint)shadertype, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetActiveSubroutineName]</b> Query the name of an active shader subroutine. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
            /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml" /></remarks>
            public static void GetActiveSubroutineName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetActiveSubroutineName_fnptr(program, (uint)shadertype, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glUniformSubroutinesuiv]</b> Load active subroutine uniforms. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
            /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml" /></remarks>
            public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => GLPointers._glUniformSubroutinesuiv_fnptr((uint)shadertype, count, indices);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetUniformSubroutineuiv]</b> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="location"> Specifies the location of the subroutine uniform. </param>
            /// <param name="values"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml" /></remarks>
            public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => GLPointers._glGetUniformSubroutineuiv_fnptr((uint)shadertype, location, parameters);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine] [glGetProgramStageiv]</b> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
            /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml" /></remarks>
            public static void GetProgramStageiv(int program, ShaderType shadertype, ProgramStagePName pname, int* values) => GLPointers._glGetProgramStageiv_fnptr(program, (uint)shadertype, (uint)pname, values);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include] [glNamedStringARB]</b>  </summary>
            public static void NamedString(All type, int namelen, byte* name, int stringlen, byte* str) => GLPointers._glNamedStringARB_fnptr((uint)type, namelen, name, stringlen, str);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include] [glDeleteNamedStringARB]</b>  </summary>
            public static void DeleteNamedString(int namelen, byte* name) => GLPointers._glDeleteNamedStringARB_fnptr(namelen, name);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include] [glCompileShaderIncludeARB]</b>  </summary>
            public static void CompileShaderInclude(int shader, int count, byte** path, int* length) => GLPointers._glCompileShaderIncludeARB_fnptr(shader, count, path, length);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include] [glIsNamedStringARB]</b>  </summary>
            public static bool IsNamedString(int namelen, byte* name) => GLPointers._glIsNamedStringARB_fnptr(namelen, name) != 0;
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include] [glGetNamedStringARB]</b>  </summary>
            public static void GetNamedString(int namelen, byte* name, int bufSize, int* stringlen, byte* str) => GLPointers._glGetNamedStringARB_fnptr(namelen, name, bufSize, stringlen, str);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include] [glGetNamedStringivARB]</b>  </summary>
            public static void GetNamedStringiv(int namelen, byte* name, All pname, int* parameters) => GLPointers._glGetNamedStringivARB_fnptr(namelen, name, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer] [glBufferPageCommitmentARB]</b>  </summary>
            public static void BufferPageCommitment(All target, IntPtr offset, nint size, bool commit) => GLPointers._glBufferPageCommitmentARB_fnptr((uint)target, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer] [glNamedBufferPageCommitmentEXT]</b>  </summary>
            public static void NamedBufferPageCommitmentEXT(int buffer, IntPtr offset, nint size, bool commit) => GLPointers._glNamedBufferPageCommitmentEXT_fnptr(buffer, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer] [glNamedBufferPageCommitmentARB]</b>  </summary>
            public static void NamedBufferPageCommitment(int buffer, IntPtr offset, nint size, bool commit) => GLPointers._glNamedBufferPageCommitmentARB_fnptr(buffer, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_texture] [glTexPageCommitmentARB]</b>  </summary>
            public static void TexPageCommitment(All target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => GLPointers._glTexPageCommitmentARB_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glFenceSync]</b> Create a new sync object and insert it into the GL command stream. </summary>
            /// <param name="condition"> Specifies the condition that must be met to set the sync object&apos;s state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
            /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml" /></remarks>
            public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) GLPointers._glFenceSync_fnptr((uint)condition, (uint)flags);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glIsSync]</b> Determine if a name corresponds to a sync object. </summary>
            /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml" /></remarks>
            public static bool IsSync(GLSync sync) => GLPointers._glIsSync_fnptr((IntPtr)sync) != 0;
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glDeleteSync]</b> Delete a sync object. </summary>
            /// <param name="sync"> The sync object to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml" /></remarks>
            public static void DeleteSync(GLSync sync) => GLPointers._glDeleteSync_fnptr((IntPtr)sync);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glClientWaitSync]</b> Block and wait for a sync object to become signaled. </summary>
            /// <param name="sync"> The sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
            /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml" /></remarks>
            public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => (SyncStatus) GLPointers._glClientWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glWaitSync]</b> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
            /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
            /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml" /></remarks>
            public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => GLPointers._glWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glGetInteger64v]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetInteger64v(GetPName pname, long* data) => GLPointers._glGetInteger64v_fnptr((uint)pname, data);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync] [glGetSynciv]</b> Query the properties of a sync object. </summary>
            /// <param name="sync"> Specifies the sync object whose properties to query. </param>
            /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in values. </param>
            /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
            /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml" /></remarks>
            public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => GLPointers._glGetSynciv_fnptr((IntPtr)sync, (uint)pname, count, length, values);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader] [glPatchParameteri]</b> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
            public static void PatchParameteri(PatchParameterName pname, int value) => GLPointers._glPatchParameteri_fnptr((uint)pname, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader] [glPatchParameterfv]</b> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
            public static void PatchParameterfv(PatchParameterName pname, float* values) => GLPointers._glPatchParameterfv_fnptr((uint)pname, values);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier] [glTextureBarrier]</b> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml" /></remarks>
            public static void TextureBarrier() => GLPointers._glTextureBarrier_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_texture_buffer_object] [glTexBufferARB]</b>  </summary>
            public static void TexBuffer(TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers._glTexBufferARB_fnptr((uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range] [glTexBufferRange]</b> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
            public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTexBufferRange_fnptr((uint)target, (uint)internalformat, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression] [glCompressedTexImage3DARB]</b>  </summary>
            public static void CompressedTexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage3DARB_fnptr((uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression] [glCompressedTexImage2DARB]</b>  </summary>
            public static void CompressedTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage2DARB_fnptr((uint)target, level, (uint)internalformat, width, height, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression] [glCompressedTexImage1DARB]</b>  </summary>
            public static void CompressedTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage1DARB_fnptr((uint)target, level, (uint)internalformat, width, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression] [glCompressedTexSubImage3DARB]</b>  </summary>
            public static void CompressedTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage3DARB_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression] [glCompressedTexSubImage2DARB]</b>  </summary>
            public static void CompressedTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage2DARB_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression] [glCompressedTexSubImage1DARB]</b>  </summary>
            public static void CompressedTexSubImage1D(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage1DARB_fnptr((uint)target, level, xoffset, width, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression] [glGetCompressedTexImageARB]</b>  </summary>
            public static void GetCompressedTexImage(TextureTarget target, int level, void* img) => GLPointers._glGetCompressedTexImageARB_fnptr((uint)target, level, img);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample] [glTexImage2DMultisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
            /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml" /></remarks>
            public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTexImage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample] [glTexImage3DMultisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
            /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
            /// <param name="depth">!!missing documentation!!</param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml" /></remarks>
            public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTexImage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample] [glGetMultisamplefv]</b> Retrieve the location of a sample. </summary>
            /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
            /// <param name="index"> Specifies the index of the sample whose position to query. </param>
            /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml" /></remarks>
            public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers._glGetMultisamplefv_fnptr((uint)pname, index, val);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample] [glSampleMaski]</b> Set the value of a sub-word of the sample mask. </summary>
            /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
            /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml" /></remarks>
            public static void SampleMaski(uint maskNumber, uint mask) => GLPointers._glSampleMaski_fnptr(maskNumber, mask);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage] [glTexStorage1D]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
            public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTexStorage1D_fnptr((uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage] [glTexStorage2D]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
            public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTexStorage2D_fnptr((uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage] [glTexStorage3D]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
            public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTexStorage3D_fnptr((uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample] [glTexStorage2DMultisample]</b> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
            public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTexStorage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample] [glTexStorage3DMultisample]</b> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
            public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTexStorage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view] [glTextureView]</b> Initialize a texture as a data alias of another texture&apos;s data store. </summary>
            /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
            /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
            /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
            /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
            /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
            /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
            /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
            /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml" /></remarks>
            public static void TextureView(int texture, TextureTarget target, int origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => GLPointers._glTextureView_fnptr(texture, (uint)target, origtexture, (uint)internalformat, minlevel, numlevels, minlayer, numlayers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query] [glQueryCounter]</b> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
            /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
            /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml" /></remarks>
            public static void QueryCounter(int id, QueryCounterTarget target) => GLPointers._glQueryCounter_fnptr(id, (uint)target);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query] [glGetQueryObjecti64v]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryObjecti64v(int id, QueryObjectParameterName pname, long* parameters) => GLPointers._glGetQueryObjecti64v_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query] [glGetQueryObjectui64v]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryObjectui64v(int id, QueryObjectParameterName pname, ulong* parameters) => GLPointers._glGetQueryObjectui64v_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glBindTransformFeedback]</b> Bind a transform feedback object. </summary>
            /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
            /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml" /></remarks>
            public static void BindTransformFeedback(BindTransformFeedbackTarget target, int id) => GLPointers._glBindTransformFeedback_fnptr((uint)target, id);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glDeleteTransformFeedbacks]</b> Delete transform feedback objects. </summary>
            /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
            /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml" /></remarks>
            public static void DeleteTransformFeedbacks(int n, int* ids) => GLPointers._glDeleteTransformFeedbacks_fnptr(n, ids);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glGenTransformFeedbacks]</b> Reserve transform feedback object names. </summary>
            /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
            /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml" /></remarks>
            public static void GenTransformFeedbacks(int n, int* ids) => GLPointers._glGenTransformFeedbacks_fnptr(n, ids);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glIsTransformFeedback]</b> Determine if a name corresponds to a transform feedback object. </summary>
            /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml" /></remarks>
            public static bool IsTransformFeedback(int id) => GLPointers._glIsTransformFeedback_fnptr(id) != 0;
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glPauseTransformFeedback]</b> Pause transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml" /></remarks>
            public static void PauseTransformFeedback() => GLPointers._glPauseTransformFeedback_fnptr();
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glResumeTransformFeedback]</b> Resume transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml" /></remarks>
            public static void ResumeTransformFeedback() => GLPointers._glResumeTransformFeedback_fnptr();
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2] [glDrawTransformFeedback]</b> Render primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml" /></remarks>
            public static void DrawTransformFeedback(PrimitiveType mode, int id) => GLPointers._glDrawTransformFeedback_fnptr((uint)mode, id);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3] [glDrawTransformFeedbackStream]</b> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml" /></remarks>
            public static void DrawTransformFeedbackStream(PrimitiveType mode, int id, uint stream) => GLPointers._glDrawTransformFeedbackStream_fnptr((uint)mode, id, stream);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3] [glBeginQueryIndexed]</b> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
            public static void BeginQueryIndexed(QueryTarget target, uint index, int id) => GLPointers._glBeginQueryIndexed_fnptr((uint)target, index, id);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3] [glEndQueryIndexed]</b> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
            public static void EndQueryIndexed(QueryTarget target, uint index) => GLPointers._glEndQueryIndexed_fnptr((uint)target, index);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3] [glGetQueryIndexediv]</b> Return parameters of an indexed query object target. </summary>
            /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
            /// <param name="index"> Specifies the index of the query object target. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
            /// <param name="parameters"> Returns the requested data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml" /></remarks>
            public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => GLPointers._glGetQueryIndexediv_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced] [glDrawTransformFeedbackInstanced]</b> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml" /></remarks>
            public static void DrawTransformFeedbackInstanced(PrimitiveType mode, int id, int instancecount) => GLPointers._glDrawTransformFeedbackInstanced_fnptr((uint)mode, id, instancecount);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced] [glDrawTransformFeedbackStreamInstanced]</b> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml" /></remarks>
            public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, int id, uint stream, int instancecount) => GLPointers._glDrawTransformFeedbackStreamInstanced_fnptr((uint)mode, id, stream, instancecount);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix] [glLoadTransposeMatrixfARB]</b>  </summary>
            public static void LoadTransposeMatrixf(float* m) => GLPointers._glLoadTransposeMatrixfARB_fnptr(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix] [glLoadTransposeMatrixdARB]</b>  </summary>
            public static void LoadTransposeMatrixd(double* m) => GLPointers._glLoadTransposeMatrixdARB_fnptr(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix] [glMultTransposeMatrixfARB]</b>  </summary>
            public static void MultTransposeMatrixf(float* m) => GLPointers._glMultTransposeMatrixfARB_fnptr(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix] [glMultTransposeMatrixdARB]</b>  </summary>
            public static void MultTransposeMatrixd(double* m) => GLPointers._glMultTransposeMatrixdARB_fnptr(m);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetUniformIndices]</b> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
            /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
            /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
            /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml" /></remarks>
            public static void GetUniformIndices(int program, int uniformCount, byte** uniformNames, uint* uniformIndices) => GLPointers._glGetUniformIndices_fnptr(program, uniformCount, uniformNames, uniformIndices);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetActiveUniformsiv]</b> Returns information about several active uniform variables for the specified program object. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
            /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
            /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
            /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml" /></remarks>
            public static void GetActiveUniformsiv(int program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => GLPointers._glGetActiveUniformsiv_fnptr(program, uniformCount, uniformIndices, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetActiveUniformName]</b> Query the name of an active uniform. </summary>
            /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
            /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
            /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
            /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
            /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml" /></remarks>
            public static void GetActiveUniformName(int program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => GLPointers._glGetActiveUniformName_fnptr(program, uniformIndex, bufSize, length, uniformName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetUniformBlockIndex]</b> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml" /></remarks>
            public static uint GetUniformBlockIndex(int program, byte* uniformBlockName) => GLPointers._glGetUniformBlockIndex_fnptr(program, uniformBlockName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetActiveUniformBlockiv]</b> Query information about an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="pname"> Specifies the name of the parameter to query. </param>
            /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml" /></remarks>
            public static void GetActiveUniformBlockiv(int program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => GLPointers._glGetActiveUniformBlockiv_fnptr(program, uniformBlockIndex, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glGetActiveUniformBlockName]</b> Retrieve the name of an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml" /></remarks>
            public static void GetActiveUniformBlockName(int program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => GLPointers._glGetActiveUniformBlockName_fnptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object] [glUniformBlockBinding]</b> Assign a binding point to an active uniform block. </summary>
            /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
            /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
            /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml" /></remarks>
            public static void UniformBlockBinding(int program, uint uniformBlockIndex, uint uniformBlockBinding) => GLPointers._glUniformBlockBinding_fnptr(program, uniformBlockIndex, uniformBlockBinding);
            
            /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object] [glBindBufferRange]</b> Bind a range within a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
            /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml" /></remarks>
            public static void BindBufferRange(BufferTargetARB target, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glBindBufferRange_fnptr((uint)target, index, buffer, offset, size);
            
            /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object] [glBindBufferBase]</b> Bind a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml" /></remarks>
            public static void BindBufferBase(BufferTargetARB target, uint index, int buffer) => GLPointers._glBindBufferBase_fnptr((uint)target, index, buffer);
            
            /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object] [glGetIntegeri_v]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetIntegeri_v(GetPName target, uint index, int* data) => GLPointers._glGetIntegeri_v_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object] [glBindVertexArray]</b> Bind a vertex array object. </summary>
            /// <param name="array"> Specifies the name of the vertex array to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" /></remarks>
            public static void BindVertexArray(int array) => GLPointers._glBindVertexArray_fnptr(array);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object] [glDeleteVertexArrays]</b> Delete vertex array objects. </summary>
            /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
            /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml" /></remarks>
            public static void DeleteVertexArrays(int n, int* arrays) => GLPointers._glDeleteVertexArrays_fnptr(n, arrays);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object] [glGenVertexArrays]</b> Generate vertex array object names. </summary>
            /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
            /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" /></remarks>
            public static void GenVertexArrays(int n, int* arrays) => GLPointers._glGenVertexArrays_fnptr(n, arrays);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object] [glIsVertexArray]</b> Determine if a name corresponds to a vertex array object. </summary>
            /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml" /></remarks>
            public static bool IsVertexArray(int array) => GLPointers._glIsVertexArray_fnptr(array) != 0;
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL1d]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL1d(uint index, double x) => GLPointers._glVertexAttribL1d_fnptr(index, x);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL2d]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL2d(uint index, double x, double y) => GLPointers._glVertexAttribL2d_fnptr(index, x, y);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL3d]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL3d(uint index, double x, double y, double z) => GLPointers._glVertexAttribL3d_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL4d]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttribL4d_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL1dv]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL1dv(uint index, double* v) => GLPointers._glVertexAttribL1dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL2dv]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL2dv(uint index, double* v) => GLPointers._glVertexAttribL2dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL3dv]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL3dv(uint index, double* v) => GLPointers._glVertexAttribL3dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribL4dv]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL4dv(uint index, double* v) => GLPointers._glVertexAttribL4dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glVertexAttribLPointer]</b> Define an array of generic vertex attribute data. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
            /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
            /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
            /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
            public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers._glVertexAttribLPointer_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit] [glGetVertexAttribLdv]</b> Return a generic vertex attribute parameter. </summary>
            /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
            /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
            public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => GLPointers._glGetVertexAttribLdv_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glBindVertexBuffer]</b> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
            public static void BindVertexBuffer(uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glBindVertexBuffer_fnptr(bindingindex, buffer, offset, stride);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexAttribFormat]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexAttribFormat_fnptr(attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexAttribIFormat]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexAttribIFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexAttribLFormat]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexAttribLFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexAttribBinding]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
            public static void VertexAttribBinding(uint attribindex, uint bindingindex) => GLPointers._glVertexAttribBinding_fnptr(attribindex, bindingindex);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding] [glVertexBindingDivisor]</b> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
            public static void VertexBindingDivisor(uint bindingindex, uint divisor) => GLPointers._glVertexBindingDivisor_fnptr(bindingindex, divisor);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glWeightbvARB]</b>  </summary>
            public static void Weightbv(int size, sbyte* weights) => GLPointers._glWeightbvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glWeightsvARB]</b>  </summary>
            public static void Weightsv(int size, short* weights) => GLPointers._glWeightsvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glWeightivARB]</b>  </summary>
            public static void Weightiv(int size, int* weights) => GLPointers._glWeightivARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glWeightfvARB]</b>  </summary>
            public static void Weightfv(int size, float* weights) => GLPointers._glWeightfvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glWeightdvARB]</b>  </summary>
            public static void Weightdv(int size, double* weights) => GLPointers._glWeightdvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glWeightubvARB]</b>  </summary>
            public static void Weightubv(int size, byte* weights) => GLPointers._glWeightubvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glWeightusvARB]</b>  </summary>
            public static void Weightusv(int size, ushort* weights) => GLPointers._glWeightusvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glWeightuivARB]</b>  </summary>
            public static void Weightuiv(int size, uint* weights) => GLPointers._glWeightuivARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glWeightPointerARB]</b>  </summary>
            public static void WeightPointer(int size, WeightPointerTypeARB type, int stride, void* pointer) => GLPointers._glWeightPointerARB_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend] [glVertexBlendARB]</b>  </summary>
            public static void VertexBlend(int count) => GLPointers._glVertexBlendARB_fnptr(count);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glBindBufferARB]</b>  </summary>
            public static void BindBuffer(BufferTargetARB target, int buffer) => GLPointers._glBindBufferARB_fnptr((uint)target, buffer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glDeleteBuffersARB]</b>  </summary>
            public static void DeleteBuffers(int n, int* buffers) => GLPointers._glDeleteBuffersARB_fnptr(n, buffers);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glGenBuffersARB]</b>  </summary>
            public static void GenBuffers(int n, int* buffers) => GLPointers._glGenBuffersARB_fnptr(n, buffers);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glIsBufferARB]</b>  </summary>
            public static bool IsBuffer(int buffer) => GLPointers._glIsBufferARB_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glBufferDataARB]</b>  </summary>
            public static void BufferData(BufferTargetARB target, nint size, void* data, BufferUsageARB usage) => GLPointers._glBufferDataARB_fnptr((uint)target, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glBufferSubDataARB]</b>  </summary>
            public static void BufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._glBufferSubDataARB_fnptr((uint)target, offset, size, data);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glGetBufferSubDataARB]</b>  </summary>
            public static void GetBufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._glGetBufferSubDataARB_fnptr((uint)target, offset, size, data);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glMapBufferARB]</b>  </summary>
            public static void* MapBuffer(BufferTargetARB target, BufferAccessARB access) => GLPointers._glMapBufferARB_fnptr((uint)target, (uint)access);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glUnmapBufferARB]</b>  </summary>
            public static bool UnmapBuffer(BufferTargetARB target) => GLPointers._glUnmapBufferARB_fnptr((uint)target) != 0;
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glGetBufferParameterivARB]</b>  </summary>
            public static void GetBufferParameteriv(BufferTargetARB target, BufferPNameARB pname, int* parameters) => GLPointers._glGetBufferParameterivARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object] [glGetBufferPointervARB]</b>  </summary>
            public static void GetBufferPointerv(BufferTargetARB target, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetBufferPointervARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib1dARB]</b>  </summary>
            public static void VertexAttrib1d(uint index, double x) => GLPointers._glVertexAttrib1dARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib1dvARB]</b>  </summary>
            public static void VertexAttrib1dv(uint index, double* v) => GLPointers._glVertexAttrib1dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib1fARB]</b>  </summary>
            public static void VertexAttrib1f(uint index, float x) => GLPointers._glVertexAttrib1fARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib1fvARB]</b>  </summary>
            public static void VertexAttrib1fv(uint index, float* v) => GLPointers._glVertexAttrib1fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib1sARB]</b>  </summary>
            public static void VertexAttrib1s(uint index, short x) => GLPointers._glVertexAttrib1sARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib1svARB]</b>  </summary>
            public static void VertexAttrib1sv(uint index, short* v) => GLPointers._glVertexAttrib1svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib2dARB]</b>  </summary>
            public static void VertexAttrib2d(uint index, double x, double y) => GLPointers._glVertexAttrib2dARB_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib2dvARB]</b>  </summary>
            public static void VertexAttrib2dv(uint index, double* v) => GLPointers._glVertexAttrib2dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib2fARB]</b>  </summary>
            public static void VertexAttrib2f(uint index, float x, float y) => GLPointers._glVertexAttrib2fARB_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib2fvARB]</b>  </summary>
            public static void VertexAttrib2fv(uint index, float* v) => GLPointers._glVertexAttrib2fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib2sARB]</b>  </summary>
            public static void VertexAttrib2s(uint index, short x, short y) => GLPointers._glVertexAttrib2sARB_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib2svARB]</b>  </summary>
            public static void VertexAttrib2sv(uint index, short* v) => GLPointers._glVertexAttrib2svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib3dARB]</b>  </summary>
            public static void VertexAttrib3d(uint index, double x, double y, double z) => GLPointers._glVertexAttrib3dARB_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib3dvARB]</b>  </summary>
            public static void VertexAttrib3dv(uint index, double* v) => GLPointers._glVertexAttrib3dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib3fARB]</b>  </summary>
            public static void VertexAttrib3f(uint index, float x, float y, float z) => GLPointers._glVertexAttrib3fARB_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib3fvARB]</b>  </summary>
            public static void VertexAttrib3fv(uint index, float* v) => GLPointers._glVertexAttrib3fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib3sARB]</b>  </summary>
            public static void VertexAttrib3s(uint index, short x, short y, short z) => GLPointers._glVertexAttrib3sARB_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib3svARB]</b>  </summary>
            public static void VertexAttrib3sv(uint index, short* v) => GLPointers._glVertexAttrib3svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4NbvARB]</b>  </summary>
            public static void VertexAttrib4Nbv(uint index, sbyte* v) => GLPointers._glVertexAttrib4NbvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4NivARB]</b>  </summary>
            public static void VertexAttrib4Niv(uint index, int* v) => GLPointers._glVertexAttrib4NivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4NsvARB]</b>  </summary>
            public static void VertexAttrib4Nsv(uint index, short* v) => GLPointers._glVertexAttrib4NsvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4NubARB]</b>  </summary>
            public static void VertexAttrib4Nub(uint index, byte x, byte y, byte z, byte w) => GLPointers._glVertexAttrib4NubARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4NubvARB]</b>  </summary>
            public static void VertexAttrib4Nubv(uint index, byte* v) => GLPointers._glVertexAttrib4NubvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4NuivARB]</b>  </summary>
            public static void VertexAttrib4Nuiv(uint index, uint* v) => GLPointers._glVertexAttrib4NuivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4NusvARB]</b>  </summary>
            public static void VertexAttrib4Nusv(uint index, ushort* v) => GLPointers._glVertexAttrib4NusvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4bvARB]</b>  </summary>
            public static void VertexAttrib4bv(uint index, sbyte* v) => GLPointers._glVertexAttrib4bvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4dARB]</b>  </summary>
            public static void VertexAttrib4d(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttrib4dARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4dvARB]</b>  </summary>
            public static void VertexAttrib4dv(uint index, double* v) => GLPointers._glVertexAttrib4dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4fARB]</b>  </summary>
            public static void VertexAttrib4f(uint index, float x, float y, float z, float w) => GLPointers._glVertexAttrib4fARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4fvARB]</b>  </summary>
            public static void VertexAttrib4fv(uint index, float* v) => GLPointers._glVertexAttrib4fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4ivARB]</b>  </summary>
            public static void VertexAttrib4iv(uint index, int* v) => GLPointers._glVertexAttrib4ivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4sARB]</b>  </summary>
            public static void VertexAttrib4s(uint index, short x, short y, short z, short w) => GLPointers._glVertexAttrib4sARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4svARB]</b>  </summary>
            public static void VertexAttrib4sv(uint index, short* v) => GLPointers._glVertexAttrib4svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4ubvARB]</b>  </summary>
            public static void VertexAttrib4ubv(uint index, byte* v) => GLPointers._glVertexAttrib4ubvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4uivARB]</b>  </summary>
            public static void VertexAttrib4uiv(uint index, uint* v) => GLPointers._glVertexAttrib4uivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttrib4usvARB]</b>  </summary>
            public static void VertexAttrib4usv(uint index, ushort* v) => GLPointers._glVertexAttrib4usvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glVertexAttribPointerARB]</b>  </summary>
            public static void VertexAttribPointer(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, void* pointer) => GLPointers._glVertexAttribPointerARB_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, pointer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glEnableVertexAttribArrayARB]</b>  </summary>
            public static void EnableVertexAttribArray(uint index) => GLPointers._glEnableVertexAttribArrayARB_fnptr(index);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glDisableVertexAttribArrayARB]</b>  </summary>
            public static void DisableVertexAttribArray(uint index) => GLPointers._glDisableVertexAttribArrayARB_fnptr(index);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glGetVertexAttribdvARB]</b>  </summary>
            public static void GetVertexAttribdv(uint index, VertexAttribPropertyARB pname, double* parameters) => GLPointers._glGetVertexAttribdvARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glGetVertexAttribfvARB]</b>  </summary>
            public static void GetVertexAttribfv(uint index, VertexAttribPropertyARB pname, float* parameters) => GLPointers._glGetVertexAttribfvARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glGetVertexAttribivARB]</b>  </summary>
            public static void GetVertexAttribiv(uint index, VertexAttribPropertyARB pname, int* parameters) => GLPointers._glGetVertexAttribivARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader] [glGetVertexAttribPointervARB]</b>  </summary>
            public static void GetVertexAttribPointerv(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => GLPointers._glGetVertexAttribPointervARB_fnptr(index, (uint)pname, pointer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader] [glBindAttribLocationARB]</b>  </summary>
            public static void BindAttribLocation(GLHandleARB programObj, uint index, byte* name) => GLPointers._glBindAttribLocationARB_fnptr((IntPtr)programObj, index, name);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader] [glGetActiveAttribARB]</b>  </summary>
            public static void GetActiveAttrib(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, AttributeType* type, byte* name) => GLPointers._glGetActiveAttribARB_fnptr((IntPtr)programObj, index, maxLength, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader] [glGetAttribLocationARB]</b>  </summary>
            public static int GetAttribLocation(GLHandleARB programObj, byte* name) => GLPointers._glGetAttribLocationARB_fnptr((IntPtr)programObj, name);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP1ui]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP1ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP1uiv]</b>  </summary>
            public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP1uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP2ui]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP2ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP2uiv]</b>  </summary>
            public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP2uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP3ui]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP3ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP3uiv]</b>  </summary>
            public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP3uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP4ui]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP4ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexAttribP4uiv]</b>  </summary>
            public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP4uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP2ui]</b>  </summary>
            public static void VertexP2ui(VertexPointerType type, uint value) => GLPointers._glVertexP2ui_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP2uiv]</b>  </summary>
            public static void VertexP2uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP2uiv_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP3ui]</b>  </summary>
            public static void VertexP3ui(VertexPointerType type, uint value) => GLPointers._glVertexP3ui_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP3uiv]</b>  </summary>
            public static void VertexP3uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP3uiv_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP4ui]</b>  </summary>
            public static void VertexP4ui(VertexPointerType type, uint value) => GLPointers._glVertexP4ui_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glVertexP4uiv]</b>  </summary>
            public static void VertexP4uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP4uiv_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP1ui]</b>  </summary>
            public static void TexCoordP1ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP1ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP1uiv]</b>  </summary>
            public static void TexCoordP1uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP1uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP2ui]</b>  </summary>
            public static void TexCoordP2ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP2ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP2uiv]</b>  </summary>
            public static void TexCoordP2uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP2uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP3ui]</b>  </summary>
            public static void TexCoordP3ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP3ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP3uiv]</b>  </summary>
            public static void TexCoordP3uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP3uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP4ui]</b>  </summary>
            public static void TexCoordP4ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP4ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glTexCoordP4uiv]</b>  </summary>
            public static void TexCoordP4uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP4uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP1ui]</b>  </summary>
            public static void MultiTexCoordP1ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP1ui_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP1uiv]</b>  </summary>
            public static void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP1uiv_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP2ui]</b>  </summary>
            public static void MultiTexCoordP2ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP2ui_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP2uiv]</b>  </summary>
            public static void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP2uiv_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP3ui]</b>  </summary>
            public static void MultiTexCoordP3ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP3ui_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP3uiv]</b>  </summary>
            public static void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP3uiv_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP4ui]</b>  </summary>
            public static void MultiTexCoordP4ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP4ui_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glMultiTexCoordP4uiv]</b>  </summary>
            public static void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP4uiv_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glNormalP3ui]</b>  </summary>
            public static void NormalP3ui(NormalPointerType type, uint coords) => GLPointers._glNormalP3ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glNormalP3uiv]</b>  </summary>
            public static void NormalP3uiv(NormalPointerType type, uint* coords) => GLPointers._glNormalP3uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glColorP3ui]</b>  </summary>
            public static void ColorP3ui(ColorPointerType type, uint color) => GLPointers._glColorP3ui_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glColorP3uiv]</b>  </summary>
            public static void ColorP3uiv(ColorPointerType type, uint* color) => GLPointers._glColorP3uiv_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glColorP4ui]</b>  </summary>
            public static void ColorP4ui(ColorPointerType type, uint color) => GLPointers._glColorP4ui_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glColorP4uiv]</b>  </summary>
            public static void ColorP4uiv(ColorPointerType type, uint* color) => GLPointers._glColorP4uiv_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glSecondaryColorP3ui]</b>  </summary>
            public static void SecondaryColorP3ui(ColorPointerType type, uint color) => GLPointers._glSecondaryColorP3ui_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev] [glSecondaryColorP3uiv]</b>  </summary>
            public static void SecondaryColorP3uiv(ColorPointerType type, uint* color) => GLPointers._glSecondaryColorP3uiv_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glViewportArrayv]</b> Set multiple viewports. </summary>
            /// <param name="first"> Specify the first viewport to set. </param>
            /// <param name="count"> Specify the number of viewports to set. </param>
            /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml" /></remarks>
            public static void ViewportArrayv(uint first, int count, float* v) => GLPointers._glViewportArrayv_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glViewportIndexedf]</b> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
            public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => GLPointers._glViewportIndexedf_fnptr(index, x, y, w, h);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glViewportIndexedfv]</b> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
            public static void ViewportIndexedfv(uint index, float* v) => GLPointers._glViewportIndexedfv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glScissorArrayv]</b> Define the scissor box for multiple viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
            /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
            /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml" /></remarks>
            public static void ScissorArrayv(uint first, int count, int* v) => GLPointers._glScissorArrayv_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glScissorIndexed]</b> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
            public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => GLPointers._glScissorIndexed_fnptr(index, left, bottom, width, height);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glScissorIndexedv]</b> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
            public static void ScissorIndexedv(uint index, int* v) => GLPointers._glScissorIndexedv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glDepthRangeArrayv]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
            /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
            /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml" /></remarks>
            public static void DepthRangeArrayv(uint first, int count, double* v) => GLPointers._glDepthRangeArrayv_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glDepthRangeIndexed]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
            /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml" /></remarks>
            public static void DepthRangeIndexed(uint index, double n, double f) => GLPointers._glDepthRangeIndexed_fnptr(index, n, f);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glGetFloati_v]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetFloati_v(GetPName target, uint index, float* data) => GLPointers._glGetFloati_v_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array] [glGetDoublei_v]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetDoublei_v(GetPName target, uint index, double* data) => GLPointers._glGetDoublei_v_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_ARB_viewport_array] [glDepthRangeArraydvNV]</b>  </summary>
            public static void DepthRangeArraydvNV(uint first, int count, double* v) => GLPointers._glDepthRangeArraydvNV_fnptr(first, count, v);
            
            /// <summary> <b>[requires: GL_ARB_viewport_array] [glDepthRangeIndexeddNV]</b>  </summary>
            public static void DepthRangeIndexeddNV(uint index, double n, double f) => GLPointers._glDepthRangeIndexeddNV_fnptr(index, n, f);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos2dARB]</b>  </summary>
            public static void WindowPos2d(double x, double y) => GLPointers._glWindowPos2dARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos2dvARB]</b>  </summary>
            public static void WindowPos2dv(double* v) => GLPointers._glWindowPos2dvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos2fARB]</b>  </summary>
            public static void WindowPos2f(float x, float y) => GLPointers._glWindowPos2fARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos2fvARB]</b>  </summary>
            public static void WindowPos2fv(float* v) => GLPointers._glWindowPos2fvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos2iARB]</b>  </summary>
            public static void WindowPos2i(int x, int y) => GLPointers._glWindowPos2iARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos2ivARB]</b>  </summary>
            public static void WindowPos2iv(int* v) => GLPointers._glWindowPos2ivARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos2sARB]</b>  </summary>
            public static void WindowPos2s(short x, short y) => GLPointers._glWindowPos2sARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos2svARB]</b>  </summary>
            public static void WindowPos2sv(short* v) => GLPointers._glWindowPos2svARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos3dARB]</b>  </summary>
            public static void WindowPos3d(double x, double y, double z) => GLPointers._glWindowPos3dARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos3dvARB]</b>  </summary>
            public static void WindowPos3dv(double* v) => GLPointers._glWindowPos3dvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos3fARB]</b>  </summary>
            public static void WindowPos3f(float x, float y, float z) => GLPointers._glWindowPos3fARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos3fvARB]</b>  </summary>
            public static void WindowPos3fv(float* v) => GLPointers._glWindowPos3fvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos3iARB]</b>  </summary>
            public static void WindowPos3i(int x, int y, int z) => GLPointers._glWindowPos3iARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos3ivARB]</b>  </summary>
            public static void WindowPos3iv(int* v) => GLPointers._glWindowPos3ivARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos3sARB]</b>  </summary>
            public static void WindowPos3s(short x, short y, short z) => GLPointers._glWindowPos3sARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos] [glWindowPos3svARB]</b>  </summary>
            public static void WindowPos3sv(short* v) => GLPointers._glWindowPos3svARB_fnptr(v);
            
        }
        /// <summary>ATI extensions.</summary>
        public static unsafe partial class ATI
        {
            /// <summary> <b>[requires: GL_ATI_draw_buffers] [glDrawBuffersATI]</b>  </summary>
            public static void DrawBuffers(int n, DrawBufferMode* bufs) => GLPointers._glDrawBuffersATI_fnptr(n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_ATI_element_array] [glElementPointerATI]</b>  </summary>
            public static void ElementPointer(ElementPointerTypeATI type, void* pointer) => GLPointers._glElementPointerATI_fnptr((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_ATI_element_array] [glDrawElementArrayATI]</b>  </summary>
            public static void DrawElementArray(PrimitiveType mode, int count) => GLPointers._glDrawElementArrayATI_fnptr((uint)mode, count);
            
            /// <summary> <b>[requires: GL_ATI_element_array] [glDrawRangeElementArrayATI]</b>  </summary>
            public static void DrawRangeElementArray(PrimitiveType mode, uint start, uint end, int count) => GLPointers._glDrawRangeElementArrayATI_fnptr((uint)mode, start, end, count);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap] [glTexBumpParameterivATI]</b>  </summary>
            public static void TexBumpParameteriv(TexBumpParameterATI pname, int* param) => GLPointers._glTexBumpParameterivATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap] [glTexBumpParameterfvATI]</b>  </summary>
            public static void TexBumpParameterfv(TexBumpParameterATI pname, float* param) => GLPointers._glTexBumpParameterfvATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap] [glGetTexBumpParameterivATI]</b>  </summary>
            public static void GetTexBumpParameteriv(GetTexBumpParameterATI pname, int* param) => GLPointers._glGetTexBumpParameterivATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap] [glGetTexBumpParameterfvATI]</b>  </summary>
            public static void GetTexBumpParameterfv(GetTexBumpParameterATI pname, float* param) => GLPointers._glGetTexBumpParameterfvATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glGenFragmentShadersATI]</b>  </summary>
            public static uint GenFragmentShaders(uint range) => GLPointers._glGenFragmentShadersATI_fnptr(range);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glBindFragmentShaderATI]</b>  </summary>
            public static void BindFragmentShader(uint id) => GLPointers._glBindFragmentShaderATI_fnptr(id);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glDeleteFragmentShaderATI]</b>  </summary>
            public static void DeleteFragmentShader(uint id) => GLPointers._glDeleteFragmentShaderATI_fnptr(id);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glBeginFragmentShaderATI]</b>  </summary>
            public static void BeginFragmentShader() => GLPointers._glBeginFragmentShaderATI_fnptr();
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glEndFragmentShaderATI]</b>  </summary>
            public static void EndFragmentShader() => GLPointers._glEndFragmentShaderATI_fnptr();
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glPassTexCoordATI]</b>  </summary>
            public static void PassTexCoord(FragmentShaderRegATI dst, FragmentShaderTextureSourceATI coord, SwizzleOpATI swizzle) => GLPointers._glPassTexCoordATI_fnptr((uint)dst, (uint)coord, (uint)swizzle);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glSampleMapATI]</b>  </summary>
            public static void SampleMap(FragmentShaderRegATI dst, FragmentShaderTextureSourceATI interp, SwizzleOpATI swizzle) => GLPointers._glSampleMapATI_fnptr((uint)dst, (uint)interp, (uint)swizzle);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glColorFragmentOp1ATI]</b>  </summary>
            public static void ColorFragmentOp1(FragmentOp1ATI op, FragmentShaderRegATI dst, FragmentShaderDestMaskATI dstMask, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod) => GLPointers._glColorFragmentOp1ATI_fnptr((uint)op, (uint)dst, (uint)dstMask, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glColorFragmentOp2ATI]</b>  </summary>
            public static void ColorFragmentOp2(FragmentOp2ATI op, FragmentShaderRegATI dst, FragmentShaderDestMaskATI dstMask, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod) => GLPointers._glColorFragmentOp2ATI_fnptr((uint)op, (uint)dst, (uint)dstMask, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glColorFragmentOp3ATI]</b>  </summary>
            public static void ColorFragmentOp3(FragmentOp3ATI op, FragmentShaderRegATI dst, FragmentShaderDestMaskATI dstMask, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod, FragmentShaderGenericSourceATI arg3, FragmentShaderValueRepATI arg3Rep, FragmentShaderColorModMaskATI arg3Mod) => GLPointers._glColorFragmentOp3ATI_fnptr((uint)op, (uint)dst, (uint)dstMask, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod, (uint)arg3, (uint)arg3Rep, (uint)arg3Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glAlphaFragmentOp1ATI]</b>  </summary>
            public static void AlphaFragmentOp1(FragmentOp1ATI op, FragmentShaderRegATI dst, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod) => GLPointers._glAlphaFragmentOp1ATI_fnptr((uint)op, (uint)dst, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glAlphaFragmentOp2ATI]</b>  </summary>
            public static void AlphaFragmentOp2(FragmentOp2ATI op, FragmentShaderRegATI dst, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod) => GLPointers._glAlphaFragmentOp2ATI_fnptr((uint)op, (uint)dst, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glAlphaFragmentOp3ATI]</b>  </summary>
            public static void AlphaFragmentOp3(FragmentOp3ATI op, FragmentShaderRegATI dst, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod, FragmentShaderGenericSourceATI arg3, FragmentShaderValueRepATI arg3Rep, FragmentShaderColorModMaskATI arg3Mod) => GLPointers._glAlphaFragmentOp3ATI_fnptr((uint)op, (uint)dst, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod, (uint)arg3, (uint)arg3Rep, (uint)arg3Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader] [glSetFragmentShaderConstantATI]</b>  </summary>
            public static void SetFragmentShaderConstant(FragmentShaderConATI dst, float* value) => GLPointers._glSetFragmentShaderConstantATI_fnptr((uint)dst, value);
            
            /// <summary> <b>[requires: GL_ATI_map_object_buffer] [glMapObjectBufferATI]</b>  </summary>
            public static void* MapObjectBuffer(int buffer) => GLPointers._glMapObjectBufferATI_fnptr(buffer);
            
            /// <summary> <b>[requires: GL_ATI_map_object_buffer] [glUnmapObjectBufferATI]</b>  </summary>
            public static void UnmapObjectBuffer(int buffer) => GLPointers._glUnmapObjectBufferATI_fnptr(buffer);
            
            /// <summary> <b>[requires: GL_ATI_pn_triangles] [glPNTrianglesiATI]</b>  </summary>
            public static void PNTrianglesi(PNTrianglesPNameATI pname, int param) => GLPointers._glPNTrianglesiATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_pn_triangles] [glPNTrianglesfATI]</b>  </summary>
            public static void PNTrianglesf(PNTrianglesPNameATI pname, float param) => GLPointers._glPNTrianglesfATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_separate_stencil] [glStencilOpSeparateATI]</b>  </summary>
            public static void StencilOpSeparate(TriangleFace face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => GLPointers._glStencilOpSeparateATI_fnptr((uint)face, (uint)sfail, (uint)dpfail, (uint)dppass);
            
            /// <summary> <b>[requires: GL_ATI_separate_stencil] [glStencilFuncSeparateATI]</b>  </summary>
            public static void StencilFuncSeparate(StencilFunction frontfunc, StencilFunction backfunc, int reference, uint mask) => GLPointers._glStencilFuncSeparateATI_fnptr((uint)frontfunc, (uint)backfunc, reference, mask);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glNewObjectBufferATI]</b>  </summary>
            public static uint NewObjectBuffer(int size, void* pointer, ArrayObjectUsageATI usage) => GLPointers._glNewObjectBufferATI_fnptr(size, pointer, (uint)usage);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glIsObjectBufferATI]</b>  </summary>
            public static bool IsObjectBuffer(int buffer) => GLPointers._glIsObjectBufferATI_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glUpdateObjectBufferATI]</b>  </summary>
            public static void UpdateObjectBuffer(int buffer, uint offset, int size, void* pointer, PreserveModeATI preserve) => GLPointers._glUpdateObjectBufferATI_fnptr(buffer, offset, size, pointer, (uint)preserve);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glGetObjectBufferfvATI]</b>  </summary>
            public static void GetObjectBufferfv(int buffer, ArrayObjectPNameATI pname, float* parameters) => GLPointers._glGetObjectBufferfvATI_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glGetObjectBufferivATI]</b>  </summary>
            public static void GetObjectBufferiv(int buffer, ArrayObjectPNameATI pname, int* parameters) => GLPointers._glGetObjectBufferivATI_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glFreeObjectBufferATI]</b>  </summary>
            public static void FreeObjectBuffer(int buffer) => GLPointers._glFreeObjectBufferATI_fnptr(buffer);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glArrayObjectATI]</b>  </summary>
            public static void ArrayObject(EnableCap array, int size, ScalarType type, int stride, int buffer, uint offset) => GLPointers._glArrayObjectATI_fnptr((uint)array, size, (uint)type, stride, buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glGetArrayObjectfvATI]</b>  </summary>
            public static void GetArrayObjectfv(EnableCap array, ArrayObjectPNameATI pname, float* parameters) => GLPointers._glGetArrayObjectfvATI_fnptr((uint)array, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glGetArrayObjectivATI]</b>  </summary>
            public static void GetArrayObjectiv(EnableCap array, ArrayObjectPNameATI pname, int* parameters) => GLPointers._glGetArrayObjectivATI_fnptr((uint)array, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glVariantArrayObjectATI]</b>  </summary>
            public static void VariantArrayObject(uint id, ScalarType type, int stride, int buffer, uint offset) => GLPointers._glVariantArrayObjectATI_fnptr(id, (uint)type, stride, buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glGetVariantArrayObjectfvATI]</b>  </summary>
            public static void GetVariantArrayObjectfv(uint id, ArrayObjectPNameATI pname, float* parameters) => GLPointers._glGetVariantArrayObjectfvATI_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object] [glGetVariantArrayObjectivATI]</b>  </summary>
            public static void GetVariantArrayObjectiv(uint id, ArrayObjectPNameATI pname, int* parameters) => GLPointers._glGetVariantArrayObjectivATI_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object] [glVertexAttribArrayObjectATI]</b>  </summary>
            public static void VertexAttribArrayObject(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, int buffer, uint offset) => GLPointers._glVertexAttribArrayObjectATI_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object] [glGetVertexAttribArrayObjectfvATI]</b>  </summary>
            public static void GetVertexAttribArrayObjectfv(uint index, ArrayObjectPNameATI pname, float* parameters) => GLPointers._glGetVertexAttribArrayObjectfvATI_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object] [glGetVertexAttribArrayObjectivATI]</b>  </summary>
            public static void GetVertexAttribArrayObjectiv(uint index, ArrayObjectPNameATI pname, int* parameters) => GLPointers._glGetVertexAttribArrayObjectivATI_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream1sATI]</b>  </summary>
            public static void VertexStream1s(VertexStreamATI stream, short x) => GLPointers._glVertexStream1sATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream1svATI]</b>  </summary>
            public static void VertexStream1sv(VertexStreamATI stream, short* coords) => GLPointers._glVertexStream1svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream1iATI]</b>  </summary>
            public static void VertexStream1i(VertexStreamATI stream, int x) => GLPointers._glVertexStream1iATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream1ivATI]</b>  </summary>
            public static void VertexStream1iv(VertexStreamATI stream, int* coords) => GLPointers._glVertexStream1ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream1fATI]</b>  </summary>
            public static void VertexStream1f(VertexStreamATI stream, float x) => GLPointers._glVertexStream1fATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream1fvATI]</b>  </summary>
            public static void VertexStream1fv(VertexStreamATI stream, float* coords) => GLPointers._glVertexStream1fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream1dATI]</b>  </summary>
            public static void VertexStream1d(VertexStreamATI stream, double x) => GLPointers._glVertexStream1dATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream1dvATI]</b>  </summary>
            public static void VertexStream1dv(VertexStreamATI stream, double* coords) => GLPointers._glVertexStream1dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream2sATI]</b>  </summary>
            public static void VertexStream2s(VertexStreamATI stream, short x, short y) => GLPointers._glVertexStream2sATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream2svATI]</b>  </summary>
            public static void VertexStream2sv(VertexStreamATI stream, short* coords) => GLPointers._glVertexStream2svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream2iATI]</b>  </summary>
            public static void VertexStream2i(VertexStreamATI stream, int x, int y) => GLPointers._glVertexStream2iATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream2ivATI]</b>  </summary>
            public static void VertexStream2iv(VertexStreamATI stream, int* coords) => GLPointers._glVertexStream2ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream2fATI]</b>  </summary>
            public static void VertexStream2f(VertexStreamATI stream, float x, float y) => GLPointers._glVertexStream2fATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream2fvATI]</b>  </summary>
            public static void VertexStream2fv(VertexStreamATI stream, float* coords) => GLPointers._glVertexStream2fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream2dATI]</b>  </summary>
            public static void VertexStream2d(VertexStreamATI stream, double x, double y) => GLPointers._glVertexStream2dATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream2dvATI]</b>  </summary>
            public static void VertexStream2dv(VertexStreamATI stream, double* coords) => GLPointers._glVertexStream2dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream3sATI]</b>  </summary>
            public static void VertexStream3s(VertexStreamATI stream, short x, short y, short z) => GLPointers._glVertexStream3sATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream3svATI]</b>  </summary>
            public static void VertexStream3sv(VertexStreamATI stream, short* coords) => GLPointers._glVertexStream3svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream3iATI]</b>  </summary>
            public static void VertexStream3i(VertexStreamATI stream, int x, int y, int z) => GLPointers._glVertexStream3iATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream3ivATI]</b>  </summary>
            public static void VertexStream3iv(VertexStreamATI stream, int* coords) => GLPointers._glVertexStream3ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream3fATI]</b>  </summary>
            public static void VertexStream3f(VertexStreamATI stream, float x, float y, float z) => GLPointers._glVertexStream3fATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream3fvATI]</b>  </summary>
            public static void VertexStream3fv(VertexStreamATI stream, float* coords) => GLPointers._glVertexStream3fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream3dATI]</b>  </summary>
            public static void VertexStream3d(VertexStreamATI stream, double x, double y, double z) => GLPointers._glVertexStream3dATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream3dvATI]</b>  </summary>
            public static void VertexStream3dv(VertexStreamATI stream, double* coords) => GLPointers._glVertexStream3dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream4sATI]</b>  </summary>
            public static void VertexStream4s(VertexStreamATI stream, short x, short y, short z, short w) => GLPointers._glVertexStream4sATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream4svATI]</b>  </summary>
            public static void VertexStream4sv(VertexStreamATI stream, short* coords) => GLPointers._glVertexStream4svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream4iATI]</b>  </summary>
            public static void VertexStream4i(VertexStreamATI stream, int x, int y, int z, int w) => GLPointers._glVertexStream4iATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream4ivATI]</b>  </summary>
            public static void VertexStream4iv(VertexStreamATI stream, int* coords) => GLPointers._glVertexStream4ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream4fATI]</b>  </summary>
            public static void VertexStream4f(VertexStreamATI stream, float x, float y, float z, float w) => GLPointers._glVertexStream4fATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream4fvATI]</b>  </summary>
            public static void VertexStream4fv(VertexStreamATI stream, float* coords) => GLPointers._glVertexStream4fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream4dATI]</b>  </summary>
            public static void VertexStream4d(VertexStreamATI stream, double x, double y, double z, double w) => GLPointers._glVertexStream4dATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexStream4dvATI]</b>  </summary>
            public static void VertexStream4dv(VertexStreamATI stream, double* coords) => GLPointers._glVertexStream4dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3bATI]</b>  </summary>
            public static void NormalStream3b(VertexStreamATI stream, sbyte nx, sbyte ny, sbyte nz) => GLPointers._glNormalStream3bATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3bvATI]</b>  </summary>
            public static void NormalStream3bv(VertexStreamATI stream, sbyte* coords) => GLPointers._glNormalStream3bvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3sATI]</b>  </summary>
            public static void NormalStream3s(VertexStreamATI stream, short nx, short ny, short nz) => GLPointers._glNormalStream3sATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3svATI]</b>  </summary>
            public static void NormalStream3sv(VertexStreamATI stream, short* coords) => GLPointers._glNormalStream3svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3iATI]</b>  </summary>
            public static void NormalStream3i(VertexStreamATI stream, int nx, int ny, int nz) => GLPointers._glNormalStream3iATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3ivATI]</b>  </summary>
            public static void NormalStream3iv(VertexStreamATI stream, int* coords) => GLPointers._glNormalStream3ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3fATI]</b>  </summary>
            public static void NormalStream3f(VertexStreamATI stream, float nx, float ny, float nz) => GLPointers._glNormalStream3fATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3fvATI]</b>  </summary>
            public static void NormalStream3fv(VertexStreamATI stream, float* coords) => GLPointers._glNormalStream3fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3dATI]</b>  </summary>
            public static void NormalStream3d(VertexStreamATI stream, double nx, double ny, double nz) => GLPointers._glNormalStream3dATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glNormalStream3dvATI]</b>  </summary>
            public static void NormalStream3dv(VertexStreamATI stream, double* coords) => GLPointers._glNormalStream3dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glClientActiveVertexStreamATI]</b>  </summary>
            public static void ClientActiveVertexStream(VertexStreamATI stream) => GLPointers._glClientActiveVertexStreamATI_fnptr((uint)stream);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexBlendEnviATI]</b>  </summary>
            public static void VertexBlendEnvi(VertexStreamATI pname, int param) => GLPointers._glVertexBlendEnviATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams] [glVertexBlendEnvfATI]</b>  </summary>
            public static void VertexBlendEnvf(VertexStreamATI pname, float param) => GLPointers._glVertexBlendEnvfATI_fnptr((uint)pname, param);
            
        }
        /// <summary>EXT extensions.</summary>
        public static unsafe partial class EXT
        {
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage] [glEGLImageTargetTexStorageEXT]</b>  </summary>
            public static void EGLImageTargetTexStorage(All target, void* image, int* attrib_list) => GLPointers._glEGLImageTargetTexStorageEXT_fnptr((uint)target, image, attrib_list);
            
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage] [glEGLImageTargetTextureStorageEXT]</b>  </summary>
            public static void EGLImageTargetTextureStorage(int texture, void* image, int* attrib_list) => GLPointers._glEGLImageTargetTextureStorageEXT_fnptr(texture, image, attrib_list);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform] [glUniformBufferEXT]</b>  </summary>
            public static void UniformBuffer(int program, int location, int buffer) => GLPointers._glUniformBufferEXT_fnptr(program, location, buffer);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform] [glGetUniformBufferSizeEXT]</b>  </summary>
            public static int GetUniformBufferSize(int program, int location) => GLPointers._glGetUniformBufferSizeEXT_fnptr(program, location);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform] [glGetUniformOffsetEXT]</b>  </summary>
            public static IntPtr GetUniformOffset(int program, int location) => GLPointers._glGetUniformOffsetEXT_fnptr(program, location);
            
            /// <summary> <b>[requires: GL_EXT_blend_color] [glBlendColorEXT]</b>  </summary>
            public static void BlendColor(float red, float green, float blue, float alpha) => GLPointers._glBlendColorEXT_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_equation_separate] [glBlendEquationSeparateEXT]</b>  </summary>
            public static void BlendEquationSeparate(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparateEXT_fnptr((uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_func_separate] [glBlendFuncSeparateEXT]</b>  </summary>
            public static void BlendFuncSeparate(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers._glBlendFuncSeparateEXT_fnptr((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_minmax] [glBlendEquationEXT]</b>  </summary>
            public static void BlendEquation(BlendEquationModeEXT mode) => GLPointers._glBlendEquationEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_color_subtable] [glColorSubTableEXT]</b>  </summary>
            public static void ColorSubTable(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data) => GLPointers._glColorSubTableEXT_fnptr((uint)target, start, count, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_color_subtable] [glCopyColorSubTableEXT]</b>  </summary>
            public static void CopyColorSubTable(ColorTableTarget target, int start, int x, int y, int width) => GLPointers._glCopyColorSubTableEXT_fnptr((uint)target, start, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array] [glLockArraysEXT]</b>  </summary>
            public static void LockArrays(int first, int count) => GLPointers._glLockArraysEXT_fnptr(first, count);
            
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array] [glUnlockArraysEXT]</b>  </summary>
            public static void UnlockArrays() => GLPointers._glUnlockArraysEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glConvolutionFilter1DEXT]</b>  </summary>
            public static void ConvolutionFilter1D(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image) => GLPointers._glConvolutionFilter1DEXT_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glConvolutionFilter2DEXT]</b>  </summary>
            public static void ConvolutionFilter2D(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image) => GLPointers._glConvolutionFilter2DEXT_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glConvolutionParameterfEXT]</b>  </summary>
            public static void ConvolutionParameterf(ConvolutionTargetEXT target, ConvolutionParameter pname, float parameters) => GLPointers._glConvolutionParameterfEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glConvolutionParameterfvEXT]</b>  </summary>
            public static void ConvolutionParameterfv(ConvolutionTargetEXT target, ConvolutionParameter pname, float* parameters) => GLPointers._glConvolutionParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glConvolutionParameteriEXT]</b>  </summary>
            public static void ConvolutionParameteri(ConvolutionTargetEXT target, ConvolutionParameter pname, int parameters) => GLPointers._glConvolutionParameteriEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glConvolutionParameterivEXT]</b>  </summary>
            public static void ConvolutionParameteriv(ConvolutionTargetEXT target, ConvolutionParameter pname, int* parameters) => GLPointers._glConvolutionParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glCopyConvolutionFilter1DEXT]</b>  </summary>
            public static void CopyConvolutionFilter1D(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width) => GLPointers._glCopyConvolutionFilter1DEXT_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glCopyConvolutionFilter2DEXT]</b>  </summary>
            public static void CopyConvolutionFilter2D(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width, int height) => GLPointers._glCopyConvolutionFilter2DEXT_fnptr((uint)target, (uint)internalformat, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glGetConvolutionFilterEXT]</b>  </summary>
            public static void GetConvolutionFilter(ConvolutionTargetEXT target, PixelFormat format, PixelType type, void* image) => GLPointers._glGetConvolutionFilterEXT_fnptr((uint)target, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glGetConvolutionParameterfvEXT]</b>  </summary>
            public static void GetConvolutionParameterfv(ConvolutionTargetEXT target, ConvolutionParameter pname, float* parameters) => GLPointers._glGetConvolutionParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glGetConvolutionParameterivEXT]</b>  </summary>
            public static void GetConvolutionParameteriv(ConvolutionTargetEXT target, ConvolutionParameter pname, int* parameters) => GLPointers._glGetConvolutionParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glGetSeparableFilterEXT]</b>  </summary>
            public static void GetSeparableFilter(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span) => GLPointers._glGetSeparableFilterEXT_fnptr((uint)target, (uint)format, (uint)type, row, column, span);
            
            /// <summary> <b>[requires: GL_EXT_convolution] [glSeparableFilter2DEXT]</b>  </summary>
            public static void SeparableFilter2D(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column) => GLPointers._glSeparableFilter2DEXT_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, row, column);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3bEXT]</b>  </summary>
            public static void Tangent3b(sbyte tx, sbyte ty, sbyte tz) => GLPointers._glTangent3bEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3bvEXT]</b>  </summary>
            public static void Tangent3bv(sbyte* v) => GLPointers._glTangent3bvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3dEXT]</b>  </summary>
            public static void Tangent3d(double tx, double ty, double tz) => GLPointers._glTangent3dEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3dvEXT]</b>  </summary>
            public static void Tangent3dv(double* v) => GLPointers._glTangent3dvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3fEXT]</b>  </summary>
            public static void Tangent3f(float tx, float ty, float tz) => GLPointers._glTangent3fEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3fvEXT]</b>  </summary>
            public static void Tangent3fv(float* v) => GLPointers._glTangent3fvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3iEXT]</b>  </summary>
            public static void Tangent3i(int tx, int ty, int tz) => GLPointers._glTangent3iEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3ivEXT]</b>  </summary>
            public static void Tangent3iv(int* v) => GLPointers._glTangent3ivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3sEXT]</b>  </summary>
            public static void Tangent3s(short tx, short ty, short tz) => GLPointers._glTangent3sEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangent3svEXT]</b>  </summary>
            public static void Tangent3sv(short* v) => GLPointers._glTangent3svEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3bEXT]</b>  </summary>
            public static void Binormal3b(sbyte bx, sbyte by, sbyte bz) => GLPointers._glBinormal3bEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3bvEXT]</b>  </summary>
            public static void Binormal3bv(sbyte* v) => GLPointers._glBinormal3bvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3dEXT]</b>  </summary>
            public static void Binormal3d(double bx, double by, double bz) => GLPointers._glBinormal3dEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3dvEXT]</b>  </summary>
            public static void Binormal3dv(double* v) => GLPointers._glBinormal3dvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3fEXT]</b>  </summary>
            public static void Binormal3f(float bx, float by, float bz) => GLPointers._glBinormal3fEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3fvEXT]</b>  </summary>
            public static void Binormal3fv(float* v) => GLPointers._glBinormal3fvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3iEXT]</b>  </summary>
            public static void Binormal3i(int bx, int by, int bz) => GLPointers._glBinormal3iEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3ivEXT]</b>  </summary>
            public static void Binormal3iv(int* v) => GLPointers._glBinormal3ivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3sEXT]</b>  </summary>
            public static void Binormal3s(short bx, short by, short bz) => GLPointers._glBinormal3sEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormal3svEXT]</b>  </summary>
            public static void Binormal3sv(short* v) => GLPointers._glBinormal3svEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glTangentPointerEXT]</b>  </summary>
            public static void TangentPointer(TangentPointerTypeEXT type, int stride, void* pointer) => GLPointers._glTangentPointerEXT_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame] [glBinormalPointerEXT]</b>  </summary>
            public static void BinormalPointer(BinormalPointerTypeEXT type, int stride, void* pointer) => GLPointers._glBinormalPointerEXT_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture] [glCopyTexImage1DEXT]</b>  </summary>
            public static void CopyTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._glCopyTexImage1DEXT_fnptr((uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture] [glCopyTexImage2DEXT]</b>  </summary>
            public static void CopyTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._glCopyTexImage2DEXT_fnptr((uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture] [glCopyTexSubImage1DEXT]</b>  </summary>
            public static void CopyTexSubImage1D(TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTexSubImage1DEXT_fnptr((uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture] [glCopyTexSubImage2DEXT]</b>  </summary>
            public static void CopyTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTexSubImage2DEXT_fnptr((uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture] [glCopyTexSubImage3DEXT]</b>  </summary>
            public static void CopyTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTexSubImage3DEXT_fnptr((uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_cull_vertex] [glCullParameterdvEXT]</b>  </summary>
            public static void CullParameterdv(CullParameterEXT pname, double* parameters) => GLPointers._glCullParameterdvEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_cull_vertex] [glCullParameterfvEXT]</b>  </summary>
            public static void CullParameterfv(CullParameterEXT pname, float* parameters) => GLPointers._glCullParameterfvEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_debug_label] [glLabelObjectEXT]</b>  </summary>
            public static void LabelObject(All type, uint obj, int length, byte* label) => GLPointers._glLabelObjectEXT_fnptr((uint)type, obj, length, label);
            
            /// <summary> <b>[requires: GL_EXT_debug_label] [glGetObjectLabelEXT]</b>  </summary>
            public static void GetObjectLabel(All type, uint obj, int bufSize, int* length, byte* label) => GLPointers._glGetObjectLabelEXT_fnptr((uint)type, obj, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker] [glInsertEventMarkerEXT]</b>  </summary>
            public static void InsertEventMarker(int length, byte* marker) => GLPointers._glInsertEventMarkerEXT_fnptr(length, marker);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker] [glPushGroupMarkerEXT]</b>  </summary>
            public static void PushGroupMarker(int length, byte* marker) => GLPointers._glPushGroupMarkerEXT_fnptr(length, marker);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker] [glPopGroupMarkerEXT]</b>  </summary>
            public static void PopGroupMarker() => GLPointers._glPopGroupMarkerEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_depth_bounds_test] [glDepthBoundsEXT]</b>  </summary>
            public static void DepthBounds(double zmin, double zmax) => GLPointers._glDepthBoundsEXT_fnptr(zmin, zmax);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoadfEXT]</b>  </summary>
            public static void MatrixLoadf(MatrixMode mode, float* m) => GLPointers._glMatrixLoadfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoaddEXT]</b>  </summary>
            public static void MatrixLoadd(MatrixMode mode, double* m) => GLPointers._glMatrixLoaddEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixMultfEXT]</b>  </summary>
            public static void MatrixMultf(MatrixMode mode, float* m) => GLPointers._glMatrixMultfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixMultdEXT]</b>  </summary>
            public static void MatrixMultd(MatrixMode mode, double* m) => GLPointers._glMatrixMultdEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoadIdentityEXT]</b>  </summary>
            public static void MatrixLoadIdentity(MatrixMode mode) => GLPointers._glMatrixLoadIdentityEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixRotatefEXT]</b>  </summary>
            public static void MatrixRotatef(MatrixMode mode, float angle, float x, float y, float z) => GLPointers._glMatrixRotatefEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixRotatedEXT]</b>  </summary>
            public static void MatrixRotated(MatrixMode mode, double angle, double x, double y, double z) => GLPointers._glMatrixRotatedEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixScalefEXT]</b>  </summary>
            public static void MatrixScalef(MatrixMode mode, float x, float y, float z) => GLPointers._glMatrixScalefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixScaledEXT]</b>  </summary>
            public static void MatrixScaled(MatrixMode mode, double x, double y, double z) => GLPointers._glMatrixScaledEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixTranslatefEXT]</b>  </summary>
            public static void MatrixTranslatef(MatrixMode mode, float x, float y, float z) => GLPointers._glMatrixTranslatefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixTranslatedEXT]</b>  </summary>
            public static void MatrixTranslated(MatrixMode mode, double x, double y, double z) => GLPointers._glMatrixTranslatedEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixFrustumEXT]</b>  </summary>
            public static void MatrixFrustum(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glMatrixFrustumEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixOrthoEXT]</b>  </summary>
            public static void MatrixOrtho(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glMatrixOrthoEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixPopEXT]</b>  </summary>
            public static void MatrixPop(MatrixMode mode) => GLPointers._glMatrixPopEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixPushEXT]</b>  </summary>
            public static void MatrixPush(MatrixMode mode) => GLPointers._glMatrixPushEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glClientAttribDefaultEXT]</b>  </summary>
            public static void ClientAttribDefault(ClientAttribMask mask) => GLPointers._glClientAttribDefaultEXT_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glPushClientAttribDefaultEXT]</b>  </summary>
            public static void PushClientAttribDefault(ClientAttribMask mask) => GLPointers._glPushClientAttribDefaultEXT_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureParameterfEXT]</b>  </summary>
            public static void TextureParameterf(int texture, TextureTarget target, TextureParameterName pname, float param) => GLPointers._glTextureParameterfEXT_fnptr(texture, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureParameterfvEXT]</b>  </summary>
            public static void TextureParameterfv(int texture, TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers._glTextureParameterfvEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureParameteriEXT]</b>  </summary>
            public static void TextureParameteri(int texture, TextureTarget target, TextureParameterName pname, int param) => GLPointers._glTextureParameteriEXT_fnptr(texture, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureParameterivEXT]</b>  </summary>
            public static void TextureParameteriv(int texture, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTextureParameterivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureImage1DEXT]</b>  </summary>
            public static void TextureImage1D(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureImage1DEXT_fnptr(texture, (uint)target, level, (int)internalformat, width, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureImage2DEXT]</b>  </summary>
            public static void TextureImage2D(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureImage2DEXT_fnptr(texture, (uint)target, level, (int)internalformat, width, height, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureSubImage1DEXT]</b>  </summary>
            public static void TextureSubImage1D(int texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage1DEXT_fnptr(texture, (uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureSubImage2DEXT]</b>  </summary>
            public static void TextureSubImage2D(int texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage2DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyTextureImage1DEXT]</b>  </summary>
            public static void CopyTextureImage1D(int texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._glCopyTextureImage1DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyTextureImage2DEXT]</b>  </summary>
            public static void CopyTextureImage2D(int texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._glCopyTextureImage2DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyTextureSubImage1DEXT]</b>  </summary>
            public static void CopyTextureSubImage1D(int texture, TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTextureSubImage1DEXT_fnptr(texture, (uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyTextureSubImage2DEXT]</b>  </summary>
            public static void CopyTextureSubImage2D(int texture, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage2DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetTextureImageEXT]</b>  </summary>
            public static void GetTextureImage(int texture, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers._glGetTextureImageEXT_fnptr(texture, (uint)target, level, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetTextureParameterfvEXT]</b>  </summary>
            public static void GetTextureParameterfv(int texture, TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureParameterfvEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetTextureParameterivEXT]</b>  </summary>
            public static void GetTextureParameteriv(int texture, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameterivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetTextureLevelParameterfvEXT]</b>  </summary>
            public static void GetTextureLevelParameterfv(int texture, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureLevelParameterfvEXT_fnptr(texture, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetTextureLevelParameterivEXT]</b>  </summary>
            public static void GetTextureLevelParameteriv(int texture, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureLevelParameterivEXT_fnptr(texture, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureImage3DEXT]</b>  </summary>
            public static void TextureImage3D(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureImage3DEXT_fnptr(texture, (uint)target, level, (int)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureSubImage3DEXT]</b>  </summary>
            public static void TextureSubImage3D(int texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage3DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyTextureSubImage3DEXT]</b>  </summary>
            public static void CopyTextureSubImage3D(int texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage3DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glBindMultiTextureEXT]</b>  </summary>
            public static void BindMultiTexture(TextureUnit texunit, TextureTarget target, int texture) => GLPointers._glBindMultiTextureEXT_fnptr((uint)texunit, (uint)target, texture);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexCoordPointerEXT]</b>  </summary>
            public static void MultiTexCoordPointer(TextureUnit texunit, int size, TexCoordPointerType type, int stride, void* pointer) => GLPointers._glMultiTexCoordPointerEXT_fnptr((uint)texunit, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexEnvfEXT]</b>  </summary>
            public static void MultiTexEnvf(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float param) => GLPointers._glMultiTexEnvfEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexEnvfvEXT]</b>  </summary>
            public static void MultiTexEnvfv(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._glMultiTexEnvfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexEnviEXT]</b>  </summary>
            public static void MultiTexEnvi(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers._glMultiTexEnviEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexEnvivEXT]</b>  </summary>
            public static void MultiTexEnviv(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glMultiTexEnvivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexGendEXT]</b>  </summary>
            public static void MultiTexGend(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double param) => GLPointers._glMultiTexGendEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexGendvEXT]</b>  </summary>
            public static void MultiTexGendv(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._glMultiTexGendvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexGenfEXT]</b>  </summary>
            public static void MultiTexGenf(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float param) => GLPointers._glMultiTexGenfEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexGenfvEXT]</b>  </summary>
            public static void MultiTexGenfv(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._glMultiTexGenfvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexGeniEXT]</b>  </summary>
            public static void MultiTexGeni(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers._glMultiTexGeniEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexGenivEXT]</b>  </summary>
            public static void MultiTexGeniv(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glMultiTexGenivEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexEnvfvEXT]</b>  </summary>
            public static void GetMultiTexEnvfv(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._glGetMultiTexEnvfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexEnvivEXT]</b>  </summary>
            public static void GetMultiTexEnviv(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glGetMultiTexEnvivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexGendvEXT]</b>  </summary>
            public static void GetMultiTexGendv(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._glGetMultiTexGendvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexGenfvEXT]</b>  </summary>
            public static void GetMultiTexGenfv(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._glGetMultiTexGenfvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexGenivEXT]</b>  </summary>
            public static void GetMultiTexGeniv(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glGetMultiTexGenivEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexParameteriEXT]</b>  </summary>
            public static void MultiTexParameteri(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int param) => GLPointers._glMultiTexParameteriEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexParameterivEXT]</b>  </summary>
            public static void MultiTexParameteriv(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glMultiTexParameterivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexParameterfEXT]</b>  </summary>
            public static void MultiTexParameterf(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float param) => GLPointers._glMultiTexParameterfEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexParameterfvEXT]</b>  </summary>
            public static void MultiTexParameterfv(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers._glMultiTexParameterfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexImage1DEXT]</b>  </summary>
            public static void MultiTexImage1D(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexImage1DEXT_fnptr((uint)texunit, (uint)target, level, (int)internalformat, width, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexImage2DEXT]</b>  </summary>
            public static void MultiTexImage2D(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexImage2DEXT_fnptr((uint)texunit, (uint)target, level, (int)internalformat, width, height, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexSubImage1DEXT]</b>  </summary>
            public static void MultiTexSubImage1D(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexSubImage1DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexSubImage2DEXT]</b>  </summary>
            public static void MultiTexSubImage2D(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexSubImage2DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyMultiTexImage1DEXT]</b>  </summary>
            public static void CopyMultiTexImage1D(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._glCopyMultiTexImage1DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyMultiTexImage2DEXT]</b>  </summary>
            public static void CopyMultiTexImage2D(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._glCopyMultiTexImage2DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyMultiTexSubImage1DEXT]</b>  </summary>
            public static void CopyMultiTexSubImage1D(TextureUnit texunit, TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyMultiTexSubImage1DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyMultiTexSubImage2DEXT]</b>  </summary>
            public static void CopyMultiTexSubImage2D(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyMultiTexSubImage2DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexImageEXT]</b>  </summary>
            public static void GetMultiTexImage(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers._glGetMultiTexImageEXT_fnptr((uint)texunit, (uint)target, level, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexParameterfvEXT]</b>  </summary>
            public static void GetMultiTexParameterfv(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers._glGetMultiTexParameterfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexParameterivEXT]</b>  </summary>
            public static void GetMultiTexParameteriv(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetMultiTexParameterivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexLevelParameterfvEXT]</b>  </summary>
            public static void GetMultiTexLevelParameterfv(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetMultiTexLevelParameterfvEXT_fnptr((uint)texunit, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexLevelParameterivEXT]</b>  </summary>
            public static void GetMultiTexLevelParameteriv(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetMultiTexLevelParameterivEXT_fnptr((uint)texunit, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexImage3DEXT]</b>  </summary>
            public static void MultiTexImage3D(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexImage3DEXT_fnptr((uint)texunit, (uint)target, level, (int)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexSubImage3DEXT]</b>  </summary>
            public static void MultiTexSubImage3D(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexSubImage3DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCopyMultiTexSubImage3DEXT]</b>  </summary>
            public static void CopyMultiTexSubImage3D(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyMultiTexSubImage3DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glEnableClientStateIndexedEXT]</b>  </summary>
            public static void EnableClientStateIndexed(EnableCap array, uint index) => GLPointers._glEnableClientStateIndexedEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glDisableClientStateIndexedEXT]</b>  </summary>
            public static void DisableClientStateIndexed(EnableCap array, uint index) => GLPointers._glDisableClientStateIndexedEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetFloatIndexedvEXT]</b>  </summary>
            public static void GetFloatIndexedv(GetPName target, uint index, float* data) => GLPointers._glGetFloatIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetDoubleIndexedvEXT]</b>  </summary>
            public static void GetDoubleIndexedv(GetPName target, uint index, double* data) => GLPointers._glGetDoubleIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetPointerIndexedvEXT]</b>  </summary>
            public static void GetPointerIndexedv(All target, uint index, void** data) => GLPointers._glGetPointerIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2] [glEnableIndexedEXT]</b>  </summary>
            public static void EnableIndexed(EnableCap target, uint index) => GLPointers._glEnableIndexedEXT_fnptr((uint)target, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2] [glDisableIndexedEXT]</b>  </summary>
            public static void DisableIndexed(EnableCap target, uint index) => GLPointers._glDisableIndexedEXT_fnptr((uint)target, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2] [glIsEnabledIndexedEXT]</b>  </summary>
            public static bool IsEnabledIndexed(EnableCap target, uint index) => GLPointers._glIsEnabledIndexedEXT_fnptr((uint)target, index) != 0;
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2] [glGetIntegerIndexedvEXT]</b>  </summary>
            public static void GetIntegerIndexedv(GetPName target, uint index, int* data) => GLPointers._glGetIntegerIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2] [glGetBooleanIndexedvEXT]</b>  </summary>
            public static void GetBooleanIndexedv(BufferTargetARB target, uint index, bool* data) => GLPointers._glGetBooleanIndexedvEXT_fnptr((uint)target, index, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedTextureImage3DEXT]</b>  </summary>
            public static void CompressedTextureImage3D(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => GLPointers._glCompressedTextureImage3DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedTextureImage2DEXT]</b>  </summary>
            public static void CompressedTextureImage2D(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => GLPointers._glCompressedTextureImage2DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, width, height, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedTextureImage1DEXT]</b>  </summary>
            public static void CompressedTextureImage1D(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => GLPointers._glCompressedTextureImage1DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, width, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedTextureSubImage3DEXT]</b>  </summary>
            public static void CompressedTextureSubImage3D(int texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedTextureSubImage3DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedTextureSubImage2DEXT]</b>  </summary>
            public static void CompressedTextureSubImage2D(int texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedTextureSubImage2DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedTextureSubImage1DEXT]</b>  </summary>
            public static void CompressedTextureSubImage1D(int texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedTextureSubImage1DEXT_fnptr(texture, (uint)target, level, xoffset, width, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetCompressedTextureImageEXT]</b>  </summary>
            public static void GetCompressedTextureImage(int texture, TextureTarget target, int lod, void* img) => GLPointers._glGetCompressedTextureImageEXT_fnptr(texture, (uint)target, lod, img);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedMultiTexImage3DEXT]</b>  </summary>
            public static void CompressedMultiTexImage3D(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => GLPointers._glCompressedMultiTexImage3DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedMultiTexImage2DEXT]</b>  </summary>
            public static void CompressedMultiTexImage2D(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => GLPointers._glCompressedMultiTexImage2DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, width, height, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedMultiTexImage1DEXT]</b>  </summary>
            public static void CompressedMultiTexImage1D(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => GLPointers._glCompressedMultiTexImage1DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, width, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedMultiTexSubImage3DEXT]</b>  </summary>
            public static void CompressedMultiTexSubImage3D(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedMultiTexSubImage3DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedMultiTexSubImage2DEXT]</b>  </summary>
            public static void CompressedMultiTexSubImage2D(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedMultiTexSubImage2DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCompressedMultiTexSubImage1DEXT]</b>  </summary>
            public static void CompressedMultiTexSubImage1D(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedMultiTexSubImage1DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, width, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetCompressedMultiTexImageEXT]</b>  </summary>
            public static void GetCompressedMultiTexImage(TextureUnit texunit, TextureTarget target, int lod, void* img) => GLPointers._glGetCompressedMultiTexImageEXT_fnptr((uint)texunit, (uint)target, lod, img);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoadTransposefEXT]</b>  </summary>
            public static void MatrixLoadTransposef(MatrixMode mode, float* m) => GLPointers._glMatrixLoadTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoadTransposedEXT]</b>  </summary>
            public static void MatrixLoadTransposed(MatrixMode mode, double* m) => GLPointers._glMatrixLoadTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixMultTransposefEXT]</b>  </summary>
            public static void MatrixMultTransposef(MatrixMode mode, float* m) => GLPointers._glMatrixMultTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixMultTransposedEXT]</b>  </summary>
            public static void MatrixMultTransposed(MatrixMode mode, double* m) => GLPointers._glMatrixMultTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedBufferDataEXT]</b>  </summary>
            public static void NamedBufferData(int buffer, nint size, void* data, VertexBufferObjectUsage usage) => GLPointers._glNamedBufferDataEXT_fnptr(buffer, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedBufferSubDataEXT]</b>  </summary>
            public static void NamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glNamedBufferSubDataEXT_fnptr(buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMapNamedBufferEXT]</b>  </summary>
            public static void* MapNamedBuffer(int buffer, BufferAccessARB access) => GLPointers._glMapNamedBufferEXT_fnptr(buffer, (uint)access);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glUnmapNamedBufferEXT]</b>  </summary>
            public static bool UnmapNamedBuffer(int buffer) => GLPointers._glUnmapNamedBufferEXT_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedBufferParameterivEXT]</b>  </summary>
            public static void GetNamedBufferParameteriv(int buffer, BufferPNameARB pname, int* parameters) => GLPointers._glGetNamedBufferParameterivEXT_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedBufferPointervEXT]</b>  </summary>
            public static void GetNamedBufferPointerv(int buffer, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetNamedBufferPointervEXT_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedBufferSubDataEXT]</b>  </summary>
            public static void GetNamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glGetNamedBufferSubDataEXT_fnptr(buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform1fEXT]</b>  </summary>
            public static void ProgramUniform1f(int program, int location, float v0) => GLPointers._glProgramUniform1fEXT_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform2fEXT]</b>  </summary>
            public static void ProgramUniform2f(int program, int location, float v0, float v1) => GLPointers._glProgramUniform2fEXT_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform3fEXT]</b>  </summary>
            public static void ProgramUniform3f(int program, int location, float v0, float v1, float v2) => GLPointers._glProgramUniform3fEXT_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform4fEXT]</b>  </summary>
            public static void ProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3) => GLPointers._glProgramUniform4fEXT_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform1iEXT]</b>  </summary>
            public static void ProgramUniform1i(int program, int location, int v0) => GLPointers._glProgramUniform1iEXT_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform2iEXT]</b>  </summary>
            public static void ProgramUniform2i(int program, int location, int v0, int v1) => GLPointers._glProgramUniform2iEXT_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform3iEXT]</b>  </summary>
            public static void ProgramUniform3i(int program, int location, int v0, int v1, int v2) => GLPointers._glProgramUniform3iEXT_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform4iEXT]</b>  </summary>
            public static void ProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3) => GLPointers._glProgramUniform4iEXT_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform1fvEXT]</b>  </summary>
            public static void ProgramUniform1fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform1fvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform2fvEXT]</b>  </summary>
            public static void ProgramUniform2fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform2fvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform3fvEXT]</b>  </summary>
            public static void ProgramUniform3fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform3fvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform4fvEXT]</b>  </summary>
            public static void ProgramUniform4fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform4fvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform1ivEXT]</b>  </summary>
            public static void ProgramUniform1iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform1ivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform2ivEXT]</b>  </summary>
            public static void ProgramUniform2iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform2ivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform3ivEXT]</b>  </summary>
            public static void ProgramUniform3iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform3ivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform4ivEXT]</b>  </summary>
            public static void ProgramUniform4iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform4ivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniformMatrix2fvEXT]</b>  </summary>
            public static void ProgramUniformMatrix2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniformMatrix3fvEXT]</b>  </summary>
            public static void ProgramUniformMatrix3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniformMatrix4fvEXT]</b>  </summary>
            public static void ProgramUniformMatrix4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniformMatrix2x3fvEXT]</b>  </summary>
            public static void ProgramUniformMatrix2x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x3fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniformMatrix3x2fvEXT]</b>  </summary>
            public static void ProgramUniformMatrix3x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x2fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniformMatrix2x4fvEXT]</b>  </summary>
            public static void ProgramUniformMatrix2x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x4fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniformMatrix4x2fvEXT]</b>  </summary>
            public static void ProgramUniformMatrix4x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x2fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniformMatrix3x4fvEXT]</b>  </summary>
            public static void ProgramUniformMatrix3x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x4fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniformMatrix4x3fvEXT]</b>  </summary>
            public static void ProgramUniformMatrix4x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x3fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureBufferEXT]</b>  </summary>
            public static void TextureBuffer(int texture, TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers._glTextureBufferEXT_fnptr(texture, (uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexBufferEXT]</b>  </summary>
            public static void MultiTexBuffer(TextureUnit texunit, TextureTarget target, InternalFormat internalformat, int buffer) => GLPointers._glMultiTexBufferEXT_fnptr((uint)texunit, (uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureParameterIivEXT]</b>  </summary>
            public static void TextureParameterIiv(int texture, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTextureParameterIivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureParameterIuivEXT]</b>  </summary>
            public static void TextureParameterIuiv(int texture, TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._glTextureParameterIuivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetTextureParameterIivEXT]</b>  </summary>
            public static void GetTextureParameterIiv(int texture, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameterIivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetTextureParameterIuivEXT]</b>  </summary>
            public static void GetTextureParameterIuiv(int texture, TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTextureParameterIuivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexParameterIivEXT]</b>  </summary>
            public static void MultiTexParameterIiv(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glMultiTexParameterIivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexParameterIuivEXT]</b>  </summary>
            public static void MultiTexParameterIuiv(TextureUnit texunit, TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._glMultiTexParameterIuivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexParameterIivEXT]</b>  </summary>
            public static void GetMultiTexParameterIiv(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetMultiTexParameterIivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetMultiTexParameterIuivEXT]</b>  </summary>
            public static void GetMultiTexParameterIuiv(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._glGetMultiTexParameterIuivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform1uiEXT]</b>  </summary>
            public static void ProgramUniform1ui(int program, int location, uint v0) => GLPointers._glProgramUniform1uiEXT_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform2uiEXT]</b>  </summary>
            public static void ProgramUniform2ui(int program, int location, uint v0, uint v1) => GLPointers._glProgramUniform2uiEXT_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform3uiEXT]</b>  </summary>
            public static void ProgramUniform3ui(int program, int location, uint v0, uint v1, uint v2) => GLPointers._glProgramUniform3uiEXT_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform4uiEXT]</b>  </summary>
            public static void ProgramUniform4ui(int program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glProgramUniform4uiEXT_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform1uivEXT]</b>  </summary>
            public static void ProgramUniform1uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform1uivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform2uivEXT]</b>  </summary>
            public static void ProgramUniform2uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform2uivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform3uivEXT]</b>  </summary>
            public static void ProgramUniform3uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform3uivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects] [glProgramUniform4uivEXT]</b>  </summary>
            public static void ProgramUniform4uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform4uivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParameters4fvEXT]</b>  </summary>
            public static void NamedProgramLocalParameters4fv(int program, ProgramTarget target, uint index, int count, float* parameters) => GLPointers._glNamedProgramLocalParameters4fvEXT_fnptr(program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParameterI4iEXT]</b>  </summary>
            public static void NamedProgramLocalParameterI4i(int program, ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers._glNamedProgramLocalParameterI4iEXT_fnptr(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParameterI4ivEXT]</b>  </summary>
            public static void NamedProgramLocalParameterI4iv(int program, ProgramTarget target, uint index, int* parameters) => GLPointers._glNamedProgramLocalParameterI4ivEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParametersI4ivEXT]</b>  </summary>
            public static void NamedProgramLocalParametersI4iv(int program, ProgramTarget target, uint index, int count, int* parameters) => GLPointers._glNamedProgramLocalParametersI4ivEXT_fnptr(program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParameterI4uiEXT]</b>  </summary>
            public static void NamedProgramLocalParameterI4ui(int program, ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers._glNamedProgramLocalParameterI4uiEXT_fnptr(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParameterI4uivEXT]</b>  </summary>
            public static void NamedProgramLocalParameterI4uiv(int program, ProgramTarget target, uint index, uint* parameters) => GLPointers._glNamedProgramLocalParameterI4uivEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParametersI4uivEXT]</b>  </summary>
            public static void NamedProgramLocalParametersI4uiv(int program, ProgramTarget target, uint index, int count, uint* parameters) => GLPointers._glNamedProgramLocalParametersI4uivEXT_fnptr(program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedProgramLocalParameterIivEXT]</b>  </summary>
            public static void GetNamedProgramLocalParameterIiv(int program, ProgramTarget target, uint index, int* parameters) => GLPointers._glGetNamedProgramLocalParameterIivEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedProgramLocalParameterIuivEXT]</b>  </summary>
            public static void GetNamedProgramLocalParameterIuiv(int program, ProgramTarget target, uint index, uint* parameters) => GLPointers._glGetNamedProgramLocalParameterIuivEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glEnableClientStateiEXT]</b>  </summary>
            public static void EnableClientStatei(EnableCap array, uint index) => GLPointers._glEnableClientStateiEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glDisableClientStateiEXT]</b>  </summary>
            public static void DisableClientStatei(EnableCap array, uint index) => GLPointers._glDisableClientStateiEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetFloati_vEXT]</b>  </summary>
            public static void GetFloati_v(GetPName pname, uint index, float* parameters) => GLPointers._glGetFloati_vEXT_fnptr((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetDoublei_vEXT]</b>  </summary>
            public static void GetDoublei_v(GetPName pname, uint index, double* parameters) => GLPointers._glGetDoublei_vEXT_fnptr((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetPointeri_vEXT]</b>  </summary>
            public static void GetPointeri_v(All pname, uint index, void** parameters) => GLPointers._glGetPointeri_vEXT_fnptr((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramStringEXT]</b>  </summary>
            public static void NamedProgramString(int program, ProgramTarget target, ProgramFormat format, int len, void* str) => GLPointers._glNamedProgramStringEXT_fnptr(program, (uint)target, (uint)format, len, str);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParameter4dEXT]</b>  </summary>
            public static void NamedProgramLocalParameter4d(int program, ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers._glNamedProgramLocalParameter4dEXT_fnptr(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParameter4dvEXT]</b>  </summary>
            public static void NamedProgramLocalParameter4dv(int program, ProgramTarget target, uint index, double* parameters) => GLPointers._glNamedProgramLocalParameter4dvEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParameter4fEXT]</b>  </summary>
            public static void NamedProgramLocalParameter4f(int program, ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers._glNamedProgramLocalParameter4fEXT_fnptr(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedProgramLocalParameter4fvEXT]</b>  </summary>
            public static void NamedProgramLocalParameter4fv(int program, ProgramTarget target, uint index, float* parameters) => GLPointers._glNamedProgramLocalParameter4fvEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedProgramLocalParameterdvEXT]</b>  </summary>
            public static void GetNamedProgramLocalParameterdv(int program, ProgramTarget target, uint index, double* parameters) => GLPointers._glGetNamedProgramLocalParameterdvEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedProgramLocalParameterfvEXT]</b>  </summary>
            public static void GetNamedProgramLocalParameterfv(int program, ProgramTarget target, uint index, float* parameters) => GLPointers._glGetNamedProgramLocalParameterfvEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedProgramivEXT]</b>  </summary>
            public static void GetNamedProgramiv(int program, ProgramTarget target, ProgramPropertyARB pname, int* parameters) => GLPointers._glGetNamedProgramivEXT_fnptr(program, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedProgramStringEXT]</b>  </summary>
            public static void GetNamedProgramString(int program, ProgramTarget target, ProgramStringProperty pname, void* str) => GLPointers._glGetNamedProgramStringEXT_fnptr(program, (uint)target, (uint)pname, str);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedRenderbufferStorageEXT]</b>  </summary>
            public static void NamedRenderbufferStorage(int renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageEXT_fnptr(renderbuffer, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedRenderbufferParameterivEXT]</b>  </summary>
            public static void GetNamedRenderbufferParameteriv(int renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetNamedRenderbufferParameterivEXT_fnptr(renderbuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedRenderbufferStorageMultisampleEXT]</b>  </summary>
            public static void NamedRenderbufferStorageMultisample(int renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisampleEXT_fnptr(renderbuffer, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedRenderbufferStorageMultisampleCoverageEXT]</b>  </summary>
            public static void NamedRenderbufferStorageMultisampleCoverage(int renderbuffer, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisampleCoverageEXT_fnptr(renderbuffer, coverageSamples, colorSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glCheckNamedFramebufferStatusEXT]</b>  </summary>
            public static FramebufferStatus CheckNamedFramebufferStatus(int framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckNamedFramebufferStatusEXT_fnptr(framebuffer, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedFramebufferTexture1DEXT]</b>  </summary>
            public static void NamedFramebufferTexture1D(int framebuffer, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glNamedFramebufferTexture1DEXT_fnptr(framebuffer, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedFramebufferTexture2DEXT]</b>  </summary>
            public static void NamedFramebufferTexture2D(int framebuffer, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glNamedFramebufferTexture2DEXT_fnptr(framebuffer, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedFramebufferTexture3DEXT]</b>  </summary>
            public static void NamedFramebufferTexture3D(int framebuffer, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers._glNamedFramebufferTexture3DEXT_fnptr(framebuffer, (uint)attachment, (uint)textarget, texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedFramebufferRenderbufferEXT]</b>  </summary>
            public static void NamedFramebufferRenderbuffer(int framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glNamedFramebufferRenderbufferEXT_fnptr(framebuffer, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedFramebufferAttachmentParameterivEXT]</b>  </summary>
            public static void GetNamedFramebufferAttachmentParameteriv(int framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetNamedFramebufferAttachmentParameterivEXT_fnptr(framebuffer, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGenerateTextureMipmapEXT]</b>  </summary>
            public static void GenerateTextureMipmap(int texture, TextureTarget target) => GLPointers._glGenerateTextureMipmapEXT_fnptr(texture, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGenerateMultiTexMipmapEXT]</b>  </summary>
            public static void GenerateMultiTexMipmap(TextureUnit texunit, TextureTarget target) => GLPointers._glGenerateMultiTexMipmapEXT_fnptr((uint)texunit, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glFramebufferDrawBufferEXT]</b>  </summary>
            public static void FramebufferDrawBuffer(int framebuffer, DrawBufferMode mode) => GLPointers._glFramebufferDrawBufferEXT_fnptr(framebuffer, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glFramebufferDrawBuffersEXT]</b>  </summary>
            public static void FramebufferDrawBuffers(int framebuffer, int n, DrawBufferMode* bufs) => GLPointers._glFramebufferDrawBuffersEXT_fnptr(framebuffer, n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glFramebufferReadBufferEXT]</b>  </summary>
            public static void FramebufferReadBuffer(int framebuffer, ReadBufferMode mode) => GLPointers._glFramebufferReadBufferEXT_fnptr(framebuffer, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetFramebufferParameterivEXT]</b>  </summary>
            public static void GetFramebufferParameteriv(int framebuffer, GetFramebufferParameter pname, int* parameters) => GLPointers._glGetFramebufferParameterivEXT_fnptr(framebuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedCopyBufferSubDataEXT]</b>  </summary>
            public static void NamedCopyBufferSubData(int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glNamedCopyBufferSubDataEXT_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedFramebufferTextureEXT]</b>  </summary>
            public static void NamedFramebufferTexture(int framebuffer, FramebufferAttachment attachment, int texture, int level) => GLPointers._glNamedFramebufferTextureEXT_fnptr(framebuffer, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedFramebufferTextureLayerEXT]</b>  </summary>
            public static void NamedFramebufferTextureLayer(int framebuffer, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glNamedFramebufferTextureLayerEXT_fnptr(framebuffer, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedFramebufferTextureFaceEXT]</b>  </summary>
            public static void NamedFramebufferTextureFace(int framebuffer, FramebufferAttachment attachment, int texture, int level, TextureTarget face) => GLPointers._glNamedFramebufferTextureFaceEXT_fnptr(framebuffer, (uint)attachment, texture, level, (uint)face);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureRenderbufferEXT]</b>  </summary>
            public static void TextureRenderbuffer(int texture, TextureTarget target, int renderbuffer) => GLPointers._glTextureRenderbufferEXT_fnptr(texture, (uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMultiTexRenderbufferEXT]</b>  </summary>
            public static void MultiTexRenderbuffer(TextureUnit texunit, TextureTarget target, int renderbuffer) => GLPointers._glMultiTexRenderbufferEXT_fnptr((uint)texunit, (uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexOffsetEXT]</b>  </summary>
            public static void VertexArrayVertexOffset(int vaobj, int buffer, int size, VertexPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayVertexOffsetEXT_fnptr(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayColorOffsetEXT]</b>  </summary>
            public static void VertexArrayColorOffset(int vaobj, int buffer, int size, ColorPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayColorOffsetEXT_fnptr(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayEdgeFlagOffsetEXT]</b>  </summary>
            public static void VertexArrayEdgeFlagOffset(int vaobj, int buffer, int stride, IntPtr offset) => GLPointers._glVertexArrayEdgeFlagOffsetEXT_fnptr(vaobj, buffer, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayIndexOffsetEXT]</b>  </summary>
            public static void VertexArrayIndexOffset(int vaobj, int buffer, IndexPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayIndexOffsetEXT_fnptr(vaobj, buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayNormalOffsetEXT]</b>  </summary>
            public static void VertexArrayNormalOffset(int vaobj, int buffer, NormalPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayNormalOffsetEXT_fnptr(vaobj, buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayTexCoordOffsetEXT]</b>  </summary>
            public static void VertexArrayTexCoordOffset(int vaobj, int buffer, int size, TexCoordPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayTexCoordOffsetEXT_fnptr(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayMultiTexCoordOffsetEXT]</b>  </summary>
            public static void VertexArrayMultiTexCoordOffset(int vaobj, int buffer, All texunit, int size, TexCoordPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayMultiTexCoordOffsetEXT_fnptr(vaobj, buffer, (uint)texunit, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayFogCoordOffsetEXT]</b>  </summary>
            public static void VertexArrayFogCoordOffset(int vaobj, int buffer, FogCoordinatePointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayFogCoordOffsetEXT_fnptr(vaobj, buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArraySecondaryColorOffsetEXT]</b>  </summary>
            public static void VertexArraySecondaryColorOffset(int vaobj, int buffer, int size, ColorPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArraySecondaryColorOffsetEXT_fnptr(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexAttribOffsetEXT]</b>  </summary>
            public static void VertexArrayVertexAttribOffset(int vaobj, int buffer, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr offset) => GLPointers._glVertexArrayVertexAttribOffsetEXT_fnptr(vaobj, buffer, index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexAttribIOffsetEXT]</b>  </summary>
            public static void VertexArrayVertexAttribIOffset(int vaobj, int buffer, uint index, int size, VertexAttribType type, int stride, IntPtr offset) => GLPointers._glVertexArrayVertexAttribIOffsetEXT_fnptr(vaobj, buffer, index, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glEnableVertexArrayEXT]</b>  </summary>
            public static void EnableVertexArray(int vaobj, EnableCap array) => GLPointers._glEnableVertexArrayEXT_fnptr(vaobj, (uint)array);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glDisableVertexArrayEXT]</b>  </summary>
            public static void DisableVertexArray(int vaobj, EnableCap array) => GLPointers._glDisableVertexArrayEXT_fnptr(vaobj, (uint)array);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glEnableVertexArrayAttribEXT]</b>  </summary>
            public static void EnableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glEnableVertexArrayAttribEXT_fnptr(vaobj, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glDisableVertexArrayAttribEXT]</b>  </summary>
            public static void DisableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glDisableVertexArrayAttribEXT_fnptr(vaobj, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetVertexArrayIntegervEXT]</b>  </summary>
            public static void GetVertexArrayIntegerv(int vaobj, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayIntegervEXT_fnptr(vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetVertexArrayPointervEXT]</b>  </summary>
            public static void GetVertexArrayPointerv(int vaobj, VertexArrayPName pname, void** param) => GLPointers._glGetVertexArrayPointervEXT_fnptr(vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetVertexArrayIntegeri_vEXT]</b>  </summary>
            public static void GetVertexArrayIntegeri_v(int vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayIntegeri_vEXT_fnptr(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetVertexArrayPointeri_vEXT]</b>  </summary>
            public static void GetVertexArrayPointeri_v(int vaobj, uint index, VertexArrayPName pname, void** param) => GLPointers._glGetVertexArrayPointeri_vEXT_fnptr(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glMapNamedBufferRangeEXT]</b>  </summary>
            public static void* MapNamedBufferRange(int buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapNamedBufferRangeEXT_fnptr(buffer, offset, length, (uint)access);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glFlushMappedNamedBufferRangeEXT]</b>  </summary>
            public static void FlushMappedNamedBufferRange(int buffer, IntPtr offset, nint length) => GLPointers._glFlushMappedNamedBufferRangeEXT_fnptr(buffer, offset, length);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedBufferStorageEXT]</b>  </summary>
            public static void NamedBufferStorage(int buffer, nint size, void* data, BufferStorageMask flags) => GLPointers._glNamedBufferStorageEXT_fnptr(buffer, size, data, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glClearNamedBufferDataEXT]</b>  </summary>
            public static void ClearNamedBufferData(int buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferDataEXT_fnptr(buffer, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glClearNamedBufferSubDataEXT]</b>  </summary>
            public static void ClearNamedBufferSubData(int buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferSubDataEXT_fnptr(buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glNamedFramebufferParameteriEXT]</b>  </summary>
            public static void NamedFramebufferParameteri(int framebuffer, FramebufferParameterName pname, int param) => GLPointers._glNamedFramebufferParameteriEXT_fnptr(framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glGetNamedFramebufferParameterivEXT]</b>  </summary>
            public static void GetNamedFramebufferParameteriv(int framebuffer, GetFramebufferParameter pname, int* parameters) => GLPointers._glGetNamedFramebufferParameterivEXT_fnptr(framebuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniform1dEXT]</b>  </summary>
            public static void ProgramUniform1d(int program, int location, double x) => GLPointers._glProgramUniform1dEXT_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniform2dEXT]</b>  </summary>
            public static void ProgramUniform2d(int program, int location, double x, double y) => GLPointers._glProgramUniform2dEXT_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniform3dEXT]</b>  </summary>
            public static void ProgramUniform3d(int program, int location, double x, double y, double z) => GLPointers._glProgramUniform3dEXT_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniform4dEXT]</b>  </summary>
            public static void ProgramUniform4d(int program, int location, double x, double y, double z, double w) => GLPointers._glProgramUniform4dEXT_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniform1dvEXT]</b>  </summary>
            public static void ProgramUniform1dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform1dvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniform2dvEXT]</b>  </summary>
            public static void ProgramUniform2dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform2dvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniform3dvEXT]</b>  </summary>
            public static void ProgramUniform3dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform3dvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniform4dvEXT]</b>  </summary>
            public static void ProgramUniform4dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform4dvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniformMatrix2dvEXT]</b>  </summary>
            public static void ProgramUniformMatrix2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniformMatrix3dvEXT]</b>  </summary>
            public static void ProgramUniformMatrix3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniformMatrix4dvEXT]</b>  </summary>
            public static void ProgramUniformMatrix4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniformMatrix2x3dvEXT]</b>  </summary>
            public static void ProgramUniformMatrix2x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x3dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniformMatrix2x4dvEXT]</b>  </summary>
            public static void ProgramUniformMatrix2x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x4dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniformMatrix3x2dvEXT]</b>  </summary>
            public static void ProgramUniformMatrix3x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x2dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniformMatrix3x4dvEXT]</b>  </summary>
            public static void ProgramUniformMatrix3x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x4dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniformMatrix4x2dvEXT]</b>  </summary>
            public static void ProgramUniformMatrix4x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x2dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glProgramUniformMatrix4x3dvEXT]</b>  </summary>
            public static void ProgramUniformMatrix4x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x3dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureBufferRangeEXT]</b>  </summary>
            public static void TextureBufferRange(int texture, TextureTarget target, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTextureBufferRangeEXT_fnptr(texture, (uint)target, (uint)internalformat, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage] [glTextureStorage1DEXT]</b>  </summary>
            public static void TextureStorage1D(int texture, All target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTextureStorage1DEXT_fnptr(texture, (uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage] [glTextureStorage2DEXT]</b>  </summary>
            public static void TextureStorage2D(int texture, All target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTextureStorage2DEXT_fnptr(texture, (uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage] [glTextureStorage3DEXT]</b>  </summary>
            public static void TextureStorage3D(int texture, All target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTextureStorage3DEXT_fnptr(texture, (uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureStorage2DMultisampleEXT]</b>  </summary>
            public static void TextureStorage2DMultisample(int texture, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTextureStorage2DMultisampleEXT_fnptr(texture, (uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTextureStorage3DMultisampleEXT]</b>  </summary>
            public static void TextureStorage3DMultisample(int texture, All target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTextureStorage3DMultisampleEXT_fnptr(texture, (uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayBindVertexBufferEXT]</b>  </summary>
            public static void VertexArrayBindVertexBuffer(int vaobj, uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glVertexArrayBindVertexBufferEXT_fnptr(vaobj, bindingindex, buffer, offset, stride);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexAttribFormatEXT]</b>  </summary>
            public static void VertexArrayVertexAttribFormat(int vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexArrayVertexAttribFormatEXT_fnptr(vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexAttribIFormatEXT]</b>  </summary>
            public static void VertexArrayVertexAttribIFormat(int vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexArrayVertexAttribIFormatEXT_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexAttribLFormatEXT]</b>  </summary>
            public static void VertexArrayVertexAttribLFormat(int vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexArrayVertexAttribLFormatEXT_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexAttribBindingEXT]</b>  </summary>
            public static void VertexArrayVertexAttribBinding(int vaobj, uint attribindex, uint bindingindex) => GLPointers._glVertexArrayVertexAttribBindingEXT_fnptr(vaobj, attribindex, bindingindex);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexBindingDivisorEXT]</b>  </summary>
            public static void VertexArrayVertexBindingDivisor(int vaobj, uint bindingindex, uint divisor) => GLPointers._glVertexArrayVertexBindingDivisorEXT_fnptr(vaobj, bindingindex, divisor);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexAttribLOffsetEXT]</b>  </summary>
            public static void VertexArrayVertexAttribLOffset(int vaobj, int buffer, uint index, int size, VertexAttribLType type, int stride, IntPtr offset) => GLPointers._glVertexArrayVertexAttribLOffsetEXT_fnptr(vaobj, buffer, index, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glTexturePageCommitmentEXT]</b>  </summary>
            public static void TexturePageCommitment(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => GLPointers._glTexturePageCommitmentEXT_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access] [glVertexArrayVertexAttribDivisorEXT]</b>  </summary>
            public static void VertexArrayVertexAttribDivisor(int vaobj, uint index, uint divisor) => GLPointers._glVertexArrayVertexAttribDivisorEXT_fnptr(vaobj, index, divisor);
            
            /// <summary> <b>[requires: GL_EXT_draw_buffers2] [glColorMaskIndexedEXT]</b>  </summary>
            public static void ColorMaskIndexed(uint index, bool r, bool g, bool b, bool a) => GLPointers._glColorMaskIndexedEXT_fnptr(index, (byte)(r ? 1 : 0), (byte)(g ? 1 : 0), (byte)(b ? 1 : 0), (byte)(a ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_draw_instanced] [glDrawArraysInstancedEXT]</b>  </summary>
            public static void DrawArraysInstanced(PrimitiveType mode, int start, int count, int primcount) => GLPointers._glDrawArraysInstancedEXT_fnptr((uint)mode, start, count, primcount);
            
            /// <summary> <b>[requires: GL_EXT_draw_instanced] [glDrawElementsInstancedEXT]</b>  </summary>
            public static void DrawElementsInstanced(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => GLPointers._glDrawElementsInstancedEXT_fnptr((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_EXT_draw_range_elements] [glDrawRangeElementsEXT]</b>  </summary>
            public static void DrawRangeElements(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => GLPointers._glDrawRangeElementsEXT_fnptr((uint)mode, start, end, count, (uint)type, indices);
            
            /// <summary> <b>[requires: GL_EXT_external_buffer] [glBufferStorageExternalEXT]</b>  </summary>
            public static void BufferStorageExternal(All target, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => GLPointers._glBufferStorageExternalEXT_fnptr((uint)target, offset, size, clientBuffer, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_external_buffer] [glNamedBufferStorageExternalEXT]</b>  </summary>
            public static void NamedBufferStorageExternal(int buffer, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => GLPointers._glNamedBufferStorageExternalEXT_fnptr(buffer, offset, size, clientBuffer, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord] [glFogCoordfEXT]</b>  </summary>
            public static void FogCoordf(float coord) => GLPointers._glFogCoordfEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord] [glFogCoordfvEXT]</b>  </summary>
            public static void FogCoordfv(float* coord) => GLPointers._glFogCoordfvEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord] [glFogCoorddEXT]</b>  </summary>
            public static void FogCoordd(double coord) => GLPointers._glFogCoorddEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord] [glFogCoorddvEXT]</b>  </summary>
            public static void FogCoorddv(double* coord) => GLPointers._glFogCoorddvEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord] [glFogCoordPointerEXT]</b>  </summary>
            public static void FogCoordPointer(FogPointerTypeEXT type, int stride, void* pointer) => GLPointers._glFogCoordPointerEXT_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit] [glBlitFramebufferEXT]</b>  </summary>
            public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebufferEXT_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit_layers] [glBlitFramebufferLayersEXT]</b>  </summary>
            public static void BlitFramebufferLayers(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebufferLayersEXT_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit_layers] [glBlitFramebufferLayerEXT]</b>  </summary>
            public static void BlitFramebufferLayer(int srcX0, int srcY0, int srcX1, int srcY1, int srcLayer, int dstX0, int dstY0, int dstX1, int dstY1, int dstLayer, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebufferLayerEXT_fnptr(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_multisample] [glRenderbufferStorageMultisampleEXT]</b>  </summary>
            public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisampleEXT_fnptr((uint)target, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glIsRenderbufferEXT]</b>  </summary>
            public static bool IsRenderbuffer(int renderbuffer) => GLPointers._glIsRenderbufferEXT_fnptr(renderbuffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glBindRenderbufferEXT]</b>  </summary>
            public static void BindRenderbuffer(RenderbufferTarget target, int renderbuffer) => GLPointers._glBindRenderbufferEXT_fnptr((uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glDeleteRenderbuffersEXT]</b>  </summary>
            public static void DeleteRenderbuffers(int n, int* renderbuffers) => GLPointers._glDeleteRenderbuffersEXT_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glGenRenderbuffersEXT]</b>  </summary>
            public static void GenRenderbuffers(int n, int* renderbuffers) => GLPointers._glGenRenderbuffersEXT_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glRenderbufferStorageEXT]</b>  </summary>
            public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageEXT_fnptr((uint)target, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glGetRenderbufferParameterivEXT]</b>  </summary>
            public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetRenderbufferParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glIsFramebufferEXT]</b>  </summary>
            public static bool IsFramebuffer(int framebuffer) => GLPointers._glIsFramebufferEXT_fnptr(framebuffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glBindFramebufferEXT]</b>  </summary>
            public static void BindFramebuffer(FramebufferTarget target, int framebuffer) => GLPointers._glBindFramebufferEXT_fnptr((uint)target, framebuffer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glDeleteFramebuffersEXT]</b>  </summary>
            public static void DeleteFramebuffers(int n, int* framebuffers) => GLPointers._glDeleteFramebuffersEXT_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glGenFramebuffersEXT]</b>  </summary>
            public static void GenFramebuffers(int n, int* framebuffers) => GLPointers._glGenFramebuffersEXT_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glCheckFramebufferStatusEXT]</b>  </summary>
            public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckFramebufferStatusEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glFramebufferTexture1DEXT]</b>  </summary>
            public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture1DEXT_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glFramebufferTexture2DEXT]</b>  </summary>
            public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture2DEXT_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glFramebufferTexture3DEXT]</b>  </summary>
            public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers._glFramebufferTexture3DEXT_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glFramebufferRenderbufferEXT]</b>  </summary>
            public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glFramebufferRenderbufferEXT_fnptr((uint)target, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glGetFramebufferAttachmentParameterivEXT]</b>  </summary>
            public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferAttachmentParameterivEXT_fnptr((uint)target, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object] [glGenerateMipmapEXT]</b>  </summary>
            public static void GenerateMipmap(TextureTarget target) => GLPointers._glGenerateMipmapEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_geometry_shader4 | GL_EXT_separate_shader_objects] [glProgramParameteriEXT]</b>  </summary>
            public static void ProgramParameteri(int program, ProgramParameterPName pname, int value) => GLPointers._glProgramParameteriEXT_fnptr(program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters] [glProgramEnvParameters4fvEXT]</b>  </summary>
            public static void ProgramEnvParameters4fv(ProgramTarget target, uint index, int count, float* parameters) => GLPointers._glProgramEnvParameters4fvEXT_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters] [glProgramLocalParameters4fvEXT]</b>  </summary>
            public static void ProgramLocalParameters4fv(ProgramTarget target, uint index, int count, float* parameters) => GLPointers._glProgramLocalParameters4fvEXT_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glGetUniformuivEXT]</b>  </summary>
            public static void GetUniformuiv(int program, int location, uint* parameters) => GLPointers._glGetUniformuivEXT_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glBindFragDataLocationEXT]</b>  </summary>
            public static void BindFragDataLocation(int program, uint color, byte* name) => GLPointers._glBindFragDataLocationEXT_fnptr(program, color, name);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glGetFragDataLocationEXT]</b>  </summary>
            public static int GetFragDataLocation(int program, byte* name) => GLPointers._glGetFragDataLocationEXT_fnptr(program, name);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glUniform1uiEXT]</b>  </summary>
            public static void Uniform1ui(int location, uint v0) => GLPointers._glUniform1uiEXT_fnptr(location, v0);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glUniform2uiEXT]</b>  </summary>
            public static void Uniform2ui(int location, uint v0, uint v1) => GLPointers._glUniform2uiEXT_fnptr(location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glUniform3uiEXT]</b>  </summary>
            public static void Uniform3ui(int location, uint v0, uint v1, uint v2) => GLPointers._glUniform3uiEXT_fnptr(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glUniform4uiEXT]</b>  </summary>
            public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glUniform4uiEXT_fnptr(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glUniform1uivEXT]</b>  </summary>
            public static void Uniform1uiv(int location, int count, uint* value) => GLPointers._glUniform1uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glUniform2uivEXT]</b>  </summary>
            public static void Uniform2uiv(int location, int count, uint* value) => GLPointers._glUniform2uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glUniform3uivEXT]</b>  </summary>
            public static void Uniform3uiv(int location, int count, uint* value) => GLPointers._glUniform3uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4] [glUniform4uivEXT]</b>  </summary>
            public static void Uniform4uiv(int location, int count, uint* value) => GLPointers._glUniform4uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI1iEXT]</b>  </summary>
            public static void VertexAttribI1i(uint index, int x) => GLPointers._glVertexAttribI1iEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI2iEXT]</b>  </summary>
            public static void VertexAttribI2i(uint index, int x, int y) => GLPointers._glVertexAttribI2iEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI3iEXT]</b>  </summary>
            public static void VertexAttribI3i(uint index, int x, int y, int z) => GLPointers._glVertexAttribI3iEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4iEXT]</b>  </summary>
            public static void VertexAttribI4i(uint index, int x, int y, int z, int w) => GLPointers._glVertexAttribI4iEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI1uiEXT]</b>  </summary>
            public static void VertexAttribI1ui(uint index, uint x) => GLPointers._glVertexAttribI1uiEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI2uiEXT]</b>  </summary>
            public static void VertexAttribI2ui(uint index, uint x, uint y) => GLPointers._glVertexAttribI2uiEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI3uiEXT]</b>  </summary>
            public static void VertexAttribI3ui(uint index, uint x, uint y, uint z) => GLPointers._glVertexAttribI3uiEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4uiEXT]</b>  </summary>
            public static void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w) => GLPointers._glVertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI1ivEXT]</b>  </summary>
            public static void VertexAttribI1iv(uint index, int* v) => GLPointers._glVertexAttribI1ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI2ivEXT]</b>  </summary>
            public static void VertexAttribI2iv(uint index, int* v) => GLPointers._glVertexAttribI2ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI3ivEXT]</b>  </summary>
            public static void VertexAttribI3iv(uint index, int* v) => GLPointers._glVertexAttribI3ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4ivEXT]</b>  </summary>
            public static void VertexAttribI4iv(uint index, int* v) => GLPointers._glVertexAttribI4ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI1uivEXT]</b>  </summary>
            public static void VertexAttribI1uiv(uint index, uint* v) => GLPointers._glVertexAttribI1uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI2uivEXT]</b>  </summary>
            public static void VertexAttribI2uiv(uint index, uint* v) => GLPointers._glVertexAttribI2uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI3uivEXT]</b>  </summary>
            public static void VertexAttribI3uiv(uint index, uint* v) => GLPointers._glVertexAttribI3uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4uivEXT]</b>  </summary>
            public static void VertexAttribI4uiv(uint index, uint* v) => GLPointers._glVertexAttribI4uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4bvEXT]</b>  </summary>
            public static void VertexAttribI4bv(uint index, sbyte* v) => GLPointers._glVertexAttribI4bvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4svEXT]</b>  </summary>
            public static void VertexAttribI4sv(uint index, short* v) => GLPointers._glVertexAttribI4svEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4ubvEXT]</b>  </summary>
            public static void VertexAttribI4ubv(uint index, byte* v) => GLPointers._glVertexAttribI4ubvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4usvEXT]</b>  </summary>
            public static void VertexAttribI4usv(uint index, ushort* v) => GLPointers._glVertexAttribI4usvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribIPointerEXT]</b>  </summary>
            public static void VertexAttribIPointer(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers._glVertexAttribIPointerEXT_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glGetVertexAttribIivEXT]</b>  </summary>
            public static void GetVertexAttribIiv(uint index, VertexAttribEnum pname, int* parameters) => GLPointers._glGetVertexAttribIivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glGetVertexAttribIuivEXT]</b>  </summary>
            public static void GetVertexAttribIuiv(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers._glGetVertexAttribIuivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glGetHistogramEXT]</b>  </summary>
            public static void GetHistogram(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._glGetHistogramEXT_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glGetHistogramParameterfvEXT]</b>  </summary>
            public static void GetHistogramParameterfv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters) => GLPointers._glGetHistogramParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glGetHistogramParameterivEXT]</b>  </summary>
            public static void GetHistogramParameteriv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers._glGetHistogramParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glGetMinmaxEXT]</b>  </summary>
            public static void GetMinmax(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._glGetMinmaxEXT_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glGetMinmaxParameterfvEXT]</b>  </summary>
            public static void GetMinmaxParameterfv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters) => GLPointers._glGetMinmaxParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glGetMinmaxParameterivEXT]</b>  </summary>
            public static void GetMinmaxParameteriv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters) => GLPointers._glGetMinmaxParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glHistogramEXT]</b>  </summary>
            public static void Histogram(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink) => GLPointers._glHistogramEXT_fnptr((uint)target, width, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glMinmaxEXT]</b>  </summary>
            public static void Minmax(MinmaxTargetEXT target, InternalFormat internalformat, bool sink) => GLPointers._glMinmaxEXT_fnptr((uint)target, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glResetHistogramEXT]</b>  </summary>
            public static void ResetHistogram(HistogramTargetEXT target) => GLPointers._glResetHistogramEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_histogram] [glResetMinmaxEXT]</b>  </summary>
            public static void ResetMinmax(MinmaxTargetEXT target) => GLPointers._glResetMinmaxEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_index_func] [glIndexFuncEXT]</b>  </summary>
            public static void IndexFunc(IndexFunctionEXT func, float reference) => GLPointers._glIndexFuncEXT_fnptr((uint)func, reference);
            
            /// <summary> <b>[requires: GL_EXT_index_material] [glIndexMaterialEXT]</b>  </summary>
            public static void IndexMaterial(TriangleFace face, IndexMaterialParameterEXT mode) => GLPointers._glIndexMaterialEXT_fnptr((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_light_texture] [glApplyTextureEXT]</b>  </summary>
            public static void ApplyTexture(LightTextureModeEXT mode) => GLPointers._glApplyTextureEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_light_texture] [glTextureLightEXT]</b>  </summary>
            public static void TextureLight(LightTexturePNameEXT pname) => GLPointers._glTextureLightEXT_fnptr((uint)pname);
            
            /// <summary> <b>[requires: GL_EXT_light_texture] [glTextureMaterialEXT]</b>  </summary>
            public static void TextureMaterial(TriangleFace face, MaterialParameter mode) => GLPointers._glTextureMaterialEXT_fnptr((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore] [glGetUnsignedBytevEXT]</b>  </summary>
            public static void GetUnsignedBytev(GetPName pname, byte* data) => GLPointers._glGetUnsignedBytevEXT_fnptr((uint)pname, data);
            
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore] [glGetUnsignedBytei_vEXT]</b>  </summary>
            public static void GetUnsignedBytei_v(All target, uint index, byte* data) => GLPointers._glGetUnsignedBytei_vEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glDeleteMemoryObjectsEXT]</b>  </summary>
            public static void DeleteMemoryObjects(int n, uint* memoryObjects) => GLPointers._glDeleteMemoryObjectsEXT_fnptr(n, memoryObjects);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glIsMemoryObjectEXT]</b>  </summary>
            public static bool IsMemoryObject(uint memoryObject) => GLPointers._glIsMemoryObjectEXT_fnptr(memoryObject) != 0;
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glCreateMemoryObjectsEXT]</b>  </summary>
            public static void CreateMemoryObjects(int n, uint* memoryObjects) => GLPointers._glCreateMemoryObjectsEXT_fnptr(n, memoryObjects);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glMemoryObjectParameterivEXT]</b>  </summary>
            public static void MemoryObjectParameteriv(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => GLPointers._glMemoryObjectParameterivEXT_fnptr(memoryObject, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glGetMemoryObjectParameterivEXT]</b>  </summary>
            public static void GetMemoryObjectParameteriv(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => GLPointers._glGetMemoryObjectParameterivEXT_fnptr(memoryObject, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTexStorageMem2DEXT]</b>  </summary>
            public static void TexStorageMem2D(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => GLPointers._glTexStorageMem2DEXT_fnptr((uint)target, levels, (uint)internalFormat, width, height, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTexStorageMem2DMultisampleEXT]</b>  </summary>
            public static void TexStorageMem2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._glTexStorageMem2DMultisampleEXT_fnptr((uint)target, samples, (uint)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTexStorageMem3DEXT]</b>  </summary>
            public static void TexStorageMem3D(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => GLPointers._glTexStorageMem3DEXT_fnptr((uint)target, levels, (uint)internalFormat, width, height, depth, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTexStorageMem3DMultisampleEXT]</b>  </summary>
            public static void TexStorageMem3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._glTexStorageMem3DMultisampleEXT_fnptr((uint)target, samples, (uint)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glBufferStorageMemEXT]</b>  </summary>
            public static void BufferStorageMem(BufferTargetARB target, nint size, uint memory, ulong offset) => GLPointers._glBufferStorageMemEXT_fnptr((uint)target, size, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTextureStorageMem2DEXT]</b>  </summary>
            public static void TextureStorageMem2D(int texture, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => GLPointers._glTextureStorageMem2DEXT_fnptr(texture, levels, (uint)internalFormat, width, height, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTextureStorageMem2DMultisampleEXT]</b>  </summary>
            public static void TextureStorageMem2DMultisample(int texture, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._glTextureStorageMem2DMultisampleEXT_fnptr(texture, samples, (uint)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTextureStorageMem3DEXT]</b>  </summary>
            public static void TextureStorageMem3D(int texture, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => GLPointers._glTextureStorageMem3DEXT_fnptr(texture, levels, (uint)internalFormat, width, height, depth, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTextureStorageMem3DMultisampleEXT]</b>  </summary>
            public static void TextureStorageMem3DMultisample(int texture, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._glTextureStorageMem3DMultisampleEXT_fnptr(texture, samples, (uint)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glNamedBufferStorageMemEXT]</b>  </summary>
            public static void NamedBufferStorageMem(int buffer, nint size, uint memory, ulong offset) => GLPointers._glNamedBufferStorageMemEXT_fnptr(buffer, size, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTexStorageMem1DEXT]</b>  </summary>
            public static void TexStorageMem1D(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => GLPointers._glTexStorageMem1DEXT_fnptr((uint)target, levels, (uint)internalFormat, width, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object] [glTextureStorageMem1DEXT]</b>  </summary>
            public static void TextureStorageMem1D(int texture, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => GLPointers._glTextureStorageMem1DEXT_fnptr(texture, levels, (uint)internalFormat, width, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_fd] [glImportMemoryFdEXT]</b>  </summary>
            public static void ImportMemoryFd(uint memory, ulong size, ExternalHandleType handleType, int fd) => GLPointers._glImportMemoryFdEXT_fnptr(memory, size, (uint)handleType, fd);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_win32] [glImportMemoryWin32HandleEXT]</b>  </summary>
            public static void ImportMemoryWin32Handle(uint memory, ulong size, ExternalHandleType handleType, void* handle) => GLPointers._glImportMemoryWin32HandleEXT_fnptr(memory, size, (uint)handleType, handle);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_win32] [glImportMemoryWin32NameEXT]</b>  </summary>
            public static void ImportMemoryWin32Name(uint memory, ulong size, ExternalHandleType handleType, void* name) => GLPointers._glImportMemoryWin32NameEXT_fnptr(memory, size, (uint)handleType, name);
            
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays] [glMultiDrawArraysEXT]</b>  </summary>
            public static void MultiDrawArrays(PrimitiveType mode, int* first, int* count, int primcount) => GLPointers._glMultiDrawArraysEXT_fnptr((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays] [glMultiDrawElementsEXT]</b>  </summary>
            public static void MultiDrawElements(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int primcount) => GLPointers._glMultiDrawElementsEXT_fnptr((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_EXT_multisample] [glSampleMaskEXT]</b>  </summary>
            public static void SampleMask(float value, bool invert) => GLPointers._glSampleMaskEXT_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_multisample] [glSamplePatternEXT]</b>  </summary>
            public static void SamplePattern(SamplePatternEXT pattern) => GLPointers._glSamplePatternEXT_fnptr((uint)pattern);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture] [glColorTableEXT]</b>  </summary>
            public static void ColorTable(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, void* table) => GLPointers._glColorTableEXT_fnptr((uint)target, (uint)internalFormat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture] [glGetColorTableEXT]</b>  </summary>
            public static void GetColorTable(ColorTableTarget target, PixelFormat format, PixelType type, void* data) => GLPointers._glGetColorTableEXT_fnptr((uint)target, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture] [glGetColorTableParameterivEXT]</b>  </summary>
            public static void GetColorTableParameteriv(ColorTableTarget target, ColorTableParameterPName pname, int* parameters) => GLPointers._glGetColorTableParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture] [glGetColorTableParameterfvEXT]</b>  </summary>
            public static void GetColorTableParameterfv(ColorTableTarget target, ColorTableParameterPName pname, float* parameters) => GLPointers._glGetColorTableParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform] [glPixelTransformParameteriEXT]</b>  </summary>
            public static void PixelTransformParameteri(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int param) => GLPointers._glPixelTransformParameteriEXT_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform] [glPixelTransformParameterfEXT]</b>  </summary>
            public static void PixelTransformParameterf(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float param) => GLPointers._glPixelTransformParameterfEXT_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform] [glPixelTransformParameterivEXT]</b>  </summary>
            public static void PixelTransformParameteriv(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int* parameters) => GLPointers._glPixelTransformParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform] [glPixelTransformParameterfvEXT]</b>  </summary>
            public static void PixelTransformParameterfv(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float* parameters) => GLPointers._glPixelTransformParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform] [glGetPixelTransformParameterivEXT]</b>  </summary>
            public static void GetPixelTransformParameteriv(All target, All pname, int* parameters) => GLPointers._glGetPixelTransformParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform] [glGetPixelTransformParameterfvEXT]</b>  </summary>
            public static void GetPixelTransformParameterfv(All target, All pname, float* parameters) => GLPointers._glGetPixelTransformParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_point_parameters] [glPointParameterfEXT]</b>  </summary>
            public static void PointParameterf(PointParameterNameARB pname, float param) => GLPointers._glPointParameterfEXT_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_point_parameters] [glPointParameterfvEXT]</b>  </summary>
            public static void PointParameterfv(PointParameterNameARB pname, float* parameters) => GLPointers._glPointParameterfvEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_polygon_offset] [glPolygonOffsetEXT]</b>  </summary>
            public static void PolygonOffset(float factor, float bias) => GLPointers._glPolygonOffsetEXT_fnptr(factor, bias);
            
            /// <summary> <b>[requires: GL_EXT_polygon_offset_clamp] [glPolygonOffsetClampEXT]</b>  </summary>
            public static void PolygonOffsetClamp(float factor, float units, float clamp) => GLPointers._glPolygonOffsetClampEXT_fnptr(factor, units, clamp);
            
            /// <summary> <b>[requires: GL_EXT_provoking_vertex] [glProvokingVertexEXT]</b>  </summary>
            public static void ProvokingVertex(VertexProvokingMode mode) => GLPointers._glProvokingVertexEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples] [glRasterSamplesEXT]</b>  </summary>
            public static void RasterSamples(uint samples, bool fixedsamplelocations) => GLPointers._glRasterSamplesEXT_fnptr(samples, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_semaphore] [glGenSemaphoresEXT]</b>  </summary>
            public static void GenSemaphores(int n, uint* semaphores) => GLPointers._glGenSemaphoresEXT_fnptr(n, semaphores);
            
            /// <summary> <b>[requires: GL_EXT_semaphore] [glDeleteSemaphoresEXT]</b>  </summary>
            public static void DeleteSemaphores(int n, uint* semaphores) => GLPointers._glDeleteSemaphoresEXT_fnptr(n, semaphores);
            
            /// <summary> <b>[requires: GL_EXT_semaphore] [glIsSemaphoreEXT]</b>  </summary>
            public static bool IsSemaphore(uint semaphore) => GLPointers._glIsSemaphoreEXT_fnptr(semaphore) != 0;
            
            /// <summary> <b>[requires: GL_EXT_semaphore] [glSemaphoreParameterui64vEXT]</b>  </summary>
            public static void SemaphoreParameterui64v(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => GLPointers._glSemaphoreParameterui64vEXT_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_semaphore] [glGetSemaphoreParameterui64vEXT]</b>  </summary>
            public static void GetSemaphoreParameterui64v(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => GLPointers._glGetSemaphoreParameterui64vEXT_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_semaphore] [glWaitSemaphoreEXT]</b>  </summary>
            public static void WaitSemaphore(uint semaphore, uint numBufferBarriers, int* buffers, uint numTextureBarriers, int* textures, TextureLayout* srcLayouts) => GLPointers._glWaitSemaphoreEXT_fnptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, (uint*)srcLayouts);
            
            /// <summary> <b>[requires: GL_EXT_semaphore] [glSignalSemaphoreEXT]</b>  </summary>
            public static void SignalSemaphore(uint semaphore, uint numBufferBarriers, int* buffers, uint numTextureBarriers, int* textures, TextureLayout* dstLayouts) => GLPointers._glSignalSemaphoreEXT_fnptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, (uint*)dstLayouts);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_fd] [glImportSemaphoreFdEXT]</b>  </summary>
            public static void ImportSemaphoreFd(uint semaphore, ExternalHandleType handleType, int fd) => GLPointers._glImportSemaphoreFdEXT_fnptr(semaphore, (uint)handleType, fd);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_win32] [glImportSemaphoreWin32HandleEXT]</b>  </summary>
            public static void ImportSemaphoreWin32Handle(uint semaphore, ExternalHandleType handleType, void* handle) => GLPointers._glImportSemaphoreWin32HandleEXT_fnptr(semaphore, (uint)handleType, handle);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_win32] [glImportSemaphoreWin32NameEXT]</b>  </summary>
            public static void ImportSemaphoreWin32Name(uint semaphore, ExternalHandleType handleType, void* name) => GLPointers._glImportSemaphoreWin32NameEXT_fnptr(semaphore, (uint)handleType, name);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3bEXT]</b>  </summary>
            public static void SecondaryColor3b(sbyte red, sbyte green, sbyte blue) => GLPointers._glSecondaryColor3bEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3bvEXT]</b>  </summary>
            public static void SecondaryColor3bv(sbyte* v) => GLPointers._glSecondaryColor3bvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3dEXT]</b>  </summary>
            public static void SecondaryColor3d(double red, double green, double blue) => GLPointers._glSecondaryColor3dEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3dvEXT]</b>  </summary>
            public static void SecondaryColor3dv(double* v) => GLPointers._glSecondaryColor3dvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3fEXT]</b>  </summary>
            public static void SecondaryColor3f(float red, float green, float blue) => GLPointers._glSecondaryColor3fEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3fvEXT]</b>  </summary>
            public static void SecondaryColor3fv(float* v) => GLPointers._glSecondaryColor3fvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3iEXT]</b>  </summary>
            public static void SecondaryColor3i(int red, int green, int blue) => GLPointers._glSecondaryColor3iEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3ivEXT]</b>  </summary>
            public static void SecondaryColor3iv(int* v) => GLPointers._glSecondaryColor3ivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3sEXT]</b>  </summary>
            public static void SecondaryColor3s(short red, short green, short blue) => GLPointers._glSecondaryColor3sEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3svEXT]</b>  </summary>
            public static void SecondaryColor3sv(short* v) => GLPointers._glSecondaryColor3svEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3ubEXT]</b>  </summary>
            public static void SecondaryColor3ub(byte red, byte green, byte blue) => GLPointers._glSecondaryColor3ubEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3ubvEXT]</b>  </summary>
            public static void SecondaryColor3ubv(byte* v) => GLPointers._glSecondaryColor3ubvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3uiEXT]</b>  </summary>
            public static void SecondaryColor3ui(uint red, uint green, uint blue) => GLPointers._glSecondaryColor3uiEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3uivEXT]</b>  </summary>
            public static void SecondaryColor3uiv(uint* v) => GLPointers._glSecondaryColor3uivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3usEXT]</b>  </summary>
            public static void SecondaryColor3us(ushort red, ushort green, ushort blue) => GLPointers._glSecondaryColor3usEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColor3usvEXT]</b>  </summary>
            public static void SecondaryColor3usv(ushort* v) => GLPointers._glSecondaryColor3usvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color] [glSecondaryColorPointerEXT]</b>  </summary>
            public static void SecondaryColorPointer(int size, ColorPointerType type, int stride, void* pointer) => GLPointers._glSecondaryColorPointerEXT_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glUseShaderProgramEXT]</b>  </summary>
            public static void UseShaderProgram(All type, int program) => GLPointers._glUseShaderProgramEXT_fnptr((uint)type, program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glActiveProgramEXT]</b>  </summary>
            public static void ActiveProgram(int program) => GLPointers._glActiveProgramEXT_fnptr(program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glCreateShaderProgramEXT]</b>  </summary>
            public static int CreateShaderProgram(ShaderType type, byte* str) => GLPointers._glCreateShaderProgramEXT_fnptr((uint)type, str);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glActiveShaderProgramEXT]</b>  </summary>
            public static void ActiveShaderProgram(int pipeline, int program) => GLPointers._glActiveShaderProgramEXT_fnptr(pipeline, program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glBindProgramPipelineEXT]</b>  </summary>
            public static void BindProgramPipeline(int pipeline) => GLPointers._glBindProgramPipelineEXT_fnptr(pipeline);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glCreateShaderProgramvEXT]</b>  </summary>
            public static int CreateShaderProgramv(ShaderType type, int count, byte** strings) => GLPointers._glCreateShaderProgramvEXT_fnptr((uint)type, count, strings);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glDeleteProgramPipelinesEXT]</b>  </summary>
            public static void DeleteProgramPipelines(int n, int* pipelines) => GLPointers._glDeleteProgramPipelinesEXT_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glGenProgramPipelinesEXT]</b>  </summary>
            public static void GenProgramPipelines(int n, int* pipelines) => GLPointers._glGenProgramPipelinesEXT_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glGetProgramPipelineInfoLogEXT]</b>  </summary>
            public static void GetProgramPipelineInfoLog(int pipeline, int bufSize, int* length, byte* infoLog) => GLPointers._glGetProgramPipelineInfoLogEXT_fnptr(pipeline, bufSize, length, infoLog);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glGetProgramPipelineivEXT]</b>  </summary>
            public static void GetProgramPipelineiv(int pipeline, PipelineParameterName pname, int* parameters) => GLPointers._glGetProgramPipelineivEXT_fnptr(pipeline, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glIsProgramPipelineEXT]</b>  </summary>
            public static bool IsProgramPipeline(int pipeline) => GLPointers._glIsProgramPipelineEXT_fnptr(pipeline) != 0;
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glUseProgramStagesEXT]</b>  </summary>
            public static void UseProgramStages(int pipeline, UseProgramStageMask stages, int program) => GLPointers._glUseProgramStagesEXT_fnptr(pipeline, (uint)stages, program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects] [glValidateProgramPipelineEXT]</b>  </summary>
            public static void ValidateProgramPipeline(int pipeline) => GLPointers._glValidateProgramPipelineEXT_fnptr(pipeline);
            
            /// <summary> <b>[requires: GL_EXT_shader_framebuffer_fetch_non_coherent] [glFramebufferFetchBarrierEXT]</b>  </summary>
            public static void FramebufferFetchBarrier() => GLPointers._glFramebufferFetchBarrierEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store] [glBindImageTextureEXT]</b>  </summary>
            public static void BindImageTexture(uint index, int texture, int level, bool layered, int layer, BufferAccessARB access, int format) => GLPointers._glBindImageTextureEXT_fnptr(index, texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, format);
            
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store] [glMemoryBarrierEXT]</b>  </summary>
            public static void MemoryBarrier(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrierEXT_fnptr((uint)barriers);
            
            /// <summary> <b>[requires: GL_EXT_stencil_clear_tag] [glStencilClearTagEXT]</b>  </summary>
            public static void StencilClearTag(int stencilTagBits, uint stencilClearTag) => GLPointers._glStencilClearTagEXT_fnptr(stencilTagBits, stencilClearTag);
            
            /// <summary> <b>[requires: GL_EXT_stencil_two_side] [glActiveStencilFaceEXT]</b>  </summary>
            public static void ActiveStencilFace(TriangleFace face) => GLPointers._glActiveStencilFaceEXT_fnptr((uint)face);
            
            /// <summary> <b>[requires: GL_EXT_subtexture] [glTexSubImage1DEXT]</b>  </summary>
            public static void TexSubImage1D(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage1DEXT_fnptr((uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_subtexture] [glTexSubImage2DEXT]</b>  </summary>
            public static void TexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage2DEXT_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture3D] [glTexImage3DEXT]</b>  </summary>
            public static void TexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage3DEXT_fnptr((uint)target, level, (uint)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture3D] [glTexSubImage3DEXT]</b>  </summary>
            public static void TexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage3DEXT_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4] [glFramebufferTextureLayerEXT]</b>  </summary>
            public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayerEXT_fnptr((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_EXT_texture_buffer_object] [glTexBufferEXT]</b>  </summary>
            public static void TexBuffer(TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers._glTexBufferEXT_fnptr((uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer] [glTexParameterIivEXT]</b>  </summary>
            public static void TexParameterIiv(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTexParameterIivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer] [glTexParameterIuivEXT]</b>  </summary>
            public static void TexParameterIuiv(TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._glTexParameterIuivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer] [glGetTexParameterIivEXT]</b>  </summary>
            public static void GetTexParameterIiv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexParameterIivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer] [glGetTexParameterIuivEXT]</b>  </summary>
            public static void GetTexParameterIuiv(TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTexParameterIuivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer] [glClearColorIiEXT]</b>  </summary>
            public static void ClearColorIi(int red, int green, int blue, int alpha) => GLPointers._glClearColorIiEXT_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer] [glClearColorIuiEXT]</b>  </summary>
            public static void ClearColorIui(uint red, uint green, uint blue, uint alpha) => GLPointers._glClearColorIuiEXT_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_texture_object] [glAreTexturesResidentEXT]</b>  </summary>
            public static bool AreTexturesResident(int n, int* textures, bool* residences) => GLPointers._glAreTexturesResidentEXT_fnptr(n, textures, (byte*)residences) != 0;
            
            /// <summary> <b>[requires: GL_EXT_texture_object] [glBindTextureEXT]</b>  </summary>
            public static void BindTexture(TextureTarget target, int texture) => GLPointers._glBindTextureEXT_fnptr((uint)target, texture);
            
            /// <summary> <b>[requires: GL_EXT_texture_object] [glDeleteTexturesEXT]</b>  </summary>
            public static void DeleteTextures(int n, int* textures) => GLPointers._glDeleteTexturesEXT_fnptr(n, textures);
            
            /// <summary> <b>[requires: GL_EXT_texture_object] [glGenTexturesEXT]</b>  </summary>
            public static void GenTextures(int n, int* textures) => GLPointers._glGenTexturesEXT_fnptr(n, textures);
            
            /// <summary> <b>[requires: GL_EXT_texture_object] [glIsTextureEXT]</b>  </summary>
            public static bool IsTexture(int texture) => GLPointers._glIsTextureEXT_fnptr(texture) != 0;
            
            /// <summary> <b>[requires: GL_EXT_texture_object] [glPrioritizeTexturesEXT]</b>  </summary>
            public static void PrioritizeTextures(int n, int* textures, float* priorities) => GLPointers._glPrioritizeTexturesEXT_fnptr(n, textures, priorities);
            
            /// <summary> <b>[requires: GL_EXT_texture_perturb_normal] [glTextureNormalEXT]</b>  </summary>
            public static void TextureNormal(TextureNormalModeEXT mode) => GLPointers._glTextureNormalEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage] [glTexStorage1DEXT]</b>  </summary>
            public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTexStorage1DEXT_fnptr((uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage] [glTexStorage2DEXT]</b>  </summary>
            public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTexStorage2DEXT_fnptr((uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage] [glTexStorage3DEXT]</b>  </summary>
            public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTexStorage3DEXT_fnptr((uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: GL_EXT_timer_query] [glGetQueryObjecti64vEXT]</b>  </summary>
            public static void GetQueryObjecti64v(int id, QueryObjectParameterName pname, long* parameters) => GLPointers._glGetQueryObjecti64vEXT_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_timer_query] [glGetQueryObjectui64vEXT]</b>  </summary>
            public static void GetQueryObjectui64v(int id, QueryObjectParameterName pname, ulong* parameters) => GLPointers._glGetQueryObjectui64vEXT_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback] [glBeginTransformFeedbackEXT]</b>  </summary>
            public static void BeginTransformFeedback(PrimitiveType primitiveMode) => GLPointers._glBeginTransformFeedbackEXT_fnptr((uint)primitiveMode);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback] [glEndTransformFeedbackEXT]</b>  </summary>
            public static void EndTransformFeedback() => GLPointers._glEndTransformFeedbackEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback] [glBindBufferRangeEXT]</b>  </summary>
            public static void BindBufferRange(BufferTargetARB target, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glBindBufferRangeEXT_fnptr((uint)target, index, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback] [glBindBufferOffsetEXT]</b>  </summary>
            public static void BindBufferOffset(BufferTargetARB target, uint index, int buffer, IntPtr offset) => GLPointers._glBindBufferOffsetEXT_fnptr((uint)target, index, buffer, offset);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback] [glBindBufferBaseEXT]</b>  </summary>
            public static void BindBufferBase(BufferTargetARB target, uint index, int buffer) => GLPointers._glBindBufferBaseEXT_fnptr((uint)target, index, buffer);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback] [glTransformFeedbackVaryingsEXT]</b>  </summary>
            public static void TransformFeedbackVaryings(int program, int count, byte** varyings, TransformFeedbackBufferMode bufferMode) => GLPointers._glTransformFeedbackVaryingsEXT_fnptr(program, count, varyings, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback] [glGetTransformFeedbackVaryingEXT]</b>  </summary>
            public static void GetTransformFeedbackVarying(int program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers._glGetTransformFeedbackVaryingEXT_fnptr(program, index, bufSize, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array] [glArrayElementEXT]</b>  </summary>
            public static void ArrayElement(int i) => GLPointers._glArrayElementEXT_fnptr(i);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array] [glColorPointerEXT]</b>  </summary>
            public static void ColorPointer(int size, ColorPointerType type, int stride, int count, void* pointer) => GLPointers._glColorPointerEXT_fnptr(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array] [glDrawArraysEXT]</b>  </summary>
            public static void DrawArrays(PrimitiveType mode, int first, int count) => GLPointers._glDrawArraysEXT_fnptr((uint)mode, first, count);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array] [glEdgeFlagPointerEXT]</b>  </summary>
            public static void EdgeFlagPointer(int stride, int count, bool* pointer) => GLPointers._glEdgeFlagPointerEXT_fnptr(stride, count, (byte*)pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array] [glGetPointervEXT]</b>  </summary>
            public static void GetPointerv(GetPointervPName pname, void** parameters) => GLPointers._glGetPointervEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array] [glIndexPointerEXT]</b>  </summary>
            public static void IndexPointer(IndexPointerType type, int stride, int count, void* pointer) => GLPointers._glIndexPointerEXT_fnptr((uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array] [glNormalPointerEXT]</b>  </summary>
            public static void NormalPointer(NormalPointerType type, int stride, int count, void* pointer) => GLPointers._glNormalPointerEXT_fnptr((uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array] [glTexCoordPointerEXT]</b>  </summary>
            public static void TexCoordPointer(int size, TexCoordPointerType type, int stride, int count, void* pointer) => GLPointers._glTexCoordPointerEXT_fnptr(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array] [glVertexPointerEXT]</b>  </summary>
            public static void VertexPointer(int size, VertexPointerType type, int stride, int count, void* pointer) => GLPointers._glVertexPointerEXT_fnptr(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glVertexAttribL1dEXT]</b>  </summary>
            public static void VertexAttribL1d(uint index, double x) => GLPointers._glVertexAttribL1dEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glVertexAttribL2dEXT]</b>  </summary>
            public static void VertexAttribL2d(uint index, double x, double y) => GLPointers._glVertexAttribL2dEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glVertexAttribL3dEXT]</b>  </summary>
            public static void VertexAttribL3d(uint index, double x, double y, double z) => GLPointers._glVertexAttribL3dEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glVertexAttribL4dEXT]</b>  </summary>
            public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttribL4dEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glVertexAttribL1dvEXT]</b>  </summary>
            public static void VertexAttribL1dv(uint index, double* v) => GLPointers._glVertexAttribL1dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glVertexAttribL2dvEXT]</b>  </summary>
            public static void VertexAttribL2dv(uint index, double* v) => GLPointers._glVertexAttribL2dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glVertexAttribL3dvEXT]</b>  </summary>
            public static void VertexAttribL3dv(uint index, double* v) => GLPointers._glVertexAttribL3dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glVertexAttribL4dvEXT]</b>  </summary>
            public static void VertexAttribL4dv(uint index, double* v) => GLPointers._glVertexAttribL4dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glVertexAttribLPointerEXT]</b>  </summary>
            public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers._glVertexAttribLPointerEXT_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit] [glGetVertexAttribLdvEXT]</b>  </summary>
            public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => GLPointers._glGetVertexAttribLdvEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glBeginVertexShaderEXT]</b>  </summary>
            public static void BeginVertexShader() => GLPointers._glBeginVertexShaderEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glEndVertexShaderEXT]</b>  </summary>
            public static void EndVertexShader() => GLPointers._glEndVertexShaderEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glBindVertexShaderEXT]</b>  </summary>
            public static void BindVertexShader(uint id) => GLPointers._glBindVertexShaderEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGenVertexShadersEXT]</b>  </summary>
            public static uint GenVertexShaders(uint range) => GLPointers._glGenVertexShadersEXT_fnptr(range);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glDeleteVertexShaderEXT]</b>  </summary>
            public static void DeleteVertexShader(uint id) => GLPointers._glDeleteVertexShaderEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glShaderOp1EXT]</b>  </summary>
            public static void ShaderOp1(VertexShaderOpEXT op, uint res, uint arg1) => GLPointers._glShaderOp1EXT_fnptr((uint)op, res, arg1);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glShaderOp2EXT]</b>  </summary>
            public static void ShaderOp2(VertexShaderOpEXT op, uint res, uint arg1, uint arg2) => GLPointers._glShaderOp2EXT_fnptr((uint)op, res, arg1, arg2);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glShaderOp3EXT]</b>  </summary>
            public static void ShaderOp3(VertexShaderOpEXT op, uint res, uint arg1, uint arg2, uint arg3) => GLPointers._glShaderOp3EXT_fnptr((uint)op, res, arg1, arg2, arg3);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glSwizzleEXT]</b>  </summary>
            public static void Swizzle(uint res, uint input, VertexShaderCoordOutEXT outX, VertexShaderCoordOutEXT outY, VertexShaderCoordOutEXT outZ, VertexShaderCoordOutEXT outW) => GLPointers._glSwizzleEXT_fnptr(res, input, (uint)outX, (uint)outY, (uint)outZ, (uint)outW);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glWriteMaskEXT]</b>  </summary>
            public static void WriteMask(uint res, uint input, VertexShaderWriteMaskEXT outX, VertexShaderWriteMaskEXT outY, VertexShaderWriteMaskEXT outZ, VertexShaderWriteMaskEXT outW) => GLPointers._glWriteMaskEXT_fnptr(res, input, (uint)outX, (uint)outY, (uint)outZ, (uint)outW);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glInsertComponentEXT]</b>  </summary>
            public static void InsertComponent(uint res, uint src, uint num) => GLPointers._glInsertComponentEXT_fnptr(res, src, num);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glExtractComponentEXT]</b>  </summary>
            public static void ExtractComponent(uint res, uint src, uint num) => GLPointers._glExtractComponentEXT_fnptr(res, src, num);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGenSymbolsEXT]</b>  </summary>
            public static uint GenSymbols(DataTypeEXT datatype, VertexShaderStorageTypeEXT storagetype, ParameterRangeEXT range, uint components) => GLPointers._glGenSymbolsEXT_fnptr((uint)datatype, (uint)storagetype, (uint)range, components);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glSetInvariantEXT]</b>  </summary>
            public static void SetInvariant(uint id, ScalarType type, void* addr) => GLPointers._glSetInvariantEXT_fnptr(id, (uint)type, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glSetLocalConstantEXT]</b>  </summary>
            public static void SetLocalConstant(uint id, ScalarType type, void* addr) => GLPointers._glSetLocalConstantEXT_fnptr(id, (uint)type, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glVariantbvEXT]</b>  </summary>
            public static void Variantbv(uint id, sbyte* addr) => GLPointers._glVariantbvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glVariantsvEXT]</b>  </summary>
            public static void Variantsv(uint id, short* addr) => GLPointers._glVariantsvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glVariantivEXT]</b>  </summary>
            public static void Variantiv(uint id, int* addr) => GLPointers._glVariantivEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glVariantfvEXT]</b>  </summary>
            public static void Variantfv(uint id, float* addr) => GLPointers._glVariantfvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glVariantdvEXT]</b>  </summary>
            public static void Variantdv(uint id, double* addr) => GLPointers._glVariantdvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glVariantubvEXT]</b>  </summary>
            public static void Variantubv(uint id, byte* addr) => GLPointers._glVariantubvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glVariantusvEXT]</b>  </summary>
            public static void Variantusv(uint id, ushort* addr) => GLPointers._glVariantusvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glVariantuivEXT]</b>  </summary>
            public static void Variantuiv(uint id, uint* addr) => GLPointers._glVariantuivEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glVariantPointerEXT]</b>  </summary>
            public static void VariantPointer(uint id, ScalarType type, uint stride, void* addr) => GLPointers._glVariantPointerEXT_fnptr(id, (uint)type, stride, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glEnableVariantClientStateEXT]</b>  </summary>
            public static void EnableVariantClientState(uint id) => GLPointers._glEnableVariantClientStateEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glDisableVariantClientStateEXT]</b>  </summary>
            public static void DisableVariantClientState(uint id) => GLPointers._glDisableVariantClientStateEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glBindLightParameterEXT]</b>  </summary>
            public static uint BindLightParameter(LightName light, LightParameter value) => GLPointers._glBindLightParameterEXT_fnptr((uint)light, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glBindMaterialParameterEXT]</b>  </summary>
            public static uint BindMaterialParameter(TriangleFace face, MaterialParameter value) => GLPointers._glBindMaterialParameterEXT_fnptr((uint)face, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glBindTexGenParameterEXT]</b>  </summary>
            public static uint BindTexGenParameter(TextureUnit unit, TextureCoordName coord, TextureGenParameter value) => GLPointers._glBindTexGenParameterEXT_fnptr((uint)unit, (uint)coord, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glBindTextureUnitParameterEXT]</b>  </summary>
            public static uint BindTextureUnitParameter(TextureUnit unit, VertexShaderTextureUnitParameter value) => GLPointers._glBindTextureUnitParameterEXT_fnptr((uint)unit, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glBindParameterEXT]</b>  </summary>
            public static uint BindParameter(VertexShaderParameterEXT value) => GLPointers._glBindParameterEXT_fnptr((uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glIsVariantEnabledEXT]</b>  </summary>
            public static bool IsVariantEnabled(uint id, VariantCapEXT cap) => GLPointers._glIsVariantEnabledEXT_fnptr(id, (uint)cap) != 0;
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetVariantBooleanvEXT]</b>  </summary>
            public static void GetVariantBooleanv(uint id, GetVariantValueEXT value, bool* data) => GLPointers._glGetVariantBooleanvEXT_fnptr(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetVariantIntegervEXT]</b>  </summary>
            public static void GetVariantIntegerv(uint id, GetVariantValueEXT value, int* data) => GLPointers._glGetVariantIntegervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetVariantFloatvEXT]</b>  </summary>
            public static void GetVariantFloatv(uint id, GetVariantValueEXT value, float* data) => GLPointers._glGetVariantFloatvEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetVariantPointervEXT]</b>  </summary>
            public static void GetVariantPointerv(uint id, GetVariantValueEXT value, void** data) => GLPointers._glGetVariantPointervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetInvariantBooleanvEXT]</b>  </summary>
            public static void GetInvariantBooleanv(uint id, GetVariantValueEXT value, bool* data) => GLPointers._glGetInvariantBooleanvEXT_fnptr(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetInvariantIntegervEXT]</b>  </summary>
            public static void GetInvariantIntegerv(uint id, GetVariantValueEXT value, int* data) => GLPointers._glGetInvariantIntegervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetInvariantFloatvEXT]</b>  </summary>
            public static void GetInvariantFloatv(uint id, GetVariantValueEXT value, float* data) => GLPointers._glGetInvariantFloatvEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetLocalConstantBooleanvEXT]</b>  </summary>
            public static void GetLocalConstantBooleanv(uint id, GetVariantValueEXT value, bool* data) => GLPointers._glGetLocalConstantBooleanvEXT_fnptr(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetLocalConstantIntegervEXT]</b>  </summary>
            public static void GetLocalConstantIntegerv(uint id, GetVariantValueEXT value, int* data) => GLPointers._glGetLocalConstantIntegervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader] [glGetLocalConstantFloatvEXT]</b>  </summary>
            public static void GetLocalConstantFloatv(uint id, GetVariantValueEXT value, float* data) => GLPointers._glGetLocalConstantFloatvEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting] [glVertexWeightfEXT]</b>  </summary>
            public static void VertexWeightf(float weight) => GLPointers._glVertexWeightfEXT_fnptr(weight);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting] [glVertexWeightfvEXT]</b>  </summary>
            public static void VertexWeightfv(float* weight) => GLPointers._glVertexWeightfvEXT_fnptr(weight);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting] [glVertexWeightPointerEXT]</b>  </summary>
            public static void VertexWeightPointer(int size, VertexWeightPointerTypeEXT type, int stride, void* pointer) => GLPointers._glVertexWeightPointerEXT_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex] [glAcquireKeyedMutexWin32EXT]</b>  </summary>
            public static bool AcquireKeyedMutexWin32(uint memory, ulong key, uint timeout) => GLPointers._glAcquireKeyedMutexWin32EXT_fnptr(memory, key, timeout) != 0;
            
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex] [glReleaseKeyedMutexWin32EXT]</b>  </summary>
            public static bool ReleaseKeyedMutexWin32(uint memory, ulong key) => GLPointers._glReleaseKeyedMutexWin32EXT_fnptr(memory, key) != 0;
            
            /// <summary> <b>[requires: GL_EXT_window_rectangles] [glWindowRectanglesEXT]</b>  </summary>
            public static void WindowRectangles(All mode, int count, int* box) => GLPointers._glWindowRectanglesEXT_fnptr((uint)mode, count, box);
            
            /// <summary> <b>[requires: GL_EXT_x11_sync_object] [glImportSyncEXT]</b>  </summary>
            public static GLSync ImportSync(All external_sync_type, IntPtr external_sync, uint flags) => (GLSync) GLPointers._glImportSyncEXT_fnptr((uint)external_sync_type, external_sync, flags);
            
        }
        /// <summary>NV extensions.</summary>
        public static unsafe partial class NV
        {
            /// <summary> <b>[requires: GL_NV_timeline_semaphore] [glCreateSemaphoresNV]</b>  </summary>
            public static void CreateSemaphores(int n, uint* semaphores) => GLPointers._glCreateSemaphoresNV_fnptr(n, semaphores);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore] [glSemaphoreParameterivNV]</b>  </summary>
            public static void SemaphoreParameteriv(uint semaphore, SemaphoreParameterName pname, int* parameters) => GLPointers._glSemaphoreParameterivNV_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore] [glGetSemaphoreParameterivNV]</b>  </summary>
            public static void GetSemaphoreParameteriv(uint semaphore, SemaphoreParameterName pname, int* parameters) => GLPointers._glGetSemaphoreParameterivNV_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_alpha_to_coverage_dither_control] [glAlphaToCoverageDitherControlNV]</b>  </summary>
            public static void AlphaToCoverageDitherControl(All mode) => GLPointers._glAlphaToCoverageDitherControlNV_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect] [glMultiDrawArraysIndirectBindlessNV]</b>  </summary>
            public static void MultiDrawArraysIndirectBindless(PrimitiveType mode, void* indirect, int drawCount, int stride, int vertexBufferCount) => GLPointers._glMultiDrawArraysIndirectBindlessNV_fnptr((uint)mode, indirect, drawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect] [glMultiDrawElementsIndirectBindlessNV]</b>  </summary>
            public static void MultiDrawElementsIndirectBindless(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int stride, int vertexBufferCount) => GLPointers._glMultiDrawElementsIndirectBindlessNV_fnptr((uint)mode, (uint)type, indirect, drawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count] [glMultiDrawArraysIndirectBindlessCountNV]</b>  </summary>
            public static void MultiDrawArraysIndirectBindlessCount(PrimitiveType mode, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => GLPointers._glMultiDrawArraysIndirectBindlessCountNV_fnptr((uint)mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count] [glMultiDrawElementsIndirectBindlessCountNV]</b>  </summary>
            public static void MultiDrawElementsIndirectBindlessCount(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => GLPointers._glMultiDrawElementsIndirectBindlessCountNV_fnptr((uint)mode, (uint)type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glGetTextureHandleNV]</b>  </summary>
            public static ulong GetTextureHandle(int texture) => GLPointers._glGetTextureHandleNV_fnptr(texture);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glGetTextureSamplerHandleNV]</b>  </summary>
            public static ulong GetTextureSamplerHandle(int texture, int sampler) => GLPointers._glGetTextureSamplerHandleNV_fnptr(texture, sampler);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glMakeTextureHandleResidentNV]</b>  </summary>
            public static void MakeTextureHandleResident(ulong handle) => GLPointers._glMakeTextureHandleResidentNV_fnptr(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glMakeTextureHandleNonResidentNV]</b>  </summary>
            public static void MakeTextureHandleNonResident(ulong handle) => GLPointers._glMakeTextureHandleNonResidentNV_fnptr(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glGetImageHandleNV]</b>  </summary>
            public static ulong GetImageHandle(int texture, int level, bool layered, int layer, PixelFormat format) => GLPointers._glGetImageHandleNV_fnptr(texture, level, (byte)(layered ? 1 : 0), layer, (uint)format);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glMakeImageHandleResidentNV]</b>  </summary>
            public static void MakeImageHandleResident(ulong handle, All access) => GLPointers._glMakeImageHandleResidentNV_fnptr(handle, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glMakeImageHandleNonResidentNV]</b>  </summary>
            public static void MakeImageHandleNonResident(ulong handle) => GLPointers._glMakeImageHandleNonResidentNV_fnptr(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glUniformHandleui64NV]</b>  </summary>
            public static void UniformHandleui64(int location, ulong value) => GLPointers._glUniformHandleui64NV_fnptr(location, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glUniformHandleui64vNV]</b>  </summary>
            public static void UniformHandleui64v(int location, int count, ulong* value) => GLPointers._glUniformHandleui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glProgramUniformHandleui64NV]</b>  </summary>
            public static void ProgramUniformHandleui64(int program, int location, ulong value) => GLPointers._glProgramUniformHandleui64NV_fnptr(program, location, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glProgramUniformHandleui64vNV]</b>  </summary>
            public static void ProgramUniformHandleui64v(int program, int location, int count, ulong* values) => GLPointers._glProgramUniformHandleui64vNV_fnptr(program, location, count, values);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glIsTextureHandleResidentNV]</b>  </summary>
            public static bool IsTextureHandleResident(ulong handle) => GLPointers._glIsTextureHandleResidentNV_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_NV_bindless_texture] [glIsImageHandleResidentNV]</b>  </summary>
            public static bool IsImageHandleResident(ulong handle) => GLPointers._glIsImageHandleResidentNV_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced] [glBlendParameteriNV]</b>  </summary>
            public static void BlendParameteri(All pname, int value) => GLPointers._glBlendParameteriNV_fnptr((uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced] [glBlendBarrierNV]</b>  </summary>
            public static void BlendBarrier() => GLPointers._glBlendBarrierNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_clip_space_w_scaling] [glViewportPositionWScaleNV]</b>  </summary>
            public static void ViewportPositionWScale(uint index, float xcoeff, float ycoeff) => GLPointers._glViewportPositionWScaleNV_fnptr(index, xcoeff, ycoeff);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glCreateStatesNV]</b>  </summary>
            public static void CreateStates(int n, uint* states) => GLPointers._glCreateStatesNV_fnptr(n, states);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glDeleteStatesNV]</b>  </summary>
            public static void DeleteStates(int n, uint* states) => GLPointers._glDeleteStatesNV_fnptr(n, states);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glIsStateNV]</b>  </summary>
            public static bool IsState(uint state) => GLPointers._glIsStateNV_fnptr(state) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list] [glStateCaptureNV]</b>  </summary>
            public static void StateCapture(uint state, All mode) => GLPointers._glStateCaptureNV_fnptr(state, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glGetCommandHeaderNV]</b>  </summary>
            public static uint GetCommandHeader(CommandOpcodesNV tokenID, uint size) => GLPointers._glGetCommandHeaderNV_fnptr((uint)tokenID, size);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glGetStageIndexNV]</b>  </summary>
            public static ushort GetStageIndex(ShaderType shadertype) => GLPointers._glGetStageIndexNV_fnptr((uint)shadertype);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glDrawCommandsNV]</b>  </summary>
            public static void DrawCommands(All primitiveMode, uint buffer, IntPtr* indirects, int* sizes, uint count) => GLPointers._glDrawCommandsNV_fnptr((uint)primitiveMode, buffer, indirects, sizes, count);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glDrawCommandsAddressNV]</b>  </summary>
            public static void DrawCommandsAddress(All primitiveMode, ulong* indirects, int* sizes, uint count) => GLPointers._glDrawCommandsAddressNV_fnptr((uint)primitiveMode, indirects, sizes, count);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glDrawCommandsStatesNV]</b>  </summary>
            public static void DrawCommandsStates(int buffer, IntPtr* indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers._glDrawCommandsStatesNV_fnptr(buffer, indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glDrawCommandsStatesAddressNV]</b>  </summary>
            public static void DrawCommandsStatesAddress(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers._glDrawCommandsStatesAddressNV_fnptr(indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glCreateCommandListsNV]</b>  </summary>
            public static void CreateCommandLists(int n, uint* lists) => GLPointers._glCreateCommandListsNV_fnptr(n, lists);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glDeleteCommandListsNV]</b>  </summary>
            public static void DeleteCommandLists(int n, uint* lists) => GLPointers._glDeleteCommandListsNV_fnptr(n, lists);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glIsCommandListNV]</b>  </summary>
            public static bool IsCommandList(uint list) => GLPointers._glIsCommandListNV_fnptr(list) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list] [glListDrawCommandsStatesClientNV]</b>  </summary>
            public static void ListDrawCommandsStatesClient(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers._glListDrawCommandsStatesClientNV_fnptr(list, segment, indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glCommandListSegmentsNV]</b>  </summary>
            public static void CommandListSegments(uint list, uint segments) => GLPointers._glCommandListSegmentsNV_fnptr(list, segments);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glCompileCommandListNV]</b>  </summary>
            public static void CompileCommandList(uint list) => GLPointers._glCompileCommandListNV_fnptr(list);
            
            /// <summary> <b>[requires: GL_NV_command_list] [glCallCommandListNV]</b>  </summary>
            public static void CallCommandList(uint list) => GLPointers._glCallCommandListNV_fnptr(list);
            
            /// <summary> <b>[requires: GL_NV_conditional_render] [glBeginConditionalRenderNV]</b>  </summary>
            public static void BeginConditionalRender(uint id, ConditionalRenderMode mode) => GLPointers._glBeginConditionalRenderNV_fnptr(id, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_conditional_render] [glEndConditionalRenderNV]</b>  </summary>
            public static void EndConditionalRender() => GLPointers._glEndConditionalRenderNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_conservative_raster] [glSubpixelPrecisionBiasNV]</b>  </summary>
            public static void SubpixelPrecisionBias(uint xbits, uint ybits) => GLPointers._glSubpixelPrecisionBiasNV_fnptr(xbits, ybits);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster_dilate] [glConservativeRasterParameterfNV]</b>  </summary>
            public static void ConservativeRasterParameterf(All pname, float value) => GLPointers._glConservativeRasterParameterfNV_fnptr((uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster_pre_snap_triangles] [glConservativeRasterParameteriNV]</b>  </summary>
            public static void ConservativeRasterParameteri(All pname, int param) => GLPointers._glConservativeRasterParameteriNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_copy_image] [glCopyImageSubDataNV]</b>  </summary>
            public static void CopyImageSubData(uint srcName, CopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => GLPointers._glCopyImageSubDataNV_fnptr(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float] [glDepthRangedNV]</b>  </summary>
            public static void DepthRanged(double zNear, double zFar) => GLPointers._glDepthRangedNV_fnptr(zNear, zFar);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float] [glClearDepthdNV]</b>  </summary>
            public static void ClearDepthd(double depth) => GLPointers._glClearDepthdNV_fnptr(depth);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float] [glDepthBoundsdNV]</b>  </summary>
            public static void DepthBoundsd(double zmin, double zmax) => GLPointers._glDepthBoundsdNV_fnptr(zmin, zmax);
            
            /// <summary> <b>[requires: GL_NV_draw_texture] [glDrawTextureNV]</b>  </summary>
            public static void DrawTexture(int texture, int sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => GLPointers._glDrawTextureNV_fnptr(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image] [glDrawVkImageNV]</b>  </summary>
            public static void DrawVkImage(ulong vkImage, int sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => GLPointers._glDrawVkImageNV_fnptr(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image] [glGetVkProcAddrNV]</b>  </summary>
            public static IntPtr GetVkProcAddr(byte* name) => GLPointers._glGetVkProcAddrNV_fnptr(name);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image] [glWaitVkSemaphoreNV]</b>  </summary>
            public static void WaitVkSemaphore(ulong vkSemaphore) => GLPointers._glWaitVkSemaphoreNV_fnptr(vkSemaphore);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image] [glSignalVkSemaphoreNV]</b>  </summary>
            public static void SignalVkSemaphore(ulong vkSemaphore) => GLPointers._glSignalVkSemaphoreNV_fnptr(vkSemaphore);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image] [glSignalVkFenceNV]</b>  </summary>
            public static void SignalVkFence(ulong vkFence) => GLPointers._glSignalVkFenceNV_fnptr(vkFence);
            
            /// <summary> <b>[requires: GL_NV_evaluators] [glMapControlPointsNV]</b>  </summary>
            public static void MapControlPoints(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, bool packed, void* points) => GLPointers._glMapControlPointsNV_fnptr((uint)target, index, (uint)type, ustride, vstride, uorder, vorder, (byte)(packed ? 1 : 0), points);
            
            /// <summary> <b>[requires: GL_NV_evaluators] [glMapParameterivNV]</b>  </summary>
            public static void MapParameteriv(EvalTargetNV target, MapParameterNV pname, int* parameters) => GLPointers._glMapParameterivNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators] [glMapParameterfvNV]</b>  </summary>
            public static void MapParameterfv(EvalTargetNV target, MapParameterNV pname, float* parameters) => GLPointers._glMapParameterfvNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators] [glGetMapControlPointsNV]</b>  </summary>
            public static void GetMapControlPoints(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, bool packed, void* points) => GLPointers._glGetMapControlPointsNV_fnptr((uint)target, index, (uint)type, ustride, vstride, (byte)(packed ? 1 : 0), points);
            
            /// <summary> <b>[requires: GL_NV_evaluators] [glGetMapParameterivNV]</b>  </summary>
            public static void GetMapParameteriv(EvalTargetNV target, MapParameterNV pname, int* parameters) => GLPointers._glGetMapParameterivNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators] [glGetMapParameterfvNV]</b>  </summary>
            public static void GetMapParameterfv(EvalTargetNV target, MapParameterNV pname, float* parameters) => GLPointers._glGetMapParameterfvNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators] [glGetMapAttribParameterivNV]</b>  </summary>
            public static void GetMapAttribParameteriv(EvalTargetNV target, uint index, MapAttribParameterNV pname, int* parameters) => GLPointers._glGetMapAttribParameterivNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators] [glGetMapAttribParameterfvNV]</b>  </summary>
            public static void GetMapAttribParameterfv(EvalTargetNV target, uint index, MapAttribParameterNV pname, float* parameters) => GLPointers._glGetMapAttribParameterfvNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators] [glEvalMapsNV]</b>  </summary>
            public static void EvalMaps(EvalTargetNV target, EvalMapsModeNV mode) => GLPointers._glEvalMapsNV_fnptr((uint)target, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample] [glGetMultisamplefvNV]</b>  </summary>
            public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers._glGetMultisamplefvNV_fnptr((uint)pname, index, val);
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample] [glSampleMaskIndexedNV]</b>  </summary>
            public static void SampleMaskIndexed(uint index, uint mask) => GLPointers._glSampleMaskIndexedNV_fnptr(index, mask);
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample] [glTexRenderbufferNV]</b>  </summary>
            public static void TexRenderbuffer(TextureTarget target, int renderbuffer) => GLPointers._glTexRenderbufferNV_fnptr((uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_NV_fence] [glDeleteFencesNV]</b>  </summary>
            public static void DeleteFences(int n, uint* fences) => GLPointers._glDeleteFencesNV_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_NV_fence] [glGenFencesNV]</b>  </summary>
            public static void GenFences(int n, uint* fences) => GLPointers._glGenFencesNV_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_NV_fence] [glIsFenceNV]</b>  </summary>
            public static bool IsFence(uint fence) => GLPointers._glIsFenceNV_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_NV_fence] [glTestFenceNV]</b>  </summary>
            public static bool TestFence(uint fence) => GLPointers._glTestFenceNV_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_NV_fence] [glGetFenceivNV]</b>  </summary>
            public static void GetFenceiv(uint fence, FenceParameterNameNV pname, int* parameters) => GLPointers._glGetFenceivNV_fnptr(fence, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_fence] [glFinishFenceNV]</b>  </summary>
            public static void FinishFence(uint fence) => GLPointers._glFinishFenceNV_fnptr(fence);
            
            /// <summary> <b>[requires: GL_NV_fence] [glSetFenceNV]</b>  </summary>
            public static void SetFence(uint fence, FenceConditionNV condition) => GLPointers._glSetFenceNV_fnptr(fence, (uint)condition);
            
            /// <summary> <b>[requires: GL_NV_fragment_coverage_to_color] [glFragmentCoverageColorNV]</b>  </summary>
            public static void FragmentCoverageColor(uint color) => GLPointers._glFragmentCoverageColorNV_fnptr(color);
            
            /// <summary> <b>[requires: GL_NV_fragment_program] [glProgramNamedParameter4fNV]</b>  </summary>
            public static void ProgramNamedParameter4f(int id, int len, byte* name, float x, float y, float z, float w) => GLPointers._glProgramNamedParameter4fNV_fnptr(id, len, name, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_fragment_program] [glProgramNamedParameter4fvNV]</b>  </summary>
            public static void ProgramNamedParameter4fv(int id, int len, byte* name, float* v) => GLPointers._glProgramNamedParameter4fvNV_fnptr(id, len, name, v);
            
            /// <summary> <b>[requires: GL_NV_fragment_program] [glProgramNamedParameter4dNV]</b>  </summary>
            public static void ProgramNamedParameter4d(int id, int len, byte* name, double x, double y, double z, double w) => GLPointers._glProgramNamedParameter4dNV_fnptr(id, len, name, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_fragment_program] [glProgramNamedParameter4dvNV]</b>  </summary>
            public static void ProgramNamedParameter4dv(int id, int len, byte* name, double* v) => GLPointers._glProgramNamedParameter4dvNV_fnptr(id, len, name, v);
            
            /// <summary> <b>[requires: GL_NV_fragment_program] [glGetProgramNamedParameterfvNV]</b>  </summary>
            public static void GetProgramNamedParameterfv(int id, int len, byte* name, float* parameters) => GLPointers._glGetProgramNamedParameterfvNV_fnptr(id, len, name, parameters);
            
            /// <summary> <b>[requires: GL_NV_fragment_program] [glGetProgramNamedParameterdvNV]</b>  </summary>
            public static void GetProgramNamedParameterdv(int id, int len, byte* name, double* parameters) => GLPointers._glGetProgramNamedParameterdvNV_fnptr(id, len, name, parameters);
            
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples] [glRasterSamplesEXT]</b>  </summary>
            public static void RasterSamplesEXT(uint samples, bool fixedsamplelocations) => GLPointers._glRasterSamplesEXT_fnptr(samples, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples] [glCoverageModulationTableNV]</b>  </summary>
            public static void CoverageModulationTable(int n, float* v) => GLPointers._glCoverageModulationTableNV_fnptr(n, v);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples] [glGetCoverageModulationTableNV]</b>  </summary>
            public static void GetCoverageModulationTable(int bufSize, float* v) => GLPointers._glGetCoverageModulationTableNV_fnptr(bufSize, v);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples] [glCoverageModulationNV]</b>  </summary>
            public static void CoverageModulation(All components) => GLPointers._glCoverageModulationNV_fnptr((uint)components);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_multisample_coverage] [glRenderbufferStorageMultisampleCoverageNV]</b>  </summary>
            public static void RenderbufferStorageMultisampleCoverage(RenderbufferTarget target, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisampleCoverageNV_fnptr((uint)target, coverageSamples, colorSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4] [glProgramVertexLimitNV]</b>  </summary>
            public static void ProgramVertexLimit(ProgramTarget target, int limit) => GLPointers._glProgramVertexLimitNV_fnptr((uint)target, limit);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4] [glFramebufferTextureEXT]</b>  </summary>
            public static void FramebufferTextureEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level) => GLPointers._glFramebufferTextureEXT_fnptr((uint)target, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4] [glFramebufferTextureLayerEXT]</b>  </summary>
            public static void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayerEXT_fnptr((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4] [glFramebufferTextureFaceEXT]</b>  </summary>
            public static void FramebufferTextureFaceEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, TextureTarget face) => GLPointers._glFramebufferTextureFaceEXT_fnptr((uint)target, (uint)attachment, texture, level, (uint)face);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramLocalParameterI4iNV]</b>  </summary>
            public static void ProgramLocalParameterI4i(ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers._glProgramLocalParameterI4iNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramLocalParameterI4ivNV]</b>  </summary>
            public static void ProgramLocalParameterI4iv(ProgramTarget target, uint index, int* parameters) => GLPointers._glProgramLocalParameterI4ivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramLocalParametersI4ivNV]</b>  </summary>
            public static void ProgramLocalParametersI4iv(ProgramTarget target, uint index, int count, int* parameters) => GLPointers._glProgramLocalParametersI4ivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramLocalParameterI4uiNV]</b>  </summary>
            public static void ProgramLocalParameterI4ui(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers._glProgramLocalParameterI4uiNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramLocalParameterI4uivNV]</b>  </summary>
            public static void ProgramLocalParameterI4uiv(ProgramTarget target, uint index, uint* parameters) => GLPointers._glProgramLocalParameterI4uivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramLocalParametersI4uivNV]</b>  </summary>
            public static void ProgramLocalParametersI4uiv(ProgramTarget target, uint index, int count, uint* parameters) => GLPointers._glProgramLocalParametersI4uivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramEnvParameterI4iNV]</b>  </summary>
            public static void ProgramEnvParameterI4i(ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers._glProgramEnvParameterI4iNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramEnvParameterI4ivNV]</b>  </summary>
            public static void ProgramEnvParameterI4iv(ProgramTarget target, uint index, int* parameters) => GLPointers._glProgramEnvParameterI4ivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramEnvParametersI4ivNV]</b>  </summary>
            public static void ProgramEnvParametersI4iv(ProgramTarget target, uint index, int count, int* parameters) => GLPointers._glProgramEnvParametersI4ivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramEnvParameterI4uiNV]</b>  </summary>
            public static void ProgramEnvParameterI4ui(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers._glProgramEnvParameterI4uiNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramEnvParameterI4uivNV]</b>  </summary>
            public static void ProgramEnvParameterI4uiv(ProgramTarget target, uint index, uint* parameters) => GLPointers._glProgramEnvParameterI4uivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glProgramEnvParametersI4uivNV]</b>  </summary>
            public static void ProgramEnvParametersI4uiv(ProgramTarget target, uint index, int count, uint* parameters) => GLPointers._glProgramEnvParametersI4uivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glGetProgramLocalParameterIivNV]</b>  </summary>
            public static void GetProgramLocalParameterIiv(ProgramTarget target, uint index, int* parameters) => GLPointers._glGetProgramLocalParameterIivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glGetProgramLocalParameterIuivNV]</b>  </summary>
            public static void GetProgramLocalParameterIuiv(ProgramTarget target, uint index, uint* parameters) => GLPointers._glGetProgramLocalParameterIuivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glGetProgramEnvParameterIivNV]</b>  </summary>
            public static void GetProgramEnvParameterIiv(ProgramTarget target, uint index, int* parameters) => GLPointers._glGetProgramEnvParameterIivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4] [glGetProgramEnvParameterIuivNV]</b>  </summary>
            public static void GetProgramEnvParameterIuiv(ProgramTarget target, uint index, uint* parameters) => GLPointers._glGetProgramEnvParameterIuivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program5] [glProgramSubroutineParametersuivNV]</b>  </summary>
            public static void ProgramSubroutineParametersuiv(All target, int count, uint* parameters) => GLPointers._glProgramSubroutineParametersuivNV_fnptr((uint)target, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program5] [glGetProgramSubroutineParameteruivNV]</b>  </summary>
            public static void GetProgramSubroutineParameteruiv(All target, uint index, uint* param) => GLPointers._glGetProgramSubroutineParameteruivNV_fnptr((uint)target, index, param);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform1i64NV]</b>  </summary>
            public static void Uniform1i64(int location, long x) => GLPointers._glUniform1i64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform2i64NV]</b>  </summary>
            public static void Uniform2i64(int location, long x, long y) => GLPointers._glUniform2i64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform3i64NV]</b>  </summary>
            public static void Uniform3i64(int location, long x, long y, long z) => GLPointers._glUniform3i64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform4i64NV]</b>  </summary>
            public static void Uniform4i64(int location, long x, long y, long z, long w) => GLPointers._glUniform4i64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform1i64vNV]</b>  </summary>
            public static void Uniform1i64v(int location, int count, long* value) => GLPointers._glUniform1i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform2i64vNV]</b>  </summary>
            public static void Uniform2i64v(int location, int count, long* value) => GLPointers._glUniform2i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform3i64vNV]</b>  </summary>
            public static void Uniform3i64v(int location, int count, long* value) => GLPointers._glUniform3i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform4i64vNV]</b>  </summary>
            public static void Uniform4i64v(int location, int count, long* value) => GLPointers._glUniform4i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform1ui64NV]</b>  </summary>
            public static void Uniform1ui64(int location, ulong x) => GLPointers._glUniform1ui64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform2ui64NV]</b>  </summary>
            public static void Uniform2ui64(int location, ulong x, ulong y) => GLPointers._glUniform2ui64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform3ui64NV]</b>  </summary>
            public static void Uniform3ui64(int location, ulong x, ulong y, ulong z) => GLPointers._glUniform3ui64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform4ui64NV]</b>  </summary>
            public static void Uniform4ui64(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glUniform4ui64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform1ui64vNV]</b>  </summary>
            public static void Uniform1ui64v(int location, int count, ulong* value) => GLPointers._glUniform1ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform2ui64vNV]</b>  </summary>
            public static void Uniform2ui64v(int location, int count, ulong* value) => GLPointers._glUniform2ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform3ui64vNV]</b>  </summary>
            public static void Uniform3ui64v(int location, int count, ulong* value) => GLPointers._glUniform3ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glUniform4ui64vNV]</b>  </summary>
            public static void Uniform4ui64v(int location, int count, ulong* value) => GLPointers._glUniform4ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glGetUniformi64vNV]</b>  </summary>
            public static void GetUniformi64v(int program, int location, long* parameters) => GLPointers._glGetUniformi64vNV_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform1i64NV]</b>  </summary>
            public static void ProgramUniform1i64(int program, int location, long x) => GLPointers._glProgramUniform1i64NV_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform2i64NV]</b>  </summary>
            public static void ProgramUniform2i64(int program, int location, long x, long y) => GLPointers._glProgramUniform2i64NV_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform3i64NV]</b>  </summary>
            public static void ProgramUniform3i64(int program, int location, long x, long y, long z) => GLPointers._glProgramUniform3i64NV_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform4i64NV]</b>  </summary>
            public static void ProgramUniform4i64(int program, int location, long x, long y, long z, long w) => GLPointers._glProgramUniform4i64NV_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform1i64vNV]</b>  </summary>
            public static void ProgramUniform1i64v(int program, int location, int count, long* value) => GLPointers._glProgramUniform1i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform2i64vNV]</b>  </summary>
            public static void ProgramUniform2i64v(int program, int location, int count, long* value) => GLPointers._glProgramUniform2i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform3i64vNV]</b>  </summary>
            public static void ProgramUniform3i64v(int program, int location, int count, long* value) => GLPointers._glProgramUniform3i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform4i64vNV]</b>  </summary>
            public static void ProgramUniform4i64v(int program, int location, int count, long* value) => GLPointers._glProgramUniform4i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform1ui64NV]</b>  </summary>
            public static void ProgramUniform1ui64(int program, int location, ulong x) => GLPointers._glProgramUniform1ui64NV_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform2ui64NV]</b>  </summary>
            public static void ProgramUniform2ui64(int program, int location, ulong x, ulong y) => GLPointers._glProgramUniform2ui64NV_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform3ui64NV]</b>  </summary>
            public static void ProgramUniform3ui64(int program, int location, ulong x, ulong y, ulong z) => GLPointers._glProgramUniform3ui64NV_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform4ui64NV]</b>  </summary>
            public static void ProgramUniform4ui64(int program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glProgramUniform4ui64NV_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform1ui64vNV]</b>  </summary>
            public static void ProgramUniform1ui64v(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform1ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform2ui64vNV]</b>  </summary>
            public static void ProgramUniform2ui64v(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform2ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform3ui64vNV]</b>  </summary>
            public static void ProgramUniform3ui64v(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform3ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5] [glProgramUniform4ui64vNV]</b>  </summary>
            public static void ProgramUniform4ui64v(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform4ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertex2hNV]</b>  </summary>
            public static void Vertex2h(Half x, Half y) => GLPointers._glVertex2hNV_fnptr((ushort)x, (ushort)y);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertex2hvNV]</b>  </summary>
            public static void Vertex2hv(Half* v) => GLPointers._glVertex2hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertex3hNV]</b>  </summary>
            public static void Vertex3h(Half x, Half y, Half z) => GLPointers._glVertex3hNV_fnptr((ushort)x, (ushort)y, (ushort)z);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertex3hvNV]</b>  </summary>
            public static void Vertex3hv(Half* v) => GLPointers._glVertex3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertex4hNV]</b>  </summary>
            public static void Vertex4h(Half x, Half y, Half z, Half w) => GLPointers._glVertex4hNV_fnptr((ushort)x, (ushort)y, (ushort)z, (ushort)w);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertex4hvNV]</b>  </summary>
            public static void Vertex4hv(Half* v) => GLPointers._glVertex4hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glNormal3hNV]</b>  </summary>
            public static void Normal3h(Half nx, Half ny, Half nz) => GLPointers._glNormal3hNV_fnptr((ushort)nx, (ushort)ny, (ushort)nz);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glNormal3hvNV]</b>  </summary>
            public static void Normal3hv(Half* v) => GLPointers._glNormal3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glColor3hNV]</b>  </summary>
            public static void Color3h(Half red, Half green, Half blue) => GLPointers._glColor3hNV_fnptr((ushort)red, (ushort)green, (ushort)blue);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glColor3hvNV]</b>  </summary>
            public static void Color3hv(Half* v) => GLPointers._glColor3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glColor4hNV]</b>  </summary>
            public static void Color4h(Half red, Half green, Half blue, Half alpha) => GLPointers._glColor4hNV_fnptr((ushort)red, (ushort)green, (ushort)blue, (ushort)alpha);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glColor4hvNV]</b>  </summary>
            public static void Color4hv(Half* v) => GLPointers._glColor4hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glTexCoord1hNV]</b>  </summary>
            public static void TexCoord1h(Half s) => GLPointers._glTexCoord1hNV_fnptr((ushort)s);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glTexCoord1hvNV]</b>  </summary>
            public static void TexCoord1hv(Half* v) => GLPointers._glTexCoord1hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glTexCoord2hNV]</b>  </summary>
            public static void TexCoord2h(Half s, Half t) => GLPointers._glTexCoord2hNV_fnptr((ushort)s, (ushort)t);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glTexCoord2hvNV]</b>  </summary>
            public static void TexCoord2hv(Half* v) => GLPointers._glTexCoord2hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glTexCoord3hNV]</b>  </summary>
            public static void TexCoord3h(Half s, Half t, Half r) => GLPointers._glTexCoord3hNV_fnptr((ushort)s, (ushort)t, (ushort)r);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glTexCoord3hvNV]</b>  </summary>
            public static void TexCoord3hv(Half* v) => GLPointers._glTexCoord3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glTexCoord4hNV]</b>  </summary>
            public static void TexCoord4h(Half s, Half t, Half r, Half q) => GLPointers._glTexCoord4hNV_fnptr((ushort)s, (ushort)t, (ushort)r, (ushort)q);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glTexCoord4hvNV]</b>  </summary>
            public static void TexCoord4hv(Half* v) => GLPointers._glTexCoord4hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glMultiTexCoord1hNV]</b>  </summary>
            public static void MultiTexCoord1h(TextureUnit target, Half s) => GLPointers._glMultiTexCoord1hNV_fnptr((uint)target, (ushort)s);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glMultiTexCoord1hvNV]</b>  </summary>
            public static void MultiTexCoord1hv(TextureUnit target, Half* v) => GLPointers._glMultiTexCoord1hvNV_fnptr((uint)target, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glMultiTexCoord2hNV]</b>  </summary>
            public static void MultiTexCoord2h(TextureUnit target, Half s, Half t) => GLPointers._glMultiTexCoord2hNV_fnptr((uint)target, (ushort)s, (ushort)t);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glMultiTexCoord2hvNV]</b>  </summary>
            public static void MultiTexCoord2hv(TextureUnit target, Half* v) => GLPointers._glMultiTexCoord2hvNV_fnptr((uint)target, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glMultiTexCoord3hNV]</b>  </summary>
            public static void MultiTexCoord3h(TextureUnit target, Half s, Half t, Half r) => GLPointers._glMultiTexCoord3hNV_fnptr((uint)target, (ushort)s, (ushort)t, (ushort)r);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glMultiTexCoord3hvNV]</b>  </summary>
            public static void MultiTexCoord3hv(TextureUnit target, Half* v) => GLPointers._glMultiTexCoord3hvNV_fnptr((uint)target, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glMultiTexCoord4hNV]</b>  </summary>
            public static void MultiTexCoord4h(TextureUnit target, Half s, Half t, Half r, Half q) => GLPointers._glMultiTexCoord4hNV_fnptr((uint)target, (ushort)s, (ushort)t, (ushort)r, (ushort)q);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glMultiTexCoord4hvNV]</b>  </summary>
            public static void MultiTexCoord4hv(TextureUnit target, Half* v) => GLPointers._glMultiTexCoord4hvNV_fnptr((uint)target, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glFogCoordhNV]</b>  </summary>
            public static void FogCoordh(Half fog) => GLPointers._glFogCoordhNV_fnptr((ushort)fog);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glFogCoordhvNV]</b>  </summary>
            public static void FogCoordhv(Half* fog) => GLPointers._glFogCoordhvNV_fnptr((ushort*)fog);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glSecondaryColor3hNV]</b>  </summary>
            public static void SecondaryColor3h(Half red, Half green, Half blue) => GLPointers._glSecondaryColor3hNV_fnptr((ushort)red, (ushort)green, (ushort)blue);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glSecondaryColor3hvNV]</b>  </summary>
            public static void SecondaryColor3hv(Half* v) => GLPointers._glSecondaryColor3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexWeighthNV]</b>  </summary>
            public static void VertexWeighth(Half weight) => GLPointers._glVertexWeighthNV_fnptr((ushort)weight);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexWeighthvNV]</b>  </summary>
            public static void VertexWeighthv(Half* weight) => GLPointers._glVertexWeighthvNV_fnptr((ushort*)weight);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttrib1hNV]</b>  </summary>
            public static void VertexAttrib1h(uint index, Half x) => GLPointers._glVertexAttrib1hNV_fnptr(index, (ushort)x);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttrib1hvNV]</b>  </summary>
            public static void VertexAttrib1hv(uint index, Half* v) => GLPointers._glVertexAttrib1hvNV_fnptr(index, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttrib2hNV]</b>  </summary>
            public static void VertexAttrib2h(uint index, Half x, Half y) => GLPointers._glVertexAttrib2hNV_fnptr(index, (ushort)x, (ushort)y);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttrib2hvNV]</b>  </summary>
            public static void VertexAttrib2hv(uint index, Half* v) => GLPointers._glVertexAttrib2hvNV_fnptr(index, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttrib3hNV]</b>  </summary>
            public static void VertexAttrib3h(uint index, Half x, Half y, Half z) => GLPointers._glVertexAttrib3hNV_fnptr(index, (ushort)x, (ushort)y, (ushort)z);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttrib3hvNV]</b>  </summary>
            public static void VertexAttrib3hv(uint index, Half* v) => GLPointers._glVertexAttrib3hvNV_fnptr(index, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttrib4hNV]</b>  </summary>
            public static void VertexAttrib4h(uint index, Half x, Half y, Half z, Half w) => GLPointers._glVertexAttrib4hNV_fnptr(index, (ushort)x, (ushort)y, (ushort)z, (ushort)w);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttrib4hvNV]</b>  </summary>
            public static void VertexAttrib4hv(uint index, Half* v) => GLPointers._glVertexAttrib4hvNV_fnptr(index, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttribs1hvNV]</b>  </summary>
            public static void VertexAttribs1hv(uint index, int n, Half* v) => GLPointers._glVertexAttribs1hvNV_fnptr(index, n, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttribs2hvNV]</b>  </summary>
            public static void VertexAttribs2hv(uint index, int n, Half* v) => GLPointers._glVertexAttribs2hvNV_fnptr(index, n, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttribs3hvNV]</b>  </summary>
            public static void VertexAttribs3hv(uint index, int n, Half* v) => GLPointers._glVertexAttribs3hvNV_fnptr(index, n, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float] [glVertexAttribs4hvNV]</b>  </summary>
            public static void VertexAttribs4hv(uint index, int n, Half* v) => GLPointers._glVertexAttribs4hvNV_fnptr(index, n, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_internalformat_sample_query] [glGetInternalformatSampleivNV]</b>  </summary>
            public static void GetInternalformatSampleiv(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, int* parameters) => GLPointers._glGetInternalformatSampleivNV_fnptr((uint)target, (uint)internalformat, samples, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glRenderGpuMaskNV]</b>  </summary>
            public static void RenderGpuMask(uint mask) => GLPointers._glRenderGpuMaskNV_fnptr(mask);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastBufferSubDataNV]</b>  </summary>
            public static void MulticastBufferSubData(uint gpuMask, int buffer, IntPtr offset, nint size, void* data) => GLPointers._glMulticastBufferSubDataNV_fnptr(gpuMask, buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastCopyBufferSubDataNV]</b>  </summary>
            public static void MulticastCopyBufferSubData(uint readGpu, uint writeGpuMask, int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glMulticastCopyBufferSubDataNV_fnptr(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastCopyImageSubDataNV]</b>  </summary>
            public static void MulticastCopyImageSubData(uint srcGpu, uint dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers._glMulticastCopyImageSubDataNV_fnptr(srcGpu, dstGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastBlitFramebufferNV]</b>  </summary>
            public static void MulticastBlitFramebuffer(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, All filter) => GLPointers._glMulticastBlitFramebufferNV_fnptr(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastFramebufferSampleLocationsfvNV]</b>  </summary>
            public static void MulticastFramebufferSampleLocationsfv(uint gpu, int framebuffer, uint start, int count, float* v) => GLPointers._glMulticastFramebufferSampleLocationsfvNV_fnptr(gpu, framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastBarrierNV]</b>  </summary>
            public static void MulticastBarrier() => GLPointers._glMulticastBarrierNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastWaitSyncNV]</b>  </summary>
            public static void MulticastWaitSync(uint signalGpu, uint waitGpuMask) => GLPointers._glMulticastWaitSyncNV_fnptr(signalGpu, waitGpuMask);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastGetQueryObjectivNV]</b>  </summary>
            public static void MulticastGetQueryObjectiv(uint gpu, uint id, All pname, int* parameters) => GLPointers._glMulticastGetQueryObjectivNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastGetQueryObjectuivNV]</b>  </summary>
            public static void MulticastGetQueryObjectuiv(uint gpu, uint id, All pname, uint* parameters) => GLPointers._glMulticastGetQueryObjectuivNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastGetQueryObjecti64vNV]</b>  </summary>
            public static void MulticastGetQueryObjecti64v(uint gpu, uint id, All pname, long* parameters) => GLPointers._glMulticastGetQueryObjecti64vNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast] [glMulticastGetQueryObjectui64vNV]</b>  </summary>
            public static void MulticastGetQueryObjectui64v(uint gpu, uint id, All pname, ulong* parameters) => GLPointers._glMulticastGetQueryObjectui64vNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment] [glGetMemoryObjectDetachedResourcesuivNV]</b>  </summary>
            public static void GetMemoryObjectDetachedResourcesuiv(uint memory, All pname, int first, int count, uint* parameters) => GLPointers._glGetMemoryObjectDetachedResourcesuivNV_fnptr(memory, (uint)pname, first, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment] [glResetMemoryObjectParameterNV]</b>  </summary>
            public static void ResetMemoryObjectParameter(uint memory, All pname) => GLPointers._glResetMemoryObjectParameterNV_fnptr(memory, (uint)pname);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment] [glTexAttachMemoryNV]</b>  </summary>
            public static void TexAttachMemory(TextureTarget target, uint memory, ulong offset) => GLPointers._glTexAttachMemoryNV_fnptr((uint)target, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment] [glBufferAttachMemoryNV]</b>  </summary>
            public static void BufferAttachMemory(BufferTargetARB target, uint memory, ulong offset) => GLPointers._glBufferAttachMemoryNV_fnptr((uint)target, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment] [glTextureAttachMemoryNV]</b>  </summary>
            public static void TextureAttachMemory(int texture, uint memory, ulong offset) => GLPointers._glTextureAttachMemoryNV_fnptr(texture, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment] [glNamedBufferAttachMemoryNV]</b>  </summary>
            public static void NamedBufferAttachMemory(int buffer, uint memory, ulong offset) => GLPointers._glNamedBufferAttachMemoryNV_fnptr(buffer, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse] [glBufferPageCommitmentMemNV]</b>  </summary>
            public static void BufferPageCommitmentMem(BufferStorageTarget target, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit) => GLPointers._glBufferPageCommitmentMemNV_fnptr((uint)target, offset, size, memory, memOffset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse] [glTexPageCommitmentMemNV]</b>  </summary>
            public static void TexPageCommitmentMem(TextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit) => GLPointers._glTexPageCommitmentMemNV_fnptr((uint)target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse] [glNamedBufferPageCommitmentMemNV]</b>  </summary>
            public static void NamedBufferPageCommitmentMem(int buffer, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit) => GLPointers._glNamedBufferPageCommitmentMemNV_fnptr(buffer, offset, size, memory, memOffset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse] [glTexturePageCommitmentMemNV]</b>  </summary>
            public static void TexturePageCommitmentMem(int texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit) => GLPointers._glTexturePageCommitmentMemNV_fnptr(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_mesh_shader] [glDrawMeshTasksNV]</b>  </summary>
            public static void DrawMeshTasks(uint first, uint count) => GLPointers._glDrawMeshTasksNV_fnptr(first, count);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader] [glDrawMeshTasksIndirectNV]</b>  </summary>
            public static void DrawMeshTasksIndirect(IntPtr indirect) => GLPointers._glDrawMeshTasksIndirectNV_fnptr(indirect);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader] [glMultiDrawMeshTasksIndirectNV]</b>  </summary>
            public static void MultiDrawMeshTasksIndirect(IntPtr indirect, int drawcount, int stride) => GLPointers._glMultiDrawMeshTasksIndirectNV_fnptr(indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader] [glMultiDrawMeshTasksIndirectCountNV]</b>  </summary>
            public static void MultiDrawMeshTasksIndirectCount(IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawMeshTasksIndirectCountNV_fnptr(indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query] [glGenOcclusionQueriesNV]</b>  </summary>
            public static void GenOcclusionQueries(int n, uint* ids) => GLPointers._glGenOcclusionQueriesNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query] [glDeleteOcclusionQueriesNV]</b>  </summary>
            public static void DeleteOcclusionQueries(int n, uint* ids) => GLPointers._glDeleteOcclusionQueriesNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query] [glIsOcclusionQueryNV]</b>  </summary>
            public static bool IsOcclusionQuery(uint id) => GLPointers._glIsOcclusionQueryNV_fnptr(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_occlusion_query] [glBeginOcclusionQueryNV]</b>  </summary>
            public static void BeginOcclusionQuery(uint id) => GLPointers._glBeginOcclusionQueryNV_fnptr(id);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query] [glEndOcclusionQueryNV]</b>  </summary>
            public static void EndOcclusionQuery() => GLPointers._glEndOcclusionQueryNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_occlusion_query] [glGetOcclusionQueryivNV]</b>  </summary>
            public static void GetOcclusionQueryiv(uint id, OcclusionQueryParameterNameNV pname, int* parameters) => GLPointers._glGetOcclusionQueryivNV_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query] [glGetOcclusionQueryuivNV]</b>  </summary>
            public static void GetOcclusionQueryuiv(uint id, OcclusionQueryParameterNameNV pname, uint* parameters) => GLPointers._glGetOcclusionQueryuivNV_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object] [glProgramBufferParametersfvNV]</b>  </summary>
            public static void ProgramBufferParametersfv(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, float* parameters) => GLPointers._glProgramBufferParametersfvNV_fnptr((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object] [glProgramBufferParametersIivNV]</b>  </summary>
            public static void ProgramBufferParametersIiv(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, int* parameters) => GLPointers._glProgramBufferParametersIivNV_fnptr((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object] [glProgramBufferParametersIuivNV]</b>  </summary>
            public static void ProgramBufferParametersIuiv(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, uint* parameters) => GLPointers._glProgramBufferParametersIuivNV_fnptr((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGenPathsNV]</b>  </summary>
            public static uint GenPaths(int range) => GLPointers._glGenPathsNV_fnptr(range);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glDeletePathsNV]</b>  </summary>
            public static void DeletePaths(uint path, int range) => GLPointers._glDeletePathsNV_fnptr(path, range);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glIsPathNV]</b>  </summary>
            public static bool IsPath(uint path) => GLPointers._glIsPathNV_fnptr(path) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathCommandsNV]</b>  </summary>
            public static void PathCommands(uint path, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => GLPointers._glPathCommandsNV_fnptr(path, numCommands, commands, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathCoordsNV]</b>  </summary>
            public static void PathCoords(uint path, int numCoords, PathCoordType coordType, void* coords) => GLPointers._glPathCoordsNV_fnptr(path, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathSubCommandsNV]</b>  </summary>
            public static void PathSubCommands(uint path, int commandStart, int commandsToDelete, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => GLPointers._glPathSubCommandsNV_fnptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathSubCoordsNV]</b>  </summary>
            public static void PathSubCoords(uint path, int coordStart, int numCoords, PathCoordType coordType, void* coords) => GLPointers._glPathSubCoordsNV_fnptr(path, coordStart, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathStringNV]</b>  </summary>
            public static void PathString(uint path, PathStringFormat format, int length, void* pathString) => GLPointers._glPathStringNV_fnptr(path, (uint)format, length, pathString);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathGlyphsNV]</b>  </summary>
            public static void PathGlyphs(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, void* charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => GLPointers._glPathGlyphsNV_fnptr(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, numGlyphs, (uint)type, charcodes, (uint)handleMissingGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathGlyphRangeNV]</b>  </summary>
            public static void PathGlyphRange(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => GLPointers._glPathGlyphRangeNV_fnptr(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, firstGlyph, numGlyphs, (uint)handleMissingGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glWeightPathsNV]</b>  </summary>
            public static void WeightPaths(uint resultPath, int numPaths, uint* paths, float* weights) => GLPointers._glWeightPathsNV_fnptr(resultPath, numPaths, paths, weights);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glCopyPathNV]</b>  </summary>
            public static void CopyPath(uint resultPath, uint srcPath) => GLPointers._glCopyPathNV_fnptr(resultPath, srcPath);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glInterpolatePathsNV]</b>  </summary>
            public static void InterpolatePaths(uint resultPath, uint pathA, uint pathB, float weight) => GLPointers._glInterpolatePathsNV_fnptr(resultPath, pathA, pathB, weight);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glTransformPathNV]</b>  </summary>
            public static void TransformPath(uint resultPath, uint srcPath, PathTransformType transformType, float* transformValues) => GLPointers._glTransformPathNV_fnptr(resultPath, srcPath, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathParameterivNV]</b>  </summary>
            public static void PathParameteriv(uint path, PathParameter pname, int* value) => GLPointers._glPathParameterivNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathParameteriNV]</b>  </summary>
            public static void PathParameteri(uint path, PathParameter pname, int value) => GLPointers._glPathParameteriNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathParameterfvNV]</b>  </summary>
            public static void PathParameterfv(uint path, PathParameter pname, float* value) => GLPointers._glPathParameterfvNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathParameterfNV]</b>  </summary>
            public static void PathParameterf(uint path, PathParameter pname, float value) => GLPointers._glPathParameterfNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathDashArrayNV]</b>  </summary>
            public static void PathDashArray(uint path, int dashCount, float* dashArray) => GLPointers._glPathDashArrayNV_fnptr(path, dashCount, dashArray);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathStencilFuncNV]</b>  </summary>
            public static void PathStencilFunc(StencilFunction func, int reference, uint mask) => GLPointers._glPathStencilFuncNV_fnptr((uint)func, reference, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathStencilDepthOffsetNV]</b>  </summary>
            public static void PathStencilDepthOffset(float factor, float units) => GLPointers._glPathStencilDepthOffsetNV_fnptr(factor, units);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glStencilFillPathNV]</b>  </summary>
            public static void StencilFillPath(uint path, PathFillMode fillMode, uint mask) => GLPointers._glStencilFillPathNV_fnptr(path, (uint)fillMode, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glStencilStrokePathNV]</b>  </summary>
            public static void StencilStrokePath(uint path, int reference, uint mask) => GLPointers._glStencilStrokePathNV_fnptr(path, reference, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glStencilFillPathInstancedNV]</b>  </summary>
            public static void StencilFillPathInstanced(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float* transformValues) => GLPointers._glStencilFillPathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)fillMode, mask, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glStencilStrokePathInstancedNV]</b>  </summary>
            public static void StencilStrokePathInstanced(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float* transformValues) => GLPointers._glStencilStrokePathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, reference, mask, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathCoverDepthFuncNV]</b>  </summary>
            public static void PathCoverDepthFunc(DepthFunction func) => GLPointers._glPathCoverDepthFuncNV_fnptr((uint)func);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glCoverFillPathNV]</b>  </summary>
            public static void CoverFillPath(uint path, PathCoverMode coverMode) => GLPointers._glCoverFillPathNV_fnptr(path, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glCoverStrokePathNV]</b>  </summary>
            public static void CoverStrokePath(uint path, PathCoverMode coverMode) => GLPointers._glCoverStrokePathNV_fnptr(path, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glCoverFillPathInstancedNV]</b>  </summary>
            public static void CoverFillPathInstanced(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._glCoverFillPathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glCoverStrokePathInstancedNV]</b>  </summary>
            public static void CoverStrokePathInstanced(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._glCoverStrokePathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathParameterivNV]</b>  </summary>
            public static void GetPathParameteriv(uint path, PathParameter pname, int* value) => GLPointers._glGetPathParameterivNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathParameterfvNV]</b>  </summary>
            public static void GetPathParameterfv(uint path, PathParameter pname, float* value) => GLPointers._glGetPathParameterfvNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathCommandsNV]</b>  </summary>
            public static void GetPathCommands(uint path, byte* commands) => GLPointers._glGetPathCommandsNV_fnptr(path, commands);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathCoordsNV]</b>  </summary>
            public static void GetPathCoords(uint path, float* coords) => GLPointers._glGetPathCoordsNV_fnptr(path, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathDashArrayNV]</b>  </summary>
            public static void GetPathDashArray(uint path, float* dashArray) => GLPointers._glGetPathDashArrayNV_fnptr(path, dashArray);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathMetricsNV]</b>  </summary>
            public static void GetPathMetrics(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics) => GLPointers._glGetPathMetricsNV_fnptr((uint)metricQueryMask, numPaths, (uint)pathNameType, paths, pathBase, stride, metrics);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathMetricRangeNV]</b>  </summary>
            public static void GetPathMetricRange(PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics) => GLPointers._glGetPathMetricRangeNV_fnptr((uint)metricQueryMask, firstPathName, numPaths, stride, metrics);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathSpacingNV]</b>  </summary>
            public static void GetPathSpacing(PathListMode pathListMode, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float* returnedSpacing) => GLPointers._glGetPathSpacingNV_fnptr((uint)pathListMode, numPaths, (uint)pathNameType, paths, pathBase, advanceScale, kerningScale, (uint)transformType, returnedSpacing);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glIsPointInFillPathNV]</b>  </summary>
            public static bool IsPointInFillPath(uint path, uint mask, float x, float y) => GLPointers._glIsPointInFillPathNV_fnptr(path, mask, x, y) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glIsPointInStrokePathNV]</b>  </summary>
            public static bool IsPointInStrokePath(uint path, float x, float y) => GLPointers._glIsPointInStrokePathNV_fnptr(path, x, y) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathLengthNV]</b>  </summary>
            public static float GetPathLength(uint path, int startSegment, int numSegments) => GLPointers._glGetPathLengthNV_fnptr(path, startSegment, numSegments);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPointAlongPathNV]</b>  </summary>
            public static bool PointAlongPath(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY) => GLPointers._glPointAlongPathNV_fnptr(path, startSegment, numSegments, distance, x, y, tangentX, tangentY) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glMatrixLoad3x2fNV]</b>  </summary>
            public static void MatrixLoad3x2f(All matrixMode, float* m) => GLPointers._glMatrixLoad3x2fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glMatrixLoad3x3fNV]</b>  </summary>
            public static void MatrixLoad3x3f(All matrixMode, float* m) => GLPointers._glMatrixLoad3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glMatrixLoadTranspose3x3fNV]</b>  </summary>
            public static void MatrixLoadTranspose3x3f(All matrixMode, float* m) => GLPointers._glMatrixLoadTranspose3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glMatrixMult3x2fNV]</b>  </summary>
            public static void MatrixMult3x2f(All matrixMode, float* m) => GLPointers._glMatrixMult3x2fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glMatrixMult3x3fNV]</b>  </summary>
            public static void MatrixMult3x3f(All matrixMode, float* m) => GLPointers._glMatrixMult3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glMatrixMultTranspose3x3fNV]</b>  </summary>
            public static void MatrixMultTranspose3x3f(All matrixMode, float* m) => GLPointers._glMatrixMultTranspose3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glStencilThenCoverFillPathNV]</b>  </summary>
            public static void StencilThenCoverFillPath(uint path, PathFillMode fillMode, uint mask, PathCoverMode coverMode) => GLPointers._glStencilThenCoverFillPathNV_fnptr(path, (uint)fillMode, mask, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glStencilThenCoverStrokePathNV]</b>  </summary>
            public static void StencilThenCoverStrokePath(uint path, int reference, uint mask, PathCoverMode coverMode) => GLPointers._glStencilThenCoverStrokePathNV_fnptr(path, reference, mask, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glStencilThenCoverFillPathInstancedNV]</b>  </summary>
            public static void StencilThenCoverFillPathInstanced(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathFillMode fillMode, uint mask, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._glStencilThenCoverFillPathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)fillMode, mask, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glStencilThenCoverStrokePathInstancedNV]</b>  </summary>
            public static void StencilThenCoverStrokePathInstanced(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._glStencilThenCoverStrokePathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, reference, mask, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathGlyphIndexRangeNV]</b>  </summary>
            public static All PathGlyphIndexRange(All fontTarget, void* fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount) => (All) GLPointers._glPathGlyphIndexRangeNV_fnptr((uint)fontTarget, fontName, (uint)fontStyle, pathParameterTemplate, emScale, baseAndCount);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathGlyphIndexArrayNV]</b>  </summary>
            public static All PathGlyphIndexArray(uint firstPathName, All fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => (All) GLPointers._glPathGlyphIndexArrayNV_fnptr(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathMemoryGlyphIndexArrayNV]</b>  </summary>
            public static All PathMemoryGlyphIndexArray(uint firstPathName, All fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => (All) GLPointers._glPathMemoryGlyphIndexArrayNV_fnptr(firstPathName, (uint)fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glProgramPathFragmentInputGenNV]</b>  </summary>
            public static void ProgramPathFragmentInputGen(int program, int location, All genMode, int components, float* coeffs) => GLPointers._glProgramPathFragmentInputGenNV_fnptr(program, location, (uint)genMode, components, coeffs);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetProgramResourcefvNV]</b>  </summary>
            public static void GetProgramResourcefv(int program, ProgramInterface programInterface, uint index, int propCount, All* props, int count, int* length, float* parameters) => GLPointers._glGetProgramResourcefvNV_fnptr(program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathColorGenNV]</b>  </summary>
            public static void PathColorGen(PathColor color, PathGenMode genMode, PathColorFormat colorFormat, float* coeffs) => GLPointers._glPathColorGenNV_fnptr((uint)color, (uint)genMode, (uint)colorFormat, coeffs);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathTexGenNV]</b>  </summary>
            public static void PathTexGen(PathColor texCoordSet, PathGenMode genMode, int components, float* coeffs) => GLPointers._glPathTexGenNV_fnptr((uint)texCoordSet, (uint)genMode, components, coeffs);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glPathFogGenNV]</b>  </summary>
            public static void PathFogGen(PathGenMode genMode) => GLPointers._glPathFogGenNV_fnptr((uint)genMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathColorGenivNV]</b>  </summary>
            public static void GetPathColorGeniv(PathColor color, PathGenMode pname, int* value) => GLPointers._glGetPathColorGenivNV_fnptr((uint)color, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathColorGenfvNV]</b>  </summary>
            public static void GetPathColorGenfv(PathColor color, PathGenMode pname, float* value) => GLPointers._glGetPathColorGenfvNV_fnptr((uint)color, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathTexGenivNV]</b>  </summary>
            public static void GetPathTexGeniv(TextureUnit texCoordSet, PathGenMode pname, int* value) => GLPointers._glGetPathTexGenivNV_fnptr((uint)texCoordSet, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering] [glGetPathTexGenfvNV]</b>  </summary>
            public static void GetPathTexGenfv(TextureUnit texCoordSet, PathGenMode pname, float* value) => GLPointers._glGetPathTexGenfvNV_fnptr((uint)texCoordSet, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixFrustumEXT]</b>  </summary>
            public static void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glMatrixFrustumEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoadIdentityEXT]</b>  </summary>
            public static void MatrixLoadIdentityEXT(MatrixMode mode) => GLPointers._glMatrixLoadIdentityEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoadTransposefEXT]</b>  </summary>
            public static void MatrixLoadTransposefEXT(MatrixMode mode, float* m) => GLPointers._glMatrixLoadTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoadTransposedEXT]</b>  </summary>
            public static void MatrixLoadTransposedEXT(MatrixMode mode, double* m) => GLPointers._glMatrixLoadTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoadfEXT]</b>  </summary>
            public static void MatrixLoadfEXT(MatrixMode mode, float* m) => GLPointers._glMatrixLoadfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixLoaddEXT]</b>  </summary>
            public static void MatrixLoaddEXT(MatrixMode mode, double* m) => GLPointers._glMatrixLoaddEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixMultTransposefEXT]</b>  </summary>
            public static void MatrixMultTransposefEXT(MatrixMode mode, float* m) => GLPointers._glMatrixMultTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixMultTransposedEXT]</b>  </summary>
            public static void MatrixMultTransposedEXT(MatrixMode mode, double* m) => GLPointers._glMatrixMultTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixMultfEXT]</b>  </summary>
            public static void MatrixMultfEXT(MatrixMode mode, float* m) => GLPointers._glMatrixMultfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixMultdEXT]</b>  </summary>
            public static void MatrixMultdEXT(MatrixMode mode, double* m) => GLPointers._glMatrixMultdEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixOrthoEXT]</b>  </summary>
            public static void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glMatrixOrthoEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixPopEXT]</b>  </summary>
            public static void MatrixPopEXT(MatrixMode mode) => GLPointers._glMatrixPopEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixPushEXT]</b>  </summary>
            public static void MatrixPushEXT(MatrixMode mode) => GLPointers._glMatrixPushEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixRotatefEXT]</b>  </summary>
            public static void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => GLPointers._glMatrixRotatefEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixRotatedEXT]</b>  </summary>
            public static void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => GLPointers._glMatrixRotatedEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixScalefEXT]</b>  </summary>
            public static void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._glMatrixScalefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixScaledEXT]</b>  </summary>
            public static void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => GLPointers._glMatrixScaledEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixTranslatefEXT]</b>  </summary>
            public static void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._glMatrixTranslatefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering] [glMatrixTranslatedEXT]</b>  </summary>
            public static void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => GLPointers._glMatrixTranslatedEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_pixel_data_range] [glPixelDataRangeNV]</b>  </summary>
            public static void PixelDataRange(PixelDataRangeTargetNV target, int length, void* pointer) => GLPointers._glPixelDataRangeNV_fnptr((uint)target, length, pointer);
            
            /// <summary> <b>[requires: GL_NV_pixel_data_range] [glFlushPixelDataRangeNV]</b>  </summary>
            public static void FlushPixelDataRange(PixelDataRangeTargetNV target) => GLPointers._glFlushPixelDataRangeNV_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_NV_point_sprite] [glPointParameteriNV]</b>  </summary>
            public static void PointParameteri(PointParameterNameARB pname, int param) => GLPointers._glPointParameteriNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_point_sprite] [glPointParameterivNV]</b>  </summary>
            public static void PointParameteriv(PointParameterNameARB pname, int* parameters) => GLPointers._glPointParameterivNV_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video] [glPresentFrameKeyedNV]</b>  </summary>
            public static void PresentFrameKeyed(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, uint key0, All target1, uint fill1, uint key1) => GLPointers._glPresentFrameKeyedNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, (uint)type, (uint)target0, fill0, key0, (uint)target1, fill1, key1);
            
            /// <summary> <b>[requires: GL_NV_present_video] [glPresentFrameDualFillNV]</b>  </summary>
            public static void PresentFrameDualFill(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, All target1, uint fill1, All target2, uint fill2, All target3, uint fill3) => GLPointers._glPresentFrameDualFillNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, (uint)type, (uint)target0, fill0, (uint)target1, fill1, (uint)target2, fill2, (uint)target3, fill3);
            
            /// <summary> <b>[requires: GL_NV_present_video] [glGetVideoivNV]</b>  </summary>
            public static void GetVideoiv(uint video_slot, All pname, int* parameters) => GLPointers._glGetVideoivNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video] [glGetVideouivNV]</b>  </summary>
            public static void GetVideouiv(uint video_slot, All pname, uint* parameters) => GLPointers._glGetVideouivNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video] [glGetVideoi64vNV]</b>  </summary>
            public static void GetVideoi64v(uint video_slot, All pname, long* parameters) => GLPointers._glGetVideoi64vNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video] [glGetVideoui64vNV]</b>  </summary>
            public static void GetVideoui64v(uint video_slot, All pname, ulong* parameters) => GLPointers._glGetVideoui64vNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_primitive_restart] [glPrimitiveRestartNV]</b>  </summary>
            public static void PrimitiveRestart() => GLPointers._glPrimitiveRestartNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_primitive_restart] [glPrimitiveRestartIndexNV]</b>  </summary>
            public static void PrimitiveRestartIndex(uint index) => GLPointers._glPrimitiveRestartIndexNV_fnptr(index);
            
            /// <summary> <b>[requires: GL_NV_query_resource] [glQueryResourceNV]</b>  </summary>
            public static int QueryResource(All queryType, int tagId, uint count, int* buffer) => GLPointers._glQueryResourceNV_fnptr((uint)queryType, tagId, count, buffer);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag] [glGenQueryResourceTagNV]</b>  </summary>
            public static void GenQueryResourceTag(int n, int* tagIds) => GLPointers._glGenQueryResourceTagNV_fnptr(n, tagIds);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag] [glDeleteQueryResourceTagNV]</b>  </summary>
            public static void DeleteQueryResourceTag(int n, int* tagIds) => GLPointers._glDeleteQueryResourceTagNV_fnptr(n, tagIds);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag] [glQueryResourceTagNV]</b>  </summary>
            public static void QueryResourceTag(int tagId, byte* tagString) => GLPointers._glQueryResourceTagNV_fnptr(tagId, tagString);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glCombinerParameterfvNV]</b>  </summary>
            public static void CombinerParameterfv(CombinerParameterNV pname, float* parameters) => GLPointers._glCombinerParameterfvNV_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glCombinerParameterfNV]</b>  </summary>
            public static void CombinerParameterf(CombinerParameterNV pname, float param) => GLPointers._glCombinerParameterfNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glCombinerParameterivNV]</b>  </summary>
            public static void CombinerParameteriv(CombinerParameterNV pname, int* parameters) => GLPointers._glCombinerParameterivNV_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glCombinerParameteriNV]</b>  </summary>
            public static void CombinerParameteri(CombinerParameterNV pname, int param) => GLPointers._glCombinerParameteriNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glCombinerInputNV]</b>  </summary>
            public static void CombinerInput(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => GLPointers._glCombinerInputNV_fnptr((uint)stage, (uint)portion, (uint)variable, (uint)input, (uint)mapping, (uint)componentUsage);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glCombinerOutputNV]</b>  </summary>
            public static void CombinerOutput(CombinerStageNV stage, CombinerPortionNV portion, CombinerRegisterNV abOutput, CombinerRegisterNV cdOutput, CombinerRegisterNV sumOutput, CombinerScaleNV scale, CombinerBiasNV bias, bool abDotProduct, bool cdDotProduct, bool muxSum) => GLPointers._glCombinerOutputNV_fnptr((uint)stage, (uint)portion, (uint)abOutput, (uint)cdOutput, (uint)sumOutput, (uint)scale, (uint)bias, (byte)(abDotProduct ? 1 : 0), (byte)(cdDotProduct ? 1 : 0), (byte)(muxSum ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glFinalCombinerInputNV]</b>  </summary>
            public static void FinalCombinerInput(CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => GLPointers._glFinalCombinerInputNV_fnptr((uint)variable, (uint)input, (uint)mapping, (uint)componentUsage);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glGetCombinerInputParameterfvNV]</b>  </summary>
            public static void GetCombinerInputParameterfv(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => GLPointers._glGetCombinerInputParameterfvNV_fnptr((uint)stage, (uint)portion, (uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glGetCombinerInputParameterivNV]</b>  </summary>
            public static void GetCombinerInputParameteriv(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => GLPointers._glGetCombinerInputParameterivNV_fnptr((uint)stage, (uint)portion, (uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glGetCombinerOutputParameterfvNV]</b>  </summary>
            public static void GetCombinerOutputParameterfv(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, float* parameters) => GLPointers._glGetCombinerOutputParameterfvNV_fnptr((uint)stage, (uint)portion, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glGetCombinerOutputParameterivNV]</b>  </summary>
            public static void GetCombinerOutputParameteriv(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, int* parameters) => GLPointers._glGetCombinerOutputParameterivNV_fnptr((uint)stage, (uint)portion, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glGetFinalCombinerInputParameterfvNV]</b>  </summary>
            public static void GetFinalCombinerInputParameterfv(CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => GLPointers._glGetFinalCombinerInputParameterfvNV_fnptr((uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners] [glGetFinalCombinerInputParameterivNV]</b>  </summary>
            public static void GetFinalCombinerInputParameteriv(CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => GLPointers._glGetFinalCombinerInputParameterivNV_fnptr((uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners2] [glCombinerStageParameterfvNV]</b>  </summary>
            public static void CombinerStageParameterfv(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => GLPointers._glCombinerStageParameterfvNV_fnptr((uint)stage, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners2] [glGetCombinerStageParameterfvNV]</b>  </summary>
            public static void GetCombinerStageParameterfv(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => GLPointers._glGetCombinerStageParameterfvNV_fnptr((uint)stage, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_sample_locations] [glFramebufferSampleLocationsfvNV]</b>  </summary>
            public static void FramebufferSampleLocationsfv(FramebufferTarget target, uint start, int count, float* v) => GLPointers._glFramebufferSampleLocationsfvNV_fnptr((uint)target, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_sample_locations] [glNamedFramebufferSampleLocationsfvNV]</b>  </summary>
            public static void NamedFramebufferSampleLocationsfv(int framebuffer, uint start, int count, float* v) => GLPointers._glNamedFramebufferSampleLocationsfvNV_fnptr(framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_sample_locations] [glResolveDepthValuesNV]</b>  </summary>
            public static void ResolveDepthValues() => GLPointers._glResolveDepthValuesNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_scissor_exclusive] [glScissorExclusiveNV]</b>  </summary>
            public static void ScissorExclusive(int x, int y, int width, int height) => GLPointers._glScissorExclusiveNV_fnptr(x, y, width, height);
            
            /// <summary> <b>[requires: GL_NV_scissor_exclusive] [glScissorExclusiveArrayvNV]</b>  </summary>
            public static void ScissorExclusiveArrayv(uint first, int count, int* v) => GLPointers._glScissorExclusiveArrayvNV_fnptr(first, count, v);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glMakeBufferResidentNV]</b>  </summary>
            public static void MakeBufferResident(All target, All access) => GLPointers._glMakeBufferResidentNV_fnptr((uint)target, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glMakeBufferNonResidentNV]</b>  </summary>
            public static void MakeBufferNonResident(All target) => GLPointers._glMakeBufferNonResidentNV_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glIsBufferResidentNV]</b>  </summary>
            public static bool IsBufferResident(All target) => GLPointers._glIsBufferResidentNV_fnptr((uint)target) != 0;
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glMakeNamedBufferResidentNV]</b>  </summary>
            public static void MakeNamedBufferResident(int buffer, All access) => GLPointers._glMakeNamedBufferResidentNV_fnptr(buffer, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glMakeNamedBufferNonResidentNV]</b>  </summary>
            public static void MakeNamedBufferNonResident(int buffer) => GLPointers._glMakeNamedBufferNonResidentNV_fnptr(buffer);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glIsNamedBufferResidentNV]</b>  </summary>
            public static bool IsNamedBufferResident(int buffer) => GLPointers._glIsNamedBufferResidentNV_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glGetBufferParameterui64vNV]</b>  </summary>
            public static void GetBufferParameterui64v(BufferTargetARB target, All pname, ulong* parameters) => GLPointers._glGetBufferParameterui64vNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glGetNamedBufferParameterui64vNV]</b>  </summary>
            public static void GetNamedBufferParameterui64v(int buffer, BufferPNameARB pname, ulong* parameters) => GLPointers._glGetNamedBufferParameterui64vNV_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glGetIntegerui64vNV]</b>  </summary>
            public static void GetIntegerui64v(All value, ulong* result) => GLPointers._glGetIntegerui64vNV_fnptr((uint)value, result);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glUniformui64NV]</b>  </summary>
            public static void Uniformui64(int location, ulong value) => GLPointers._glUniformui64NV_fnptr(location, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glUniformui64vNV]</b>  </summary>
            public static void Uniformui64v(int location, int count, ulong* value) => GLPointers._glUniformui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load] [glGetUniformui64vNV]</b>  </summary>
            public static void GetUniformui64v(int program, int location, ulong* parameters) => GLPointers._glGetUniformui64vNV_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glProgramUniformui64NV]</b>  </summary>
            public static void ProgramUniformui64(int program, int location, ulong value) => GLPointers._glProgramUniformui64NV_fnptr(program, location, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load] [glProgramUniformui64vNV]</b>  </summary>
            public static void ProgramUniformui64v(int program, int location, int count, ulong* value) => GLPointers._glProgramUniformui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image] [glBindShadingRateImageNV]</b>  </summary>
            public static void BindShadingRateImage(int texture) => GLPointers._glBindShadingRateImageNV_fnptr(texture);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image] [glGetShadingRateImagePaletteNV]</b>  </summary>
            public static void GetShadingRateImagePalette(uint viewport, uint entry, All* rate) => GLPointers._glGetShadingRateImagePaletteNV_fnptr(viewport, entry, (uint*)rate);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image] [glGetShadingRateSampleLocationivNV]</b>  </summary>
            public static void GetShadingRateSampleLocationiv(All rate, uint samples, uint index, int* location) => GLPointers._glGetShadingRateSampleLocationivNV_fnptr((uint)rate, samples, index, location);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image] [glShadingRateImageBarrierNV]</b>  </summary>
            public static void ShadingRateImageBarrier(bool synchronize) => GLPointers._glShadingRateImageBarrierNV_fnptr((byte)(synchronize ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image] [glShadingRateImagePaletteNV]</b>  </summary>
            public static void ShadingRateImagePalette(uint viewport, uint first, int count, All* rates) => GLPointers._glShadingRateImagePaletteNV_fnptr(viewport, first, count, (uint*)rates);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image] [glShadingRateSampleOrderNV]</b>  </summary>
            public static void ShadingRateSampleOrder(All order) => GLPointers._glShadingRateSampleOrderNV_fnptr((uint)order);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image] [glShadingRateSampleOrderCustomNV]</b>  </summary>
            public static void ShadingRateSampleOrderCustom(All rate, uint samples, int* locations) => GLPointers._glShadingRateSampleOrderCustomNV_fnptr((uint)rate, samples, locations);
            
            /// <summary> <b>[requires: GL_NV_texture_barrier] [glTextureBarrierNV]</b>  </summary>
            public static void TextureBarrier() => GLPointers._glTextureBarrierNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_texture_multisample] [glTexImage2DMultisampleCoverageNV]</b>  </summary>
            public static void TexImage2DMultisampleCoverage(TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers._glTexImage2DMultisampleCoverageNV_fnptr((uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample] [glTexImage3DMultisampleCoverageNV]</b>  </summary>
            public static void TexImage3DMultisampleCoverage(TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers._glTexImage3DMultisampleCoverageNV_fnptr((uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample] [glTextureImage2DMultisampleNV]</b>  </summary>
            public static void TextureImage2DMultisample(int texture, TextureTarget target, int samples, InternalFormat internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers._glTextureImage2DMultisampleNV_fnptr(texture, (uint)target, samples, (int)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample] [glTextureImage3DMultisampleNV]</b>  </summary>
            public static void TextureImage3DMultisample(int texture, TextureTarget target, int samples, InternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers._glTextureImage3DMultisampleNV_fnptr(texture, (uint)target, samples, (int)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample] [glTextureImage2DMultisampleCoverageNV]</b>  </summary>
            public static void TextureImage2DMultisampleCoverage(int texture, TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers._glTextureImage2DMultisampleCoverageNV_fnptr(texture, (uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample] [glTextureImage3DMultisampleCoverageNV]</b>  </summary>
            public static void TextureImage3DMultisampleCoverage(int texture, TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers._glTextureImage3DMultisampleCoverageNV_fnptr(texture, (uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glBeginTransformFeedbackNV]</b>  </summary>
            public static void BeginTransformFeedback(PrimitiveType primitiveMode) => GLPointers._glBeginTransformFeedbackNV_fnptr((uint)primitiveMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glEndTransformFeedbackNV]</b>  </summary>
            public static void EndTransformFeedback() => GLPointers._glEndTransformFeedbackNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glTransformFeedbackAttribsNV]</b>  </summary>
            public static void TransformFeedbackAttribs(int count, int* attribs, All bufferMode) => GLPointers._glTransformFeedbackAttribsNV_fnptr(count, attribs, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glBindBufferRangeNV]</b>  </summary>
            public static void BindBufferRange(BufferTargetARB target, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glBindBufferRangeNV_fnptr((uint)target, index, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glBindBufferOffsetNV]</b>  </summary>
            public static void BindBufferOffset(BufferTargetARB target, uint index, int buffer, IntPtr offset) => GLPointers._glBindBufferOffsetNV_fnptr((uint)target, index, buffer, offset);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glBindBufferBaseNV]</b>  </summary>
            public static void BindBufferBase(BufferTargetARB target, uint index, int buffer) => GLPointers._glBindBufferBaseNV_fnptr((uint)target, index, buffer);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glTransformFeedbackVaryingsNV]</b>  </summary>
            public static void TransformFeedbackVaryings(int program, int count, TransformFeedbackTokenNV* locations, TransformFeedbackBufferMode bufferMode) => GLPointers._glTransformFeedbackVaryingsNV_fnptr(program, count, (int*)locations, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glActiveVaryingNV]</b>  </summary>
            public static void ActiveVarying(int program, byte* name) => GLPointers._glActiveVaryingNV_fnptr(program, name);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glGetVaryingLocationNV]</b>  </summary>
            public static int GetVaryingLocation(int program, byte* name) => GLPointers._glGetVaryingLocationNV_fnptr(program, name);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glGetActiveVaryingNV]</b>  </summary>
            public static void GetActiveVarying(int program, uint index, int bufSize, int* length, int* size, All* type, byte* name) => GLPointers._glGetActiveVaryingNV_fnptr(program, index, bufSize, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glGetTransformFeedbackVaryingNV]</b>  </summary>
            public static void GetTransformFeedbackVarying(int program, uint index, int* location) => GLPointers._glGetTransformFeedbackVaryingNV_fnptr(program, index, location);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback] [glTransformFeedbackStreamAttribsNV]</b>  </summary>
            public static void TransformFeedbackStreamAttribs(int count, int* attribs, int nbuffers, int* bufstreams, All bufferMode) => GLPointers._glTransformFeedbackStreamAttribsNV_fnptr(count, attribs, nbuffers, bufstreams, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2] [glBindTransformFeedbackNV]</b>  </summary>
            public static void BindTransformFeedback(BufferTargetARB target, int id) => GLPointers._glBindTransformFeedbackNV_fnptr((uint)target, id);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2] [glDeleteTransformFeedbacksNV]</b>  </summary>
            public static void DeleteTransformFeedbacks(int n, int* ids) => GLPointers._glDeleteTransformFeedbacksNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2] [glGenTransformFeedbacksNV]</b>  </summary>
            public static void GenTransformFeedbacks(int n, int* ids) => GLPointers._glGenTransformFeedbacksNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2] [glIsTransformFeedbackNV]</b>  </summary>
            public static bool IsTransformFeedback(int id) => GLPointers._glIsTransformFeedbackNV_fnptr(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2] [glPauseTransformFeedbackNV]</b>  </summary>
            public static void PauseTransformFeedback() => GLPointers._glPauseTransformFeedbackNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2] [glResumeTransformFeedbackNV]</b>  </summary>
            public static void ResumeTransformFeedback() => GLPointers._glResumeTransformFeedbackNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2] [glDrawTransformFeedbackNV]</b>  </summary>
            public static void DrawTransformFeedback(PrimitiveType mode, int id) => GLPointers._glDrawTransformFeedbackNV_fnptr((uint)mode, id);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAUInitNV]</b>  </summary>
            public static void VDPAUInit(void* vdpDevice, void* getProcAddress) => GLPointers._glVDPAUInitNV_fnptr(vdpDevice, getProcAddress);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAUFiniNV]</b>  </summary>
            public static void VDPAUFini() => GLPointers._glVDPAUFiniNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAURegisterVideoSurfaceNV]</b>  </summary>
            public static IntPtr VDPAURegisterVideoSurface(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => GLPointers._glVDPAURegisterVideoSurfaceNV_fnptr(vdpSurface, (uint)target, numTextureNames, textureNames);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAURegisterOutputSurfaceNV]</b>  </summary>
            public static IntPtr VDPAURegisterOutputSurface(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => GLPointers._glVDPAURegisterOutputSurfaceNV_fnptr(vdpSurface, (uint)target, numTextureNames, textureNames);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAUIsSurfaceNV]</b>  </summary>
            public static bool VDPAUIsSurface(IntPtr surface) => GLPointers._glVDPAUIsSurfaceNV_fnptr(surface) != 0;
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAUUnregisterSurfaceNV]</b>  </summary>
            public static void VDPAUUnregisterSurface(IntPtr surface) => GLPointers._glVDPAUUnregisterSurfaceNV_fnptr(surface);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAUGetSurfaceivNV]</b>  </summary>
            public static void VDPAUGetSurfaceiv(IntPtr surface, All pname, int count, int* length, int* values) => GLPointers._glVDPAUGetSurfaceivNV_fnptr(surface, (uint)pname, count, length, values);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAUSurfaceAccessNV]</b>  </summary>
            public static void VDPAUSurfaceAccess(IntPtr surface, All access) => GLPointers._glVDPAUSurfaceAccessNV_fnptr(surface, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAUMapSurfacesNV]</b>  </summary>
            public static void VDPAUMapSurfaces(int numSurfaces, IntPtr* surfaces) => GLPointers._glVDPAUMapSurfacesNV_fnptr(numSurfaces, surfaces);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop] [glVDPAUUnmapSurfacesNV]</b>  </summary>
            public static void VDPAUUnmapSurfaces(int numSurface, IntPtr* surfaces) => GLPointers._glVDPAUUnmapSurfacesNV_fnptr(numSurface, surfaces);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop2] [glVDPAURegisterVideoSurfaceWithPictureStructureNV]</b>  </summary>
            public static IntPtr VDPAURegisterVideoSurfaceWithPictureStructure(void* vdpSurface, All target, int numTextureNames, uint* textureNames, bool isFrameStructure) => GLPointers._glVDPAURegisterVideoSurfaceWithPictureStructureNV_fnptr(vdpSurface, (uint)target, numTextureNames, textureNames, (byte)(isFrameStructure ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_vertex_array_range] [glFlushVertexArrayRangeNV]</b>  </summary>
            public static void FlushVertexArrayRange() => GLPointers._glFlushVertexArrayRangeNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_vertex_array_range] [glVertexArrayRangeNV]</b>  </summary>
            public static void VertexArrayRange(int length, void* pointer) => GLPointers._glVertexArrayRangeNV_fnptr(length, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL1i64NV]</b>  </summary>
            public static void VertexAttribL1i64(uint index, long x) => GLPointers._glVertexAttribL1i64NV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL2i64NV]</b>  </summary>
            public static void VertexAttribL2i64(uint index, long x, long y) => GLPointers._glVertexAttribL2i64NV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL3i64NV]</b>  </summary>
            public static void VertexAttribL3i64(uint index, long x, long y, long z) => GLPointers._glVertexAttribL3i64NV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL4i64NV]</b>  </summary>
            public static void VertexAttribL4i64(uint index, long x, long y, long z, long w) => GLPointers._glVertexAttribL4i64NV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL1i64vNV]</b>  </summary>
            public static void VertexAttribL1i64v(uint index, long* v) => GLPointers._glVertexAttribL1i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL2i64vNV]</b>  </summary>
            public static void VertexAttribL2i64v(uint index, long* v) => GLPointers._glVertexAttribL2i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL3i64vNV]</b>  </summary>
            public static void VertexAttribL3i64v(uint index, long* v) => GLPointers._glVertexAttribL3i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL4i64vNV]</b>  </summary>
            public static void VertexAttribL4i64v(uint index, long* v) => GLPointers._glVertexAttribL4i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL1ui64NV]</b>  </summary>
            public static void VertexAttribL1ui64(uint index, ulong x) => GLPointers._glVertexAttribL1ui64NV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL2ui64NV]</b>  </summary>
            public static void VertexAttribL2ui64(uint index, ulong x, ulong y) => GLPointers._glVertexAttribL2ui64NV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL3ui64NV]</b>  </summary>
            public static void VertexAttribL3ui64(uint index, ulong x, ulong y, ulong z) => GLPointers._glVertexAttribL3ui64NV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL4ui64NV]</b>  </summary>
            public static void VertexAttribL4ui64(uint index, ulong x, ulong y, ulong z, ulong w) => GLPointers._glVertexAttribL4ui64NV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL1ui64vNV]</b>  </summary>
            public static void VertexAttribL1ui64v(uint index, ulong* v) => GLPointers._glVertexAttribL1ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL2ui64vNV]</b>  </summary>
            public static void VertexAttribL2ui64v(uint index, ulong* v) => GLPointers._glVertexAttribL2ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL3ui64vNV]</b>  </summary>
            public static void VertexAttribL3ui64v(uint index, ulong* v) => GLPointers._glVertexAttribL3ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribL4ui64vNV]</b>  </summary>
            public static void VertexAttribL4ui64v(uint index, ulong* v) => GLPointers._glVertexAttribL4ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glGetVertexAttribLi64vNV]</b>  </summary>
            public static void GetVertexAttribLi64v(uint index, VertexAttribEnum pname, long* parameters) => GLPointers._glGetVertexAttribLi64vNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glGetVertexAttribLui64vNV]</b>  </summary>
            public static void GetVertexAttribLui64v(uint index, VertexAttribEnum pname, ulong* parameters) => GLPointers._glGetVertexAttribLui64vNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit] [glVertexAttribLFormatNV]</b>  </summary>
            public static void VertexAttribLFormat(uint index, int size, VertexAttribLType type, int stride) => GLPointers._glVertexAttribLFormatNV_fnptr(index, size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glBufferAddressRangeNV]</b>  </summary>
            public static void BufferAddressRange(All pname, uint index, ulong address, nint length) => GLPointers._glBufferAddressRangeNV_fnptr((uint)pname, index, address, length);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glVertexFormatNV]</b>  </summary>
            public static void VertexFormat(int size, VertexPointerType type, int stride) => GLPointers._glVertexFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glNormalFormatNV]</b>  </summary>
            public static void NormalFormat(All type, int stride) => GLPointers._glNormalFormatNV_fnptr((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glColorFormatNV]</b>  </summary>
            public static void ColorFormat(int size, ColorPointerType type, int stride) => GLPointers._glColorFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glIndexFormatNV]</b>  </summary>
            public static void IndexFormat(All type, int stride) => GLPointers._glIndexFormatNV_fnptr((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glTexCoordFormatNV]</b>  </summary>
            public static void TexCoordFormat(int size, All type, int stride) => GLPointers._glTexCoordFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glEdgeFlagFormatNV]</b>  </summary>
            public static void EdgeFlagFormat(int stride) => GLPointers._glEdgeFlagFormatNV_fnptr(stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glSecondaryColorFormatNV]</b>  </summary>
            public static void SecondaryColorFormat(int size, ColorPointerType type, int stride) => GLPointers._glSecondaryColorFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glFogCoordFormatNV]</b>  </summary>
            public static void FogCoordFormat(All type, int stride) => GLPointers._glFogCoordFormatNV_fnptr((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glVertexAttribFormatNV]</b>  </summary>
            public static void VertexAttribFormat(uint index, int size, VertexAttribType type, bool normalized, int stride) => GLPointers._glVertexAttribFormatNV_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glVertexAttribIFormatNV]</b>  </summary>
            public static void VertexAttribIFormat(uint index, int size, VertexAttribIType type, int stride) => GLPointers._glVertexAttribIFormatNV_fnptr(index, size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory] [glGetIntegerui64i_vNV]</b>  </summary>
            public static void GetIntegerui64i_v(All value, uint index, ulong* result) => GLPointers._glGetIntegerui64i_vNV_fnptr((uint)value, index, result);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glAreProgramsResidentNV]</b>  </summary>
            public static bool AreProgramsResident(int n, int* programs, bool* residences) => GLPointers._glAreProgramsResidentNV_fnptr(n, programs, (byte*)residences) != 0;
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glBindProgramNV]</b>  </summary>
            public static void BindProgram(VertexAttribEnumNV target, int id) => GLPointers._glBindProgramNV_fnptr((uint)target, id);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glDeleteProgramsNV]</b>  </summary>
            public static void DeletePrograms(int n, int* programs) => GLPointers._glDeleteProgramsNV_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glExecuteProgramNV]</b>  </summary>
            public static void ExecuteProgram(VertexAttribEnumNV target, uint id, float* parameters) => GLPointers._glExecuteProgramNV_fnptr((uint)target, id, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGenProgramsNV]</b>  </summary>
            public static void GenPrograms(int n, int* programs) => GLPointers._glGenProgramsNV_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGetProgramParameterdvNV]</b>  </summary>
            public static void GetProgramParameterdv(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, double* parameters) => GLPointers._glGetProgramParameterdvNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGetProgramParameterfvNV]</b>  </summary>
            public static void GetProgramParameterfv(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, float* parameters) => GLPointers._glGetProgramParameterfvNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGetProgramivNV]</b>  </summary>
            public static void GetProgramiv(int id, VertexAttribEnumNV pname, int* parameters) => GLPointers._glGetProgramivNV_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGetProgramStringNV]</b>  </summary>
            public static void GetProgramString(int id, VertexAttribEnumNV pname, byte* program) => GLPointers._glGetProgramStringNV_fnptr(id, (uint)pname, program);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGetTrackMatrixivNV]</b>  </summary>
            public static void GetTrackMatrixiv(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, int* parameters) => GLPointers._glGetTrackMatrixivNV_fnptr((uint)target, address, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGetVertexAttribdvNV]</b>  </summary>
            public static void GetVertexAttribdv(uint index, VertexAttribEnumNV pname, double* parameters) => GLPointers._glGetVertexAttribdvNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGetVertexAttribfvNV]</b>  </summary>
            public static void GetVertexAttribfv(uint index, VertexAttribEnumNV pname, float* parameters) => GLPointers._glGetVertexAttribfvNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGetVertexAttribivNV]</b>  </summary>
            public static void GetVertexAttribiv(uint index, VertexAttribEnumNV pname, int* parameters) => GLPointers._glGetVertexAttribivNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glGetVertexAttribPointervNV]</b>  </summary>
            public static void GetVertexAttribPointerv(uint index, VertexAttribEnumNV pname, void** pointer) => GLPointers._glGetVertexAttribPointervNV_fnptr(index, (uint)pname, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glIsProgramNV]</b>  </summary>
            public static bool IsProgram(int id) => GLPointers._glIsProgramNV_fnptr(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glLoadProgramNV]</b>  </summary>
            public static void LoadProgram(VertexAttribEnumNV target, uint id, int len, byte* program) => GLPointers._glLoadProgramNV_fnptr((uint)target, id, len, program);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glProgramParameter4dNV]</b>  </summary>
            public static void ProgramParameter4d(VertexAttribEnumNV target, uint index, double x, double y, double z, double w) => GLPointers._glProgramParameter4dNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glProgramParameter4dvNV]</b>  </summary>
            public static void ProgramParameter4dv(VertexAttribEnumNV target, uint index, double* v) => GLPointers._glProgramParameter4dvNV_fnptr((uint)target, index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glProgramParameter4fNV]</b>  </summary>
            public static void ProgramParameter4f(VertexAttribEnumNV target, uint index, float x, float y, float z, float w) => GLPointers._glProgramParameter4fNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glProgramParameter4fvNV]</b>  </summary>
            public static void ProgramParameter4fv(VertexAttribEnumNV target, uint index, float* v) => GLPointers._glProgramParameter4fvNV_fnptr((uint)target, index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glProgramParameters4dvNV]</b>  </summary>
            public static void ProgramParameters4dv(VertexAttribEnumNV target, uint index, int count, double* v) => GLPointers._glProgramParameters4dvNV_fnptr((uint)target, index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glProgramParameters4fvNV]</b>  </summary>
            public static void ProgramParameters4fv(VertexAttribEnumNV target, uint index, int count, float* v) => GLPointers._glProgramParameters4fvNV_fnptr((uint)target, index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glRequestResidentProgramsNV]</b>  </summary>
            public static void RequestResidentPrograms(int n, int* programs) => GLPointers._glRequestResidentProgramsNV_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glTrackMatrixNV]</b>  </summary>
            public static void TrackMatrix(VertexAttribEnumNV target, uint address, VertexAttribEnumNV matrix, VertexAttribEnumNV transform) => GLPointers._glTrackMatrixNV_fnptr((uint)target, address, (uint)matrix, (uint)transform);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribPointerNV]</b>  </summary>
            public static void VertexAttribPointer(uint index, int fsize, VertexAttribEnumNV type, int stride, void* pointer) => GLPointers._glVertexAttribPointerNV_fnptr(index, fsize, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib1dNV]</b>  </summary>
            public static void VertexAttrib1d(uint index, double x) => GLPointers._glVertexAttrib1dNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib1dvNV]</b>  </summary>
            public static void VertexAttrib1dv(uint index, double* v) => GLPointers._glVertexAttrib1dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib1fNV]</b>  </summary>
            public static void VertexAttrib1f(uint index, float x) => GLPointers._glVertexAttrib1fNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib1fvNV]</b>  </summary>
            public static void VertexAttrib1fv(uint index, float* v) => GLPointers._glVertexAttrib1fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib1sNV]</b>  </summary>
            public static void VertexAttrib1s(uint index, short x) => GLPointers._glVertexAttrib1sNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib1svNV]</b>  </summary>
            public static void VertexAttrib1sv(uint index, short* v) => GLPointers._glVertexAttrib1svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib2dNV]</b>  </summary>
            public static void VertexAttrib2d(uint index, double x, double y) => GLPointers._glVertexAttrib2dNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib2dvNV]</b>  </summary>
            public static void VertexAttrib2dv(uint index, double* v) => GLPointers._glVertexAttrib2dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib2fNV]</b>  </summary>
            public static void VertexAttrib2f(uint index, float x, float y) => GLPointers._glVertexAttrib2fNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib2fvNV]</b>  </summary>
            public static void VertexAttrib2fv(uint index, float* v) => GLPointers._glVertexAttrib2fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib2sNV]</b>  </summary>
            public static void VertexAttrib2s(uint index, short x, short y) => GLPointers._glVertexAttrib2sNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib2svNV]</b>  </summary>
            public static void VertexAttrib2sv(uint index, short* v) => GLPointers._glVertexAttrib2svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib3dNV]</b>  </summary>
            public static void VertexAttrib3d(uint index, double x, double y, double z) => GLPointers._glVertexAttrib3dNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib3dvNV]</b>  </summary>
            public static void VertexAttrib3dv(uint index, double* v) => GLPointers._glVertexAttrib3dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib3fNV]</b>  </summary>
            public static void VertexAttrib3f(uint index, float x, float y, float z) => GLPointers._glVertexAttrib3fNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib3fvNV]</b>  </summary>
            public static void VertexAttrib3fv(uint index, float* v) => GLPointers._glVertexAttrib3fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib3sNV]</b>  </summary>
            public static void VertexAttrib3s(uint index, short x, short y, short z) => GLPointers._glVertexAttrib3sNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib3svNV]</b>  </summary>
            public static void VertexAttrib3sv(uint index, short* v) => GLPointers._glVertexAttrib3svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib4dNV]</b>  </summary>
            public static void VertexAttrib4d(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttrib4dNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib4dvNV]</b>  </summary>
            public static void VertexAttrib4dv(uint index, double* v) => GLPointers._glVertexAttrib4dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib4fNV]</b>  </summary>
            public static void VertexAttrib4f(uint index, float x, float y, float z, float w) => GLPointers._glVertexAttrib4fNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib4fvNV]</b>  </summary>
            public static void VertexAttrib4fv(uint index, float* v) => GLPointers._glVertexAttrib4fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib4sNV]</b>  </summary>
            public static void VertexAttrib4s(uint index, short x, short y, short z, short w) => GLPointers._glVertexAttrib4sNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib4svNV]</b>  </summary>
            public static void VertexAttrib4sv(uint index, short* v) => GLPointers._glVertexAttrib4svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib4ubNV]</b>  </summary>
            public static void VertexAttrib4ub(uint index, byte x, byte y, byte z, byte w) => GLPointers._glVertexAttrib4ubNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttrib4ubvNV]</b>  </summary>
            public static void VertexAttrib4ubv(uint index, byte* v) => GLPointers._glVertexAttrib4ubvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs1dvNV]</b>  </summary>
            public static void VertexAttribs1dv(uint index, int count, double* v) => GLPointers._glVertexAttribs1dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs1fvNV]</b>  </summary>
            public static void VertexAttribs1fv(uint index, int count, float* v) => GLPointers._glVertexAttribs1fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs1svNV]</b>  </summary>
            public static void VertexAttribs1sv(uint index, int count, short* v) => GLPointers._glVertexAttribs1svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs2dvNV]</b>  </summary>
            public static void VertexAttribs2dv(uint index, int count, double* v) => GLPointers._glVertexAttribs2dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs2fvNV]</b>  </summary>
            public static void VertexAttribs2fv(uint index, int count, float* v) => GLPointers._glVertexAttribs2fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs2svNV]</b>  </summary>
            public static void VertexAttribs2sv(uint index, int count, short* v) => GLPointers._glVertexAttribs2svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs3dvNV]</b>  </summary>
            public static void VertexAttribs3dv(uint index, int count, double* v) => GLPointers._glVertexAttribs3dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs3fvNV]</b>  </summary>
            public static void VertexAttribs3fv(uint index, int count, float* v) => GLPointers._glVertexAttribs3fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs3svNV]</b>  </summary>
            public static void VertexAttribs3sv(uint index, int count, short* v) => GLPointers._glVertexAttribs3svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs4dvNV]</b>  </summary>
            public static void VertexAttribs4dv(uint index, int count, double* v) => GLPointers._glVertexAttribs4dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs4fvNV]</b>  </summary>
            public static void VertexAttribs4fv(uint index, int count, float* v) => GLPointers._glVertexAttribs4fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs4svNV]</b>  </summary>
            public static void VertexAttribs4sv(uint index, int count, short* v) => GLPointers._glVertexAttribs4svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program] [glVertexAttribs4ubvNV]</b>  </summary>
            public static void VertexAttribs4ubv(uint index, int count, byte* v) => GLPointers._glVertexAttribs4ubvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI1iEXT]</b>  </summary>
            public static void VertexAttribI1iEXT(uint index, int x) => GLPointers._glVertexAttribI1iEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI2iEXT]</b>  </summary>
            public static void VertexAttribI2iEXT(uint index, int x, int y) => GLPointers._glVertexAttribI2iEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI3iEXT]</b>  </summary>
            public static void VertexAttribI3iEXT(uint index, int x, int y, int z) => GLPointers._glVertexAttribI3iEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4iEXT]</b>  </summary>
            public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => GLPointers._glVertexAttribI4iEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI1uiEXT]</b>  </summary>
            public static void VertexAttribI1uiEXT(uint index, uint x) => GLPointers._glVertexAttribI1uiEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI2uiEXT]</b>  </summary>
            public static void VertexAttribI2uiEXT(uint index, uint x, uint y) => GLPointers._glVertexAttribI2uiEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI3uiEXT]</b>  </summary>
            public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => GLPointers._glVertexAttribI3uiEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4uiEXT]</b>  </summary>
            public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => GLPointers._glVertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI1ivEXT]</b>  </summary>
            public static void VertexAttribI1ivEXT(uint index, int* v) => GLPointers._glVertexAttribI1ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI2ivEXT]</b>  </summary>
            public static void VertexAttribI2ivEXT(uint index, int* v) => GLPointers._glVertexAttribI2ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI3ivEXT]</b>  </summary>
            public static void VertexAttribI3ivEXT(uint index, int* v) => GLPointers._glVertexAttribI3ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4ivEXT]</b>  </summary>
            public static void VertexAttribI4ivEXT(uint index, int* v) => GLPointers._glVertexAttribI4ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI1uivEXT]</b>  </summary>
            public static void VertexAttribI1uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI1uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI2uivEXT]</b>  </summary>
            public static void VertexAttribI2uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI2uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI3uivEXT]</b>  </summary>
            public static void VertexAttribI3uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI3uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4uivEXT]</b>  </summary>
            public static void VertexAttribI4uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI4uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4bvEXT]</b>  </summary>
            public static void VertexAttribI4bvEXT(uint index, sbyte* v) => GLPointers._glVertexAttribI4bvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4svEXT]</b>  </summary>
            public static void VertexAttribI4svEXT(uint index, short* v) => GLPointers._glVertexAttribI4svEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4ubvEXT]</b>  </summary>
            public static void VertexAttribI4ubvEXT(uint index, byte* v) => GLPointers._glVertexAttribI4ubvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribI4usvEXT]</b>  </summary>
            public static void VertexAttribI4usvEXT(uint index, ushort* v) => GLPointers._glVertexAttribI4usvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glVertexAttribIPointerEXT]</b>  </summary>
            public static void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers._glVertexAttribIPointerEXT_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glGetVertexAttribIivEXT]</b>  </summary>
            public static void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int* parameters) => GLPointers._glGetVertexAttribIivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4] [glGetVertexAttribIuivEXT]</b>  </summary>
            public static void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers._glGetVertexAttribIuivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glBeginVideoCaptureNV]</b>  </summary>
            public static void BeginVideoCapture(uint video_capture_slot) => GLPointers._glBeginVideoCaptureNV_fnptr(video_capture_slot);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glBindVideoCaptureStreamBufferNV]</b>  </summary>
            public static void BindVideoCaptureStreamBuffer(uint video_capture_slot, uint stream, All frame_region, IntPtr offset) => GLPointers._glBindVideoCaptureStreamBufferNV_fnptr(video_capture_slot, stream, (uint)frame_region, offset);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glBindVideoCaptureStreamTextureNV]</b>  </summary>
            public static void BindVideoCaptureStreamTexture(uint video_capture_slot, uint stream, All frame_region, All target, int texture) => GLPointers._glBindVideoCaptureStreamTextureNV_fnptr(video_capture_slot, stream, (uint)frame_region, (uint)target, texture);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glEndVideoCaptureNV]</b>  </summary>
            public static void EndVideoCapture(uint video_capture_slot) => GLPointers._glEndVideoCaptureNV_fnptr(video_capture_slot);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glGetVideoCaptureivNV]</b>  </summary>
            public static void GetVideoCaptureiv(uint video_capture_slot, All pname, int* parameters) => GLPointers._glGetVideoCaptureivNV_fnptr(video_capture_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glGetVideoCaptureStreamivNV]</b>  </summary>
            public static void GetVideoCaptureStreamiv(uint video_capture_slot, uint stream, All pname, int* parameters) => GLPointers._glGetVideoCaptureStreamivNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glGetVideoCaptureStreamfvNV]</b>  </summary>
            public static void GetVideoCaptureStreamfv(uint video_capture_slot, uint stream, All pname, float* parameters) => GLPointers._glGetVideoCaptureStreamfvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glGetVideoCaptureStreamdvNV]</b>  </summary>
            public static void GetVideoCaptureStreamdv(uint video_capture_slot, uint stream, All pname, double* parameters) => GLPointers._glGetVideoCaptureStreamdvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glVideoCaptureNV]</b>  </summary>
            public static All VideoCapture(uint video_capture_slot, uint* sequence_num, ulong* capture_time) => (All) GLPointers._glVideoCaptureNV_fnptr(video_capture_slot, sequence_num, capture_time);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glVideoCaptureStreamParameterivNV]</b>  </summary>
            public static void VideoCaptureStreamParameteriv(uint video_capture_slot, uint stream, All pname, int* parameters) => GLPointers._glVideoCaptureStreamParameterivNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glVideoCaptureStreamParameterfvNV]</b>  </summary>
            public static void VideoCaptureStreamParameterfv(uint video_capture_slot, uint stream, All pname, float* parameters) => GLPointers._glVideoCaptureStreamParameterfvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture] [glVideoCaptureStreamParameterdvNV]</b>  </summary>
            public static void VideoCaptureStreamParameterdv(uint video_capture_slot, uint stream, All pname, double* parameters) => GLPointers._glVideoCaptureStreamParameterdvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_viewport_swizzle] [glViewportSwizzleNV]</b>  </summary>
            public static void ViewportSwizzle(uint index, All swizzlex, All swizzley, All swizzlez, All swizzlew) => GLPointers._glViewportSwizzleNV_fnptr(index, (uint)swizzlex, (uint)swizzley, (uint)swizzlez, (uint)swizzlew);
            
        }
        /// <summary>GREMEDY extensions.</summary>
        public static unsafe partial class GREMEDY
        {
            /// <summary> <b>[requires: GL_GREMEDY_frame_terminator] [glFrameTerminatorGREMEDY]</b>  </summary>
            public static void FrameTerminator() => GLPointers._glFrameTerminatorGREMEDY_fnptr();
            
            /// <summary> <b>[requires: GL_GREMEDY_string_marker] [glStringMarkerGREMEDY]</b>  </summary>
            public static void StringMarker(int len, void* str) => GLPointers._glStringMarkerGREMEDY_fnptr(len, str);
            
        }
        /// <summary>HP extensions.</summary>
        public static unsafe partial class HP
        {
            /// <summary> <b>[requires: GL_HP_image_transform] [glImageTransformParameteriHP]</b>  </summary>
            public static void ImageTransformParameteri(ImageTransformTargetHP target, ImageTransformPNameHP pname, int param) => GLPointers._glImageTransformParameteriHP_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_HP_image_transform] [glImageTransformParameterfHP]</b>  </summary>
            public static void ImageTransformParameterf(ImageTransformTargetHP target, ImageTransformPNameHP pname, float param) => GLPointers._glImageTransformParameterfHP_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_HP_image_transform] [glImageTransformParameterivHP]</b>  </summary>
            public static void ImageTransformParameteriv(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => GLPointers._glImageTransformParameterivHP_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform] [glImageTransformParameterfvHP]</b>  </summary>
            public static void ImageTransformParameterfv(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => GLPointers._glImageTransformParameterfvHP_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform] [glGetImageTransformParameterivHP]</b>  </summary>
            public static void GetImageTransformParameteriv(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => GLPointers._glGetImageTransformParameterivHP_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform] [glGetImageTransformParameterfvHP]</b>  </summary>
            public static void GetImageTransformParameterfv(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => GLPointers._glGetImageTransformParameterfvHP_fnptr((uint)target, (uint)pname, parameters);
            
        }
        /// <summary>IBM extensions.</summary>
        public static unsafe partial class IBM
        {
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays] [glMultiModeDrawArraysIBM]</b>  </summary>
            public static void MultiModeDrawArrays(PrimitiveType* mode, int* first, int* count, int primcount, int modestride) => GLPointers._glMultiModeDrawArraysIBM_fnptr((uint*)mode, first, count, primcount, modestride);
            
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays] [glMultiModeDrawElementsIBM]</b>  </summary>
            public static void MultiModeDrawElements(PrimitiveType* mode, int* count, DrawElementsType type, void** indices, int primcount, int modestride) => GLPointers._glMultiModeDrawElementsIBM_fnptr((uint*)mode, count, (uint)type, indices, primcount, modestride);
            
            /// <summary> <b>[requires: GL_IBM_static_data] [glFlushStaticDataIBM]</b>  </summary>
            public static void FlushStaticData(All target) => GLPointers._glFlushStaticDataIBM_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists] [glColorPointerListIBM]</b>  </summary>
            public static void ColorPointerList(int size, ColorPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glColorPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists] [glSecondaryColorPointerListIBM]</b>  </summary>
            public static void SecondaryColorPointerList(int size, SecondaryColorPointerTypeIBM type, int stride, void** pointer, int ptrstride) => GLPointers._glSecondaryColorPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists] [glEdgeFlagPointerListIBM]</b>  </summary>
            public static void EdgeFlagPointerList(int stride, bool** pointer, int ptrstride) => GLPointers._glEdgeFlagPointerListIBM_fnptr(stride, (byte**)pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists] [glFogCoordPointerListIBM]</b>  </summary>
            public static void FogCoordPointerList(FogPointerTypeIBM type, int stride, void** pointer, int ptrstride) => GLPointers._glFogCoordPointerListIBM_fnptr((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists] [glIndexPointerListIBM]</b>  </summary>
            public static void IndexPointerList(IndexPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glIndexPointerListIBM_fnptr((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists] [glNormalPointerListIBM]</b>  </summary>
            public static void NormalPointerList(NormalPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glNormalPointerListIBM_fnptr((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists] [glTexCoordPointerListIBM]</b>  </summary>
            public static void TexCoordPointerList(int size, TexCoordPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glTexCoordPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists] [glVertexPointerListIBM]</b>  </summary>
            public static void VertexPointerList(int size, VertexPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glVertexPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
        }
        /// <summary>INGR extensions.</summary>
        public static unsafe partial class INGR
        {
            /// <summary> <b>[requires: GL_INGR_blend_func_separate] [glBlendFuncSeparateINGR]</b>  </summary>
            public static void BlendFuncSeparate(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers._glBlendFuncSeparateINGR_fnptr((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
            
        }
        /// <summary>INTEL extensions.</summary>
        public static unsafe partial class INTEL
        {
            /// <summary> <b>[requires: GL_INTEL_framebuffer_CMAA] [glApplyFramebufferAttachmentCMAAINTEL]</b>  </summary>
            public static void ApplyFramebufferAttachmentCMAA() => GLPointers._glApplyFramebufferAttachmentCMAAINTEL_fnptr();
            
            /// <summary> <b>[requires: GL_INTEL_map_texture] [glSyncTextureINTEL]</b>  </summary>
            public static void SyncTexture(int texture) => GLPointers._glSyncTextureINTEL_fnptr(texture);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture] [glUnmapTexture2DINTEL]</b>  </summary>
            public static void UnmapTexture2D(int texture, int level) => GLPointers._glUnmapTexture2DINTEL_fnptr(texture, level);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture] [glMapTexture2DINTEL]</b>  </summary>
            public static void* MapTexture2D(int texture, int level, uint access, int* stride, All* layout) => GLPointers._glMapTexture2DINTEL_fnptr(texture, level, access, stride, (uint*)layout);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays] [glVertexPointervINTEL]</b>  </summary>
            public static void VertexPointerv(int size, VertexPointerType type, void** pointer) => GLPointers._glVertexPointervINTEL_fnptr(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays] [glNormalPointervINTEL]</b>  </summary>
            public static void NormalPointerv(NormalPointerType type, void** pointer) => GLPointers._glNormalPointervINTEL_fnptr((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays] [glColorPointervINTEL]</b>  </summary>
            public static void ColorPointerv(int size, VertexPointerType type, void** pointer) => GLPointers._glColorPointervINTEL_fnptr(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays] [glTexCoordPointervINTEL]</b>  </summary>
            public static void TexCoordPointerv(int size, VertexPointerType type, void** pointer) => GLPointers._glTexCoordPointervINTEL_fnptr(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glBeginPerfQueryINTEL]</b>  </summary>
            public static void BeginPerfQuery(uint queryHandle) => GLPointers._glBeginPerfQueryINTEL_fnptr(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glCreatePerfQueryINTEL]</b>  </summary>
            public static void CreatePerfQuery(uint queryId, uint* queryHandle) => GLPointers._glCreatePerfQueryINTEL_fnptr(queryId, queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glDeletePerfQueryINTEL]</b>  </summary>
            public static void DeletePerfQuery(uint queryHandle) => GLPointers._glDeletePerfQueryINTEL_fnptr(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glEndPerfQueryINTEL]</b>  </summary>
            public static void EndPerfQuery(uint queryHandle) => GLPointers._glEndPerfQueryINTEL_fnptr(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glGetFirstPerfQueryIdINTEL]</b>  </summary>
            public static void GetFirstPerfQueryId(uint* queryId) => GLPointers._glGetFirstPerfQueryIdINTEL_fnptr(queryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glGetNextPerfQueryIdINTEL]</b>  </summary>
            public static void GetNextPerfQueryId(uint queryId, uint* nextQueryId) => GLPointers._glGetNextPerfQueryIdINTEL_fnptr(queryId, nextQueryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glGetPerfCounterInfoINTEL]</b>  </summary>
            public static void GetPerfCounterInfo(uint queryId, uint counterId, uint counterNameLength, byte* counterName, uint counterDescLength, byte* counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) => GLPointers._glGetPerfCounterInfoINTEL_fnptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glGetPerfQueryDataINTEL]</b>  </summary>
            public static void GetPerfQueryData(uint queryHandle, uint flags, int dataSize, void* data, uint* bytesWritten) => GLPointers._glGetPerfQueryDataINTEL_fnptr(queryHandle, flags, dataSize, data, bytesWritten);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glGetPerfQueryIdByNameINTEL]</b>  </summary>
            public static void GetPerfQueryIdByName(byte* queryName, uint* queryId) => GLPointers._glGetPerfQueryIdByNameINTEL_fnptr(queryName, queryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query] [glGetPerfQueryInfoINTEL]</b>  </summary>
            public static void GetPerfQueryInfo(uint queryId, uint queryNameLength, byte* queryName, uint* dataSize, uint* noCounters, uint* noInstances, PerformanceQueryCapsMaskINTEL* capsMask) => GLPointers._glGetPerfQueryInfoINTEL_fnptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, (uint*)capsMask);
            
        }
        /// <summary>KHR extensions.</summary>
        public static unsafe partial class KHR
        {
            /// <summary> <b>[requires: GL_KHR_blend_equation_advanced] [glBlendBarrierKHR]</b>  </summary>
            public static void BlendBarrier() => GLPointers._glBlendBarrierKHR_fnptr();
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glDebugMessageControl]</b> Control the reporting of debug messages in a debug context. </summary>
            /// <param name="source"> The source of debug messages to enable or disable. </param>
            /// <param name="type"> The type of debug messages to enable or disable. </param>
            /// <param name="severity"> The severity of debug messages to enable or disable. </param>
            /// <param name="count"> The length of the array ids. </param>
            /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
            /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml" /></remarks>
            public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageControl_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glDebugMessageInsert]</b> Inject an application-supplied message into the debug message queue. </summary>
            /// <param name="source"> The source of the debug message to insert. </param>
            /// <param name="type"> The type of the debug message insert. </param>
            /// <param name="id"> The user-supplied identifier of the message to insert. </param>
            /// <param name="severity"> The severity of the debug messages to insert. </param>
            /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
            /// <param name="message"> The address of a character array containing the message to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml" /></remarks>
            public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._glDebugMessageInsert_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glDebugMessageCallback]</b> Specify a callback to receive debugging messages from the GL. </summary>
            /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
            /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml" /></remarks>
            public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallback_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glGetDebugMessageLog]</b> Retrieve messages from the debug message log. </summary>
            /// <param name="count"> The number of debug messages to retrieve from the log. </param>
            /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
            /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
            /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
            /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
            /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
            /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
            /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml" /></remarks>
            public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._glGetDebugMessageLog_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glPushDebugGroup]</b> Push a named debug group into the command stream. </summary>
            /// <param name="source"> The source of the debug message. </param>
            /// <param name="id"> The identifier of the message. </param>
            /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
            /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml" /></remarks>
            public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => GLPointers._glPushDebugGroup_fnptr((uint)source, id, length, message);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glPopDebugGroup]</b> Pop the active debug group. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml" /></remarks>
            public static void PopDebugGroup() => GLPointers._glPopDebugGroup_fnptr();
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glObjectLabel]</b> Label a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object to label. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml" /></remarks>
            public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers._glObjectLabel_fnptr((uint)identifier, name, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glGetObjectLabel]</b> Retrieve the label of a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml" /></remarks>
            public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => GLPointers._glGetObjectLabel_fnptr((uint)identifier, name, bufSize, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glObjectPtrLabel]</b> Label a sync object identified by a pointer. </summary>
            /// <param name="ptr"> A pointer identifying a sync object. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml" /></remarks>
            public static void ObjectPtrLabel(void* ptr, int length, byte* label) => GLPointers._glObjectPtrLabel_fnptr(ptr, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug] [glGetObjectPtrLabel]</b> Retrieve the label of a sync object identified by a pointer. </summary>
            /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml" /></remarks>
            public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => GLPointers._glGetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
            
            /// <summary> <b>[requires: v1.1 | v4.3 | GL_KHR_debug] [glGetPointerv]</b> Return the address of the specified pointer. </summary>
            /// <param name="pname"> Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or GL_DEBUG_CALLBACK_USER_PARAM. </param>
            /// <param name="parameters"> Returns the pointer value specified by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml" /></remarks>
            public static void GetPointerv(GetPointervPName pname, void** parameters) => GLPointers._glGetPointerv_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_KHR_debug] [glDebugMessageControlKHR]</b>  </summary>
            public static void DebugMessageControlKHR(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageControlKHR_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_KHR_debug] [glDebugMessageInsertKHR]</b>  </summary>
            public static void DebugMessageInsertKHR(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._glDebugMessageInsertKHR_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: GL_KHR_debug] [glDebugMessageCallbackKHR]</b>  </summary>
            public static void DebugMessageCallbackKHR(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallbackKHR_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: GL_KHR_debug] [glGetDebugMessageLogKHR]</b>  </summary>
            public static uint GetDebugMessageLogKHR(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._glGetDebugMessageLogKHR_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: GL_KHR_debug] [glPushDebugGroupKHR]</b>  </summary>
            public static void PushDebugGroupKHR(DebugSource source, uint id, int length, byte* message) => GLPointers._glPushDebugGroupKHR_fnptr((uint)source, id, length, message);
            
            /// <summary> <b>[requires: GL_KHR_debug] [glPopDebugGroupKHR]</b>  </summary>
            public static void PopDebugGroupKHR() => GLPointers._glPopDebugGroupKHR_fnptr();
            
            /// <summary> <b>[requires: GL_KHR_debug] [glObjectLabelKHR]</b>  </summary>
            public static void ObjectLabelKHR(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers._glObjectLabelKHR_fnptr((uint)identifier, name, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug] [glGetObjectLabelKHR]</b>  </summary>
            public static void GetObjectLabelKHR(All identifier, uint name, int bufSize, int* length, byte* label) => GLPointers._glGetObjectLabelKHR_fnptr((uint)identifier, name, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug] [glObjectPtrLabelKHR]</b>  </summary>
            public static void ObjectPtrLabelKHR(void* ptr, int length, byte* label) => GLPointers._glObjectPtrLabelKHR_fnptr(ptr, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug] [glGetObjectPtrLabelKHR]</b>  </summary>
            public static void GetObjectPtrLabelKHR(void* ptr, int bufSize, int* length, byte* label) => GLPointers._glGetObjectPtrLabelKHR_fnptr(ptr, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug] [glGetPointervKHR]</b>  </summary>
            public static void GetPointervKHR(All pname, void** parameters) => GLPointers._glGetPointervKHR_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glGetGraphicsResetStatus]</b> Check if the rendering context has not been lost due to software or hardware issues. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml" /></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatus() => (GraphicsResetStatus) GLPointers._glGetGraphicsResetStatus_fnptr();
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glReadnPixels]</b> Read a block of pixels from the frame buffer. </summary>
            /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
            /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
            /// <param name="data">Returns the pixel data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
            public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._glReadnPixels_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glGetnUniformfv]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformfv(int program, int location, int bufSize, float* parameters) => GLPointers._glGetnUniformfv_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glGetnUniformiv]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformiv(int program, int location, int bufSize, int* parameters) => GLPointers._glGetnUniformiv_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness] [glGetnUniformuiv]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformuiv(int program, int location, int bufSize, uint* parameters) => GLPointers._glGetnUniformuiv_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness] [glGetGraphicsResetStatusKHR]</b>  </summary>
            public static GraphicsResetStatus GetGraphicsResetStatusKHR() => (GraphicsResetStatus) GLPointers._glGetGraphicsResetStatusKHR_fnptr();
            
            /// <summary> <b>[requires: GL_KHR_robustness] [glReadnPixelsKHR]</b>  </summary>
            public static void ReadnPixelsKHR(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._glReadnPixelsKHR_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: GL_KHR_robustness] [glGetnUniformfvKHR]</b>  </summary>
            public static void GetnUniformfvKHR(int program, int location, int bufSize, float* parameters) => GLPointers._glGetnUniformfvKHR_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness] [glGetnUniformivKHR]</b>  </summary>
            public static void GetnUniformivKHR(int program, int location, int bufSize, int* parameters) => GLPointers._glGetnUniformivKHR_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness] [glGetnUniformuivKHR]</b>  </summary>
            public static void GetnUniformuivKHR(int program, int location, int bufSize, uint* parameters) => GLPointers._glGetnUniformuivKHR_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_parallel_shader_compile] [glMaxShaderCompilerThreadsKHR]</b>  </summary>
            public static void MaxShaderCompilerThreads(uint count) => GLPointers._glMaxShaderCompilerThreadsKHR_fnptr(count);
            
        }
        /// <summary>MESA extensions.</summary>
        public static unsafe partial class MESA
        {
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y] [glFramebufferParameteriMESA]</b>  </summary>
            public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers._glFramebufferParameteriMESA_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y] [glGetFramebufferParameterivMESA]</b>  </summary>
            public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferParameterivMESA_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_MESA_resize_buffers] [glResizeBuffersMESA]</b>  </summary>
            public static void ResizeBuffers() => GLPointers._glResizeBuffersMESA_fnptr();
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos2dMESA]</b>  </summary>
            public static void WindowPos2d(double x, double y) => GLPointers._glWindowPos2dMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos2dvMESA]</b>  </summary>
            public static void WindowPos2dv(double* v) => GLPointers._glWindowPos2dvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos2fMESA]</b>  </summary>
            public static void WindowPos2f(float x, float y) => GLPointers._glWindowPos2fMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos2fvMESA]</b>  </summary>
            public static void WindowPos2fv(float* v) => GLPointers._glWindowPos2fvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos2iMESA]</b>  </summary>
            public static void WindowPos2i(int x, int y) => GLPointers._glWindowPos2iMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos2ivMESA]</b>  </summary>
            public static void WindowPos2iv(int* v) => GLPointers._glWindowPos2ivMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos2sMESA]</b>  </summary>
            public static void WindowPos2s(short x, short y) => GLPointers._glWindowPos2sMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos2svMESA]</b>  </summary>
            public static void WindowPos2sv(short* v) => GLPointers._glWindowPos2svMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos3dMESA]</b>  </summary>
            public static void WindowPos3d(double x, double y, double z) => GLPointers._glWindowPos3dMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos3dvMESA]</b>  </summary>
            public static void WindowPos3dv(double* v) => GLPointers._glWindowPos3dvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos3fMESA]</b>  </summary>
            public static void WindowPos3f(float x, float y, float z) => GLPointers._glWindowPos3fMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos3fvMESA]</b>  </summary>
            public static void WindowPos3fv(float* v) => GLPointers._glWindowPos3fvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos3iMESA]</b>  </summary>
            public static void WindowPos3i(int x, int y, int z) => GLPointers._glWindowPos3iMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos3ivMESA]</b>  </summary>
            public static void WindowPos3iv(int* v) => GLPointers._glWindowPos3ivMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos3sMESA]</b>  </summary>
            public static void WindowPos3s(short x, short y, short z) => GLPointers._glWindowPos3sMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos3svMESA]</b>  </summary>
            public static void WindowPos3sv(short* v) => GLPointers._glWindowPos3svMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos4dMESA]</b>  </summary>
            public static void WindowPos4d(double x, double y, double z, double w) => GLPointers._glWindowPos4dMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos4dvMESA]</b>  </summary>
            public static void WindowPos4dv(double* v) => GLPointers._glWindowPos4dvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos4fMESA]</b>  </summary>
            public static void WindowPos4f(float x, float y, float z, float w) => GLPointers._glWindowPos4fMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos4fvMESA]</b>  </summary>
            public static void WindowPos4fv(float* v) => GLPointers._glWindowPos4fvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos4iMESA]</b>  </summary>
            public static void WindowPos4i(int x, int y, int z, int w) => GLPointers._glWindowPos4iMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos4ivMESA]</b>  </summary>
            public static void WindowPos4iv(int* v) => GLPointers._glWindowPos4ivMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos4sMESA]</b>  </summary>
            public static void WindowPos4s(short x, short y, short z, short w) => GLPointers._glWindowPos4sMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos] [glWindowPos4svMESA]</b>  </summary>
            public static void WindowPos4sv(short* v) => GLPointers._glWindowPos4svMESA_fnptr(v);
            
        }
        /// <summary>NVX extensions.</summary>
        public static unsafe partial class NVX
        {
            /// <summary> <b>[requires: GL_NVX_conditional_render] [glBeginConditionalRenderNVX]</b>  </summary>
            public static void BeginConditionalRender(uint id) => GLPointers._glBeginConditionalRenderNVX_fnptr(id);
            
            /// <summary> <b>[requires: GL_NVX_conditional_render] [glEndConditionalRenderNVX]</b>  </summary>
            public static void EndConditionalRender() => GLPointers._glEndConditionalRenderNVX_fnptr();
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast] [glLGPUNamedBufferSubDataNVX]</b>  </summary>
            public static void LGPUNamedBufferSubData(uint gpuMask, int buffer, IntPtr offset, nint size, void* data) => GLPointers._glLGPUNamedBufferSubDataNVX_fnptr(gpuMask, buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast] [glLGPUCopyImageSubDataNVX]</b>  </summary>
            public static void LGPUCopyImageSubData(uint sourceGpu, uint destinationGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => GLPointers._glLGPUCopyImageSubDataNVX_fnptr(sourceGpu, destinationGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srxY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast] [glLGPUInterlockNVX]</b>  </summary>
            public static void LGPUInterlock() => GLPointers._glLGPUInterlockNVX_fnptr();
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2] [glUploadGpuMaskNVX]</b>  </summary>
            public static void UploadGpuMask(uint mask) => GLPointers._glUploadGpuMaskNVX_fnptr(mask);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2] [glMulticastViewportArrayvNVX]</b>  </summary>
            public static void MulticastViewportArrayv(uint gpu, uint first, int count, float* v) => GLPointers._glMulticastViewportArrayvNVX_fnptr(gpu, first, count, v);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2] [glMulticastViewportPositionWScaleNVX]</b>  </summary>
            public static void MulticastViewportPositionWScale(uint gpu, uint index, float xcoeff, float ycoeff) => GLPointers._glMulticastViewportPositionWScaleNVX_fnptr(gpu, index, xcoeff, ycoeff);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2] [glMulticastScissorArrayvNVX]</b>  </summary>
            public static void MulticastScissorArrayv(uint gpu, uint first, int count, int* v) => GLPointers._glMulticastScissorArrayvNVX_fnptr(gpu, first, count, v);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2] [glAsyncCopyBufferSubDataNVX]</b>  </summary>
            public static uint AsyncCopyBufferSubData(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => GLPointers._glAsyncCopyBufferSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2] [glAsyncCopyImageSubDataNVX]</b>  </summary>
            public static uint AsyncCopyImageSubData(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => GLPointers._glAsyncCopyImageSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence] [glCreateProgressFenceNVX]</b>  </summary>
            public static uint CreateProgressFence() => GLPointers._glCreateProgressFenceNVX_fnptr();
            
            /// <summary> <b>[requires: GL_NVX_progress_fence] [glSignalSemaphoreui64NVX]</b>  </summary>
            public static void SignalSemaphoreui64(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers._glSignalSemaphoreui64NVX_fnptr(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence] [glWaitSemaphoreui64NVX]</b>  </summary>
            public static void WaitSemaphoreui64(uint waitGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers._glWaitSemaphoreui64NVX_fnptr(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence] [glClientWaitSemaphoreui64NVX]</b>  </summary>
            public static void ClientWaitSemaphoreui64(int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers._glClientWaitSemaphoreui64NVX_fnptr(fenceObjectCount, semaphoreArray, fenceValueArray);
            
        }
        /// <summary>OES extensions.</summary>
        public static unsafe partial class OES
        {
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glMultiTexCoord1bOES]</b>  </summary>
            public static void MultiTexCoord1b(TextureUnit texture, sbyte s) => GLPointers._glMultiTexCoord1bOES_fnptr((uint)texture, s);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glMultiTexCoord1bvOES]</b>  </summary>
            public static void MultiTexCoord1bv(TextureUnit texture, sbyte* coords) => GLPointers._glMultiTexCoord1bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glMultiTexCoord2bOES]</b>  </summary>
            public static void MultiTexCoord2b(TextureUnit texture, sbyte s, sbyte t) => GLPointers._glMultiTexCoord2bOES_fnptr((uint)texture, s, t);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glMultiTexCoord2bvOES]</b>  </summary>
            public static void MultiTexCoord2bv(TextureUnit texture, sbyte* coords) => GLPointers._glMultiTexCoord2bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glMultiTexCoord3bOES]</b>  </summary>
            public static void MultiTexCoord3b(TextureUnit texture, sbyte s, sbyte t, sbyte r) => GLPointers._glMultiTexCoord3bOES_fnptr((uint)texture, s, t, r);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glMultiTexCoord3bvOES]</b>  </summary>
            public static void MultiTexCoord3bv(TextureUnit texture, sbyte* coords) => GLPointers._glMultiTexCoord3bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glMultiTexCoord4bOES]</b>  </summary>
            public static void MultiTexCoord4b(TextureUnit texture, sbyte s, sbyte t, sbyte r, sbyte q) => GLPointers._glMultiTexCoord4bOES_fnptr((uint)texture, s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glMultiTexCoord4bvOES]</b>  </summary>
            public static void MultiTexCoord4bv(TextureUnit texture, sbyte* coords) => GLPointers._glMultiTexCoord4bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glTexCoord1bOES]</b>  </summary>
            public static void TexCoord1b(sbyte s) => GLPointers._glTexCoord1bOES_fnptr(s);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glTexCoord1bvOES]</b>  </summary>
            public static void TexCoord1bv(sbyte* coords) => GLPointers._glTexCoord1bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glTexCoord2bOES]</b>  </summary>
            public static void TexCoord2b(sbyte s, sbyte t) => GLPointers._glTexCoord2bOES_fnptr(s, t);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glTexCoord2bvOES]</b>  </summary>
            public static void TexCoord2bv(sbyte* coords) => GLPointers._glTexCoord2bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glTexCoord3bOES]</b>  </summary>
            public static void TexCoord3b(sbyte s, sbyte t, sbyte r) => GLPointers._glTexCoord3bOES_fnptr(s, t, r);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glTexCoord3bvOES]</b>  </summary>
            public static void TexCoord3bv(sbyte* coords) => GLPointers._glTexCoord3bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glTexCoord4bOES]</b>  </summary>
            public static void TexCoord4b(sbyte s, sbyte t, sbyte r, sbyte q) => GLPointers._glTexCoord4bOES_fnptr(s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glTexCoord4bvOES]</b>  </summary>
            public static void TexCoord4bv(sbyte* coords) => GLPointers._glTexCoord4bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glVertex2bOES]</b>  </summary>
            public static void Vertex2b(sbyte x, sbyte y) => GLPointers._glVertex2bOES_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glVertex2bvOES]</b>  </summary>
            public static void Vertex2bv(sbyte* coords) => GLPointers._glVertex2bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glVertex3bOES]</b>  </summary>
            public static void Vertex3b(sbyte x, sbyte y, sbyte z) => GLPointers._glVertex3bOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glVertex3bvOES]</b>  </summary>
            public static void Vertex3bv(sbyte* coords) => GLPointers._glVertex3bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glVertex4bOES]</b>  </summary>
            public static void Vertex4b(sbyte x, sbyte y, sbyte z, sbyte w) => GLPointers._glVertex4bOES_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates] [glVertex4bvOES]</b>  </summary>
            public static void Vertex4bv(sbyte* coords) => GLPointers._glVertex4bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glAlphaFuncxOES]</b>  </summary>
            public static void AlphaFuncx(AlphaFunction func, int reference) => GLPointers._glAlphaFuncxOES_fnptr((uint)func, reference);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glClearColorxOES]</b>  </summary>
            public static void ClearColorx(int red, int green, int blue, int alpha) => GLPointers._glClearColorxOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glClearDepthxOES]</b>  </summary>
            public static void ClearDepthx(int depth) => GLPointers._glClearDepthxOES_fnptr(depth);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glClipPlanexOES]</b>  </summary>
            public static void ClipPlanex(ClipPlaneName plane, int* equation) => GLPointers._glClipPlanexOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glColor4xOES]</b>  </summary>
            public static void Color4x(int red, int green, int blue, int alpha) => GLPointers._glColor4xOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glDepthRangexOES]</b>  </summary>
            public static void DepthRangex(int n, int f) => GLPointers._glDepthRangexOES_fnptr(n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glFogxOES]</b>  </summary>
            public static void Fogx(FogPName pname, int param) => GLPointers._glFogxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glFogxvOES]</b>  </summary>
            public static void Fogxv(FogPName pname, int* param) => GLPointers._glFogxvOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glFrustumxOES]</b>  </summary>
            public static void Frustumx(int l, int r, int b, int t, int n, int f) => GLPointers._glFrustumxOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetClipPlanexOES]</b>  </summary>
            public static void GetClipPlanex(ClipPlaneName plane, int* equation) => GLPointers._glGetClipPlanexOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetFixedvOES]</b>  </summary>
            public static void GetFixedv(GetPName pname, int* parameters) => GLPointers._glGetFixedvOES_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetTexEnvxvOES]</b>  </summary>
            public static void GetTexEnvxv(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glGetTexEnvxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetTexParameterxvOES]</b>  </summary>
            public static void GetTexParameterxv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glLightModelxOES]</b>  </summary>
            public static void LightModelx(LightModelParameter pname, int param) => GLPointers._glLightModelxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glLightModelxvOES]</b>  </summary>
            public static void LightModelxv(LightModelParameter pname, int* param) => GLPointers._glLightModelxvOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glLightxOES]</b>  </summary>
            public static void Lightx(LightName light, LightParameter pname, int param) => GLPointers._glLightxOES_fnptr((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glLightxvOES]</b>  </summary>
            public static void Lightxv(LightName light, LightParameter pname, int* parameters) => GLPointers._glLightxvOES_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glLineWidthxOES]</b>  </summary>
            public static void LineWidthx(int width) => GLPointers._glLineWidthxOES_fnptr(width);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glLoadMatrixxOES]</b>  </summary>
            public static void LoadMatrixx(int* m) => GLPointers._glLoadMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMaterialxOES]</b>  </summary>
            public static void Materialx(TriangleFace face, MaterialParameter pname, int param) => GLPointers._glMaterialxOES_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMaterialxvOES]</b>  </summary>
            public static void Materialxv(TriangleFace face, MaterialParameter pname, int* param) => GLPointers._glMaterialxvOES_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultMatrixxOES]</b>  </summary>
            public static void MultMatrixx(int* m) => GLPointers._glMultMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultiTexCoord4xOES]</b>  </summary>
            public static void MultiTexCoord4x(TextureUnit texture, int s, int t, int r, int q) => GLPointers._glMultiTexCoord4xOES_fnptr((uint)texture, s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glNormal3xOES]</b>  </summary>
            public static void Normal3x(int nx, int ny, int nz) => GLPointers._glNormal3xOES_fnptr(nx, ny, nz);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glOrthoxOES]</b>  </summary>
            public static void Orthox(int l, int r, int b, int t, int n, int f) => GLPointers._glOrthoxOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPointParameterxvOES]</b>  </summary>
            public static void PointParameterxv(PointParameterNameARB pname, int* parameters) => GLPointers._glPointParameterxvOES_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPointSizexOES]</b>  </summary>
            public static void PointSizex(int size) => GLPointers._glPointSizexOES_fnptr(size);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPolygonOffsetxOES]</b>  </summary>
            public static void PolygonOffsetx(int factor, int units) => GLPointers._glPolygonOffsetxOES_fnptr(factor, units);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glRotatexOES]</b>  </summary>
            public static void Rotatex(int angle, int x, int y, int z) => GLPointers._glRotatexOES_fnptr(angle, x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glScalexOES]</b>  </summary>
            public static void Scalex(int x, int y, int z) => GLPointers._glScalexOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexEnvxOES]</b>  </summary>
            public static void TexEnvx(TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers._glTexEnvxOES_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexEnvxvOES]</b>  </summary>
            public static void TexEnvxv(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glTexEnvxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexParameterxOES]</b>  </summary>
            public static void TexParameterx(TextureTarget target, GetTextureParameter pname, int param) => GLPointers._glTexParameterxOES_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexParameterxvOES]</b>  </summary>
            public static void TexParameterxv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glTexParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTranslatexOES]</b>  </summary>
            public static void Translatex(int x, int y, int z) => GLPointers._glTranslatexOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetLightxvOES]</b>  </summary>
            public static void GetLightxv(LightName light, LightParameter pname, int* parameters) => GLPointers._glGetLightxvOES_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetMaterialxvOES]</b>  </summary>
            public static void GetMaterialxv(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glGetMaterialxvOES_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPointParameterxOES]</b>  </summary>
            public static void PointParameterx(PointParameterNameARB pname, int param) => GLPointers._glPointParameterxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glSampleCoveragexOES]</b>  </summary>
            public static void SampleCoveragex(int value, bool invert) => GLPointers._glSampleCoveragexOES_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glAccumxOES]</b>  </summary>
            public static void Accumx(All op, int value) => GLPointers._glAccumxOES_fnptr((uint)op, value);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glBitmapxOES]</b>  </summary>
            public static void Bitmapx(int width, int height, int xorig, int yorig, int xmove, int ymove, byte* bitmap) => GLPointers._glBitmapxOES_fnptr(width, height, xorig, yorig, xmove, ymove, bitmap);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glBlendColorxOES]</b>  </summary>
            public static void BlendColorx(int red, int green, int blue, int alpha) => GLPointers._glBlendColorxOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glClearAccumxOES]</b>  </summary>
            public static void ClearAccumx(int red, int green, int blue, int alpha) => GLPointers._glClearAccumxOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glColor3xOES]</b>  </summary>
            public static void Color3x(int red, int green, int blue) => GLPointers._glColor3xOES_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glColor3xvOES]</b>  </summary>
            public static void Color3xv(int* components) => GLPointers._glColor3xvOES_fnptr(components);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glColor4xvOES]</b>  </summary>
            public static void Color4xv(int* components) => GLPointers._glColor4xvOES_fnptr(components);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glConvolutionParameterxOES]</b>  </summary>
            public static void ConvolutionParameterx(ConvolutionTargetEXT target, ConvolutionParameter pname, int param) => GLPointers._glConvolutionParameterxOES_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glConvolutionParameterxvOES]</b>  </summary>
            public static void ConvolutionParameterxv(ConvolutionTargetEXT target, ConvolutionParameter pname, int* parameters) => GLPointers._glConvolutionParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glEvalCoord1xOES]</b>  </summary>
            public static void EvalCoord1x(int u) => GLPointers._glEvalCoord1xOES_fnptr(u);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glEvalCoord1xvOES]</b>  </summary>
            public static void EvalCoord1xv(int* coords) => GLPointers._glEvalCoord1xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glEvalCoord2xOES]</b>  </summary>
            public static void EvalCoord2x(int u, int v) => GLPointers._glEvalCoord2xOES_fnptr(u, v);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glEvalCoord2xvOES]</b>  </summary>
            public static void EvalCoord2xv(int* coords) => GLPointers._glEvalCoord2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glFeedbackBufferxOES]</b>  </summary>
            public static void FeedbackBufferx(int n, All type, int* buffer) => GLPointers._glFeedbackBufferxOES_fnptr(n, (uint)type, buffer);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetConvolutionParameterxvOES]</b>  </summary>
            public static void GetConvolutionParameterxv(All target, All pname, int* parameters) => GLPointers._glGetConvolutionParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetHistogramParameterxvOES]</b>  </summary>
            public static void GetHistogramParameterxv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers._glGetHistogramParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetLightxOES]</b>  </summary>
            public static void GetLightx(LightName light, LightParameter pname, int* parameters) => GLPointers._glGetLightxOES_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetMapxvOES]</b>  </summary>
            public static void GetMapxv(MapTarget target, GetMapQuery query, int* v) => GLPointers._glGetMapxvOES_fnptr((uint)target, (uint)query, v);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetMaterialxOES]</b>  </summary>
            public static void GetMaterialx(TriangleFace face, MaterialParameter pname, int param) => GLPointers._glGetMaterialxOES_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetPixelMapxv]</b>  </summary>
            public static void GetPixelMapxv(PixelMap map, int size, int* values) => GLPointers._glGetPixelMapxv_fnptr((uint)map, size, values);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetTexGenxvOES]</b>  </summary>
            public static void GetTexGenxv(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glGetTexGenxvOES_fnptr((uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glGetTexLevelParameterxvOES]</b>  </summary>
            public static void GetTexLevelParameterxv(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexLevelParameterxvOES_fnptr((uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glIndexxOES]</b>  </summary>
            public static void Indexx(int component) => GLPointers._glIndexxOES_fnptr(component);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glIndexxvOES]</b>  </summary>
            public static void Indexxv(int* component) => GLPointers._glIndexxvOES_fnptr(component);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glLoadTransposeMatrixxOES]</b>  </summary>
            public static void LoadTransposeMatrixx(int* m) => GLPointers._glLoadTransposeMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMap1xOES]</b>  </summary>
            public static void Map1x(MapTarget target, int u1, int u2, int stride, int order, int points) => GLPointers._glMap1xOES_fnptr((uint)target, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMap2xOES]</b>  </summary>
            public static void Map2x(MapTarget target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points) => GLPointers._glMap2xOES_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMapGrid1xOES]</b>  </summary>
            public static void MapGrid1x(int n, int u1, int u2) => GLPointers._glMapGrid1xOES_fnptr(n, u1, u2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMapGrid2xOES]</b>  </summary>
            public static void MapGrid2x(int n, int u1, int u2, int v1, int v2) => GLPointers._glMapGrid2xOES_fnptr(n, u1, u2, v1, v2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultTransposeMatrixxOES]</b>  </summary>
            public static void MultTransposeMatrixx(int* m) => GLPointers._glMultTransposeMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultiTexCoord1xOES]</b>  </summary>
            public static void MultiTexCoord1x(TextureUnit texture, int s) => GLPointers._glMultiTexCoord1xOES_fnptr((uint)texture, s);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultiTexCoord1xvOES]</b>  </summary>
            public static void MultiTexCoord1xv(TextureUnit texture, int* coords) => GLPointers._glMultiTexCoord1xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultiTexCoord2xOES]</b>  </summary>
            public static void MultiTexCoord2x(TextureUnit texture, int s, int t) => GLPointers._glMultiTexCoord2xOES_fnptr((uint)texture, s, t);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultiTexCoord2xvOES]</b>  </summary>
            public static void MultiTexCoord2xv(TextureUnit texture, int* coords) => GLPointers._glMultiTexCoord2xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultiTexCoord3xOES]</b>  </summary>
            public static void MultiTexCoord3x(TextureUnit texture, int s, int t, int r) => GLPointers._glMultiTexCoord3xOES_fnptr((uint)texture, s, t, r);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultiTexCoord3xvOES]</b>  </summary>
            public static void MultiTexCoord3xv(TextureUnit texture, int* coords) => GLPointers._glMultiTexCoord3xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glMultiTexCoord4xvOES]</b>  </summary>
            public static void MultiTexCoord4xv(TextureUnit texture, int* coords) => GLPointers._glMultiTexCoord4xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glNormal3xvOES]</b>  </summary>
            public static void Normal3xv(int* coords) => GLPointers._glNormal3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPassThroughxOES]</b>  </summary>
            public static void PassThroughx(int token) => GLPointers._glPassThroughxOES_fnptr(token);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPixelMapx]</b>  </summary>
            public static void PixelMapx(PixelMap map, int size, int* values) => GLPointers._glPixelMapx_fnptr((uint)map, size, values);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPixelStorex]</b>  </summary>
            public static void PixelStorex(PixelStoreParameter pname, int param) => GLPointers._glPixelStorex_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPixelTransferxOES]</b>  </summary>
            public static void PixelTransferx(PixelTransferParameter pname, int param) => GLPointers._glPixelTransferxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPixelZoomxOES]</b>  </summary>
            public static void PixelZoomx(int xfactor, int yfactor) => GLPointers._glPixelZoomxOES_fnptr(xfactor, yfactor);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glPrioritizeTexturesxOES]</b>  </summary>
            public static void PrioritizeTexturesx(int n, int* textures, int* priorities) => GLPointers._glPrioritizeTexturesxOES_fnptr(n, textures, priorities);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glRasterPos2xOES]</b>  </summary>
            public static void RasterPos2x(int x, int y) => GLPointers._glRasterPos2xOES_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glRasterPos2xvOES]</b>  </summary>
            public static void RasterPos2xv(int* coords) => GLPointers._glRasterPos2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glRasterPos3xOES]</b>  </summary>
            public static void RasterPos3x(int x, int y, int z) => GLPointers._glRasterPos3xOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glRasterPos3xvOES]</b>  </summary>
            public static void RasterPos3xv(int* coords) => GLPointers._glRasterPos3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glRasterPos4xOES]</b>  </summary>
            public static void RasterPos4x(int x, int y, int z, int w) => GLPointers._glRasterPos4xOES_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glRasterPos4xvOES]</b>  </summary>
            public static void RasterPos4xv(int* coords) => GLPointers._glRasterPos4xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glRectxOES]</b>  </summary>
            public static void Rectx(int x1, int y1, int x2, int y2) => GLPointers._glRectxOES_fnptr(x1, y1, x2, y2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glRectxvOES]</b>  </summary>
            public static void Rectxv(int* v1, int* v2) => GLPointers._glRectxvOES_fnptr(v1, v2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexCoord1xOES]</b>  </summary>
            public static void TexCoord1x(int s) => GLPointers._glTexCoord1xOES_fnptr(s);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexCoord1xvOES]</b>  </summary>
            public static void TexCoord1xv(int* coords) => GLPointers._glTexCoord1xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexCoord2xOES]</b>  </summary>
            public static void TexCoord2x(int s, int t) => GLPointers._glTexCoord2xOES_fnptr(s, t);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexCoord2xvOES]</b>  </summary>
            public static void TexCoord2xv(int* coords) => GLPointers._glTexCoord2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexCoord3xOES]</b>  </summary>
            public static void TexCoord3x(int s, int t, int r) => GLPointers._glTexCoord3xOES_fnptr(s, t, r);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexCoord3xvOES]</b>  </summary>
            public static void TexCoord3xv(int* coords) => GLPointers._glTexCoord3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexCoord4xOES]</b>  </summary>
            public static void TexCoord4x(int s, int t, int r, int q) => GLPointers._glTexCoord4xOES_fnptr(s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexCoord4xvOES]</b>  </summary>
            public static void TexCoord4xv(int* coords) => GLPointers._glTexCoord4xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexGenxOES]</b>  </summary>
            public static void TexGenx(TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers._glTexGenxOES_fnptr((uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glTexGenxvOES]</b>  </summary>
            public static void TexGenxv(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glTexGenxvOES_fnptr((uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glVertex2xOES]</b>  </summary>
            public static void Vertex2x(int x) => GLPointers._glVertex2xOES_fnptr(x);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glVertex2xvOES]</b>  </summary>
            public static void Vertex2xv(int* coords) => GLPointers._glVertex2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glVertex3xOES]</b>  </summary>
            public static void Vertex3x(int x, int y) => GLPointers._glVertex3xOES_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glVertex3xvOES]</b>  </summary>
            public static void Vertex3xv(int* coords) => GLPointers._glVertex3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glVertex4xOES]</b>  </summary>
            public static void Vertex4x(int x, int y, int z) => GLPointers._glVertex4xOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point] [glVertex4xvOES]</b>  </summary>
            public static void Vertex4xv(int* coords) => GLPointers._glVertex4xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_query_matrix] [glQueryMatrixxOES]</b>  </summary>
            public static uint QueryMatrixx(int* mantissa, int* exponent) => GLPointers._glQueryMatrixxOES_fnptr(mantissa, exponent);
            
            /// <summary> <b>[requires: GL_OES_single_precision] [glClearDepthfOES]</b>  </summary>
            public static void ClearDepthf(float depth) => GLPointers._glClearDepthfOES_fnptr(depth);
            
            /// <summary> <b>[requires: GL_OES_single_precision] [glClipPlanefOES]</b>  </summary>
            public static void ClipPlanef(ClipPlaneName plane, float* equation) => GLPointers._glClipPlanefOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_single_precision] [glDepthRangefOES]</b>  </summary>
            public static void DepthRangef(float n, float f) => GLPointers._glDepthRangefOES_fnptr(n, f);
            
            /// <summary> <b>[requires: GL_OES_single_precision] [glFrustumfOES]</b>  </summary>
            public static void Frustumf(float l, float r, float b, float t, float n, float f) => GLPointers._glFrustumfOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_single_precision] [glGetClipPlanefOES]</b>  </summary>
            public static void GetClipPlanef(ClipPlaneName plane, float* equation) => GLPointers._glGetClipPlanefOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_single_precision] [glOrthofOES]</b>  </summary>
            public static void Orthof(float l, float r, float b, float t, float n, float f) => GLPointers._glOrthofOES_fnptr(l, r, b, t, n, f);
            
        }
        /// <summary>OVR extensions.</summary>
        public static unsafe partial class OVR
        {
            /// <summary> <b>[requires: GL_OVR_multiview] [glFramebufferTextureMultiviewOVR]</b>  </summary>
            public static void FramebufferTextureMultiview(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int baseViewIndex, int numViews) => GLPointers._glFramebufferTextureMultiviewOVR_fnptr((uint)target, (uint)attachment, texture, level, baseViewIndex, numViews);
            
        }
        /// <summary>PGI extensions.</summary>
        public static unsafe partial class PGI
        {
            /// <summary> <b>[requires: GL_PGI_misc_hints] [glHintPGI]</b>  </summary>
            public static void Hint(HintTargetPGI target, VertexHintsMaskPGI mode) => GLPointers._glHintPGI_fnptr((uint)target, (int)mode);
            
        }
        /// <summary>SGIS extensions.</summary>
        public static unsafe partial class SGIS
        {
            /// <summary> <b>[requires: GL_SGIS_detail_texture] [glDetailTexFuncSGIS]</b>  </summary>
            public static void DetailTexFunc(TextureTarget target, int n, float* points) => GLPointers._glDetailTexFuncSGIS_fnptr((uint)target, n, points);
            
            /// <summary> <b>[requires: GL_SGIS_detail_texture] [glGetDetailTexFuncSGIS]</b>  </summary>
            public static void GetDetailTexFunc(TextureTarget target, float* points) => GLPointers._glGetDetailTexFuncSGIS_fnptr((uint)target, points);
            
            /// <summary> <b>[requires: GL_SGIS_fog_function] [glFogFuncSGIS]</b>  </summary>
            public static void FogFunc(int n, float* points) => GLPointers._glFogFuncSGIS_fnptr(n, points);
            
            /// <summary> <b>[requires: GL_SGIS_fog_function] [glGetFogFuncSGIS]</b>  </summary>
            public static void GetFogFunc(float* points) => GLPointers._glGetFogFuncSGIS_fnptr(points);
            
            /// <summary> <b>[requires: GL_SGIS_multisample] [glSampleMaskSGIS]</b>  </summary>
            public static void SampleMask(float value, bool invert) => GLPointers._glSampleMaskSGIS_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_SGIS_multisample] [glSamplePatternSGIS]</b>  </summary>
            public static void SamplePattern(SamplePatternSGIS pattern) => GLPointers._glSamplePatternSGIS_fnptr((uint)pattern);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture] [glPixelTexGenParameteriSGIS]</b>  </summary>
            public static void PixelTexGenParameteri(PixelTexGenParameterNameSGIS pname, int param) => GLPointers._glPixelTexGenParameteriSGIS_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture] [glPixelTexGenParameterivSGIS]</b>  </summary>
            public static void PixelTexGenParameteriv(PixelTexGenParameterNameSGIS pname, int* parameters) => GLPointers._glPixelTexGenParameterivSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture] [glPixelTexGenParameterfSGIS]</b>  </summary>
            public static void PixelTexGenParameterf(PixelTexGenParameterNameSGIS pname, float param) => GLPointers._glPixelTexGenParameterfSGIS_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture] [glPixelTexGenParameterfvSGIS]</b>  </summary>
            public static void PixelTexGenParameterfv(PixelTexGenParameterNameSGIS pname, float* parameters) => GLPointers._glPixelTexGenParameterfvSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture] [glGetPixelTexGenParameterivSGIS]</b>  </summary>
            public static void GetPixelTexGenParameteriv(PixelTexGenParameterNameSGIS pname, int* parameters) => GLPointers._glGetPixelTexGenParameterivSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture] [glGetPixelTexGenParameterfvSGIS]</b>  </summary>
            public static void GetPixelTexGenParameterfv(PixelTexGenParameterNameSGIS pname, float* parameters) => GLPointers._glGetPixelTexGenParameterfvSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_point_parameters] [glPointParameterfSGIS]</b>  </summary>
            public static void PointParameterf(PointParameterNameARB pname, float param) => GLPointers._glPointParameterfSGIS_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_point_parameters] [glPointParameterfvSGIS]</b>  </summary>
            public static void PointParameterfv(PointParameterNameARB pname, float* parameters) => GLPointers._glPointParameterfvSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture] [glSharpenTexFuncSGIS]</b>  </summary>
            public static void SharpenTexFunc(TextureTarget target, int n, float* points) => GLPointers._glSharpenTexFuncSGIS_fnptr((uint)target, n, points);
            
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture] [glGetSharpenTexFuncSGIS]</b>  </summary>
            public static void GetSharpenTexFunc(TextureTarget target, float* points) => GLPointers._glGetSharpenTexFuncSGIS_fnptr((uint)target, points);
            
            /// <summary> <b>[requires: GL_SGIS_texture4D] [glTexImage4DSGIS]</b>  </summary>
            public static void TexImage4D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage4DSGIS_fnptr((uint)target, level, (uint)internalformat, width, height, depth, size4d, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_SGIS_texture4D] [glTexSubImage4DSGIS]</b>  </summary>
            public static void TexSubImage4D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage4DSGIS_fnptr((uint)target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_SGIS_texture_color_mask] [glTextureColorMaskSGIS]</b>  </summary>
            public static void TextureColorMask(bool red, bool green, bool blue, bool alpha) => GLPointers._glTextureColorMaskSGIS_fnptr((byte)(red ? 1 : 0), (byte)(green ? 1 : 0), (byte)(blue ? 1 : 0), (byte)(alpha ? 1 : 0));
            
            /// <summary> <b>[requires: GL_SGIS_texture_filter4] [glGetTexFilterFuncSGIS]</b>  </summary>
            public static void GetTexFilterFunc(TextureTarget target, TextureFilterSGIS filter, float* weights) => GLPointers._glGetTexFilterFuncSGIS_fnptr((uint)target, (uint)filter, weights);
            
            /// <summary> <b>[requires: GL_SGIS_texture_filter4] [glTexFilterFuncSGIS]</b>  </summary>
            public static void TexFilterFunc(TextureTarget target, TextureFilterSGIS filter, int n, float* weights) => GLPointers._glTexFilterFuncSGIS_fnptr((uint)target, (uint)filter, n, weights);
            
        }
        /// <summary>SGIX extensions.</summary>
        public static unsafe partial class SGIX
        {
            /// <summary> <b>[requires: GL_SGIX_async] [glAsyncMarkerSGIX]</b>  </summary>
            public static void AsyncMarker(uint marker) => GLPointers._glAsyncMarkerSGIX_fnptr(marker);
            
            /// <summary> <b>[requires: GL_SGIX_async] [glFinishAsyncSGIX]</b>  </summary>
            public static int FinishAsync(uint* markerp) => GLPointers._glFinishAsyncSGIX_fnptr(markerp);
            
            /// <summary> <b>[requires: GL_SGIX_async] [glPollAsyncSGIX]</b>  </summary>
            public static int PollAsync(uint* markerp) => GLPointers._glPollAsyncSGIX_fnptr(markerp);
            
            /// <summary> <b>[requires: GL_SGIX_async] [glGenAsyncMarkersSGIX]</b>  </summary>
            public static uint GenAsyncMarkers(int range) => GLPointers._glGenAsyncMarkersSGIX_fnptr(range);
            
            /// <summary> <b>[requires: GL_SGIX_async] [glDeleteAsyncMarkersSGIX]</b>  </summary>
            public static void DeleteAsyncMarkers(uint marker, int range) => GLPointers._glDeleteAsyncMarkersSGIX_fnptr(marker, range);
            
            /// <summary> <b>[requires: GL_SGIX_async] [glIsAsyncMarkerSGIX]</b>  </summary>
            public static bool IsAsyncMarker(uint marker) => GLPointers._glIsAsyncMarkerSGIX_fnptr(marker) != 0;
            
            /// <summary> <b>[requires: GL_SGIX_flush_raster] [glFlushRasterSGIX]</b>  </summary>
            public static void FlushRaster() => GLPointers._glFlushRasterSGIX_fnptr();
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentColorMaterialSGIX]</b>  </summary>
            public static void FragmentColorMaterial(TriangleFace face, MaterialParameter mode) => GLPointers._glFragmentColorMaterialSGIX_fnptr((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentLightfSGIX]</b>  </summary>
            public static void FragmentLightf(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float param) => GLPointers._glFragmentLightfSGIX_fnptr((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentLightfvSGIX]</b>  </summary>
            public static void FragmentLightfv(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => GLPointers._glFragmentLightfvSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentLightiSGIX]</b>  </summary>
            public static void FragmentLighti(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int param) => GLPointers._glFragmentLightiSGIX_fnptr((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentLightivSGIX]</b>  </summary>
            public static void FragmentLightiv(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => GLPointers._glFragmentLightivSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentLightModelfSGIX]</b>  </summary>
            public static void FragmentLightModelf(FragmentLightModelParameterSGIX pname, float param) => GLPointers._glFragmentLightModelfSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentLightModelfvSGIX]</b>  </summary>
            public static void FragmentLightModelfv(FragmentLightModelParameterSGIX pname, float* parameters) => GLPointers._glFragmentLightModelfvSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentLightModeliSGIX]</b>  </summary>
            public static void FragmentLightModeli(FragmentLightModelParameterSGIX pname, int param) => GLPointers._glFragmentLightModeliSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentLightModelivSGIX]</b>  </summary>
            public static void FragmentLightModeliv(FragmentLightModelParameterSGIX pname, int* parameters) => GLPointers._glFragmentLightModelivSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentMaterialfSGIX]</b>  </summary>
            public static void FragmentMaterialf(TriangleFace face, MaterialParameter pname, float param) => GLPointers._glFragmentMaterialfSGIX_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentMaterialfvSGIX]</b>  </summary>
            public static void FragmentMaterialfv(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers._glFragmentMaterialfvSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentMaterialiSGIX]</b>  </summary>
            public static void FragmentMateriali(TriangleFace face, MaterialParameter pname, int param) => GLPointers._glFragmentMaterialiSGIX_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glFragmentMaterialivSGIX]</b>  </summary>
            public static void FragmentMaterialiv(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glFragmentMaterialivSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glGetFragmentLightfvSGIX]</b>  </summary>
            public static void GetFragmentLightfv(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => GLPointers._glGetFragmentLightfvSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glGetFragmentLightivSGIX]</b>  </summary>
            public static void GetFragmentLightiv(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => GLPointers._glGetFragmentLightivSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glGetFragmentMaterialfvSGIX]</b>  </summary>
            public static void GetFragmentMaterialfv(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers._glGetFragmentMaterialfvSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glGetFragmentMaterialivSGIX]</b>  </summary>
            public static void GetFragmentMaterialiv(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glGetFragmentMaterialivSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting] [glLightEnviSGIX]</b>  </summary>
            public static void LightEnvi(LightEnvParameterSGIX pname, LightEnvModeSGIX param) => GLPointers._glLightEnviSGIX_fnptr((uint)pname, (int)param);
            
            /// <summary> <b>[requires: GL_SGIX_framezoom] [glFrameZoomSGIX]</b>  </summary>
            public static void FrameZoom(int factor) => GLPointers._glFrameZoomSGIX_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SGIX_igloo_interface] [glIglooInterfaceSGIX]</b>  </summary>
            public static void IglooInterface(All pname, void* parameters) => GLPointers._glIglooInterfaceSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_instruments] [glGetInstrumentsSGIX]</b>  </summary>
            public static int GetInstruments() => GLPointers._glGetInstrumentsSGIX_fnptr();
            
            /// <summary> <b>[requires: GL_SGIX_instruments] [glInstrumentsBufferSGIX]</b>  </summary>
            public static void InstrumentsBuffer(int size, int* buffer) => GLPointers._glInstrumentsBufferSGIX_fnptr(size, buffer);
            
            /// <summary> <b>[requires: GL_SGIX_instruments] [glPollInstrumentsSGIX]</b>  </summary>
            public static int PollInstruments(int* marker_p) => GLPointers._glPollInstrumentsSGIX_fnptr(marker_p);
            
            /// <summary> <b>[requires: GL_SGIX_instruments] [glReadInstrumentsSGIX]</b>  </summary>
            public static void ReadInstruments(int marker) => GLPointers._glReadInstrumentsSGIX_fnptr(marker);
            
            /// <summary> <b>[requires: GL_SGIX_instruments] [glStartInstrumentsSGIX]</b>  </summary>
            public static void StartInstruments() => GLPointers._glStartInstrumentsSGIX_fnptr();
            
            /// <summary> <b>[requires: GL_SGIX_instruments] [glStopInstrumentsSGIX]</b>  </summary>
            public static void StopInstruments(int marker) => GLPointers._glStopInstrumentsSGIX_fnptr(marker);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority] [glGetListParameterfvSGIX]</b>  </summary>
            public static void GetListParameterfv(int list, ListParameterName pname, float* parameters) => GLPointers._glGetListParameterfvSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority] [glGetListParameterivSGIX]</b>  </summary>
            public static void GetListParameteriv(int list, ListParameterName pname, int* parameters) => GLPointers._glGetListParameterivSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority] [glListParameterfSGIX]</b>  </summary>
            public static void ListParameterf(int list, ListParameterName pname, float param) => GLPointers._glListParameterfSGIX_fnptr(list, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority] [glListParameterfvSGIX]</b>  </summary>
            public static void ListParameterfv(int list, ListParameterName pname, float* parameters) => GLPointers._glListParameterfvSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority] [glListParameteriSGIX]</b>  </summary>
            public static void ListParameteri(int list, ListParameterName pname, int param) => GLPointers._glListParameteriSGIX_fnptr(list, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority] [glListParameterivSGIX]</b>  </summary>
            public static void ListParameteriv(int list, ListParameterName pname, int* parameters) => GLPointers._glListParameterivSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_pixel_texture] [glPixelTexGenSGIX]</b>  </summary>
            public static void PixelTexGen(PixelTexGenModeSGIX mode) => GLPointers._glPixelTexGenSGIX_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd] [glDeformationMap3dSGIX]</b>  </summary>
            public static void DeformationMap3d(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double* points) => GLPointers._glDeformationMap3dSGIX_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd] [glDeformationMap3fSGIX]</b>  </summary>
            public static void DeformationMap3f(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float* points) => GLPointers._glDeformationMap3fSGIX_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd] [glDeformSGIX]</b>  </summary>
            public static void Deform(FfdMaskSGIX mask) => GLPointers._glDeformSGIX_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd] [glLoadIdentityDeformationMapSGIX]</b>  </summary>
            public static void LoadIdentityDeformationMap(FfdMaskSGIX mask) => GLPointers._glLoadIdentityDeformationMapSGIX_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_SGIX_reference_plane] [glReferencePlaneSGIX]</b>  </summary>
            public static void ReferencePlane(double* equation) => GLPointers._glReferencePlaneSGIX_fnptr(equation);
            
            /// <summary> <b>[requires: GL_SGIX_sprite] [glSpriteParameterfSGIX]</b>  </summary>
            public static void SpriteParameterf(SpriteParameterNameSGIX pname, float param) => GLPointers._glSpriteParameterfSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_sprite] [glSpriteParameterfvSGIX]</b>  </summary>
            public static void SpriteParameterfv(SpriteParameterNameSGIX pname, float* parameters) => GLPointers._glSpriteParameterfvSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_sprite] [glSpriteParameteriSGIX]</b>  </summary>
            public static void SpriteParameteri(SpriteParameterNameSGIX pname, SpriteModeSGIX param) => GLPointers._glSpriteParameteriSGIX_fnptr((uint)pname, (int)param);
            
            /// <summary> <b>[requires: GL_SGIX_sprite] [glSpriteParameterivSGIX]</b>  </summary>
            public static void SpriteParameteriv(SpriteParameterNameSGIX pname, SpriteModeSGIX* parameters) => GLPointers._glSpriteParameterivSGIX_fnptr((uint)pname, (int*)parameters);
            
            /// <summary> <b>[requires: GL_SGIX_tag_sample_buffer] [glTagSampleBufferSGIX]</b>  </summary>
            public static void TagSampleBuffer() => GLPointers._glTagSampleBufferSGIX_fnptr();
            
        }
        /// <summary>SGI extensions.</summary>
        public static unsafe partial class SGI
        {
            /// <summary> <b>[requires: GL_SGI_color_table] [glColorTableSGI]</b>  </summary>
            public static void ColorTable(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table) => GLPointers._glColorTableSGI_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_SGI_color_table] [glColorTableParameterfvSGI]</b>  </summary>
            public static void ColorTableParameterfv(ColorTableTargetSGI target, ColorTableParameterPName pname, float* parameters) => GLPointers._glColorTableParameterfvSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table] [glColorTableParameterivSGI]</b>  </summary>
            public static void ColorTableParameteriv(ColorTableTargetSGI target, ColorTableParameterPName pname, int* parameters) => GLPointers._glColorTableParameterivSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table] [glCopyColorTableSGI]</b>  </summary>
            public static void CopyColorTable(ColorTableTargetSGI target, InternalFormat internalformat, int x, int y, int width) => GLPointers._glCopyColorTableSGI_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_SGI_color_table] [glGetColorTableSGI]</b>  </summary>
            public static void GetColorTable(ColorTableTargetSGI target, PixelFormat format, PixelType type, void* table) => GLPointers._glGetColorTableSGI_fnptr((uint)target, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_SGI_color_table] [glGetColorTableParameterfvSGI]</b>  </summary>
            public static void GetColorTableParameterfv(ColorTableTargetSGI target, ColorTableParameterPName pname, float* parameters) => GLPointers._glGetColorTableParameterfvSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table] [glGetColorTableParameterivSGI]</b>  </summary>
            public static void GetColorTableParameteriv(ColorTableTargetSGI target, ColorTableParameterPName pname, int* parameters) => GLPointers._glGetColorTableParameterivSGI_fnptr((uint)target, (uint)pname, parameters);
            
        }
        /// <summary>SUNX extensions.</summary>
        public static unsafe partial class SUNX
        {
            /// <summary> <b>[requires: GL_SUNX_constant_data] [glFinishTextureSUNX]</b>  </summary>
            public static void FinishTexture() => GLPointers._glFinishTextureSUNX_fnptr();
            
        }
        /// <summary>SUN extensions.</summary>
        public static unsafe partial class SUN
        {
            /// <summary> <b>[requires: GL_SUN_global_alpha] [glGlobalAlphaFactorbSUN]</b>  </summary>
            public static void GlobalAlphaFactorb(sbyte factor) => GLPointers._glGlobalAlphaFactorbSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha] [glGlobalAlphaFactorsSUN]</b>  </summary>
            public static void GlobalAlphaFactors(short factor) => GLPointers._glGlobalAlphaFactorsSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha] [glGlobalAlphaFactoriSUN]</b>  </summary>
            public static void GlobalAlphaFactori(int factor) => GLPointers._glGlobalAlphaFactoriSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha] [glGlobalAlphaFactorfSUN]</b>  </summary>
            public static void GlobalAlphaFactorf(float factor) => GLPointers._glGlobalAlphaFactorfSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha] [glGlobalAlphaFactordSUN]</b>  </summary>
            public static void GlobalAlphaFactord(double factor) => GLPointers._glGlobalAlphaFactordSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha] [glGlobalAlphaFactorubSUN]</b>  </summary>
            public static void GlobalAlphaFactorub(byte factor) => GLPointers._glGlobalAlphaFactorubSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha] [glGlobalAlphaFactorusSUN]</b>  </summary>
            public static void GlobalAlphaFactorus(ushort factor) => GLPointers._glGlobalAlphaFactorusSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha] [glGlobalAlphaFactoruiSUN]</b>  </summary>
            public static void GlobalAlphaFactorui(uint factor) => GLPointers._glGlobalAlphaFactoruiSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_mesh_array] [glDrawMeshArraysSUN]</b>  </summary>
            public static void DrawMeshArrays(PrimitiveType mode, int first, int count, int width) => GLPointers._glDrawMeshArraysSUN_fnptr((uint)mode, first, count, width);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list] [glReplacementCodeuiSUN]</b>  </summary>
            public static void ReplacementCodeui(TriangleListSUN code) => GLPointers._glReplacementCodeuiSUN_fnptr((uint)code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list] [glReplacementCodeusSUN]</b>  </summary>
            public static void ReplacementCodeus(ushort code) => GLPointers._glReplacementCodeusSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list] [glReplacementCodeubSUN]</b>  </summary>
            public static void ReplacementCodeub(byte code) => GLPointers._glReplacementCodeubSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list] [glReplacementCodeuivSUN]</b>  </summary>
            public static void ReplacementCodeuiv(TriangleListSUN* code) => GLPointers._glReplacementCodeuivSUN_fnptr((uint*)code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list] [glReplacementCodeusvSUN]</b>  </summary>
            public static void ReplacementCodeusv(ushort* code) => GLPointers._glReplacementCodeusvSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list] [glReplacementCodeubvSUN]</b>  </summary>
            public static void ReplacementCodeubv(byte* code) => GLPointers._glReplacementCodeubvSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list] [glReplacementCodePointerSUN]</b>  </summary>
            public static void ReplacementCodePointer(ReplacementCodeTypeSUN type, int stride, void** pointer) => GLPointers._glReplacementCodePointerSUN_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glColor4ubVertex2fSUN]</b>  </summary>
            public static void Color4ubVertex2f(byte r, byte g, byte b, byte a, float x, float y) => GLPointers._glColor4ubVertex2fSUN_fnptr(r, g, b, a, x, y);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glColor4ubVertex2fvSUN]</b>  </summary>
            public static void Color4ubVertex2fv(byte* c, float* v) => GLPointers._glColor4ubVertex2fvSUN_fnptr(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glColor4ubVertex3fSUN]</b>  </summary>
            public static void Color4ubVertex3f(byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers._glColor4ubVertex3fSUN_fnptr(r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glColor4ubVertex3fvSUN]</b>  </summary>
            public static void Color4ubVertex3fv(byte* c, float* v) => GLPointers._glColor4ubVertex3fvSUN_fnptr(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glColor3fVertex3fSUN]</b>  </summary>
            public static void Color3fVertex3f(float r, float g, float b, float x, float y, float z) => GLPointers._glColor3fVertex3fSUN_fnptr(r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glColor3fVertex3fvSUN]</b>  </summary>
            public static void Color3fVertex3fv(float* c, float* v) => GLPointers._glColor3fVertex3fvSUN_fnptr(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glNormal3fVertex3fSUN]</b>  </summary>
            public static void Normal3fVertex3f(float nx, float ny, float nz, float x, float y, float z) => GLPointers._glNormal3fVertex3fSUN_fnptr(nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glNormal3fVertex3fvSUN]</b>  </summary>
            public static void Normal3fVertex3fv(float* n, float* v) => GLPointers._glNormal3fVertex3fvSUN_fnptr(n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glColor4fNormal3fVertex3fSUN]</b>  </summary>
            public static void Color4fNormal3fVertex3f(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glColor4fNormal3fVertex3fSUN_fnptr(r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glColor4fNormal3fVertex3fvSUN]</b>  </summary>
            public static void Color4fNormal3fVertex3fv(float* c, float* n, float* v) => GLPointers._glColor4fNormal3fVertex3fvSUN_fnptr(c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fVertex3fSUN]</b>  </summary>
            public static void TexCoord2fVertex3f(float s, float t, float x, float y, float z) => GLPointers._glTexCoord2fVertex3fSUN_fnptr(s, t, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fVertex3fvSUN]</b>  </summary>
            public static void TexCoord2fVertex3fv(float* tc, float* v) => GLPointers._glTexCoord2fVertex3fvSUN_fnptr(tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord4fVertex4fSUN]</b>  </summary>
            public static void TexCoord4fVertex4f(float s, float t, float p, float q, float x, float y, float z, float w) => GLPointers._glTexCoord4fVertex4fSUN_fnptr(s, t, p, q, x, y, z, w);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord4fVertex4fvSUN]</b>  </summary>
            public static void TexCoord4fVertex4fv(float* tc, float* v) => GLPointers._glTexCoord4fVertex4fvSUN_fnptr(tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fColor4ubVertex3fSUN]</b>  </summary>
            public static void TexCoord2fColor4ubVertex3f(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers._glTexCoord2fColor4ubVertex3fSUN_fnptr(s, t, r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fColor4ubVertex3fvSUN]</b>  </summary>
            public static void TexCoord2fColor4ubVertex3fv(float* tc, byte* c, float* v) => GLPointers._glTexCoord2fColor4ubVertex3fvSUN_fnptr(tc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fColor3fVertex3fSUN]</b>  </summary>
            public static void TexCoord2fColor3fVertex3f(float s, float t, float r, float g, float b, float x, float y, float z) => GLPointers._glTexCoord2fColor3fVertex3fSUN_fnptr(s, t, r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fColor3fVertex3fvSUN]</b>  </summary>
            public static void TexCoord2fColor3fVertex3fv(float* tc, float* c, float* v) => GLPointers._glTexCoord2fColor3fVertex3fvSUN_fnptr(tc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fNormal3fVertex3fSUN]</b>  </summary>
            public static void TexCoord2fNormal3fVertex3f(float s, float t, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glTexCoord2fNormal3fVertex3fSUN_fnptr(s, t, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fNormal3fVertex3fvSUN]</b>  </summary>
            public static void TexCoord2fNormal3fVertex3fv(float* tc, float* n, float* v) => GLPointers._glTexCoord2fNormal3fVertex3fvSUN_fnptr(tc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fColor4fNormal3fVertex3fSUN]</b>  </summary>
            public static void TexCoord2fColor4fNormal3fVertex3f(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glTexCoord2fColor4fNormal3fVertex3fSUN_fnptr(s, t, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord2fColor4fNormal3fVertex3fvSUN]</b>  </summary>
            public static void TexCoord2fColor4fNormal3fVertex3fv(float* tc, float* c, float* n, float* v) => GLPointers._glTexCoord2fColor4fNormal3fVertex3fvSUN_fnptr(tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord4fColor4fNormal3fVertex4fSUN]</b>  </summary>
            public static void TexCoord4fColor4fNormal3fVertex4f(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w) => GLPointers._glTexCoord4fColor4fNormal3fVertex4fSUN_fnptr(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glTexCoord4fColor4fNormal3fVertex4fvSUN]</b>  </summary>
            public static void TexCoord4fColor4fNormal3fVertex4fv(float* tc, float* c, float* n, float* v) => GLPointers._glTexCoord4fColor4fNormal3fVertex4fvSUN_fnptr(tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiVertex3fSUN]</b>  </summary>
            public static void ReplacementCodeuiVertex3f(TriangleListSUN rc, float x, float y, float z) => GLPointers._glReplacementCodeuiVertex3fSUN_fnptr((uint)rc, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiVertex3fvSUN]</b>  </summary>
            public static void ReplacementCodeuiVertex3fv(TriangleListSUN* rc, float* v) => GLPointers._glReplacementCodeuiVertex3fvSUN_fnptr((uint*)rc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiColor4ubVertex3fSUN]</b>  </summary>
            public static void ReplacementCodeuiColor4ubVertex3f(TriangleListSUN rc, byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers._glReplacementCodeuiColor4ubVertex3fSUN_fnptr((uint)rc, r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiColor4ubVertex3fvSUN]</b>  </summary>
            public static void ReplacementCodeuiColor4ubVertex3fv(TriangleListSUN* rc, byte* c, float* v) => GLPointers._glReplacementCodeuiColor4ubVertex3fvSUN_fnptr((uint*)rc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiColor3fVertex3fSUN]</b>  </summary>
            public static void ReplacementCodeuiColor3fVertex3f(TriangleListSUN rc, float r, float g, float b, float x, float y, float z) => GLPointers._glReplacementCodeuiColor3fVertex3fSUN_fnptr((uint)rc, r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiColor3fVertex3fvSUN]</b>  </summary>
            public static void ReplacementCodeuiColor3fVertex3fv(TriangleListSUN* rc, float* c, float* v) => GLPointers._glReplacementCodeuiColor3fVertex3fvSUN_fnptr((uint*)rc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiNormal3fVertex3fSUN]</b>  </summary>
            public static void ReplacementCodeuiNormal3fVertex3f(TriangleListSUN rc, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glReplacementCodeuiNormal3fVertex3fSUN_fnptr((uint)rc, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiNormal3fVertex3fvSUN]</b>  </summary>
            public static void ReplacementCodeuiNormal3fVertex3fv(TriangleListSUN* rc, float* n, float* v) => GLPointers._glReplacementCodeuiNormal3fVertex3fvSUN_fnptr((uint*)rc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiColor4fNormal3fVertex3fSUN]</b>  </summary>
            public static void ReplacementCodeuiColor4fNormal3fVertex3f(TriangleListSUN rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glReplacementCodeuiColor4fNormal3fVertex3fSUN_fnptr((uint)rc, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiColor4fNormal3fVertex3fvSUN]</b>  </summary>
            public static void ReplacementCodeuiColor4fNormal3fVertex3fv(TriangleListSUN* rc, float* c, float* n, float* v) => GLPointers._glReplacementCodeuiColor4fNormal3fVertex3fvSUN_fnptr((uint*)rc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiTexCoord2fVertex3fSUN]</b>  </summary>
            public static void ReplacementCodeuiTexCoord2fVertex3f(TriangleListSUN rc, float s, float t, float x, float y, float z) => GLPointers._glReplacementCodeuiTexCoord2fVertex3fSUN_fnptr((uint)rc, s, t, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiTexCoord2fVertex3fvSUN]</b>  </summary>
            public static void ReplacementCodeuiTexCoord2fVertex3fv(TriangleListSUN* rc, float* tc, float* v) => GLPointers._glReplacementCodeuiTexCoord2fVertex3fvSUN_fnptr((uint*)rc, tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN]</b>  </summary>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3f(TriangleListSUN rc, float s, float t, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_fnptr((uint)rc, s, t, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN]</b>  </summary>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fv(TriangleListSUN* rc, float* tc, float* n, float* v) => GLPointers._glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_fnptr((uint*)rc, tc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN]</b>  </summary>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3f(TriangleListSUN rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_fnptr((uint)rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex] [glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN]</b>  </summary>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fv(TriangleListSUN* rc, float* tc, float* c, float* n, float* v) => GLPointers._glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_fnptr((uint*)rc, tc, c, n, v);
            
        }
    }
}
