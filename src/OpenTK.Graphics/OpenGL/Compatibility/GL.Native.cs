// This file is auto generated, do not edit.
using System;
using System.Runtime.InteropServices;
using OpenTK.Graphics;

namespace OpenTK.Graphics.OpenGL.Compatibility
{
    public static unsafe partial class GL
    {
        private static delegate* unmanaged<CullFaceMode, void> _CullFace_fnptr = &CullFace_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify whether front- or back-facing facets can be culled. </summary>
        /// <param name="mode"> Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCullFace.xhtml" /></remarks>
        public static void CullFace(CullFaceMode mode) => _CullFace_fnptr(mode);
        [UnmanagedCallersOnly]
        private static void CullFace_Lazy(CullFaceMode mode)
        {
            _CullFace_fnptr = (delegate* unmanaged<CullFaceMode, void>)GLLoader.BindingsContext.GetProcAddress("glCullFace");
            _CullFace_fnptr(mode);
        }
        
        private static delegate* unmanaged<FrontFaceDirection, void> _FrontFace_fnptr = &FrontFace_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define front- and back-facing polygons. </summary>
        /// <param name="mode"> Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFrontFace.xhtml" /></remarks>
        public static void FrontFace(FrontFaceDirection mode) => _FrontFace_fnptr(mode);
        [UnmanagedCallersOnly]
        private static void FrontFace_Lazy(FrontFaceDirection mode)
        {
            _FrontFace_fnptr = (delegate* unmanaged<FrontFaceDirection, void>)GLLoader.BindingsContext.GetProcAddress("glFrontFace");
            _FrontFace_fnptr(mode);
        }
        
        private static delegate* unmanaged<HintTarget, HintMode, void> _Hint_fnptr = &Hint_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify implementation-specific hints. </summary>
        /// <param name="target"> Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted. </param>
        /// <param name="mode"> Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glHint.xhtml" /></remarks>
        public static void Hint(HintTarget target, HintMode mode) => _Hint_fnptr(target, mode);
        [UnmanagedCallersOnly]
        private static void Hint_Lazy(HintTarget target, HintMode mode)
        {
            _Hint_fnptr = (delegate* unmanaged<HintTarget, HintMode, void>)GLLoader.BindingsContext.GetProcAddress("glHint");
            _Hint_fnptr(target, mode);
        }
        
        private static delegate* unmanaged<float, void> _LineWidth_fnptr = &LineWidth_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the width of rasterized lines. </summary>
        /// <param name="width"> Specifies the width of rasterized lines. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLineWidth.xhtml" /></remarks>
        public static void LineWidth(float width) => _LineWidth_fnptr(width);
        [UnmanagedCallersOnly]
        private static void LineWidth_Lazy(float width)
        {
            _LineWidth_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glLineWidth");
            _LineWidth_fnptr(width);
        }
        
        private static delegate* unmanaged<float, void> _PointSize_fnptr = &PointSize_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the diameter of rasterized points. </summary>
        /// <param name="size"> Specifies the diameter of rasterized points. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointSize.xhtml" /></remarks>
        public static void PointSize(float size) => _PointSize_fnptr(size);
        [UnmanagedCallersOnly]
        private static void PointSize_Lazy(float size)
        {
            _PointSize_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glPointSize");
            _PointSize_fnptr(size);
        }
        
        private static delegate* unmanaged<MaterialFace, PolygonMode, void> _PolygonMode_fnptr = &PolygonMode_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Select a polygon rasterization mode. </summary>
        /// <param name="face"> Specifies the polygons that mode applies to. Must be GL_FRONT_AND_BACK for front- and back-facing polygons. </param>
        /// <param name="mode"> Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The initial value is GL_FILL for both front- and back-facing polygons. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonMode.xhtml" /></remarks>
        public static void PolygonMode(MaterialFace face, PolygonMode mode) => _PolygonMode_fnptr(face, mode);
        [UnmanagedCallersOnly]
        private static void PolygonMode_Lazy(MaterialFace face, PolygonMode mode)
        {
            _PolygonMode_fnptr = (delegate* unmanaged<MaterialFace, PolygonMode, void>)GLLoader.BindingsContext.GetProcAddress("glPolygonMode");
            _PolygonMode_fnptr(face, mode);
        }
        
        private static delegate* unmanaged<int, int, int, int, void> _Scissor_fnptr = &Scissor_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define the scissor box. </summary>
        /// <param name="x"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="y"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="width"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissor.xhtml" /></remarks>
        public static void Scissor(int x, int y, int width, int height) => _Scissor_fnptr(x, y, width, height);
        [UnmanagedCallersOnly]
        private static void Scissor_Lazy(int x, int y, int width, int height)
        {
            _Scissor_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glScissor");
            _Scissor_fnptr(x, y, width, height);
        }
        
        private static delegate* unmanaged<TextureTarget, TextureParameterName, float, void> _TexParameterf_fnptr = &TexParameterf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterf(TextureTarget target, TextureParameterName pname, float param) => _TexParameterf_fnptr(target, pname, param);
        [UnmanagedCallersOnly]
        private static void TexParameterf_Lazy(TextureTarget target, TextureParameterName pname, float param)
        {
            _TexParameterf_fnptr = (delegate* unmanaged<TextureTarget, TextureParameterName, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameterf");
            _TexParameterf_fnptr(target, pname, param);
        }
        
        private static delegate* unmanaged<TextureTarget, TextureParameterName, float*, void> _TexParameterfv_fnptr = &TexParameterfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterfv(TextureTarget target, TextureParameterName pname, float* parameters) => _TexParameterfv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TexParameterfv_Lazy(TextureTarget target, TextureParameterName pname, float* parameters)
        {
            _TexParameterfv_fnptr = (delegate* unmanaged<TextureTarget, TextureParameterName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameterfv");
            _TexParameterfv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, TextureParameterName, int, void> _TexParameteri_fnptr = &TexParameteri_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameteri(TextureTarget target, TextureParameterName pname, int param) => _TexParameteri_fnptr(target, pname, param);
        [UnmanagedCallersOnly]
        private static void TexParameteri_Lazy(TextureTarget target, TextureParameterName pname, int param)
        {
            _TexParameteri_fnptr = (delegate* unmanaged<TextureTarget, TextureParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameteri");
            _TexParameteri_fnptr(target, pname, param);
        }
        
        private static delegate* unmanaged<TextureTarget, TextureParameterName, int*, void> _TexParameteriv_fnptr = &TexParameteriv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameteriv(TextureTarget target, TextureParameterName pname, int* parameters) => _TexParameteriv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TexParameteriv_Lazy(TextureTarget target, TextureParameterName pname, int* parameters)
        {
            _TexParameteriv_fnptr = (delegate* unmanaged<TextureTarget, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameteriv");
            _TexParameteriv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, PixelFormat, PixelType, void*, void> _TexImage1D_fnptr = &TexImage1D_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a one-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage1D.xhtml" /></remarks>
        public static void TexImage1D(TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => _TexImage1D_fnptr(target, level, internalformat, width, border, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void TexImage1D_Lazy(TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels)
        {
            _TexImage1D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage1D");
            _TexImage1D_fnptr(target, level, internalformat, width, border, format, type, pixels);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TexImage2D_fnptr = &TexImage2D_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a two-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml" /></remarks>
        public static void TexImage2D(TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => _TexImage2D_fnptr(target, level, internalformat, width, height, border, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void TexImage2D_Lazy(TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels)
        {
            _TexImage2D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage2D");
            _TexImage2D_fnptr(target, level, internalformat, width, height, border, format, type, pixels);
        }
        
        private static delegate* unmanaged<DrawBufferMode, void> _DrawBuffer_fnptr = &DrawBuffer_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify which color buffers are to be drawn into. </summary>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
        public static void DrawBuffer(DrawBufferMode buf) => _DrawBuffer_fnptr(buf);
        [UnmanagedCallersOnly]
        private static void DrawBuffer_Lazy(DrawBufferMode buf)
        {
            _DrawBuffer_fnptr = (delegate* unmanaged<DrawBufferMode, void>)GLLoader.BindingsContext.GetProcAddress("glDrawBuffer");
            _DrawBuffer_fnptr(buf);
        }
        
        private static delegate* unmanaged<ClearBufferMask, void> _Clear_fnptr = &Clear_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Clear buffers to preset values. </summary>
        /// <param name="mask"> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml" /></remarks>
        public static void Clear(ClearBufferMask mask) => _Clear_fnptr(mask);
        [UnmanagedCallersOnly]
        private static void Clear_Lazy(ClearBufferMask mask)
        {
            _Clear_fnptr = (delegate* unmanaged<ClearBufferMask, void>)GLLoader.BindingsContext.GetProcAddress("glClear");
            _Clear_fnptr(mask);
        }
        
        private static delegate* unmanaged<float, float, float, float, void> _ClearColor_fnptr = &ClearColor_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify clear values for the color buffers. </summary>
        /// <param name="red"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="green"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="blue"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="alpha"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml" /></remarks>
        public static void ClearColor(float red, float green, float blue, float alpha) => _ClearColor_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void ClearColor_Lazy(float red, float green, float blue, float alpha)
        {
            _ClearColor_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glClearColor");
            _ClearColor_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<int, void> _ClearStencil_fnptr = &ClearStencil_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the clear value for the stencil buffer. </summary>
        /// <param name="s"> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearStencil.xhtml" /></remarks>
        public static void ClearStencil(int s) => _ClearStencil_fnptr(s);
        [UnmanagedCallersOnly]
        private static void ClearStencil_Lazy(int s)
        {
            _ClearStencil_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glClearStencil");
            _ClearStencil_fnptr(s);
        }
        
        private static delegate* unmanaged<double, void> _ClearDepth_fnptr = &ClearDepth_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the clear value for the depth buffer. </summary>
        /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
        public static void ClearDepth(double depth) => _ClearDepth_fnptr(depth);
        [UnmanagedCallersOnly]
        private static void ClearDepth_Lazy(double depth)
        {
            _ClearDepth_fnptr = (delegate* unmanaged<double, void>)GLLoader.BindingsContext.GetProcAddress("glClearDepth");
            _ClearDepth_fnptr(depth);
        }
        
        private static delegate* unmanaged<uint, void> _StencilMask_fnptr = &StencilMask_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Control the front and back writing of individual bits in the stencil planes. </summary>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMask.xhtml" /></remarks>
        public static void StencilMask(uint mask) => _StencilMask_fnptr(mask);
        [UnmanagedCallersOnly]
        private static void StencilMask_Lazy(uint mask)
        {
            _StencilMask_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glStencilMask");
            _StencilMask_fnptr(mask);
        }
        
        private static delegate* unmanaged<byte, byte, byte, byte, void> _ColorMask_fnptr = &ColorMask_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="red"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="green"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="blue"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="alpha"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml" /></remarks>
        public static void ColorMask(byte red, byte green, byte blue, byte alpha) => _ColorMask_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void ColorMask_Lazy(byte red, byte green, byte blue, byte alpha)
        {
            _ColorMask_fnptr = (delegate* unmanaged<byte, byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glColorMask");
            _ColorMask_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<byte, void> _DepthMask_fnptr = &DepthMask_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Enable or disable writing into the depth buffer. </summary>
        /// <param name="flag"> Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthMask.xhtml" /></remarks>
        public static void DepthMask(byte flag) => _DepthMask_fnptr(flag);
        [UnmanagedCallersOnly]
        private static void DepthMask_Lazy(byte flag)
        {
            _DepthMask_fnptr = (delegate* unmanaged<byte, void>)GLLoader.BindingsContext.GetProcAddress("glDepthMask");
            _DepthMask_fnptr(flag);
        }
        
        private static delegate* unmanaged<EnableCap, void> _Disable_fnptr = &Disable_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Disable(EnableCap cap) => _Disable_fnptr(cap);
        [UnmanagedCallersOnly]
        private static void Disable_Lazy(EnableCap cap)
        {
            _Disable_fnptr = (delegate* unmanaged<EnableCap, void>)GLLoader.BindingsContext.GetProcAddress("glDisable");
            _Disable_fnptr(cap);
        }
        
        private static delegate* unmanaged<EnableCap, void> _Enable_fnptr = &Enable_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Enable(EnableCap cap) => _Enable_fnptr(cap);
        [UnmanagedCallersOnly]
        private static void Enable_Lazy(EnableCap cap)
        {
            _Enable_fnptr = (delegate* unmanaged<EnableCap, void>)GLLoader.BindingsContext.GetProcAddress("glEnable");
            _Enable_fnptr(cap);
        }
        
        private static delegate* unmanaged<void> _Finish_fnptr = &Finish_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Block until all GL execution is complete. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFinish.xhtml" /></remarks>
        public static void Finish() => _Finish_fnptr();
        [UnmanagedCallersOnly]
        private static void Finish_Lazy()
        {
            _Finish_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glFinish");
            _Finish_fnptr();
        }
        
        private static delegate* unmanaged<void> _Flush_fnptr = &Flush_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Force execution of GL commands in finite time. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlush.xhtml" /></remarks>
        public static void Flush() => _Flush_fnptr();
        [UnmanagedCallersOnly]
        private static void Flush_Lazy()
        {
            _Flush_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glFlush");
            _Flush_fnptr();
        }
        
        private static delegate* unmanaged<BlendingFactor, BlendingFactor, void> _BlendFunc_fnptr = &BlendFunc_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify pixel arithmetic. </summary>
        /// <param name="sfactor"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactor"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" /></remarks>
        public static void BlendFunc(BlendingFactor sfactor, BlendingFactor dfactor) => _BlendFunc_fnptr(sfactor, dfactor);
        [UnmanagedCallersOnly]
        private static void BlendFunc_Lazy(BlendingFactor sfactor, BlendingFactor dfactor)
        {
            _BlendFunc_fnptr = (delegate* unmanaged<BlendingFactor, BlendingFactor, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFunc");
            _BlendFunc_fnptr(sfactor, dfactor);
        }
        
        private static delegate* unmanaged<LogicOp, void> _LogicOp_fnptr = &LogicOp_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a logical pixel operation for rendering. </summary>
        /// <param name="opcode"> Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLogicOp.xhtml" /></remarks>
        public static void LogicOp(LogicOp opcode) => _LogicOp_fnptr(opcode);
        [UnmanagedCallersOnly]
        private static void LogicOp_Lazy(LogicOp opcode)
        {
            _LogicOp_fnptr = (delegate* unmanaged<LogicOp, void>)GLLoader.BindingsContext.GetProcAddress("glLogicOp");
            _LogicOp_fnptr(opcode);
        }
        
        private static delegate* unmanaged<StencilFunction, int, uint, void> _StencilFunc_fnptr = &StencilFunc_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set front and back function and reference value for stencil testing. </summary>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml" /></remarks>
        public static void StencilFunc(StencilFunction func, int reference, uint mask) => _StencilFunc_fnptr(func, reference, mask);
        [UnmanagedCallersOnly]
        private static void StencilFunc_Lazy(StencilFunction func, int reference, uint mask)
        {
            _StencilFunc_fnptr = (delegate* unmanaged<StencilFunction, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glStencilFunc");
            _StencilFunc_fnptr(func, reference, mask);
        }
        
        private static delegate* unmanaged<StencilOp, StencilOp, StencilOp, void> _StencilOp_fnptr = &StencilOp_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set front and back stencil test actions. </summary>
        /// <param name="sfail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="dpfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="dppass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOp.xhtml" /></remarks>
        public static void StencilOp(StencilOp fail, StencilOp zfail, StencilOp zpass) => _StencilOp_fnptr(fail, zfail, zpass);
        [UnmanagedCallersOnly]
        private static void StencilOp_Lazy(StencilOp fail, StencilOp zfail, StencilOp zpass)
        {
            _StencilOp_fnptr = (delegate* unmanaged<StencilOp, StencilOp, StencilOp, void>)GLLoader.BindingsContext.GetProcAddress("glStencilOp");
            _StencilOp_fnptr(fail, zfail, zpass);
        }
        
        private static delegate* unmanaged<DepthFunction, void> _DepthFunc_fnptr = &DepthFunc_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the value used for depth buffer comparisons. </summary>
        /// <param name="func"> Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml" /></remarks>
        public static void DepthFunc(DepthFunction func) => _DepthFunc_fnptr(func);
        [UnmanagedCallersOnly]
        private static void DepthFunc_Lazy(DepthFunction func)
        {
            _DepthFunc_fnptr = (delegate* unmanaged<DepthFunction, void>)GLLoader.BindingsContext.GetProcAddress("glDepthFunc");
            _DepthFunc_fnptr(func);
        }
        
        private static delegate* unmanaged<PixelStoreParameter, float, void> _PixelStoref_fnptr = &PixelStoref_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml" /></remarks>
        public static void PixelStoref(PixelStoreParameter pname, float param) => _PixelStoref_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void PixelStoref_Lazy(PixelStoreParameter pname, float param)
        {
            _PixelStoref_fnptr = (delegate* unmanaged<PixelStoreParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glPixelStoref");
            _PixelStoref_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<PixelStoreParameter, int, void> _PixelStorei_fnptr = &PixelStorei_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml" /></remarks>
        public static void PixelStorei(PixelStoreParameter pname, int param) => _PixelStorei_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void PixelStorei_Lazy(PixelStoreParameter pname, int param)
        {
            _PixelStorei_fnptr = (delegate* unmanaged<PixelStoreParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glPixelStorei");
            _PixelStorei_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<ReadBufferMode, void> _ReadBuffer_fnptr = &ReadBuffer_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Select a color buffer source for pixels. </summary>
        /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
        public static void ReadBuffer(ReadBufferMode src) => _ReadBuffer_fnptr(src);
        [UnmanagedCallersOnly]
        private static void ReadBuffer_Lazy(ReadBufferMode src)
        {
            _ReadBuffer_fnptr = (delegate* unmanaged<ReadBufferMode, void>)GLLoader.BindingsContext.GetProcAddress("glReadBuffer");
            _ReadBuffer_fnptr(src);
        }
        
        private static delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, void*, void> _ReadPixels_fnptr = &ReadPixels_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="data">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
        public static void ReadPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, void* pixels) => _ReadPixels_fnptr(x, y, width, height, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void ReadPixels_Lazy(int x, int y, int width, int height, PixelFormat format, PixelType type, void* pixels)
        {
            _ReadPixels_fnptr = (delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glReadPixels");
            _ReadPixels_fnptr(x, y, width, height, format, type, pixels);
        }
        
        private static delegate* unmanaged<GetPName, byte*, void> _GetBooleanv_fnptr = &GetBooleanv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetBooleanv(GetPName pname, byte* data) => _GetBooleanv_fnptr(pname, data);
        [UnmanagedCallersOnly]
        private static void GetBooleanv_Lazy(GetPName pname, byte* data)
        {
            _GetBooleanv_fnptr = (delegate* unmanaged<GetPName, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetBooleanv");
            _GetBooleanv_fnptr(pname, data);
        }
        
        private static delegate* unmanaged<GetPName, double*, void> _GetDoublev_fnptr = &GetDoublev_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetDoublev(GetPName pname, double* data) => _GetDoublev_fnptr(pname, data);
        [UnmanagedCallersOnly]
        private static void GetDoublev_Lazy(GetPName pname, double* data)
        {
            _GetDoublev_fnptr = (delegate* unmanaged<GetPName, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetDoublev");
            _GetDoublev_fnptr(pname, data);
        }
        
        private static delegate* unmanaged<ErrorCode> _GetError_fnptr = &GetError_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return error information. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetError.xhtml" /></remarks>
        public static ErrorCode GetError() => _GetError_fnptr();
        [UnmanagedCallersOnly]
        private static ErrorCode GetError_Lazy()
        {
            _GetError_fnptr = (delegate* unmanaged<ErrorCode>)GLLoader.BindingsContext.GetProcAddress("glGetError");
            return _GetError_fnptr();
        }
        
        private static delegate* unmanaged<GetPName, float*, void> _GetFloatv_fnptr = &GetFloatv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetFloatv(GetPName pname, float* data) => _GetFloatv_fnptr(pname, data);
        [UnmanagedCallersOnly]
        private static void GetFloatv_Lazy(GetPName pname, float* data)
        {
            _GetFloatv_fnptr = (delegate* unmanaged<GetPName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFloatv");
            _GetFloatv_fnptr(pname, data);
        }
        
        private static delegate* unmanaged<GetPName, int*, void> _GetIntegerv_fnptr = &GetIntegerv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetIntegerv(GetPName pname, int* data) => _GetIntegerv_fnptr(pname, data);
        [UnmanagedCallersOnly]
        private static void GetIntegerv_Lazy(GetPName pname, int* data)
        {
            _GetIntegerv_fnptr = (delegate* unmanaged<GetPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetIntegerv");
            _GetIntegerv_fnptr(pname, data);
        }
        
        private static delegate* unmanaged<StringName, byte*> _GetString__fnptr = &GetString__Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml" /></remarks>
        public static byte* GetString_(StringName name) => _GetString__fnptr(name);
        [UnmanagedCallersOnly]
        private static byte* GetString__Lazy(StringName name)
        {
            _GetString__fnptr = (delegate* unmanaged<StringName, byte*>)GLLoader.BindingsContext.GetProcAddress("glGetString");
            return _GetString__fnptr(name);
        }
        
        private static delegate* unmanaged<TextureTarget, int, PixelFormat, PixelType, void*, void> _GetTexImage_fnptr = &GetTexImage_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => _GetTexImage_fnptr(target, level, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void GetTexImage_Lazy(TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels)
        {
            _GetTexImage_fnptr = (delegate* unmanaged<TextureTarget, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexImage");
            _GetTexImage_fnptr(target, level, format, type, pixels);
        }
        
        private static delegate* unmanaged<TextureTarget, GetTextureParameter, float*, void> _GetTexParameterfv_fnptr = &GetTexParameterfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterfv(TextureTarget target, GetTextureParameter pname, float* parameters) => _GetTexParameterfv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexParameterfv_Lazy(TextureTarget target, GetTextureParameter pname, float* parameters)
        {
            _GetTexParameterfv_fnptr = (delegate* unmanaged<TextureTarget, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexParameterfv");
            _GetTexParameterfv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void> _GetTexParameteriv_fnptr = &GetTexParameteriv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameteriv(TextureTarget target, GetTextureParameter pname, int* parameters) => _GetTexParameteriv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexParameteriv_Lazy(TextureTarget target, GetTextureParameter pname, int* parameters)
        {
            _GetTexParameteriv_fnptr = (delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexParameteriv");
            _GetTexParameteriv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, int, GetTextureParameter, float*, void> _GetTexLevelParameterfv_fnptr = &GetTexLevelParameterfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTexLevelParameterfv(TextureTarget target, int level, GetTextureParameter pname, float* parameters) => _GetTexLevelParameterfv_fnptr(target, level, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexLevelParameterfv_Lazy(TextureTarget target, int level, GetTextureParameter pname, float* parameters)
        {
            _GetTexLevelParameterfv_fnptr = (delegate* unmanaged<TextureTarget, int, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexLevelParameterfv");
            _GetTexLevelParameterfv_fnptr(target, level, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, int, GetTextureParameter, int*, void> _GetTexLevelParameteriv_fnptr = &GetTexLevelParameteriv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTexLevelParameteriv(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => _GetTexLevelParameteriv_fnptr(target, level, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexLevelParameteriv_Lazy(TextureTarget target, int level, GetTextureParameter pname, int* parameters)
        {
            _GetTexLevelParameteriv_fnptr = (delegate* unmanaged<TextureTarget, int, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexLevelParameteriv");
            _GetTexLevelParameteriv_fnptr(target, level, pname, parameters);
        }
        
        private static delegate* unmanaged<EnableCap, byte> _IsEnabled_fnptr = &IsEnabled_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Test whether a capability is enabled. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml" /></remarks>
        public static byte IsEnabled(EnableCap cap) => _IsEnabled_fnptr(cap);
        [UnmanagedCallersOnly]
        private static byte IsEnabled_Lazy(EnableCap cap)
        {
            _IsEnabled_fnptr = (delegate* unmanaged<EnableCap, byte>)GLLoader.BindingsContext.GetProcAddress("glIsEnabled");
            return _IsEnabled_fnptr(cap);
        }
        
        private static delegate* unmanaged<double, double, void> _DepthRange_fnptr = &DepthRange_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
        public static void DepthRange(double n, double f) => _DepthRange_fnptr(n, f);
        [UnmanagedCallersOnly]
        private static void DepthRange_Lazy(double n, double f)
        {
            _DepthRange_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRange");
            _DepthRange_fnptr(n, f);
        }
        
        private static delegate* unmanaged<int, int, int, int, void> _Viewport_fnptr = &Viewport_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the viewport. </summary>
        /// <param name="x"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="width"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml" /></remarks>
        public static void Viewport(int x, int y, int width, int height) => _Viewport_fnptr(x, y, width, height);
        [UnmanagedCallersOnly]
        private static void Viewport_Lazy(int x, int y, int width, int height)
        {
            _Viewport_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glViewport");
            _Viewport_fnptr(x, y, width, height);
        }
        
        private static delegate* unmanaged<uint, ListMode, void> _NewList_fnptr = &NewList_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Create or replace a display list. </summary>
        /// <param name="list"> Specifies the display-list name. </param>
        /// <param name="mode"> Specifies the compilation mode, which can be GL_COMPILE or GL_COMPILE_AND_EXECUTE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNewList.xml" /></remarks>
        public static void NewList(uint list, ListMode mode) => _NewList_fnptr(list, mode);
        [UnmanagedCallersOnly]
        private static void NewList_Lazy(uint list, ListMode mode)
        {
            _NewList_fnptr = (delegate* unmanaged<uint, ListMode, void>)GLLoader.BindingsContext.GetProcAddress("glNewList");
            _NewList_fnptr(list, mode);
        }
        
        private static delegate* unmanaged<void> _EndList_fnptr = &EndList_Lazy;
        public static void EndList() => _EndList_fnptr();
        [UnmanagedCallersOnly]
        private static void EndList_Lazy()
        {
            _EndList_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndList");
            _EndList_fnptr();
        }
        
        private static delegate* unmanaged<uint, void> _CallList_fnptr = &CallList_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Execute a display list. </summary>
        /// <param name="list"> Specifies the integer name of the display list to be executed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCallList.xml" /></remarks>
        public static void CallList(uint list) => _CallList_fnptr(list);
        [UnmanagedCallersOnly]
        private static void CallList_Lazy(uint list)
        {
            _CallList_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glCallList");
            _CallList_fnptr(list);
        }
        
        private static delegate* unmanaged<int, ListNameType, void*, void> _CallLists_fnptr = &CallLists_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Execute a list of display lists. </summary>
        /// <param name="n"> Specifies the number of display lists to be executed. </param>
        /// <param name="type"> Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted. </param>
        /// <param name="lists"> Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCallLists.xml" /></remarks>
        public static void CallLists(int n, ListNameType type, void* lists) => _CallLists_fnptr(n, type, lists);
        [UnmanagedCallersOnly]
        private static void CallLists_Lazy(int n, ListNameType type, void* lists)
        {
            _CallLists_fnptr = (delegate* unmanaged<int, ListNameType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCallLists");
            _CallLists_fnptr(n, type, lists);
        }
        
        private static delegate* unmanaged<DisplayListHandle, int, void> _DeleteLists_fnptr = &DeleteLists_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Delete a contiguous group of display lists. </summary>
        /// <param name="list"> Specifies the integer name of the first display list to delete. </param>
        /// <param name="range"> Specifies the number of display lists to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDeleteLists.xml" /></remarks>
        public static void DeleteLists(DisplayListHandle list, int range) => _DeleteLists_fnptr(list, range);
        [UnmanagedCallersOnly]
        private static void DeleteLists_Lazy(DisplayListHandle list, int range)
        {
            _DeleteLists_fnptr = (delegate* unmanaged<DisplayListHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteLists");
            _DeleteLists_fnptr(list, range);
        }
        
        private static delegate* unmanaged<int, int> _GenLists_fnptr = &GenLists_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Generate a contiguous set of empty display lists. </summary>
        /// <param name="range"> Specifies the number of contiguous empty display lists to be generated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGenLists.xml" /></remarks>
        public static DisplayListHandle GenLists(int range) => (DisplayListHandle) _GenLists_fnptr(range);
        [UnmanagedCallersOnly]
        private static int GenLists_Lazy(int range)
        {
            _GenLists_fnptr = (delegate* unmanaged<int, int>)GLLoader.BindingsContext.GetProcAddress("glGenLists");
            return _GenLists_fnptr(range);
        }
        
        private static delegate* unmanaged<uint, void> _ListBase_fnptr = &ListBase_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the display-list base for glCallLists. </summary>
        /// <param name="@base"> Specifies an integer offset that will be added to glCallLists offsets to generate display-list names. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glListBase.xml" /></remarks>
        public static void ListBase(uint @base) => _ListBase_fnptr(@base);
        [UnmanagedCallersOnly]
        private static void ListBase_Lazy(uint @base)
        {
            _ListBase_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glListBase");
            _ListBase_fnptr(@base);
        }
        
        private static delegate* unmanaged<PrimitiveType, void> _Begin_fnptr = &Begin_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Delimit the vertices of a primitive or a group of like primitives. </summary>
        /// <param name="mode"> Specifies the primitive or primitives that will be created from vertices presented between glBegin and the subsequent glEnd. Ten symbolic constants are accepted: GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml" /></remarks>
        public static void Begin(PrimitiveType mode) => _Begin_fnptr(mode);
        [UnmanagedCallersOnly]
        private static void Begin_Lazy(PrimitiveType mode)
        {
            _Begin_fnptr = (delegate* unmanaged<PrimitiveType, void>)GLLoader.BindingsContext.GetProcAddress("glBegin");
            _Begin_fnptr(mode);
        }
        
        private static delegate* unmanaged<int, int, float, float, float, float, byte*, void> _Bitmap_fnptr = &Bitmap_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Draw a bitmap. </summary>
        /// <param name="width"> Specify the pixel width and height of the bitmap image. </param>
        /// <param name="height"> Specify the pixel width and height of the bitmap image. </param>
        /// <param name="xorig"> Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes. </param>
        /// <param name="yorig"> Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes. </param>
        /// <param name="xmove"> Specify the x and y offsets to be added to the current raster position after the bitmap is drawn. </param>
        /// <param name="ymove"> Specify the x and y offsets to be added to the current raster position after the bitmap is drawn. </param>
        /// <param name="bitmap"> Specifies the address of the bitmap image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBitmap.xml" /></remarks>
        public static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte* bitmap) => _Bitmap_fnptr(width, height, xorig, yorig, xmove, ymove, bitmap);
        [UnmanagedCallersOnly]
        private static void Bitmap_Lazy(int width, int height, float xorig, float yorig, float xmove, float ymove, byte* bitmap)
        {
            _Bitmap_fnptr = (delegate* unmanaged<int, int, float, float, float, float, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glBitmap");
            _Bitmap_fnptr(width, height, xorig, yorig, xmove, ymove, bitmap);
        }
        
        private static delegate* unmanaged<sbyte, sbyte, sbyte, void> _Color3b_fnptr = &Color3b_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3b(sbyte red, sbyte green, sbyte blue) => _Color3b_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void Color3b_Lazy(sbyte red, sbyte green, sbyte blue)
        {
            _Color3b_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glColor3b");
            _Color3b_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<sbyte*, void> _Color3bv_fnptr = &Color3bv_Lazy;
        public static void Color3bv(sbyte* v) => _Color3bv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color3bv_Lazy(sbyte* v)
        {
            _Color3bv_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3bv");
            _Color3bv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, void> _Color3d_fnptr = &Color3d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3d(double red, double green, double blue) => _Color3d_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void Color3d_Lazy(double red, double green, double blue)
        {
            _Color3d_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glColor3d");
            _Color3d_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<double*, void> _Color3dv_fnptr = &Color3dv_Lazy;
        public static void Color3dv(double* v) => _Color3dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color3dv_Lazy(double* v)
        {
            _Color3dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3dv");
            _Color3dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, void> _Color3f_fnptr = &Color3f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3f(float red, float green, float blue) => _Color3f_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void Color3f_Lazy(float red, float green, float blue)
        {
            _Color3f_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glColor3f");
            _Color3f_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<float*, void> _Color3fv_fnptr = &Color3fv_Lazy;
        public static void Color3fv(float* v) => _Color3fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color3fv_Lazy(float* v)
        {
            _Color3fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3fv");
            _Color3fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, void> _Color3i_fnptr = &Color3i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3i(int red, int green, int blue) => _Color3i_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void Color3i_Lazy(int red, int green, int blue)
        {
            _Color3i_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glColor3i");
            _Color3i_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<int*, void> _Color3iv_fnptr = &Color3iv_Lazy;
        public static void Color3iv(int* v) => _Color3iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color3iv_Lazy(int* v)
        {
            _Color3iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3iv");
            _Color3iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, void> _Color3s_fnptr = &Color3s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3s(short red, short green, short blue) => _Color3s_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void Color3s_Lazy(short red, short green, short blue)
        {
            _Color3s_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glColor3s");
            _Color3s_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<short*, void> _Color3sv_fnptr = &Color3sv_Lazy;
        public static void Color3sv(short* v) => _Color3sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color3sv_Lazy(short* v)
        {
            _Color3sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3sv");
            _Color3sv_fnptr(v);
        }
        
        private static delegate* unmanaged<byte, byte, byte, void> _Color3ub_fnptr = &Color3ub_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3ub(byte red, byte green, byte blue) => _Color3ub_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void Color3ub_Lazy(byte red, byte green, byte blue)
        {
            _Color3ub_fnptr = (delegate* unmanaged<byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glColor3ub");
            _Color3ub_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<byte*, void> _Color3ubv_fnptr = &Color3ubv_Lazy;
        public static void Color3ubv(byte* v) => _Color3ubv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color3ubv_Lazy(byte* v)
        {
            _Color3ubv_fnptr = (delegate* unmanaged<byte*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3ubv");
            _Color3ubv_fnptr(v);
        }
        
        private static delegate* unmanaged<uint, uint, uint, void> _Color3ui_fnptr = &Color3ui_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3ui(uint red, uint green, uint blue) => _Color3ui_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void Color3ui_Lazy(uint red, uint green, uint blue)
        {
            _Color3ui_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glColor3ui");
            _Color3ui_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<uint*, void> _Color3uiv_fnptr = &Color3uiv_Lazy;
        public static void Color3uiv(uint* v) => _Color3uiv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color3uiv_Lazy(uint* v)
        {
            _Color3uiv_fnptr = (delegate* unmanaged<uint*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3uiv");
            _Color3uiv_fnptr(v);
        }
        
        private static delegate* unmanaged<ushort, ushort, ushort, void> _Color3us_fnptr = &Color3us_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3us(ushort red, ushort green, ushort blue) => _Color3us_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void Color3us_Lazy(ushort red, ushort green, ushort blue)
        {
            _Color3us_fnptr = (delegate* unmanaged<ushort, ushort, ushort, void>)GLLoader.BindingsContext.GetProcAddress("glColor3us");
            _Color3us_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<ushort*, void> _Color3usv_fnptr = &Color3usv_Lazy;
        public static void Color3usv(ushort* v) => _Color3usv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color3usv_Lazy(ushort* v)
        {
            _Color3usv_fnptr = (delegate* unmanaged<ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3usv");
            _Color3usv_fnptr(v);
        }
        
        private static delegate* unmanaged<sbyte, sbyte, sbyte, sbyte, void> _Color4b_fnptr = &Color4b_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4b(sbyte red, sbyte green, sbyte blue, sbyte alpha) => _Color4b_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void Color4b_Lazy(sbyte red, sbyte green, sbyte blue, sbyte alpha)
        {
            _Color4b_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glColor4b");
            _Color4b_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<sbyte*, void> _Color4bv_fnptr = &Color4bv_Lazy;
        public static void Color4bv(sbyte* v) => _Color4bv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color4bv_Lazy(sbyte* v)
        {
            _Color4bv_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4bv");
            _Color4bv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, double, void> _Color4d_fnptr = &Color4d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4d(double red, double green, double blue, double alpha) => _Color4d_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void Color4d_Lazy(double red, double green, double blue, double alpha)
        {
            _Color4d_fnptr = (delegate* unmanaged<double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glColor4d");
            _Color4d_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<double*, void> _Color4dv_fnptr = &Color4dv_Lazy;
        public static void Color4dv(double* v) => _Color4dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color4dv_Lazy(double* v)
        {
            _Color4dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4dv");
            _Color4dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, float, void> _Color4f_fnptr = &Color4f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4f(float red, float green, float blue, float alpha) => _Color4f_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void Color4f_Lazy(float red, float green, float blue, float alpha)
        {
            _Color4f_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glColor4f");
            _Color4f_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<float*, void> _Color4fv_fnptr = &Color4fv_Lazy;
        public static void Color4fv(float* v) => _Color4fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color4fv_Lazy(float* v)
        {
            _Color4fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4fv");
            _Color4fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, int, void> _Color4i_fnptr = &Color4i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4i(int red, int green, int blue, int alpha) => _Color4i_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void Color4i_Lazy(int red, int green, int blue, int alpha)
        {
            _Color4i_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glColor4i");
            _Color4i_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<int*, void> _Color4iv_fnptr = &Color4iv_Lazy;
        public static void Color4iv(int* v) => _Color4iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color4iv_Lazy(int* v)
        {
            _Color4iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4iv");
            _Color4iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, short, void> _Color4s_fnptr = &Color4s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4s(short red, short green, short blue, short alpha) => _Color4s_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void Color4s_Lazy(short red, short green, short blue, short alpha)
        {
            _Color4s_fnptr = (delegate* unmanaged<short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glColor4s");
            _Color4s_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<short*, void> _Color4sv_fnptr = &Color4sv_Lazy;
        public static void Color4sv(short* v) => _Color4sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color4sv_Lazy(short* v)
        {
            _Color4sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4sv");
            _Color4sv_fnptr(v);
        }
        
        private static delegate* unmanaged<byte, byte, byte, byte, void> _Color4ub_fnptr = &Color4ub_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4ub(byte red, byte green, byte blue, byte alpha) => _Color4ub_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void Color4ub_Lazy(byte red, byte green, byte blue, byte alpha)
        {
            _Color4ub_fnptr = (delegate* unmanaged<byte, byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glColor4ub");
            _Color4ub_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<byte*, void> _Color4ubv_fnptr = &Color4ubv_Lazy;
        public static void Color4ubv(byte* v) => _Color4ubv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color4ubv_Lazy(byte* v)
        {
            _Color4ubv_fnptr = (delegate* unmanaged<byte*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4ubv");
            _Color4ubv_fnptr(v);
        }
        
        private static delegate* unmanaged<uint, uint, uint, uint, void> _Color4ui_fnptr = &Color4ui_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4ui(uint red, uint green, uint blue, uint alpha) => _Color4ui_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void Color4ui_Lazy(uint red, uint green, uint blue, uint alpha)
        {
            _Color4ui_fnptr = (delegate* unmanaged<uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glColor4ui");
            _Color4ui_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<uint*, void> _Color4uiv_fnptr = &Color4uiv_Lazy;
        public static void Color4uiv(uint* v) => _Color4uiv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color4uiv_Lazy(uint* v)
        {
            _Color4uiv_fnptr = (delegate* unmanaged<uint*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4uiv");
            _Color4uiv_fnptr(v);
        }
        
        private static delegate* unmanaged<ushort, ushort, ushort, ushort, void> _Color4us_fnptr = &Color4us_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4us(ushort red, ushort green, ushort blue, ushort alpha) => _Color4us_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void Color4us_Lazy(ushort red, ushort green, ushort blue, ushort alpha)
        {
            _Color4us_fnptr = (delegate* unmanaged<ushort, ushort, ushort, ushort, void>)GLLoader.BindingsContext.GetProcAddress("glColor4us");
            _Color4us_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<ushort*, void> _Color4usv_fnptr = &Color4usv_Lazy;
        public static void Color4usv(ushort* v) => _Color4usv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Color4usv_Lazy(ushort* v)
        {
            _Color4usv_fnptr = (delegate* unmanaged<ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4usv");
            _Color4usv_fnptr(v);
        }
        
        private static delegate* unmanaged<byte, void> _EdgeFlag_fnptr = &EdgeFlag_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Flag edges as either boundary or nonboundary. </summary>
        /// <param name="flag"> Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEdgeFlag.xml" /></remarks>
        public static void EdgeFlag(byte flag) => _EdgeFlag_fnptr(flag);
        [UnmanagedCallersOnly]
        private static void EdgeFlag_Lazy(byte flag)
        {
            _EdgeFlag_fnptr = (delegate* unmanaged<byte, void>)GLLoader.BindingsContext.GetProcAddress("glEdgeFlag");
            _EdgeFlag_fnptr(flag);
        }
        
        private static delegate* unmanaged<byte*, void> _EdgeFlagv_fnptr = &EdgeFlagv_Lazy;
        public static void EdgeFlagv(byte* flag) => _EdgeFlagv_fnptr(flag);
        [UnmanagedCallersOnly]
        private static void EdgeFlagv_Lazy(byte* flag)
        {
            _EdgeFlagv_fnptr = (delegate* unmanaged<byte*, void>)GLLoader.BindingsContext.GetProcAddress("glEdgeFlagv");
            _EdgeFlagv_fnptr(flag);
        }
        
        private static delegate* unmanaged<void> _End_fnptr = &End_Lazy;
        public static void End() => _End_fnptr();
        [UnmanagedCallersOnly]
        private static void End_Lazy()
        {
            _End_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEnd");
            _End_fnptr();
        }
        
        private static delegate* unmanaged<double, void> _Indexd_fnptr = &Indexd_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexd(double c) => _Indexd_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexd_Lazy(double c)
        {
            _Indexd_fnptr = (delegate* unmanaged<double, void>)GLLoader.BindingsContext.GetProcAddress("glIndexd");
            _Indexd_fnptr(c);
        }
        
        private static delegate* unmanaged<double*, void> _Indexdv_fnptr = &Indexdv_Lazy;
        public static void Indexdv(double* c) => _Indexdv_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexdv_Lazy(double* c)
        {
            _Indexdv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glIndexdv");
            _Indexdv_fnptr(c);
        }
        
        private static delegate* unmanaged<float, void> _Indexf_fnptr = &Indexf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexf(float c) => _Indexf_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexf_Lazy(float c)
        {
            _Indexf_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glIndexf");
            _Indexf_fnptr(c);
        }
        
        private static delegate* unmanaged<float*, void> _Indexfv_fnptr = &Indexfv_Lazy;
        public static void Indexfv(float* c) => _Indexfv_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexfv_Lazy(float* c)
        {
            _Indexfv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glIndexfv");
            _Indexfv_fnptr(c);
        }
        
        private static delegate* unmanaged<int, void> _Indexi_fnptr = &Indexi_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexi(int c) => _Indexi_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexi_Lazy(int c)
        {
            _Indexi_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glIndexi");
            _Indexi_fnptr(c);
        }
        
        private static delegate* unmanaged<int*, void> _Indexiv_fnptr = &Indexiv_Lazy;
        public static void Indexiv(int* c) => _Indexiv_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexiv_Lazy(int* c)
        {
            _Indexiv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glIndexiv");
            _Indexiv_fnptr(c);
        }
        
        private static delegate* unmanaged<short, void> _Indexs_fnptr = &Indexs_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexs(short c) => _Indexs_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexs_Lazy(short c)
        {
            _Indexs_fnptr = (delegate* unmanaged<short, void>)GLLoader.BindingsContext.GetProcAddress("glIndexs");
            _Indexs_fnptr(c);
        }
        
        private static delegate* unmanaged<short*, void> _Indexsv_fnptr = &Indexsv_Lazy;
        public static void Indexsv(short* c) => _Indexsv_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexsv_Lazy(short* c)
        {
            _Indexsv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glIndexsv");
            _Indexsv_fnptr(c);
        }
        
        private static delegate* unmanaged<sbyte, sbyte, sbyte, void> _Normal3b_fnptr = &Normal3b_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3b(sbyte nx, sbyte ny, sbyte nz) => _Normal3b_fnptr(nx, ny, nz);
        [UnmanagedCallersOnly]
        private static void Normal3b_Lazy(sbyte nx, sbyte ny, sbyte nz)
        {
            _Normal3b_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3b");
            _Normal3b_fnptr(nx, ny, nz);
        }
        
        private static delegate* unmanaged<sbyte*, void> _Normal3bv_fnptr = &Normal3bv_Lazy;
        public static void Normal3bv(sbyte* v) => _Normal3bv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Normal3bv_Lazy(sbyte* v)
        {
            _Normal3bv_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3bv");
            _Normal3bv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, void> _Normal3d_fnptr = &Normal3d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3d(double nx, double ny, double nz) => _Normal3d_fnptr(nx, ny, nz);
        [UnmanagedCallersOnly]
        private static void Normal3d_Lazy(double nx, double ny, double nz)
        {
            _Normal3d_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3d");
            _Normal3d_fnptr(nx, ny, nz);
        }
        
        private static delegate* unmanaged<double*, void> _Normal3dv_fnptr = &Normal3dv_Lazy;
        public static void Normal3dv(double* v) => _Normal3dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Normal3dv_Lazy(double* v)
        {
            _Normal3dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3dv");
            _Normal3dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, void> _Normal3f_fnptr = &Normal3f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3f(float nx, float ny, float nz) => _Normal3f_fnptr(nx, ny, nz);
        [UnmanagedCallersOnly]
        private static void Normal3f_Lazy(float nx, float ny, float nz)
        {
            _Normal3f_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3f");
            _Normal3f_fnptr(nx, ny, nz);
        }
        
        private static delegate* unmanaged<float*, void> _Normal3fv_fnptr = &Normal3fv_Lazy;
        public static void Normal3fv(float* v) => _Normal3fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Normal3fv_Lazy(float* v)
        {
            _Normal3fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3fv");
            _Normal3fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, void> _Normal3i_fnptr = &Normal3i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3i(int nx, int ny, int nz) => _Normal3i_fnptr(nx, ny, nz);
        [UnmanagedCallersOnly]
        private static void Normal3i_Lazy(int nx, int ny, int nz)
        {
            _Normal3i_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3i");
            _Normal3i_fnptr(nx, ny, nz);
        }
        
        private static delegate* unmanaged<int*, void> _Normal3iv_fnptr = &Normal3iv_Lazy;
        public static void Normal3iv(int* v) => _Normal3iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Normal3iv_Lazy(int* v)
        {
            _Normal3iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3iv");
            _Normal3iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, void> _Normal3s_fnptr = &Normal3s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3s(short nx, short ny, short nz) => _Normal3s_fnptr(nx, ny, nz);
        [UnmanagedCallersOnly]
        private static void Normal3s_Lazy(short nx, short ny, short nz)
        {
            _Normal3s_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3s");
            _Normal3s_fnptr(nx, ny, nz);
        }
        
        private static delegate* unmanaged<short*, void> _Normal3sv_fnptr = &Normal3sv_Lazy;
        public static void Normal3sv(short* v) => _Normal3sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Normal3sv_Lazy(short* v)
        {
            _Normal3sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3sv");
            _Normal3sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, void> _RasterPos2d_fnptr = &RasterPos2d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2d(double x, double y) => _RasterPos2d_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void RasterPos2d_Lazy(double x, double y)
        {
            _RasterPos2d_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2d");
            _RasterPos2d_fnptr(x, y);
        }
        
        private static delegate* unmanaged<double*, void> _RasterPos2dv_fnptr = &RasterPos2dv_Lazy;
        public static void RasterPos2dv(double* v) => _RasterPos2dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos2dv_Lazy(double* v)
        {
            _RasterPos2dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2dv");
            _RasterPos2dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, void> _RasterPos2f_fnptr = &RasterPos2f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2f(float x, float y) => _RasterPos2f_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void RasterPos2f_Lazy(float x, float y)
        {
            _RasterPos2f_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2f");
            _RasterPos2f_fnptr(x, y);
        }
        
        private static delegate* unmanaged<float*, void> _RasterPos2fv_fnptr = &RasterPos2fv_Lazy;
        public static void RasterPos2fv(float* v) => _RasterPos2fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos2fv_Lazy(float* v)
        {
            _RasterPos2fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2fv");
            _RasterPos2fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, void> _RasterPos2i_fnptr = &RasterPos2i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2i(int x, int y) => _RasterPos2i_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void RasterPos2i_Lazy(int x, int y)
        {
            _RasterPos2i_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2i");
            _RasterPos2i_fnptr(x, y);
        }
        
        private static delegate* unmanaged<int*, void> _RasterPos2iv_fnptr = &RasterPos2iv_Lazy;
        public static void RasterPos2iv(int* v) => _RasterPos2iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos2iv_Lazy(int* v)
        {
            _RasterPos2iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2iv");
            _RasterPos2iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, void> _RasterPos2s_fnptr = &RasterPos2s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2s(short x, short y) => _RasterPos2s_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void RasterPos2s_Lazy(short x, short y)
        {
            _RasterPos2s_fnptr = (delegate* unmanaged<short, short, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2s");
            _RasterPos2s_fnptr(x, y);
        }
        
        private static delegate* unmanaged<short*, void> _RasterPos2sv_fnptr = &RasterPos2sv_Lazy;
        public static void RasterPos2sv(short* v) => _RasterPos2sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos2sv_Lazy(short* v)
        {
            _RasterPos2sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2sv");
            _RasterPos2sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, void> _RasterPos3d_fnptr = &RasterPos3d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3d(double x, double y, double z) => _RasterPos3d_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void RasterPos3d_Lazy(double x, double y, double z)
        {
            _RasterPos3d_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3d");
            _RasterPos3d_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<double*, void> _RasterPos3dv_fnptr = &RasterPos3dv_Lazy;
        public static void RasterPos3dv(double* v) => _RasterPos3dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos3dv_Lazy(double* v)
        {
            _RasterPos3dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3dv");
            _RasterPos3dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, void> _RasterPos3f_fnptr = &RasterPos3f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3f(float x, float y, float z) => _RasterPos3f_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void RasterPos3f_Lazy(float x, float y, float z)
        {
            _RasterPos3f_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3f");
            _RasterPos3f_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<float*, void> _RasterPos3fv_fnptr = &RasterPos3fv_Lazy;
        public static void RasterPos3fv(float* v) => _RasterPos3fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos3fv_Lazy(float* v)
        {
            _RasterPos3fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3fv");
            _RasterPos3fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, void> _RasterPos3i_fnptr = &RasterPos3i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3i(int x, int y, int z) => _RasterPos3i_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void RasterPos3i_Lazy(int x, int y, int z)
        {
            _RasterPos3i_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3i");
            _RasterPos3i_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<int*, void> _RasterPos3iv_fnptr = &RasterPos3iv_Lazy;
        public static void RasterPos3iv(int* v) => _RasterPos3iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos3iv_Lazy(int* v)
        {
            _RasterPos3iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3iv");
            _RasterPos3iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, void> _RasterPos3s_fnptr = &RasterPos3s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3s(short x, short y, short z) => _RasterPos3s_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void RasterPos3s_Lazy(short x, short y, short z)
        {
            _RasterPos3s_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3s");
            _RasterPos3s_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<short*, void> _RasterPos3sv_fnptr = &RasterPos3sv_Lazy;
        public static void RasterPos3sv(short* v) => _RasterPos3sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos3sv_Lazy(short* v)
        {
            _RasterPos3sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3sv");
            _RasterPos3sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, double, void> _RasterPos4d_fnptr = &RasterPos4d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4d(double x, double y, double z, double w) => _RasterPos4d_fnptr(x, y, z, w);
        [UnmanagedCallersOnly]
        private static void RasterPos4d_Lazy(double x, double y, double z, double w)
        {
            _RasterPos4d_fnptr = (delegate* unmanaged<double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4d");
            _RasterPos4d_fnptr(x, y, z, w);
        }
        
        private static delegate* unmanaged<double*, void> _RasterPos4dv_fnptr = &RasterPos4dv_Lazy;
        public static void RasterPos4dv(double* v) => _RasterPos4dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos4dv_Lazy(double* v)
        {
            _RasterPos4dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4dv");
            _RasterPos4dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, float, void> _RasterPos4f_fnptr = &RasterPos4f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4f(float x, float y, float z, float w) => _RasterPos4f_fnptr(x, y, z, w);
        [UnmanagedCallersOnly]
        private static void RasterPos4f_Lazy(float x, float y, float z, float w)
        {
            _RasterPos4f_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4f");
            _RasterPos4f_fnptr(x, y, z, w);
        }
        
        private static delegate* unmanaged<float*, void> _RasterPos4fv_fnptr = &RasterPos4fv_Lazy;
        public static void RasterPos4fv(float* v) => _RasterPos4fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos4fv_Lazy(float* v)
        {
            _RasterPos4fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4fv");
            _RasterPos4fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, int, void> _RasterPos4i_fnptr = &RasterPos4i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4i(int x, int y, int z, int w) => _RasterPos4i_fnptr(x, y, z, w);
        [UnmanagedCallersOnly]
        private static void RasterPos4i_Lazy(int x, int y, int z, int w)
        {
            _RasterPos4i_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4i");
            _RasterPos4i_fnptr(x, y, z, w);
        }
        
        private static delegate* unmanaged<int*, void> _RasterPos4iv_fnptr = &RasterPos4iv_Lazy;
        public static void RasterPos4iv(int* v) => _RasterPos4iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos4iv_Lazy(int* v)
        {
            _RasterPos4iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4iv");
            _RasterPos4iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, short, void> _RasterPos4s_fnptr = &RasterPos4s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4s(short x, short y, short z, short w) => _RasterPos4s_fnptr(x, y, z, w);
        [UnmanagedCallersOnly]
        private static void RasterPos4s_Lazy(short x, short y, short z, short w)
        {
            _RasterPos4s_fnptr = (delegate* unmanaged<short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4s");
            _RasterPos4s_fnptr(x, y, z, w);
        }
        
        private static delegate* unmanaged<short*, void> _RasterPos4sv_fnptr = &RasterPos4sv_Lazy;
        public static void RasterPos4sv(short* v) => _RasterPos4sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void RasterPos4sv_Lazy(short* v)
        {
            _RasterPos4sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4sv");
            _RasterPos4sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, double, void> _Rectd_fnptr = &Rectd_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Rectd(double x1, double y1, double x2, double y2) => _Rectd_fnptr(x1, y1, x2, y2);
        [UnmanagedCallersOnly]
        private static void Rectd_Lazy(double x1, double y1, double x2, double y2)
        {
            _Rectd_fnptr = (delegate* unmanaged<double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glRectd");
            _Rectd_fnptr(x1, y1, x2, y2);
        }
        
        private static delegate* unmanaged<double*, double*, void> _Rectdv_fnptr = &Rectdv_Lazy;
        public static void Rectdv(double* v1, double* v2) => _Rectdv_fnptr(v1, v2);
        [UnmanagedCallersOnly]
        private static void Rectdv_Lazy(double* v1, double* v2)
        {
            _Rectdv_fnptr = (delegate* unmanaged<double*, double*, void>)GLLoader.BindingsContext.GetProcAddress("glRectdv");
            _Rectdv_fnptr(v1, v2);
        }
        
        private static delegate* unmanaged<float, float, float, float, void> _Rectf_fnptr = &Rectf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Rectf(float x1, float y1, float x2, float y2) => _Rectf_fnptr(x1, y1, x2, y2);
        [UnmanagedCallersOnly]
        private static void Rectf_Lazy(float x1, float y1, float x2, float y2)
        {
            _Rectf_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glRectf");
            _Rectf_fnptr(x1, y1, x2, y2);
        }
        
        private static delegate* unmanaged<float*, float*, void> _Rectfv_fnptr = &Rectfv_Lazy;
        public static void Rectfv(float* v1, float* v2) => _Rectfv_fnptr(v1, v2);
        [UnmanagedCallersOnly]
        private static void Rectfv_Lazy(float* v1, float* v2)
        {
            _Rectfv_fnptr = (delegate* unmanaged<float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glRectfv");
            _Rectfv_fnptr(v1, v2);
        }
        
        private static delegate* unmanaged<int, int, int, int, void> _Recti_fnptr = &Recti_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Recti(int x1, int y1, int x2, int y2) => _Recti_fnptr(x1, y1, x2, y2);
        [UnmanagedCallersOnly]
        private static void Recti_Lazy(int x1, int y1, int x2, int y2)
        {
            _Recti_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRecti");
            _Recti_fnptr(x1, y1, x2, y2);
        }
        
        private static delegate* unmanaged<int*, int*, void> _Rectiv_fnptr = &Rectiv_Lazy;
        public static void Rectiv(int* v1, int* v2) => _Rectiv_fnptr(v1, v2);
        [UnmanagedCallersOnly]
        private static void Rectiv_Lazy(int* v1, int* v2)
        {
            _Rectiv_fnptr = (delegate* unmanaged<int*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glRectiv");
            _Rectiv_fnptr(v1, v2);
        }
        
        private static delegate* unmanaged<short, short, short, short, void> _Rects_fnptr = &Rects_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Rects(short x1, short y1, short x2, short y2) => _Rects_fnptr(x1, y1, x2, y2);
        [UnmanagedCallersOnly]
        private static void Rects_Lazy(short x1, short y1, short x2, short y2)
        {
            _Rects_fnptr = (delegate* unmanaged<short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glRects");
            _Rects_fnptr(x1, y1, x2, y2);
        }
        
        private static delegate* unmanaged<short*, short*, void> _Rectsv_fnptr = &Rectsv_Lazy;
        public static void Rectsv(short* v1, short* v2) => _Rectsv_fnptr(v1, v2);
        [UnmanagedCallersOnly]
        private static void Rectsv_Lazy(short* v1, short* v2)
        {
            _Rectsv_fnptr = (delegate* unmanaged<short*, short*, void>)GLLoader.BindingsContext.GetProcAddress("glRectsv");
            _Rectsv_fnptr(v1, v2);
        }
        
        private static delegate* unmanaged<double, void> _TexCoord1d_fnptr = &TexCoord1d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1d(double s) => _TexCoord1d_fnptr(s);
        [UnmanagedCallersOnly]
        private static void TexCoord1d_Lazy(double s)
        {
            _TexCoord1d_fnptr = (delegate* unmanaged<double, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1d");
            _TexCoord1d_fnptr(s);
        }
        
        private static delegate* unmanaged<double*, void> _TexCoord1dv_fnptr = &TexCoord1dv_Lazy;
        public static void TexCoord1dv(double* v) => _TexCoord1dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord1dv_Lazy(double* v)
        {
            _TexCoord1dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1dv");
            _TexCoord1dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, void> _TexCoord1f_fnptr = &TexCoord1f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1f(float s) => _TexCoord1f_fnptr(s);
        [UnmanagedCallersOnly]
        private static void TexCoord1f_Lazy(float s)
        {
            _TexCoord1f_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1f");
            _TexCoord1f_fnptr(s);
        }
        
        private static delegate* unmanaged<float*, void> _TexCoord1fv_fnptr = &TexCoord1fv_Lazy;
        public static void TexCoord1fv(float* v) => _TexCoord1fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord1fv_Lazy(float* v)
        {
            _TexCoord1fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1fv");
            _TexCoord1fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, void> _TexCoord1i_fnptr = &TexCoord1i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1i(int s) => _TexCoord1i_fnptr(s);
        [UnmanagedCallersOnly]
        private static void TexCoord1i_Lazy(int s)
        {
            _TexCoord1i_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1i");
            _TexCoord1i_fnptr(s);
        }
        
        private static delegate* unmanaged<int*, void> _TexCoord1iv_fnptr = &TexCoord1iv_Lazy;
        public static void TexCoord1iv(int* v) => _TexCoord1iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord1iv_Lazy(int* v)
        {
            _TexCoord1iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1iv");
            _TexCoord1iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, void> _TexCoord1s_fnptr = &TexCoord1s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1s(short s) => _TexCoord1s_fnptr(s);
        [UnmanagedCallersOnly]
        private static void TexCoord1s_Lazy(short s)
        {
            _TexCoord1s_fnptr = (delegate* unmanaged<short, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1s");
            _TexCoord1s_fnptr(s);
        }
        
        private static delegate* unmanaged<short*, void> _TexCoord1sv_fnptr = &TexCoord1sv_Lazy;
        public static void TexCoord1sv(short* v) => _TexCoord1sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord1sv_Lazy(short* v)
        {
            _TexCoord1sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1sv");
            _TexCoord1sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, void> _TexCoord2d_fnptr = &TexCoord2d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2d(double s, double t) => _TexCoord2d_fnptr(s, t);
        [UnmanagedCallersOnly]
        private static void TexCoord2d_Lazy(double s, double t)
        {
            _TexCoord2d_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2d");
            _TexCoord2d_fnptr(s, t);
        }
        
        private static delegate* unmanaged<double*, void> _TexCoord2dv_fnptr = &TexCoord2dv_Lazy;
        public static void TexCoord2dv(double* v) => _TexCoord2dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord2dv_Lazy(double* v)
        {
            _TexCoord2dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2dv");
            _TexCoord2dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, void> _TexCoord2f_fnptr = &TexCoord2f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2f(float s, float t) => _TexCoord2f_fnptr(s, t);
        [UnmanagedCallersOnly]
        private static void TexCoord2f_Lazy(float s, float t)
        {
            _TexCoord2f_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2f");
            _TexCoord2f_fnptr(s, t);
        }
        
        private static delegate* unmanaged<float*, void> _TexCoord2fv_fnptr = &TexCoord2fv_Lazy;
        public static void TexCoord2fv(float* v) => _TexCoord2fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord2fv_Lazy(float* v)
        {
            _TexCoord2fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fv");
            _TexCoord2fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, void> _TexCoord2i_fnptr = &TexCoord2i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2i(int s, int t) => _TexCoord2i_fnptr(s, t);
        [UnmanagedCallersOnly]
        private static void TexCoord2i_Lazy(int s, int t)
        {
            _TexCoord2i_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2i");
            _TexCoord2i_fnptr(s, t);
        }
        
        private static delegate* unmanaged<int*, void> _TexCoord2iv_fnptr = &TexCoord2iv_Lazy;
        public static void TexCoord2iv(int* v) => _TexCoord2iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord2iv_Lazy(int* v)
        {
            _TexCoord2iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2iv");
            _TexCoord2iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, void> _TexCoord2s_fnptr = &TexCoord2s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2s(short s, short t) => _TexCoord2s_fnptr(s, t);
        [UnmanagedCallersOnly]
        private static void TexCoord2s_Lazy(short s, short t)
        {
            _TexCoord2s_fnptr = (delegate* unmanaged<short, short, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2s");
            _TexCoord2s_fnptr(s, t);
        }
        
        private static delegate* unmanaged<short*, void> _TexCoord2sv_fnptr = &TexCoord2sv_Lazy;
        public static void TexCoord2sv(short* v) => _TexCoord2sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord2sv_Lazy(short* v)
        {
            _TexCoord2sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2sv");
            _TexCoord2sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, void> _TexCoord3d_fnptr = &TexCoord3d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3d(double s, double t, double r) => _TexCoord3d_fnptr(s, t, r);
        [UnmanagedCallersOnly]
        private static void TexCoord3d_Lazy(double s, double t, double r)
        {
            _TexCoord3d_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3d");
            _TexCoord3d_fnptr(s, t, r);
        }
        
        private static delegate* unmanaged<double*, void> _TexCoord3dv_fnptr = &TexCoord3dv_Lazy;
        public static void TexCoord3dv(double* v) => _TexCoord3dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord3dv_Lazy(double* v)
        {
            _TexCoord3dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3dv");
            _TexCoord3dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, void> _TexCoord3f_fnptr = &TexCoord3f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3f(float s, float t, float r) => _TexCoord3f_fnptr(s, t, r);
        [UnmanagedCallersOnly]
        private static void TexCoord3f_Lazy(float s, float t, float r)
        {
            _TexCoord3f_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3f");
            _TexCoord3f_fnptr(s, t, r);
        }
        
        private static delegate* unmanaged<float*, void> _TexCoord3fv_fnptr = &TexCoord3fv_Lazy;
        public static void TexCoord3fv(float* v) => _TexCoord3fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord3fv_Lazy(float* v)
        {
            _TexCoord3fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3fv");
            _TexCoord3fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, void> _TexCoord3i_fnptr = &TexCoord3i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3i(int s, int t, int r) => _TexCoord3i_fnptr(s, t, r);
        [UnmanagedCallersOnly]
        private static void TexCoord3i_Lazy(int s, int t, int r)
        {
            _TexCoord3i_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3i");
            _TexCoord3i_fnptr(s, t, r);
        }
        
        private static delegate* unmanaged<int*, void> _TexCoord3iv_fnptr = &TexCoord3iv_Lazy;
        public static void TexCoord3iv(int* v) => _TexCoord3iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord3iv_Lazy(int* v)
        {
            _TexCoord3iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3iv");
            _TexCoord3iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, void> _TexCoord3s_fnptr = &TexCoord3s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3s(short s, short t, short r) => _TexCoord3s_fnptr(s, t, r);
        [UnmanagedCallersOnly]
        private static void TexCoord3s_Lazy(short s, short t, short r)
        {
            _TexCoord3s_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3s");
            _TexCoord3s_fnptr(s, t, r);
        }
        
        private static delegate* unmanaged<short*, void> _TexCoord3sv_fnptr = &TexCoord3sv_Lazy;
        public static void TexCoord3sv(short* v) => _TexCoord3sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord3sv_Lazy(short* v)
        {
            _TexCoord3sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3sv");
            _TexCoord3sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, double, void> _TexCoord4d_fnptr = &TexCoord4d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4d(double s, double t, double r, double q) => _TexCoord4d_fnptr(s, t, r, q);
        [UnmanagedCallersOnly]
        private static void TexCoord4d_Lazy(double s, double t, double r, double q)
        {
            _TexCoord4d_fnptr = (delegate* unmanaged<double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4d");
            _TexCoord4d_fnptr(s, t, r, q);
        }
        
        private static delegate* unmanaged<double*, void> _TexCoord4dv_fnptr = &TexCoord4dv_Lazy;
        public static void TexCoord4dv(double* v) => _TexCoord4dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord4dv_Lazy(double* v)
        {
            _TexCoord4dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4dv");
            _TexCoord4dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, float, void> _TexCoord4f_fnptr = &TexCoord4f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4f(float s, float t, float r, float q) => _TexCoord4f_fnptr(s, t, r, q);
        [UnmanagedCallersOnly]
        private static void TexCoord4f_Lazy(float s, float t, float r, float q)
        {
            _TexCoord4f_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4f");
            _TexCoord4f_fnptr(s, t, r, q);
        }
        
        private static delegate* unmanaged<float*, void> _TexCoord4fv_fnptr = &TexCoord4fv_Lazy;
        public static void TexCoord4fv(float* v) => _TexCoord4fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord4fv_Lazy(float* v)
        {
            _TexCoord4fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4fv");
            _TexCoord4fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, int, void> _TexCoord4i_fnptr = &TexCoord4i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4i(int s, int t, int r, int q) => _TexCoord4i_fnptr(s, t, r, q);
        [UnmanagedCallersOnly]
        private static void TexCoord4i_Lazy(int s, int t, int r, int q)
        {
            _TexCoord4i_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4i");
            _TexCoord4i_fnptr(s, t, r, q);
        }
        
        private static delegate* unmanaged<int*, void> _TexCoord4iv_fnptr = &TexCoord4iv_Lazy;
        public static void TexCoord4iv(int* v) => _TexCoord4iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord4iv_Lazy(int* v)
        {
            _TexCoord4iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4iv");
            _TexCoord4iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, short, void> _TexCoord4s_fnptr = &TexCoord4s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4s(short s, short t, short r, short q) => _TexCoord4s_fnptr(s, t, r, q);
        [UnmanagedCallersOnly]
        private static void TexCoord4s_Lazy(short s, short t, short r, short q)
        {
            _TexCoord4s_fnptr = (delegate* unmanaged<short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4s");
            _TexCoord4s_fnptr(s, t, r, q);
        }
        
        private static delegate* unmanaged<short*, void> _TexCoord4sv_fnptr = &TexCoord4sv_Lazy;
        public static void TexCoord4sv(short* v) => _TexCoord4sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void TexCoord4sv_Lazy(short* v)
        {
            _TexCoord4sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4sv");
            _TexCoord4sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, void> _Vertex2d_fnptr = &Vertex2d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2d(double x, double y) => _Vertex2d_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void Vertex2d_Lazy(double x, double y)
        {
            _Vertex2d_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2d");
            _Vertex2d_fnptr(x, y);
        }
        
        private static delegate* unmanaged<double*, void> _Vertex2dv_fnptr = &Vertex2dv_Lazy;
        public static void Vertex2dv(double* v) => _Vertex2dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex2dv_Lazy(double* v)
        {
            _Vertex2dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2dv");
            _Vertex2dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, void> _Vertex2f_fnptr = &Vertex2f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2f(float x, float y) => _Vertex2f_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void Vertex2f_Lazy(float x, float y)
        {
            _Vertex2f_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2f");
            _Vertex2f_fnptr(x, y);
        }
        
        private static delegate* unmanaged<float*, void> _Vertex2fv_fnptr = &Vertex2fv_Lazy;
        public static void Vertex2fv(float* v) => _Vertex2fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex2fv_Lazy(float* v)
        {
            _Vertex2fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2fv");
            _Vertex2fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, void> _Vertex2i_fnptr = &Vertex2i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2i(int x, int y) => _Vertex2i_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void Vertex2i_Lazy(int x, int y)
        {
            _Vertex2i_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2i");
            _Vertex2i_fnptr(x, y);
        }
        
        private static delegate* unmanaged<int*, void> _Vertex2iv_fnptr = &Vertex2iv_Lazy;
        public static void Vertex2iv(int* v) => _Vertex2iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex2iv_Lazy(int* v)
        {
            _Vertex2iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2iv");
            _Vertex2iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, void> _Vertex2s_fnptr = &Vertex2s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2s(short x, short y) => _Vertex2s_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void Vertex2s_Lazy(short x, short y)
        {
            _Vertex2s_fnptr = (delegate* unmanaged<short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2s");
            _Vertex2s_fnptr(x, y);
        }
        
        private static delegate* unmanaged<short*, void> _Vertex2sv_fnptr = &Vertex2sv_Lazy;
        public static void Vertex2sv(short* v) => _Vertex2sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex2sv_Lazy(short* v)
        {
            _Vertex2sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2sv");
            _Vertex2sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, void> _Vertex3d_fnptr = &Vertex3d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3d(double x, double y, double z) => _Vertex3d_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void Vertex3d_Lazy(double x, double y, double z)
        {
            _Vertex3d_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3d");
            _Vertex3d_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<double*, void> _Vertex3dv_fnptr = &Vertex3dv_Lazy;
        public static void Vertex3dv(double* v) => _Vertex3dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex3dv_Lazy(double* v)
        {
            _Vertex3dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3dv");
            _Vertex3dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, void> _Vertex3f_fnptr = &Vertex3f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3f(float x, float y, float z) => _Vertex3f_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void Vertex3f_Lazy(float x, float y, float z)
        {
            _Vertex3f_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3f");
            _Vertex3f_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<float*, void> _Vertex3fv_fnptr = &Vertex3fv_Lazy;
        public static void Vertex3fv(float* v) => _Vertex3fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex3fv_Lazy(float* v)
        {
            _Vertex3fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3fv");
            _Vertex3fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, void> _Vertex3i_fnptr = &Vertex3i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3i(int x, int y, int z) => _Vertex3i_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void Vertex3i_Lazy(int x, int y, int z)
        {
            _Vertex3i_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3i");
            _Vertex3i_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<int*, void> _Vertex3iv_fnptr = &Vertex3iv_Lazy;
        public static void Vertex3iv(int* v) => _Vertex3iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex3iv_Lazy(int* v)
        {
            _Vertex3iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3iv");
            _Vertex3iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, void> _Vertex3s_fnptr = &Vertex3s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3s(short x, short y, short z) => _Vertex3s_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void Vertex3s_Lazy(short x, short y, short z)
        {
            _Vertex3s_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3s");
            _Vertex3s_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<short*, void> _Vertex3sv_fnptr = &Vertex3sv_Lazy;
        public static void Vertex3sv(short* v) => _Vertex3sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex3sv_Lazy(short* v)
        {
            _Vertex3sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3sv");
            _Vertex3sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, double, void> _Vertex4d_fnptr = &Vertex4d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4d(double x, double y, double z, double w) => _Vertex4d_fnptr(x, y, z, w);
        [UnmanagedCallersOnly]
        private static void Vertex4d_Lazy(double x, double y, double z, double w)
        {
            _Vertex4d_fnptr = (delegate* unmanaged<double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4d");
            _Vertex4d_fnptr(x, y, z, w);
        }
        
        private static delegate* unmanaged<double*, void> _Vertex4dv_fnptr = &Vertex4dv_Lazy;
        public static void Vertex4dv(double* v) => _Vertex4dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex4dv_Lazy(double* v)
        {
            _Vertex4dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4dv");
            _Vertex4dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, float, void> _Vertex4f_fnptr = &Vertex4f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4f(float x, float y, float z, float w) => _Vertex4f_fnptr(x, y, z, w);
        [UnmanagedCallersOnly]
        private static void Vertex4f_Lazy(float x, float y, float z, float w)
        {
            _Vertex4f_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4f");
            _Vertex4f_fnptr(x, y, z, w);
        }
        
        private static delegate* unmanaged<float*, void> _Vertex4fv_fnptr = &Vertex4fv_Lazy;
        public static void Vertex4fv(float* v) => _Vertex4fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex4fv_Lazy(float* v)
        {
            _Vertex4fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4fv");
            _Vertex4fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, int, void> _Vertex4i_fnptr = &Vertex4i_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4i(int x, int y, int z, int w) => _Vertex4i_fnptr(x, y, z, w);
        [UnmanagedCallersOnly]
        private static void Vertex4i_Lazy(int x, int y, int z, int w)
        {
            _Vertex4i_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4i");
            _Vertex4i_fnptr(x, y, z, w);
        }
        
        private static delegate* unmanaged<int*, void> _Vertex4iv_fnptr = &Vertex4iv_Lazy;
        public static void Vertex4iv(int* v) => _Vertex4iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex4iv_Lazy(int* v)
        {
            _Vertex4iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4iv");
            _Vertex4iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, short, void> _Vertex4s_fnptr = &Vertex4s_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4s(short x, short y, short z, short w) => _Vertex4s_fnptr(x, y, z, w);
        [UnmanagedCallersOnly]
        private static void Vertex4s_Lazy(short x, short y, short z, short w)
        {
            _Vertex4s_fnptr = (delegate* unmanaged<short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4s");
            _Vertex4s_fnptr(x, y, z, w);
        }
        
        private static delegate* unmanaged<short*, void> _Vertex4sv_fnptr = &Vertex4sv_Lazy;
        public static void Vertex4sv(short* v) => _Vertex4sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void Vertex4sv_Lazy(short* v)
        {
            _Vertex4sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4sv");
            _Vertex4sv_fnptr(v);
        }
        
        private static delegate* unmanaged<ClipPlaneName, double*, void> _ClipPlane_fnptr = &ClipPlane_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify a plane against which all geometry is clipped. </summary>
        /// <param name="plane"> Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES -1 , are accepted. </param>
        /// <param name="equation"> Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClipPlane.xml" /></remarks>
        public static void ClipPlane(ClipPlaneName plane, double* equation) => _ClipPlane_fnptr(plane, equation);
        [UnmanagedCallersOnly]
        private static void ClipPlane_Lazy(ClipPlaneName plane, double* equation)
        {
            _ClipPlane_fnptr = (delegate* unmanaged<ClipPlaneName, double*, void>)GLLoader.BindingsContext.GetProcAddress("glClipPlane");
            _ClipPlane_fnptr(plane, equation);
        }
        
        private static delegate* unmanaged<MaterialFace, ColorMaterialParameter, void> _ColorMaterial_fnptr = &ColorMaterial_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Cause a material color to track the current color. </summary>
        /// <param name="face"> Specifies whether front, back, or both front and back material parameters should track the current color. Accepted values are GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. The initial value is GL_FRONT_AND_BACK. </param>
        /// <param name="mode"> Specifies which of several material parameters track the current color. Accepted values are GL_EMISSION, GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, and GL_AMBIENT_AND_DIFFUSE. The initial value is GL_AMBIENT_AND_DIFFUSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorMaterial.xml" /></remarks>
        public static void ColorMaterial(MaterialFace face, ColorMaterialParameter mode) => _ColorMaterial_fnptr(face, mode);
        [UnmanagedCallersOnly]
        private static void ColorMaterial_Lazy(MaterialFace face, ColorMaterialParameter mode)
        {
            _ColorMaterial_fnptr = (delegate* unmanaged<MaterialFace, ColorMaterialParameter, void>)GLLoader.BindingsContext.GetProcAddress("glColorMaterial");
            _ColorMaterial_fnptr(face, mode);
        }
        
        private static delegate* unmanaged<FogParameter, float, void> _Fogf_fnptr = &Fogf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify fog parameters. </summary>
        /// <param name="pname"> Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted. </param>
        /// <param name="param"> Specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFog.xml" /></remarks>
        public static void Fogf(FogParameter pname, float param) => _Fogf_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void Fogf_Lazy(FogParameter pname, float param)
        {
            _Fogf_fnptr = (delegate* unmanaged<FogParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glFogf");
            _Fogf_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<FogParameter, float*, void> _Fogfv_fnptr = &Fogfv_Lazy;
        public static void Fogfv(FogParameter pname, float* parameters) => _Fogfv_fnptr(pname, parameters);
        [UnmanagedCallersOnly]
        private static void Fogfv_Lazy(FogParameter pname, float* parameters)
        {
            _Fogfv_fnptr = (delegate* unmanaged<FogParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glFogfv");
            _Fogfv_fnptr(pname, parameters);
        }
        
        private static delegate* unmanaged<FogParameter, int, void> _Fogi_fnptr = &Fogi_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify fog parameters. </summary>
        /// <param name="pname"> Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted. </param>
        /// <param name="param"> Specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFog.xml" /></remarks>
        public static void Fogi(FogParameter pname, int param) => _Fogi_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void Fogi_Lazy(FogParameter pname, int param)
        {
            _Fogi_fnptr = (delegate* unmanaged<FogParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glFogi");
            _Fogi_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<FogParameter, int*, void> _Fogiv_fnptr = &Fogiv_Lazy;
        public static void Fogiv(FogParameter pname, int* parameters) => _Fogiv_fnptr(pname, parameters);
        [UnmanagedCallersOnly]
        private static void Fogiv_Lazy(FogParameter pname, int* parameters)
        {
            _Fogiv_fnptr = (delegate* unmanaged<FogParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glFogiv");
            _Fogiv_fnptr(pname, parameters);
        }
        
        private static delegate* unmanaged<LightName, LightParameter, float, void> _Lightf_fnptr = &Lightf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set light source parameters. </summary>
        /// <param name="light"> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted. </param>
        /// <param name="param"> Specifies the value that parameter pname of light source light will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLight.xml" /></remarks>
        public static void Lightf(LightName light, LightParameter pname, float param) => _Lightf_fnptr(light, pname, param);
        [UnmanagedCallersOnly]
        private static void Lightf_Lazy(LightName light, LightParameter pname, float param)
        {
            _Lightf_fnptr = (delegate* unmanaged<LightName, LightParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glLightf");
            _Lightf_fnptr(light, pname, param);
        }
        
        private static delegate* unmanaged<LightName, LightParameter, float*, void> _Lightfv_fnptr = &Lightfv_Lazy;
        public static void Lightfv(LightName light, LightParameter pname, float* parameters) => _Lightfv_fnptr(light, pname, parameters);
        [UnmanagedCallersOnly]
        private static void Lightfv_Lazy(LightName light, LightParameter pname, float* parameters)
        {
            _Lightfv_fnptr = (delegate* unmanaged<LightName, LightParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glLightfv");
            _Lightfv_fnptr(light, pname, parameters);
        }
        
        private static delegate* unmanaged<LightName, LightParameter, int, void> _Lighti_fnptr = &Lighti_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set light source parameters. </summary>
        /// <param name="light"> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted. </param>
        /// <param name="param"> Specifies the value that parameter pname of light source light will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLight.xml" /></remarks>
        public static void Lighti(LightName light, LightParameter pname, int param) => _Lighti_fnptr(light, pname, param);
        [UnmanagedCallersOnly]
        private static void Lighti_Lazy(LightName light, LightParameter pname, int param)
        {
            _Lighti_fnptr = (delegate* unmanaged<LightName, LightParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glLighti");
            _Lighti_fnptr(light, pname, param);
        }
        
        private static delegate* unmanaged<LightName, LightParameter, int*, void> _Lightiv_fnptr = &Lightiv_Lazy;
        public static void Lightiv(LightName light, LightParameter pname, int* parameters) => _Lightiv_fnptr(light, pname, parameters);
        [UnmanagedCallersOnly]
        private static void Lightiv_Lazy(LightName light, LightParameter pname, int* parameters)
        {
            _Lightiv_fnptr = (delegate* unmanaged<LightName, LightParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glLightiv");
            _Lightiv_fnptr(light, pname, parameters);
        }
        
        private static delegate* unmanaged<LightModelParameter, float, void> _LightModelf_fnptr = &LightModelf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the lighting model parameters. </summary>
        /// <param name="pname"> Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted. </param>
        /// <param name="param"> Specifies the value that param will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLightModel.xml" /></remarks>
        public static void LightModelf(LightModelParameter pname, float param) => _LightModelf_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void LightModelf_Lazy(LightModelParameter pname, float param)
        {
            _LightModelf_fnptr = (delegate* unmanaged<LightModelParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glLightModelf");
            _LightModelf_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<LightModelParameter, float*, void> _LightModelfv_fnptr = &LightModelfv_Lazy;
        public static void LightModelfv(LightModelParameter pname, float* parameters) => _LightModelfv_fnptr(pname, parameters);
        [UnmanagedCallersOnly]
        private static void LightModelfv_Lazy(LightModelParameter pname, float* parameters)
        {
            _LightModelfv_fnptr = (delegate* unmanaged<LightModelParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glLightModelfv");
            _LightModelfv_fnptr(pname, parameters);
        }
        
        private static delegate* unmanaged<LightModelParameter, int, void> _LightModeli_fnptr = &LightModeli_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the lighting model parameters. </summary>
        /// <param name="pname"> Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted. </param>
        /// <param name="param"> Specifies the value that param will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLightModel.xml" /></remarks>
        public static void LightModeli(LightModelParameter pname, int param) => _LightModeli_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void LightModeli_Lazy(LightModelParameter pname, int param)
        {
            _LightModeli_fnptr = (delegate* unmanaged<LightModelParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glLightModeli");
            _LightModeli_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<LightModelParameter, int*, void> _LightModeliv_fnptr = &LightModeliv_Lazy;
        public static void LightModeliv(LightModelParameter pname, int* parameters) => _LightModeliv_fnptr(pname, parameters);
        [UnmanagedCallersOnly]
        private static void LightModeliv_Lazy(LightModelParameter pname, int* parameters)
        {
            _LightModeliv_fnptr = (delegate* unmanaged<LightModelParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glLightModeliv");
            _LightModeliv_fnptr(pname, parameters);
        }
        
        private static delegate* unmanaged<int, ushort, void> _LineStipple_fnptr = &LineStipple_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the line stipple pattern. </summary>
        /// <param name="factor"> Specifies a multiplier for each bit in the line stipple pattern. If factor is 3, for example, each bit in the pattern is used three times before the next bit in the pattern is used. factor is clamped to the range [1, 256] and defaults to 1. </param>
        /// <param name="pattern"> Specifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized. Bit zero is used first; the default pattern is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLineStipple.xml" /></remarks>
        public static void LineStipple(int factor, ushort pattern) => _LineStipple_fnptr(factor, pattern);
        [UnmanagedCallersOnly]
        private static void LineStipple_Lazy(int factor, ushort pattern)
        {
            _LineStipple_fnptr = (delegate* unmanaged<int, ushort, void>)GLLoader.BindingsContext.GetProcAddress("glLineStipple");
            _LineStipple_fnptr(factor, pattern);
        }
        
        private static delegate* unmanaged<MaterialFace, MaterialParameter, float, void> _Materialf_fnptr = &Materialf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify material parameters for the lighting model. </summary>
        /// <param name="face"> Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. </param>
        /// <param name="pname"> Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS. </param>
        /// <param name="param"> Specifies the value that parameter GL_SHININESS will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMaterial.xml" /></remarks>
        public static void Materialf(MaterialFace face, MaterialParameter pname, float param) => _Materialf_fnptr(face, pname, param);
        [UnmanagedCallersOnly]
        private static void Materialf_Lazy(MaterialFace face, MaterialParameter pname, float param)
        {
            _Materialf_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glMaterialf");
            _Materialf_fnptr(face, pname, param);
        }
        
        private static delegate* unmanaged<MaterialFace, MaterialParameter, float*, void> _Materialfv_fnptr = &Materialfv_Lazy;
        public static void Materialfv(MaterialFace face, MaterialParameter pname, float* parameters) => _Materialfv_fnptr(face, pname, parameters);
        [UnmanagedCallersOnly]
        private static void Materialfv_Lazy(MaterialFace face, MaterialParameter pname, float* parameters)
        {
            _Materialfv_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMaterialfv");
            _Materialfv_fnptr(face, pname, parameters);
        }
        
        private static delegate* unmanaged<MaterialFace, MaterialParameter, int, void> _Materiali_fnptr = &Materiali_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify material parameters for the lighting model. </summary>
        /// <param name="face"> Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. </param>
        /// <param name="pname"> Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS. </param>
        /// <param name="param"> Specifies the value that parameter GL_SHININESS will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMaterial.xml" /></remarks>
        public static void Materiali(MaterialFace face, MaterialParameter pname, int param) => _Materiali_fnptr(face, pname, param);
        [UnmanagedCallersOnly]
        private static void Materiali_Lazy(MaterialFace face, MaterialParameter pname, int param)
        {
            _Materiali_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glMateriali");
            _Materiali_fnptr(face, pname, param);
        }
        
        private static delegate* unmanaged<MaterialFace, MaterialParameter, int*, void> _Materialiv_fnptr = &Materialiv_Lazy;
        public static void Materialiv(MaterialFace face, MaterialParameter pname, int* parameters) => _Materialiv_fnptr(face, pname, parameters);
        [UnmanagedCallersOnly]
        private static void Materialiv_Lazy(MaterialFace face, MaterialParameter pname, int* parameters)
        {
            _Materialiv_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMaterialiv");
            _Materialiv_fnptr(face, pname, parameters);
        }
        
        private static delegate* unmanaged<byte*, void> _PolygonStipple_fnptr = &PolygonStipple_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set the polygon stippling pattern. </summary>
        /// <param name="pattern"> Specifies a pointer to a 32 32 stipple pattern that will be unpacked from memory in the same way that glDrawPixels unpacks pixels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPolygonStipple.xml" /></remarks>
        public static void PolygonStipple(byte* mask) => _PolygonStipple_fnptr(mask);
        [UnmanagedCallersOnly]
        private static void PolygonStipple_Lazy(byte* mask)
        {
            _PolygonStipple_fnptr = (delegate* unmanaged<byte*, void>)GLLoader.BindingsContext.GetProcAddress("glPolygonStipple");
            _PolygonStipple_fnptr(mask);
        }
        
        private static delegate* unmanaged<ShadingModel, void> _ShadeModel_fnptr = &ShadeModel_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Select flat or smooth shading. </summary>
        /// <param name="mode"> Specifies a symbolic value representing a shading technique. Accepted values are GL_FLAT and GL_SMOOTH. The initial value is GL_SMOOTH. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glShadeModel.xml" /></remarks>
        public static void ShadeModel(ShadingModel mode) => _ShadeModel_fnptr(mode);
        [UnmanagedCallersOnly]
        private static void ShadeModel_Lazy(ShadingModel mode)
        {
            _ShadeModel_fnptr = (delegate* unmanaged<ShadingModel, void>)GLLoader.BindingsContext.GetProcAddress("glShadeModel");
            _ShadeModel_fnptr(mode);
        }
        
        private static delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, float, void> _TexEnvf_fnptr = &TexEnvf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="param"> Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml" /></remarks>
        public static void TexEnvf(TextureEnvTarget target, TextureEnvParameter pname, float param) => _TexEnvf_fnptr(target, pname, param);
        [UnmanagedCallersOnly]
        private static void TexEnvf_Lazy(TextureEnvTarget target, TextureEnvParameter pname, float param)
        {
            _TexEnvf_fnptr = (delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexEnvf");
            _TexEnvf_fnptr(target, pname, param);
        }
        
        private static delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, float*, void> _TexEnvfv_fnptr = &TexEnvfv_Lazy;
        public static void TexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => _TexEnvfv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TexEnvfv_Lazy(TextureEnvTarget target, TextureEnvParameter pname, float* parameters)
        {
            _TexEnvfv_fnptr = (delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexEnvfv");
            _TexEnvfv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int, void> _TexEnvi_fnptr = &TexEnvi_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="param"> Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml" /></remarks>
        public static void TexEnvi(TextureEnvTarget target, TextureEnvParameter pname, int param) => _TexEnvi_fnptr(target, pname, param);
        [UnmanagedCallersOnly]
        private static void TexEnvi_Lazy(TextureEnvTarget target, TextureEnvParameter pname, int param)
        {
            _TexEnvi_fnptr = (delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexEnvi");
            _TexEnvi_fnptr(target, pname, param);
        }
        
        private static delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int*, void> _TexEnviv_fnptr = &TexEnviv_Lazy;
        public static void TexEnviv(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => _TexEnviv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TexEnviv_Lazy(TextureEnvTarget target, TextureEnvParameter pname, int* parameters)
        {
            _TexEnviv_fnptr = (delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexEnviv");
            _TexEnviv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureCoordName, TextureGenParameter, double, void> _TexGend_fnptr = &TexGend_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Control the generation of texture coordinates. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE. </param>
        /// <param name="param"> Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexGen.xml" /></remarks>
        public static void TexGend(TextureCoordName coord, TextureGenParameter pname, double param) => _TexGend_fnptr(coord, pname, param);
        [UnmanagedCallersOnly]
        private static void TexGend_Lazy(TextureCoordName coord, TextureGenParameter pname, double param)
        {
            _TexGend_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, double, void>)GLLoader.BindingsContext.GetProcAddress("glTexGend");
            _TexGend_fnptr(coord, pname, param);
        }
        
        private static delegate* unmanaged<TextureCoordName, TextureGenParameter, double*, void> _TexGendv_fnptr = &TexGendv_Lazy;
        public static void TexGendv(TextureCoordName coord, TextureGenParameter pname, double* parameters) => _TexGendv_fnptr(coord, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TexGendv_Lazy(TextureCoordName coord, TextureGenParameter pname, double* parameters)
        {
            _TexGendv_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, double*, void>)GLLoader.BindingsContext.GetProcAddress("glTexGendv");
            _TexGendv_fnptr(coord, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureCoordName, TextureGenParameter, float, void> _TexGenf_fnptr = &TexGenf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Control the generation of texture coordinates. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE. </param>
        /// <param name="param"> Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexGen.xml" /></remarks>
        public static void TexGenf(TextureCoordName coord, TextureGenParameter pname, float param) => _TexGenf_fnptr(coord, pname, param);
        [UnmanagedCallersOnly]
        private static void TexGenf_Lazy(TextureCoordName coord, TextureGenParameter pname, float param)
        {
            _TexGenf_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexGenf");
            _TexGenf_fnptr(coord, pname, param);
        }
        
        private static delegate* unmanaged<TextureCoordName, TextureGenParameter, float*, void> _TexGenfv_fnptr = &TexGenfv_Lazy;
        public static void TexGenfv(TextureCoordName coord, TextureGenParameter pname, float* parameters) => _TexGenfv_fnptr(coord, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TexGenfv_Lazy(TextureCoordName coord, TextureGenParameter pname, float* parameters)
        {
            _TexGenfv_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexGenfv");
            _TexGenfv_fnptr(coord, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureCoordName, TextureGenParameter, int, void> _TexGeni_fnptr = &TexGeni_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Control the generation of texture coordinates. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE. </param>
        /// <param name="param"> Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexGen.xml" /></remarks>
        public static void TexGeni(TextureCoordName coord, TextureGenParameter pname, int param) => _TexGeni_fnptr(coord, pname, param);
        [UnmanagedCallersOnly]
        private static void TexGeni_Lazy(TextureCoordName coord, TextureGenParameter pname, int param)
        {
            _TexGeni_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexGeni");
            _TexGeni_fnptr(coord, pname, param);
        }
        
        private static delegate* unmanaged<TextureCoordName, TextureGenParameter, int*, void> _TexGeniv_fnptr = &TexGeniv_Lazy;
        public static void TexGeniv(TextureCoordName coord, TextureGenParameter pname, int* parameters) => _TexGeniv_fnptr(coord, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TexGeniv_Lazy(TextureCoordName coord, TextureGenParameter pname, int* parameters)
        {
            _TexGeniv_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexGeniv");
            _TexGeniv_fnptr(coord, pname, parameters);
        }
        
        private static delegate* unmanaged<int, FeedbackType, float*, void> _FeedbackBuffer_fnptr = &FeedbackBuffer_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Controls feedback mode. </summary>
        /// <param name="size"> Specifies the maximum number of values that can be written into buffer. </param>
        /// <param name="type"> Specifies a symbolic constant that describes the information that will be returned for each vertex. GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted. </param>
        /// <param name="buffer"> Returns the feedback data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFeedbackBuffer.xml" /></remarks>
        public static void FeedbackBuffer(int size, FeedbackType type, float* buffer) => _FeedbackBuffer_fnptr(size, type, buffer);
        [UnmanagedCallersOnly]
        private static void FeedbackBuffer_Lazy(int size, FeedbackType type, float* buffer)
        {
            _FeedbackBuffer_fnptr = (delegate* unmanaged<int, FeedbackType, float*, void>)GLLoader.BindingsContext.GetProcAddress("glFeedbackBuffer");
            _FeedbackBuffer_fnptr(size, type, buffer);
        }
        
        private static delegate* unmanaged<int, uint*, void> _SelectBuffer_fnptr = &SelectBuffer_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Establish a buffer for selection mode values. </summary>
        /// <param name="size"> Specifies the size of buffer. </param>
        /// <param name="buffer"> Returns the selection data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSelectBuffer.xml" /></remarks>
        public static void SelectBuffer(int size, uint* buffer) => _SelectBuffer_fnptr(size, buffer);
        [UnmanagedCallersOnly]
        private static void SelectBuffer_Lazy(int size, uint* buffer)
        {
            _SelectBuffer_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSelectBuffer");
            _SelectBuffer_fnptr(size, buffer);
        }
        
        private static delegate* unmanaged<RenderingMode, int> _RenderMode_fnptr = &RenderMode_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set rasterization mode. </summary>
        /// <param name="mode"> Specifies the rasterization mode. Three values are accepted: GL_RENDER, GL_SELECT, and GL_FEEDBACK. The initial value is GL_RENDER. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRenderMode.xml" /></remarks>
        public static int RenderMode(RenderingMode mode) => _RenderMode_fnptr(mode);
        [UnmanagedCallersOnly]
        private static int RenderMode_Lazy(RenderingMode mode)
        {
            _RenderMode_fnptr = (delegate* unmanaged<RenderingMode, int>)GLLoader.BindingsContext.GetProcAddress("glRenderMode");
            return _RenderMode_fnptr(mode);
        }
        
        private static delegate* unmanaged<void> _InitNames_fnptr = &InitNames_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Initialize the name stack. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glInitNames.xml" /></remarks>
        public static void InitNames() => _InitNames_fnptr();
        [UnmanagedCallersOnly]
        private static void InitNames_Lazy()
        {
            _InitNames_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glInitNames");
            _InitNames_fnptr();
        }
        
        private static delegate* unmanaged<uint, void> _LoadName_fnptr = &LoadName_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Load a name onto the name stack. </summary>
        /// <param name="name"> Specifies a name that will replace the top value on the name stack. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadName.xml" /></remarks>
        public static void LoadName(uint name) => _LoadName_fnptr(name);
        [UnmanagedCallersOnly]
        private static void LoadName_Lazy(uint name)
        {
            _LoadName_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glLoadName");
            _LoadName_fnptr(name);
        }
        
        private static delegate* unmanaged<float, void> _PassThrough_fnptr = &PassThrough_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Place a marker in the feedback buffer. </summary>
        /// <param name="token"> Specifies a marker value to be placed in the feedback buffer following a GL_PASS_THROUGH_TOKEN. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPassThrough.xml" /></remarks>
        public static void PassThrough(float token) => _PassThrough_fnptr(token);
        [UnmanagedCallersOnly]
        private static void PassThrough_Lazy(float token)
        {
            _PassThrough_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glPassThrough");
            _PassThrough_fnptr(token);
        }
        
        private static delegate* unmanaged<void> _PopName_fnptr = &PopName_Lazy;
        public static void PopName() => _PopName_fnptr();
        [UnmanagedCallersOnly]
        private static void PopName_Lazy()
        {
            _PopName_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPopName");
            _PopName_fnptr();
        }
        
        private static delegate* unmanaged<uint, void> _PushName_fnptr = &PushName_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Push and pop the name stack. </summary>
        /// <param name="name"> Specifies a name that will be pushed onto the name stack. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushName.xml" /></remarks>
        public static void PushName(uint name) => _PushName_fnptr(name);
        [UnmanagedCallersOnly]
        private static void PushName_Lazy(uint name)
        {
            _PushName_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glPushName");
            _PushName_fnptr(name);
        }
        
        private static delegate* unmanaged<float, float, float, float, void> _ClearAccum_fnptr = &ClearAccum_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify clear values for the accumulation buffer. </summary>
        /// <param name="red"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <param name="green"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <param name="blue"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <param name="alpha"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearAccum.xml" /></remarks>
        public static void ClearAccum(float red, float green, float blue, float alpha) => _ClearAccum_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void ClearAccum_Lazy(float red, float green, float blue, float alpha)
        {
            _ClearAccum_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glClearAccum");
            _ClearAccum_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<float, void> _ClearIndex_fnptr = &ClearIndex_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the clear value for the color index buffers. </summary>
        /// <param name="c"> Specifies the index used when the color index buffers are cleared. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearIndex.xml" /></remarks>
        public static void ClearIndex(float c) => _ClearIndex_fnptr(c);
        [UnmanagedCallersOnly]
        private static void ClearIndex_Lazy(float c)
        {
            _ClearIndex_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glClearIndex");
            _ClearIndex_fnptr(c);
        }
        
        private static delegate* unmanaged<uint, void> _IndexMask_fnptr = &IndexMask_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Control the writing of individual bits in the color index buffers. </summary>
        /// <param name="mask"> Specifies a bit mask to enable and disable the writing of individual bits in the color index buffers. Initially, the mask is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndexMask.xml" /></remarks>
        public static void IndexMask(uint mask) => _IndexMask_fnptr(mask);
        [UnmanagedCallersOnly]
        private static void IndexMask_Lazy(uint mask)
        {
            _IndexMask_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glIndexMask");
            _IndexMask_fnptr(mask);
        }
        
        private static delegate* unmanaged<AccumOp, float, void> _Accum_fnptr = &Accum_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Operate on the accumulation buffer. </summary>
        /// <param name="op"> Specifies the accumulation buffer operation. Symbolic constants GL_ACCUM, GL_LOAD, GL_ADD, GL_MULT, and GL_RETURN are accepted. </param>
        /// <param name="value"> Specifies a floating-point value used in the accumulation buffer operation. op determines how value is used. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glAccum.xml" /></remarks>
        public static void Accum(AccumOp op, float value) => _Accum_fnptr(op, value);
        [UnmanagedCallersOnly]
        private static void Accum_Lazy(AccumOp op, float value)
        {
            _Accum_fnptr = (delegate* unmanaged<AccumOp, float, void>)GLLoader.BindingsContext.GetProcAddress("glAccum");
            _Accum_fnptr(op, value);
        }
        
        private static delegate* unmanaged<void> _PopAttrib_fnptr = &PopAttrib_Lazy;
        public static void PopAttrib() => _PopAttrib_fnptr();
        [UnmanagedCallersOnly]
        private static void PopAttrib_Lazy()
        {
            _PopAttrib_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPopAttrib");
            _PopAttrib_fnptr();
        }
        
        private static delegate* unmanaged<AttribMask, void> _PushAttrib_fnptr = &PushAttrib_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Push and pop the server attribute stack. </summary>
        /// <param name="mask"> Specifies a mask that indicates which attributes to save. Values for mask are listed below. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushAttrib.xml" /></remarks>
        public static void PushAttrib(AttribMask mask) => _PushAttrib_fnptr(mask);
        [UnmanagedCallersOnly]
        private static void PushAttrib_Lazy(AttribMask mask)
        {
            _PushAttrib_fnptr = (delegate* unmanaged<AttribMask, void>)GLLoader.BindingsContext.GetProcAddress("glPushAttrib");
            _PushAttrib_fnptr(mask);
        }
        
        private static delegate* unmanaged<MapTarget, double, double, int, int, double*, void> _Map1d_fnptr = &Map1d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define a one-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="stride"> Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. </param>
        /// <param name="order"> Specifies the number of control points. Must be positive. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap1.xml" /></remarks>
        public static void Map1d(MapTarget target, double u1, double u2, int stride, int order, double* points) => _Map1d_fnptr(target, u1, u2, stride, order, points);
        [UnmanagedCallersOnly]
        private static void Map1d_Lazy(MapTarget target, double u1, double u2, int stride, int order, double* points)
        {
            _Map1d_fnptr = (delegate* unmanaged<MapTarget, double, double, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMap1d");
            _Map1d_fnptr(target, u1, u2, stride, order, points);
        }
        
        private static delegate* unmanaged<MapTarget, float, float, int, int, float*, void> _Map1f_fnptr = &Map1f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define a one-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="stride"> Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. </param>
        /// <param name="order"> Specifies the number of control points. Must be positive. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap1.xml" /></remarks>
        public static void Map1f(MapTarget target, float u1, float u2, int stride, int order, float* points) => _Map1f_fnptr(target, u1, u2, stride, order, points);
        [UnmanagedCallersOnly]
        private static void Map1f_Lazy(MapTarget target, float u1, float u2, int stride, int order, float* points)
        {
            _Map1f_fnptr = (delegate* unmanaged<MapTarget, float, float, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMap1f");
            _Map1f_fnptr(target, u1, u2, stride, order, points);
        }
        
        private static delegate* unmanaged<MapTarget, double, double, int, int, double, double, int, int, double*, void> _Map2d_fnptr = &Map2d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define a two-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="ustride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i + 1 j , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0. </param>
        /// <param name="uorder"> Specifies the dimension of the control point array in the u axis. Must be positive. The initial value is 1. </param>
        /// <param name="v1"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="v2"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="vstride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i j + 1 , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0. </param>
        /// <param name="vorder"> Specifies the dimension of the control point array in the v axis. Must be positive. The initial value is 1. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap2.xml" /></remarks>
        public static void Map2d(MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) => _Map2d_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        [UnmanagedCallersOnly]
        private static void Map2d_Lazy(MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points)
        {
            _Map2d_fnptr = (delegate* unmanaged<MapTarget, double, double, int, int, double, double, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMap2d");
            _Map2d_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        
        private static delegate* unmanaged<MapTarget, float, float, int, int, float, float, int, int, float*, void> _Map2f_fnptr = &Map2f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define a two-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="ustride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i + 1 j , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0. </param>
        /// <param name="uorder"> Specifies the dimension of the control point array in the u axis. Must be positive. The initial value is 1. </param>
        /// <param name="v1"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="v2"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="vstride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i j + 1 , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0. </param>
        /// <param name="vorder"> Specifies the dimension of the control point array in the v axis. Must be positive. The initial value is 1. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap2.xml" /></remarks>
        public static void Map2f(MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) => _Map2f_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        [UnmanagedCallersOnly]
        private static void Map2f_Lazy(MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points)
        {
            _Map2f_fnptr = (delegate* unmanaged<MapTarget, float, float, int, int, float, float, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMap2f");
            _Map2f_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        
        private static delegate* unmanaged<int, double, double, void> _MapGrid1d_fnptr = &MapGrid1d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid1d(int un, double u1, double u2) => _MapGrid1d_fnptr(un, u1, u2);
        [UnmanagedCallersOnly]
        private static void MapGrid1d_Lazy(int un, double u1, double u2)
        {
            _MapGrid1d_fnptr = (delegate* unmanaged<int, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMapGrid1d");
            _MapGrid1d_fnptr(un, u1, u2);
        }
        
        private static delegate* unmanaged<int, float, float, void> _MapGrid1f_fnptr = &MapGrid1f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid1f(int un, float u1, float u2) => _MapGrid1f_fnptr(un, u1, u2);
        [UnmanagedCallersOnly]
        private static void MapGrid1f_Lazy(int un, float u1, float u2)
        {
            _MapGrid1f_fnptr = (delegate* unmanaged<int, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMapGrid1f");
            _MapGrid1f_fnptr(un, u1, u2);
        }
        
        private static delegate* unmanaged<int, double, double, int, double, double, void> _MapGrid2d_fnptr = &MapGrid2d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="vn"> Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only). </param>
        /// <param name="v1"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <param name="v2"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) => _MapGrid2d_fnptr(un, u1, u2, vn, v1, v2);
        [UnmanagedCallersOnly]
        private static void MapGrid2d_Lazy(int un, double u1, double u2, int vn, double v1, double v2)
        {
            _MapGrid2d_fnptr = (delegate* unmanaged<int, double, double, int, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMapGrid2d");
            _MapGrid2d_fnptr(un, u1, u2, vn, v1, v2);
        }
        
        private static delegate* unmanaged<int, float, float, int, float, float, void> _MapGrid2f_fnptr = &MapGrid2f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="vn"> Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only). </param>
        /// <param name="v1"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <param name="v2"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) => _MapGrid2f_fnptr(un, u1, u2, vn, v1, v2);
        [UnmanagedCallersOnly]
        private static void MapGrid2f_Lazy(int un, float u1, float u2, int vn, float v1, float v2)
        {
            _MapGrid2f_fnptr = (delegate* unmanaged<int, float, float, int, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMapGrid2f");
            _MapGrid2f_fnptr(un, u1, u2, vn, v1, v2);
        }
        
        private static delegate* unmanaged<double, void> _EvalCoord1d_fnptr = &EvalCoord1d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord1d(double u) => _EvalCoord1d_fnptr(u);
        [UnmanagedCallersOnly]
        private static void EvalCoord1d_Lazy(double u)
        {
            _EvalCoord1d_fnptr = (delegate* unmanaged<double, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord1d");
            _EvalCoord1d_fnptr(u);
        }
        
        private static delegate* unmanaged<double*, void> _EvalCoord1dv_fnptr = &EvalCoord1dv_Lazy;
        public static void EvalCoord1dv(double* u) => _EvalCoord1dv_fnptr(u);
        [UnmanagedCallersOnly]
        private static void EvalCoord1dv_Lazy(double* u)
        {
            _EvalCoord1dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord1dv");
            _EvalCoord1dv_fnptr(u);
        }
        
        private static delegate* unmanaged<float, void> _EvalCoord1f_fnptr = &EvalCoord1f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord1f(float u) => _EvalCoord1f_fnptr(u);
        [UnmanagedCallersOnly]
        private static void EvalCoord1f_Lazy(float u)
        {
            _EvalCoord1f_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord1f");
            _EvalCoord1f_fnptr(u);
        }
        
        private static delegate* unmanaged<float*, void> _EvalCoord1fv_fnptr = &EvalCoord1fv_Lazy;
        public static void EvalCoord1fv(float* u) => _EvalCoord1fv_fnptr(u);
        [UnmanagedCallersOnly]
        private static void EvalCoord1fv_Lazy(float* u)
        {
            _EvalCoord1fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord1fv");
            _EvalCoord1fv_fnptr(u);
        }
        
        private static delegate* unmanaged<double, double, void> _EvalCoord2d_fnptr = &EvalCoord2d_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <param name="v"> Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord2d(double u, double v) => _EvalCoord2d_fnptr(u, v);
        [UnmanagedCallersOnly]
        private static void EvalCoord2d_Lazy(double u, double v)
        {
            _EvalCoord2d_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord2d");
            _EvalCoord2d_fnptr(u, v);
        }
        
        private static delegate* unmanaged<double*, void> _EvalCoord2dv_fnptr = &EvalCoord2dv_Lazy;
        public static void EvalCoord2dv(double* u) => _EvalCoord2dv_fnptr(u);
        [UnmanagedCallersOnly]
        private static void EvalCoord2dv_Lazy(double* u)
        {
            _EvalCoord2dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord2dv");
            _EvalCoord2dv_fnptr(u);
        }
        
        private static delegate* unmanaged<float, float, void> _EvalCoord2f_fnptr = &EvalCoord2f_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <param name="v"> Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord2f(float u, float v) => _EvalCoord2f_fnptr(u, v);
        [UnmanagedCallersOnly]
        private static void EvalCoord2f_Lazy(float u, float v)
        {
            _EvalCoord2f_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord2f");
            _EvalCoord2f_fnptr(u, v);
        }
        
        private static delegate* unmanaged<float*, void> _EvalCoord2fv_fnptr = &EvalCoord2fv_Lazy;
        public static void EvalCoord2fv(float* u) => _EvalCoord2fv_fnptr(u);
        [UnmanagedCallersOnly]
        private static void EvalCoord2fv_Lazy(float* u)
        {
            _EvalCoord2fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord2fv");
            _EvalCoord2fv_fnptr(u);
        }
        
        private static delegate* unmanaged<MeshMode1, int, int, void> _EvalMesh1_fnptr = &EvalMesh1_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Compute a one- or two-dimensional grid of points or lines. </summary>
        /// <param name="mode"> In glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants GL_POINT and GL_LINE are accepted. </param>
        /// <param name="i1"> Specify the first and last integer values for grid domain variable i. </param>
        /// <param name="i2"> Specify the first and last integer values for grid domain variable i. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalMesh.xml" /></remarks>
        public static void EvalMesh1(MeshMode1 mode, int i1, int i2) => _EvalMesh1_fnptr(mode, i1, i2);
        [UnmanagedCallersOnly]
        private static void EvalMesh1_Lazy(MeshMode1 mode, int i1, int i2)
        {
            _EvalMesh1_fnptr = (delegate* unmanaged<MeshMode1, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glEvalMesh1");
            _EvalMesh1_fnptr(mode, i1, i2);
        }
        
        private static delegate* unmanaged<int, void> _EvalPoint1_fnptr = &EvalPoint1_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Generate and evaluate a single point in a mesh. </summary>
        /// <param name="i"> Specifies the integer value for grid domain variable i. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalPoint.xml" /></remarks>
        public static void EvalPoint1(int i) => _EvalPoint1_fnptr(i);
        [UnmanagedCallersOnly]
        private static void EvalPoint1_Lazy(int i)
        {
            _EvalPoint1_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glEvalPoint1");
            _EvalPoint1_fnptr(i);
        }
        
        private static delegate* unmanaged<MeshMode2, int, int, int, int, void> _EvalMesh2_fnptr = &EvalMesh2_Lazy;
        public static void EvalMesh2(MeshMode2 mode, int i1, int i2, int j1, int j2) => _EvalMesh2_fnptr(mode, i1, i2, j1, j2);
        [UnmanagedCallersOnly]
        private static void EvalMesh2_Lazy(MeshMode2 mode, int i1, int i2, int j1, int j2)
        {
            _EvalMesh2_fnptr = (delegate* unmanaged<MeshMode2, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glEvalMesh2");
            _EvalMesh2_fnptr(mode, i1, i2, j1, j2);
        }
        
        private static delegate* unmanaged<int, int, void> _EvalPoint2_fnptr = &EvalPoint2_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Generate and evaluate a single point in a mesh. </summary>
        /// <param name="i"> Specifies the integer value for grid domain variable i. </param>
        /// <param name="j"> Specifies the integer value for grid domain variable j (glEvalPoint2 only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalPoint.xml" /></remarks>
        public static void EvalPoint2(int i, int j) => _EvalPoint2_fnptr(i, j);
        [UnmanagedCallersOnly]
        private static void EvalPoint2_Lazy(int i, int j)
        {
            _EvalPoint2_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glEvalPoint2");
            _EvalPoint2_fnptr(i, j);
        }
        
        private static delegate* unmanaged<AlphaFunction, float, void> _AlphaFunc_fnptr = &AlphaFunc_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the alpha test function. </summary>
        /// <param name="func"> Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range 0 1 , where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glAlphaFunc.xml" /></remarks>
        public static void AlphaFunc(AlphaFunction func, float reference) => _AlphaFunc_fnptr(func, reference);
        [UnmanagedCallersOnly]
        private static void AlphaFunc_Lazy(AlphaFunction func, float reference)
        {
            _AlphaFunc_fnptr = (delegate* unmanaged<AlphaFunction, float, void>)GLLoader.BindingsContext.GetProcAddress("glAlphaFunc");
            _AlphaFunc_fnptr(func, reference);
        }
        
        private static delegate* unmanaged<float, float, void> _PixelZoom_fnptr = &PixelZoom_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify the pixel zoom factors. </summary>
        /// <param name="xfactor"> Specify the x and y zoom factors for pixel write operations. </param>
        /// <param name="yfactor"> Specify the x and y zoom factors for pixel write operations. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelZoom.xml" /></remarks>
        public static void PixelZoom(float xfactor, float yfactor) => _PixelZoom_fnptr(xfactor, yfactor);
        [UnmanagedCallersOnly]
        private static void PixelZoom_Lazy(float xfactor, float yfactor)
        {
            _PixelZoom_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glPixelZoom");
            _PixelZoom_fnptr(xfactor, yfactor);
        }
        
        private static delegate* unmanaged<PixelTransferParameter, float, void> _PixelTransferf_fnptr = &PixelTransferf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set pixel transfer modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelTransfer.xml" /></remarks>
        public static void PixelTransferf(PixelTransferParameter pname, float param) => _PixelTransferf_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void PixelTransferf_Lazy(PixelTransferParameter pname, float param)
        {
            _PixelTransferf_fnptr = (delegate* unmanaged<PixelTransferParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTransferf");
            _PixelTransferf_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<PixelTransferParameter, int, void> _PixelTransferi_fnptr = &PixelTransferi_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set pixel transfer modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelTransfer.xml" /></remarks>
        public static void PixelTransferi(PixelTransferParameter pname, int param) => _PixelTransferi_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void PixelTransferi_Lazy(PixelTransferParameter pname, int param)
        {
            _PixelTransferi_fnptr = (delegate* unmanaged<PixelTransferParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTransferi");
            _PixelTransferi_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<PixelMap, int, float*, void> _PixelMapfv_fnptr = &PixelMapfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set up pixel transfer maps. </summary>
        /// <param name="map"> Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="mapsize"> Specifies the size of the map being defined. </param>
        /// <param name="values"> Specifies an array of mapsize values. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelMap.xml" /></remarks>
        public static void PixelMapfv(PixelMap map, int mapsize, float* values) => _PixelMapfv_fnptr(map, mapsize, values);
        [UnmanagedCallersOnly]
        private static void PixelMapfv_Lazy(PixelMap map, int mapsize, float* values)
        {
            _PixelMapfv_fnptr = (delegate* unmanaged<PixelMap, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPixelMapfv");
            _PixelMapfv_fnptr(map, mapsize, values);
        }
        
        private static delegate* unmanaged<PixelMap, int, uint*, void> _PixelMapuiv_fnptr = &PixelMapuiv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set up pixel transfer maps. </summary>
        /// <param name="map"> Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="mapsize"> Specifies the size of the map being defined. </param>
        /// <param name="values"> Specifies an array of mapsize values. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelMap.xml" /></remarks>
        public static void PixelMapuiv(PixelMap map, int mapsize, uint* values) => _PixelMapuiv_fnptr(map, mapsize, values);
        [UnmanagedCallersOnly]
        private static void PixelMapuiv_Lazy(PixelMap map, int mapsize, uint* values)
        {
            _PixelMapuiv_fnptr = (delegate* unmanaged<PixelMap, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glPixelMapuiv");
            _PixelMapuiv_fnptr(map, mapsize, values);
        }
        
        private static delegate* unmanaged<PixelMap, int, ushort*, void> _PixelMapusv_fnptr = &PixelMapusv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Set up pixel transfer maps. </summary>
        /// <param name="map"> Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="mapsize"> Specifies the size of the map being defined. </param>
        /// <param name="values"> Specifies an array of mapsize values. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelMap.xml" /></remarks>
        public static void PixelMapusv(PixelMap map, int mapsize, ushort* values) => _PixelMapusv_fnptr(map, mapsize, values);
        [UnmanagedCallersOnly]
        private static void PixelMapusv_Lazy(PixelMap map, int mapsize, ushort* values)
        {
            _PixelMapusv_fnptr = (delegate* unmanaged<PixelMap, int, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glPixelMapusv");
            _PixelMapusv_fnptr(map, mapsize, values);
        }
        
        private static delegate* unmanaged<int, int, int, int, PixelCopyType, void> _CopyPixels_fnptr = &CopyPixels_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Copy pixels in the frame buffer. </summary>
        /// <param name="x"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="width"> Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative. </param>
        /// <param name="height"> Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative. </param>
        /// <param name="type"> Specifies whether color values, depth values, or stencil values are to be copied. Symbolic constants GL_COLOR, GL_DEPTH, and GL_STENCIL are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyPixels.xml" /></remarks>
        public static void CopyPixels(int x, int y, int width, int height, PixelCopyType type) => _CopyPixels_fnptr(x, y, width, height, type);
        [UnmanagedCallersOnly]
        private static void CopyPixels_Lazy(int x, int y, int width, int height, PixelCopyType type)
        {
            _CopyPixels_fnptr = (delegate* unmanaged<int, int, int, int, PixelCopyType, void>)GLLoader.BindingsContext.GetProcAddress("glCopyPixels");
            _CopyPixels_fnptr(x, y, width, height, type);
        }
        
        private static delegate* unmanaged<int, int, PixelFormat, PixelType, void*, void> _DrawPixels_fnptr = &DrawPixels_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Write a block of pixels to the frame buffer. </summary>
        /// <param name="width"> Specify the dimensions of the pixel rectangle to be written into the frame buffer. </param>
        /// <param name="height"> Specify the dimensions of the pixel rectangle to be written into the frame buffer. </param>
        /// <param name="format"> Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted. </param>
        /// <param name="type"> Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
        /// <param name="data"> Specifies a pointer to the pixel data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDrawPixels.xml" /></remarks>
        public static void DrawPixels(int width, int height, PixelFormat format, PixelType type, void* pixels) => _DrawPixels_fnptr(width, height, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void DrawPixels_Lazy(int width, int height, PixelFormat format, PixelType type, void* pixels)
        {
            _DrawPixels_fnptr = (delegate* unmanaged<int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawPixels");
            _DrawPixels_fnptr(width, height, format, type, pixels);
        }
        
        private static delegate* unmanaged<ClipPlaneName, double*, void> _GetClipPlane_fnptr = &GetClipPlane_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return the coefficients of the specified clipping plane. </summary>
        /// <param name="plane"> Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE i where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1. </param>
        /// <param name="equation"> Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetClipPlane.xml" /></remarks>
        public static void GetClipPlane(ClipPlaneName plane, double* equation) => _GetClipPlane_fnptr(plane, equation);
        [UnmanagedCallersOnly]
        private static void GetClipPlane_Lazy(ClipPlaneName plane, double* equation)
        {
            _GetClipPlane_fnptr = (delegate* unmanaged<ClipPlaneName, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetClipPlane");
            _GetClipPlane_fnptr(plane, equation);
        }
        
        private static delegate* unmanaged<LightName, LightParameter, float*, void> _GetLightfv_fnptr = &GetLightfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return light source parameter values. </summary>
        /// <param name="light"> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetLight.xml" /></remarks>
        public static void GetLightfv(LightName light, LightParameter pname, float* parameters) => _GetLightfv_fnptr(light, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetLightfv_Lazy(LightName light, LightParameter pname, float* parameters)
        {
            _GetLightfv_fnptr = (delegate* unmanaged<LightName, LightParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetLightfv");
            _GetLightfv_fnptr(light, pname, parameters);
        }
        
        private static delegate* unmanaged<LightName, LightParameter, int*, void> _GetLightiv_fnptr = &GetLightiv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return light source parameter values. </summary>
        /// <param name="light"> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetLight.xml" /></remarks>
        public static void GetLightiv(LightName light, LightParameter pname, int* parameters) => _GetLightiv_fnptr(light, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetLightiv_Lazy(LightName light, LightParameter pname, int* parameters)
        {
            _GetLightiv_fnptr = (delegate* unmanaged<LightName, LightParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetLightiv");
            _GetLightiv_fnptr(light, pname, parameters);
        }
        
        private static delegate* unmanaged<MapTarget, GetMapQuery, double*, void> _GetMapdv_fnptr = &GetMapdv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return evaluator parameters. </summary>
        /// <param name="target"> Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4. </param>
        /// <param name="query"> Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted. </param>
        /// <param name="v"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMap.xml" /></remarks>
        public static void GetMapdv(MapTarget target, GetMapQuery query, double* v) => _GetMapdv_fnptr(target, query, v);
        [UnmanagedCallersOnly]
        private static void GetMapdv_Lazy(MapTarget target, GetMapQuery query, double* v)
        {
            _GetMapdv_fnptr = (delegate* unmanaged<MapTarget, GetMapQuery, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMapdv");
            _GetMapdv_fnptr(target, query, v);
        }
        
        private static delegate* unmanaged<MapTarget, GetMapQuery, float*, void> _GetMapfv_fnptr = &GetMapfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return evaluator parameters. </summary>
        /// <param name="target"> Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4. </param>
        /// <param name="query"> Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted. </param>
        /// <param name="v"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMap.xml" /></remarks>
        public static void GetMapfv(MapTarget target, GetMapQuery query, float* v) => _GetMapfv_fnptr(target, query, v);
        [UnmanagedCallersOnly]
        private static void GetMapfv_Lazy(MapTarget target, GetMapQuery query, float* v)
        {
            _GetMapfv_fnptr = (delegate* unmanaged<MapTarget, GetMapQuery, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMapfv");
            _GetMapfv_fnptr(target, query, v);
        }
        
        private static delegate* unmanaged<MapTarget, GetMapQuery, int*, void> _GetMapiv_fnptr = &GetMapiv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return evaluator parameters. </summary>
        /// <param name="target"> Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4. </param>
        /// <param name="query"> Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted. </param>
        /// <param name="v"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMap.xml" /></remarks>
        public static void GetMapiv(MapTarget target, GetMapQuery query, int* v) => _GetMapiv_fnptr(target, query, v);
        [UnmanagedCallersOnly]
        private static void GetMapiv_Lazy(MapTarget target, GetMapQuery query, int* v)
        {
            _GetMapiv_fnptr = (delegate* unmanaged<MapTarget, GetMapQuery, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMapiv");
            _GetMapiv_fnptr(target, query, v);
        }
        
        private static delegate* unmanaged<MaterialFace, MaterialParameter, float*, void> _GetMaterialfv_fnptr = &GetMaterialfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return material parameters. </summary>
        /// <param name="face"> Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively. </param>
        /// <param name="pname"> Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMaterial.xml" /></remarks>
        public static void GetMaterialfv(MaterialFace face, MaterialParameter pname, float* parameters) => _GetMaterialfv_fnptr(face, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetMaterialfv_Lazy(MaterialFace face, MaterialParameter pname, float* parameters)
        {
            _GetMaterialfv_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMaterialfv");
            _GetMaterialfv_fnptr(face, pname, parameters);
        }
        
        private static delegate* unmanaged<MaterialFace, MaterialParameter, int*, void> _GetMaterialiv_fnptr = &GetMaterialiv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return material parameters. </summary>
        /// <param name="face"> Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively. </param>
        /// <param name="pname"> Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMaterial.xml" /></remarks>
        public static void GetMaterialiv(MaterialFace face, MaterialParameter pname, int* parameters) => _GetMaterialiv_fnptr(face, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetMaterialiv_Lazy(MaterialFace face, MaterialParameter pname, int* parameters)
        {
            _GetMaterialiv_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMaterialiv");
            _GetMaterialiv_fnptr(face, pname, parameters);
        }
        
        private static delegate* unmanaged<PixelMap, float*, void> _GetPixelMapfv_fnptr = &GetPixelMapfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return the specified pixel map. </summary>
        /// <param name="map"> Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="data"> Returns the pixel map contents. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPixelMap.xml" /></remarks>
        public static void GetPixelMapfv(PixelMap map, float* values) => _GetPixelMapfv_fnptr(map, values);
        [UnmanagedCallersOnly]
        private static void GetPixelMapfv_Lazy(PixelMap map, float* values)
        {
            _GetPixelMapfv_fnptr = (delegate* unmanaged<PixelMap, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPixelMapfv");
            _GetPixelMapfv_fnptr(map, values);
        }
        
        private static delegate* unmanaged<PixelMap, uint*, void> _GetPixelMapuiv_fnptr = &GetPixelMapuiv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return the specified pixel map. </summary>
        /// <param name="map"> Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="data"> Returns the pixel map contents. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPixelMap.xml" /></remarks>
        public static void GetPixelMapuiv(PixelMap map, uint* values) => _GetPixelMapuiv_fnptr(map, values);
        [UnmanagedCallersOnly]
        private static void GetPixelMapuiv_Lazy(PixelMap map, uint* values)
        {
            _GetPixelMapuiv_fnptr = (delegate* unmanaged<PixelMap, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPixelMapuiv");
            _GetPixelMapuiv_fnptr(map, values);
        }
        
        private static delegate* unmanaged<PixelMap, ushort*, void> _GetPixelMapusv_fnptr = &GetPixelMapusv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return the specified pixel map. </summary>
        /// <param name="map"> Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="data"> Returns the pixel map contents. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPixelMap.xml" /></remarks>
        public static void GetPixelMapusv(PixelMap map, ushort* values) => _GetPixelMapusv_fnptr(map, values);
        [UnmanagedCallersOnly]
        private static void GetPixelMapusv_Lazy(PixelMap map, ushort* values)
        {
            _GetPixelMapusv_fnptr = (delegate* unmanaged<PixelMap, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPixelMapusv");
            _GetPixelMapusv_fnptr(map, values);
        }
        
        private static delegate* unmanaged<byte*, void> _GetPolygonStipple_fnptr = &GetPolygonStipple_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return the polygon stipple pattern. </summary>
        /// <param name="pattern"> Returns the stipple pattern. The initial value is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPolygonStipple.xml" /></remarks>
        public static void GetPolygonStipple(byte* mask) => _GetPolygonStipple_fnptr(mask);
        [UnmanagedCallersOnly]
        private static void GetPolygonStipple_Lazy(byte* mask)
        {
            _GetPolygonStipple_fnptr = (delegate* unmanaged<byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPolygonStipple");
            _GetPolygonStipple_fnptr(mask);
        }
        
        private static delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, float*, void> _GetTexEnvfv_fnptr = &GetTexEnvfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml" /></remarks>
        public static void GetTexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => _GetTexEnvfv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexEnvfv_Lazy(TextureEnvTarget target, TextureEnvParameter pname, float* parameters)
        {
            _GetTexEnvfv_fnptr = (delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexEnvfv");
            _GetTexEnvfv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int*, void> _GetTexEnviv_fnptr = &GetTexEnviv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml" /></remarks>
        public static void GetTexEnviv(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => _GetTexEnviv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexEnviv_Lazy(TextureEnvTarget target, TextureEnvParameter pname, int* parameters)
        {
            _GetTexEnviv_fnptr = (delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexEnviv");
            _GetTexEnviv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureCoordName, TextureGenParameter, double*, void> _GetTexGendv_fnptr = &GetTexGendv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return texture coordinate generation parameters. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexGen.xml" /></remarks>
        public static void GetTexGendv(TextureCoordName coord, TextureGenParameter pname, double* parameters) => _GetTexGendv_fnptr(coord, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexGendv_Lazy(TextureCoordName coord, TextureGenParameter pname, double* parameters)
        {
            _GetTexGendv_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexGendv");
            _GetTexGendv_fnptr(coord, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureCoordName, TextureGenParameter, float*, void> _GetTexGenfv_fnptr = &GetTexGenfv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return texture coordinate generation parameters. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexGen.xml" /></remarks>
        public static void GetTexGenfv(TextureCoordName coord, TextureGenParameter pname, float* parameters) => _GetTexGenfv_fnptr(coord, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexGenfv_Lazy(TextureCoordName coord, TextureGenParameter pname, float* parameters)
        {
            _GetTexGenfv_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexGenfv");
            _GetTexGenfv_fnptr(coord, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureCoordName, TextureGenParameter, int*, void> _GetTexGeniv_fnptr = &GetTexGeniv_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Return texture coordinate generation parameters. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexGen.xml" /></remarks>
        public static void GetTexGeniv(TextureCoordName coord, TextureGenParameter pname, int* parameters) => _GetTexGeniv_fnptr(coord, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexGeniv_Lazy(TextureCoordName coord, TextureGenParameter pname, int* parameters)
        {
            _GetTexGeniv_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexGeniv");
            _GetTexGeniv_fnptr(coord, pname, parameters);
        }
        
        private static delegate* unmanaged<DisplayListHandle, byte> _IsList_fnptr = &IsList_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Determine if a name corresponds to a display list. </summary>
        /// <param name="list"> Specifies a potential display list name. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIsList.xml" /></remarks>
        public static byte IsList(DisplayListHandle list) => _IsList_fnptr(list);
        [UnmanagedCallersOnly]
        private static byte IsList_Lazy(DisplayListHandle list)
        {
            _IsList_fnptr = (delegate* unmanaged<DisplayListHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsList");
            return _IsList_fnptr(list);
        }
        
        private static delegate* unmanaged<double, double, double, double, double, double, void> _Frustum_fnptr = &Frustum_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix by a perspective matrix. </summary>
        /// <param name="left"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="right"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="bottom"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="top"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="nearVal"> Specify the distances to the near and far depth clipping planes. Both distances must be positive. </param>
        /// <param name="farVal"> Specify the distances to the near and far depth clipping planes. Both distances must be positive. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml" /></remarks>
        public static void Frustum(double left, double right, double bottom, double top, double zNear, double zFar) => _Frustum_fnptr(left, right, bottom, top, zNear, zFar);
        [UnmanagedCallersOnly]
        private static void Frustum_Lazy(double left, double right, double bottom, double top, double zNear, double zFar)
        {
            _Frustum_fnptr = (delegate* unmanaged<double, double, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glFrustum");
            _Frustum_fnptr(left, right, bottom, top, zNear, zFar);
        }
        
        private static delegate* unmanaged<void> _LoadIdentity_fnptr = &LoadIdentity_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Replace the current matrix with the identity matrix. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml" /></remarks>
        public static void LoadIdentity() => _LoadIdentity_fnptr();
        [UnmanagedCallersOnly]
        private static void LoadIdentity_Lazy()
        {
            _LoadIdentity_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glLoadIdentity");
            _LoadIdentity_fnptr();
        }
        
        private static delegate* unmanaged<float*, void> _LoadMatrixf_fnptr = &LoadMatrixf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Replace the current matrix with the specified matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadMatrix.xml" /></remarks>
        public static void LoadMatrixf(float* m) => _LoadMatrixf_fnptr(m);
        [UnmanagedCallersOnly]
        private static void LoadMatrixf_Lazy(float* m)
        {
            _LoadMatrixf_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glLoadMatrixf");
            _LoadMatrixf_fnptr(m);
        }
        
        private static delegate* unmanaged<double*, void> _LoadMatrixd_fnptr = &LoadMatrixd_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Replace the current matrix with the specified matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadMatrix.xml" /></remarks>
        public static void LoadMatrixd(double* m) => _LoadMatrixd_fnptr(m);
        [UnmanagedCallersOnly]
        private static void LoadMatrixd_Lazy(double* m)
        {
            _LoadMatrixd_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glLoadMatrixd");
            _LoadMatrixd_fnptr(m);
        }
        
        private static delegate* unmanaged<MatrixMode, void> _MatrixMode_fnptr = &MatrixMode_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Specify which matrix is the current matrix. </summary>
        /// <param name="mode"> Specifies which matrix stack is the target for subsequent matrix operations. Three values are accepted: GL_MODELVIEW, GL_PROJECTION, and GL_TEXTURE. The initial value is GL_MODELVIEW. Additionally, if the ARB_imaging extension is supported, GL_COLOR is also accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml" /></remarks>
        public static void MatrixMode(MatrixMode mode) => _MatrixMode_fnptr(mode);
        [UnmanagedCallersOnly]
        private static void MatrixMode_Lazy(MatrixMode mode)
        {
            _MatrixMode_fnptr = (delegate* unmanaged<MatrixMode, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMode");
            _MatrixMode_fnptr(mode);
        }
        
        private static delegate* unmanaged<float*, void> _MultMatrixf_fnptr = &MultMatrixf_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix with the specified matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultMatrix.xml" /></remarks>
        public static void MultMatrixf(float* m) => _MultMatrixf_fnptr(m);
        [UnmanagedCallersOnly]
        private static void MultMatrixf_Lazy(float* m)
        {
            _MultMatrixf_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultMatrixf");
            _MultMatrixf_fnptr(m);
        }
        
        private static delegate* unmanaged<double*, void> _MultMatrixd_fnptr = &MultMatrixd_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix with the specified matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultMatrix.xml" /></remarks>
        public static void MultMatrixd(double* m) => _MultMatrixd_fnptr(m);
        [UnmanagedCallersOnly]
        private static void MultMatrixd_Lazy(double* m)
        {
            _MultMatrixd_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultMatrixd");
            _MultMatrixd_fnptr(m);
        }
        
        private static delegate* unmanaged<double, double, double, double, double, double, void> _Ortho_fnptr = &Ortho_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix with an orthographic matrix. </summary>
        /// <param name="left"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="right"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="bottom"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="top"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="nearVal"> Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer. </param>
        /// <param name="farVal"> Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml" /></remarks>
        public static void Ortho(double left, double right, double bottom, double top, double zNear, double zFar) => _Ortho_fnptr(left, right, bottom, top, zNear, zFar);
        [UnmanagedCallersOnly]
        private static void Ortho_Lazy(double left, double right, double bottom, double top, double zNear, double zFar)
        {
            _Ortho_fnptr = (delegate* unmanaged<double, double, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glOrtho");
            _Ortho_fnptr(left, right, bottom, top, zNear, zFar);
        }
        
        private static delegate* unmanaged<void> _PopMatrix_fnptr = &PopMatrix_Lazy;
        public static void PopMatrix() => _PopMatrix_fnptr();
        [UnmanagedCallersOnly]
        private static void PopMatrix_Lazy()
        {
            _PopMatrix_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPopMatrix");
            _PopMatrix_fnptr();
        }
        
        private static delegate* unmanaged<void> _PushMatrix_fnptr = &PushMatrix_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Push and pop the current matrix stack. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushMatrix.xml" /></remarks>
        public static void PushMatrix() => _PushMatrix_fnptr();
        [UnmanagedCallersOnly]
        private static void PushMatrix_Lazy()
        {
            _PushMatrix_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPushMatrix");
            _PushMatrix_fnptr();
        }
        
        private static delegate* unmanaged<double, double, double, double, void> _Rotated_fnptr = &Rotated_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix by a rotation matrix. </summary>
        /// <param name="angle"> Specifies the angle of rotation, in degrees. </param>
        /// <param name="x"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml" /></remarks>
        public static void Rotated(double angle, double x, double y, double z) => _Rotated_fnptr(angle, x, y, z);
        [UnmanagedCallersOnly]
        private static void Rotated_Lazy(double angle, double x, double y, double z)
        {
            _Rotated_fnptr = (delegate* unmanaged<double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glRotated");
            _Rotated_fnptr(angle, x, y, z);
        }
        
        private static delegate* unmanaged<float, float, float, float, void> _Rotatef_fnptr = &Rotatef_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix by a rotation matrix. </summary>
        /// <param name="angle"> Specifies the angle of rotation, in degrees. </param>
        /// <param name="x"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml" /></remarks>
        public static void Rotatef(float angle, float x, float y, float z) => _Rotatef_fnptr(angle, x, y, z);
        [UnmanagedCallersOnly]
        private static void Rotatef_Lazy(float angle, float x, float y, float z)
        {
            _Rotatef_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glRotatef");
            _Rotatef_fnptr(angle, x, y, z);
        }
        
        private static delegate* unmanaged<double, double, double, void> _Scaled_fnptr = &Scaled_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix by a general scaling matrix. </summary>
        /// <param name="x"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="y"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="z"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glScale.xml" /></remarks>
        public static void Scaled(double x, double y, double z) => _Scaled_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void Scaled_Lazy(double x, double y, double z)
        {
            _Scaled_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glScaled");
            _Scaled_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<float, float, float, void> _Scalef_fnptr = &Scalef_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix by a general scaling matrix. </summary>
        /// <param name="x"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="y"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="z"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glScale.xml" /></remarks>
        public static void Scalef(float x, float y, float z) => _Scalef_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void Scalef_Lazy(float x, float y, float z)
        {
            _Scalef_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glScalef");
            _Scalef_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<double, double, double, void> _Translated_fnptr = &Translated_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix by a translation matrix. </summary>
        /// <param name="x"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTranslate.xml" /></remarks>
        public static void Translated(double x, double y, double z) => _Translated_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void Translated_Lazy(double x, double y, double z)
        {
            _Translated_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glTranslated");
            _Translated_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<float, float, float, void> _Translatef_fnptr = &Translatef_Lazy;
        /// <summary> <b>[requires: v1.0]</b> Multiply the current matrix by a translation matrix. </summary>
        /// <param name="x"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTranslate.xml" /></remarks>
        public static void Translatef(float x, float y, float z) => _Translatef_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void Translatef_Lazy(float x, float y, float z)
        {
            _Translatef_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTranslatef");
            _Translatef_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<PrimitiveType, int, int, void> _DrawArrays_fnptr = &DrawArrays_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml" /></remarks>
        public static void DrawArrays(PrimitiveType mode, int first, int count) => _DrawArrays_fnptr(mode, first, count);
        [UnmanagedCallersOnly]
        private static void DrawArrays_Lazy(PrimitiveType mode, int first, int count)
        {
            _DrawArrays_fnptr = (delegate* unmanaged<PrimitiveType, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawArrays");
            _DrawArrays_fnptr(mode, first, count);
        }
        
        private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, void> _DrawElements_fnptr = &DrawElements_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElements.xhtml" /></remarks>
        public static void DrawElements(PrimitiveType mode, int count, DrawElementsType type, void* indices) => _DrawElements_fnptr(mode, count, type, indices);
        [UnmanagedCallersOnly]
        private static void DrawElements_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices)
        {
            _DrawElements_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElements");
            _DrawElements_fnptr(mode, count, type, indices);
        }
        
        private static delegate* unmanaged<GetPointervPName, void**, void> _GetPointerv_fnptr = &GetPointerv_Lazy;
        /// <summary> <b>[requires: v1.1 | v4.3 | GL_KHR_debug]</b> Return the address of the specified pointer. </summary>
        /// <param name="pname"> Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or GL_DEBUG_CALLBACK_USER_PARAM. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml" /></remarks>
        public static void GetPointerv(GetPointervPName pname, void** parameters) => _GetPointerv_fnptr(pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetPointerv_Lazy(GetPointervPName pname, void** parameters)
        {
            _GetPointerv_fnptr = (delegate* unmanaged<GetPointervPName, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetPointerv");
            _GetPointerv_fnptr(pname, parameters);
        }
        
        private static delegate* unmanaged<float, float, void> _PolygonOffset_fnptr = &PolygonOffset_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Set the scale and units used to calculate depth values. </summary>
        /// <param name="factor"> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </param>
        /// <param name="units"> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml" /></remarks>
        public static void PolygonOffset(float factor, float units) => _PolygonOffset_fnptr(factor, units);
        [UnmanagedCallersOnly]
        private static void PolygonOffset_Lazy(float factor, float units)
        {
            _PolygonOffset_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glPolygonOffset");
            _PolygonOffset_fnptr(factor, units);
        }
        
        private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, void> _CopyTexImage1D_fnptr = &CopyTexImage1D_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Copy pixels into a 1D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. The height of the texture image is 1. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage1D.xhtml" /></remarks>
        public static void CopyTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => _CopyTexImage1D_fnptr(target, level, internalformat, x, y, width, border);
        [UnmanagedCallersOnly]
        private static void CopyTexImage1D_Lazy(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border)
        {
            _CopyTexImage1D_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexImage1D");
            _CopyTexImage1D_fnptr(target, level, internalformat, x, y, width, border);
        }
        
        private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, void> _CopyTexImage2D_fnptr = &CopyTexImage2D_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Copy pixels into a 2D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. </param>
        /// <param name="height"> Specifies the height of the texture image. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage2D.xhtml" /></remarks>
        public static void CopyTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => _CopyTexImage2D_fnptr(target, level, internalformat, x, y, width, height, border);
        [UnmanagedCallersOnly]
        private static void CopyTexImage2D_Lazy(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border)
        {
            _CopyTexImage2D_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexImage2D");
            _CopyTexImage2D_fnptr(target, level, internalformat, x, y, width, height, border);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, int, void> _CopyTexSubImage1D_fnptr = &CopyTexSubImage1D_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Copy a one-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
        public static void CopyTexSubImage1D(TextureTarget target, int level, int xoffset, int x, int y, int width) => _CopyTexSubImage1D_fnptr(target, level, xoffset, x, y, width);
        [UnmanagedCallersOnly]
        private static void CopyTexSubImage1D_Lazy(TextureTarget target, int level, int xoffset, int x, int y, int width)
        {
            _CopyTexSubImage1D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexSubImage1D");
            _CopyTexSubImage1D_fnptr(target, level, xoffset, x, y, width);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, void> _CopyTexSubImage2D_fnptr = &CopyTexSubImage2D_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Copy a two-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
        public static void CopyTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyTexSubImage2D_fnptr(target, level, xoffset, yoffset, x, y, width, height);
        [UnmanagedCallersOnly]
        private static void CopyTexSubImage2D_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
        {
            _CopyTexSubImage2D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexSubImage2D");
            _CopyTexSubImage2D_fnptr(target, level, xoffset, yoffset, x, y, width, height);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, PixelFormat, PixelType, void*, void> _TexSubImage1D_fnptr = &TexSubImage1D_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Specify a one-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage1D. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
        public static void TexSubImage1D(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => _TexSubImage1D_fnptr(target, level, xoffset, width, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void TexSubImage1D_Lazy(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels)
        {
            _TexSubImage1D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexSubImage1D");
            _TexSubImage1D_fnptr(target, level, xoffset, width, format, type, pixels);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TexSubImage2D_fnptr = &TexSubImage2D_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Specify a two-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage2D. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
        public static void TexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => _TexSubImage2D_fnptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void TexSubImage2D_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels)
        {
            _TexSubImage2D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexSubImage2D");
            _TexSubImage2D_fnptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
        }
        
        private static delegate* unmanaged<TextureTarget, TextureHandle, void> _BindTexture_fnptr = &BindTexture_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Bind a named texture to a texturing target. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="texture"> Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTexture.xhtml" /></remarks>
        public static void BindTexture(TextureTarget target, TextureHandle texture) => _BindTexture_fnptr(target, texture);
        [UnmanagedCallersOnly]
        private static void BindTexture_Lazy(TextureTarget target, TextureHandle texture)
        {
            _BindTexture_fnptr = (delegate* unmanaged<TextureTarget, TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindTexture");
            _BindTexture_fnptr(target, texture);
        }
        
        private static delegate* unmanaged<int, TextureHandle*, void> _DeleteTextures_fnptr = &DeleteTextures_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Delete named textures. </summary>
        /// <param name="n"> Specifies the number of textures to be deleted. </param>
        /// <param name="textures"> Specifies an array of textures to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTextures.xhtml" /></remarks>
        public static void DeleteTextures(int n, TextureHandle* textures) => _DeleteTextures_fnptr(n, textures);
        [UnmanagedCallersOnly]
        private static void DeleteTextures_Lazy(int n, TextureHandle* textures)
        {
            _DeleteTextures_fnptr = (delegate* unmanaged<int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteTextures");
            _DeleteTextures_fnptr(n, textures);
        }
        
        private static delegate* unmanaged<int, TextureHandle*, void> _GenTextures_fnptr = &GenTextures_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Generate texture names. </summary>
        /// <param name="n"> Specifies the number of texture names to be generated. </param>
        /// <param name="textures"> Specifies an array in which the generated texture names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTextures.xhtml" /></remarks>
        public static void GenTextures(int n, TextureHandle* textures) => _GenTextures_fnptr(n, textures);
        [UnmanagedCallersOnly]
        private static void GenTextures_Lazy(int n, TextureHandle* textures)
        {
            _GenTextures_fnptr = (delegate* unmanaged<int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenTextures");
            _GenTextures_fnptr(n, textures);
        }
        
        private static delegate* unmanaged<TextureHandle, byte> _IsTexture_fnptr = &IsTexture_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Determine if a name corresponds to a texture. </summary>
        /// <param name="texture"> Specifies a value that may be the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTexture.xhtml" /></remarks>
        public static byte IsTexture(TextureHandle texture) => _IsTexture_fnptr(texture);
        [UnmanagedCallersOnly]
        private static byte IsTexture_Lazy(TextureHandle texture)
        {
            _IsTexture_fnptr = (delegate* unmanaged<TextureHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsTexture");
            return _IsTexture_fnptr(texture);
        }
        
        private static delegate* unmanaged<int, void> _ArrayElement_fnptr = &ArrayElement_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Render a vertex using the specified vertex array element. </summary>
        /// <param name="i"> Specifies an index into the enabled vertex data arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glArrayElement.xml" /></remarks>
        public static void ArrayElement(int i) => _ArrayElement_fnptr(i);
        [UnmanagedCallersOnly]
        private static void ArrayElement_Lazy(int i)
        {
            _ArrayElement_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glArrayElement");
            _ArrayElement_fnptr(i);
        }
        
        private static delegate* unmanaged<int, ColorPointerType, int, void*, void> _ColorPointer_fnptr = &ColorPointer_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Define an array of colors. </summary>
        /// <param name="size"> Specifies the number of components per color. Must be 3 or 4. The initial value is 4. </param>
        /// <param name="type"> Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first component of the first color element in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorPointer.xml" /></remarks>
        public static void ColorPointer(int size, ColorPointerType type, int stride, void* pointer) => _ColorPointer_fnptr(size, type, stride, pointer);
        [UnmanagedCallersOnly]
        private static void ColorPointer_Lazy(int size, ColorPointerType type, int stride, void* pointer)
        {
            _ColorPointer_fnptr = (delegate* unmanaged<int, ColorPointerType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glColorPointer");
            _ColorPointer_fnptr(size, type, stride, pointer);
        }
        
        private static delegate* unmanaged<EnableCap, void> _DisableClientState_fnptr = &DisableClientState_Lazy;
        public static void DisableClientState(EnableCap array) => _DisableClientState_fnptr(array);
        [UnmanagedCallersOnly]
        private static void DisableClientState_Lazy(EnableCap array)
        {
            _DisableClientState_fnptr = (delegate* unmanaged<EnableCap, void>)GLLoader.BindingsContext.GetProcAddress("glDisableClientState");
            _DisableClientState_fnptr(array);
        }
        
        private static delegate* unmanaged<int, void*, void> _EdgeFlagPointer_fnptr = &EdgeFlagPointer_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Define an array of edge flags. </summary>
        /// <param name="stride"> Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first edge flag in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEdgeFlagPointer.xml" /></remarks>
        public static void EdgeFlagPointer(int stride, void* pointer) => _EdgeFlagPointer_fnptr(stride, pointer);
        [UnmanagedCallersOnly]
        private static void EdgeFlagPointer_Lazy(int stride, void* pointer)
        {
            _EdgeFlagPointer_fnptr = (delegate* unmanaged<int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glEdgeFlagPointer");
            _EdgeFlagPointer_fnptr(stride, pointer);
        }
        
        private static delegate* unmanaged<EnableCap, void> _EnableClientState_fnptr = &EnableClientState_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Enable or disable client-side capability. </summary>
        /// <param name="cap"> Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnableClientState.xml" /></remarks>
        public static void EnableClientState(EnableCap array) => _EnableClientState_fnptr(array);
        [UnmanagedCallersOnly]
        private static void EnableClientState_Lazy(EnableCap array)
        {
            _EnableClientState_fnptr = (delegate* unmanaged<EnableCap, void>)GLLoader.BindingsContext.GetProcAddress("glEnableClientState");
            _EnableClientState_fnptr(array);
        }
        
        private static delegate* unmanaged<IndexPointerType, int, void*, void> _IndexPointer_fnptr = &IndexPointer_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Define an array of color indexes. </summary>
        /// <param name="type"> Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first index in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndexPointer.xml" /></remarks>
        public static void IndexPointer(IndexPointerType type, int stride, void* pointer) => _IndexPointer_fnptr(type, stride, pointer);
        [UnmanagedCallersOnly]
        private static void IndexPointer_Lazy(IndexPointerType type, int stride, void* pointer)
        {
            _IndexPointer_fnptr = (delegate* unmanaged<IndexPointerType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glIndexPointer");
            _IndexPointer_fnptr(type, stride, pointer);
        }
        
        private static delegate* unmanaged<InterleavedArrayFormat, int, void*, void> _InterleavedArrays_fnptr = &InterleavedArrays_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Simultaneously specify and enable several interleaved arrays. </summary>
        /// <param name="format"> Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted. </param>
        /// <param name="stride"> Specifies the offset in bytes between each aggregate array element. </param>
        /// <param name="pointer">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glInterleavedArrays.xml" /></remarks>
        public static void InterleavedArrays(InterleavedArrayFormat format, int stride, void* pointer) => _InterleavedArrays_fnptr(format, stride, pointer);
        [UnmanagedCallersOnly]
        private static void InterleavedArrays_Lazy(InterleavedArrayFormat format, int stride, void* pointer)
        {
            _InterleavedArrays_fnptr = (delegate* unmanaged<InterleavedArrayFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glInterleavedArrays");
            _InterleavedArrays_fnptr(format, stride, pointer);
        }
        
        private static delegate* unmanaged<NormalPointerType, int, void*, void> _NormalPointer_fnptr = &NormalPointer_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Define an array of normals. </summary>
        /// <param name="type"> Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormalPointer.xml" /></remarks>
        public static void NormalPointer(NormalPointerType type, int stride, void* pointer) => _NormalPointer_fnptr(type, stride, pointer);
        [UnmanagedCallersOnly]
        private static void NormalPointer_Lazy(NormalPointerType type, int stride, void* pointer)
        {
            _NormalPointer_fnptr = (delegate* unmanaged<NormalPointerType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glNormalPointer");
            _NormalPointer_fnptr(type, stride, pointer);
        }
        
        private static delegate* unmanaged<int, TexCoordPointerType, int, void*, void> _TexCoordPointer_fnptr = &TexCoordPointer_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Define an array of texture coordinates. </summary>
        /// <param name="size"> Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4. </param>
        /// <param name="type"> Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoordPointer.xml" /></remarks>
        public static void TexCoordPointer(int size, TexCoordPointerType type, int stride, void* pointer) => _TexCoordPointer_fnptr(size, type, stride, pointer);
        [UnmanagedCallersOnly]
        private static void TexCoordPointer_Lazy(int size, TexCoordPointerType type, int stride, void* pointer)
        {
            _TexCoordPointer_fnptr = (delegate* unmanaged<int, TexCoordPointerType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordPointer");
            _TexCoordPointer_fnptr(size, type, stride, pointer);
        }
        
        private static delegate* unmanaged<int, VertexPointerType, int, void*, void> _VertexPointer_fnptr = &VertexPointer_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Define an array of vertex data. </summary>
        /// <param name="size"> Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4. </param>
        /// <param name="type"> Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertexPointer.xml" /></remarks>
        public static void VertexPointer(int size, VertexPointerType type, int stride, void* pointer) => _VertexPointer_fnptr(size, type, stride, pointer);
        [UnmanagedCallersOnly]
        private static void VertexPointer_Lazy(int size, VertexPointerType type, int stride, void* pointer)
        {
            _VertexPointer_fnptr = (delegate* unmanaged<int, VertexPointerType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexPointer");
            _VertexPointer_fnptr(size, type, stride, pointer);
        }
        
        private static delegate* unmanaged<int, TextureHandle*, byte*, byte> _AreTexturesResident_fnptr = &AreTexturesResident_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Determine if textures are loaded in texture memory. </summary>
        /// <param name="n"> Specifies the number of textures to be queried. </param>
        /// <param name="textures"> Specifies an array containing the names of the textures to be queried. </param>
        /// <param name="residences"> Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glAreTexturesResident.xml" /></remarks>
        public static byte AreTexturesResident(int n, TextureHandle* textures, byte* residences) => _AreTexturesResident_fnptr(n, textures, residences);
        [UnmanagedCallersOnly]
        private static byte AreTexturesResident_Lazy(int n, TextureHandle* textures, byte* residences)
        {
            _AreTexturesResident_fnptr = (delegate* unmanaged<int, TextureHandle*, byte*, byte>)GLLoader.BindingsContext.GetProcAddress("glAreTexturesResident");
            return _AreTexturesResident_fnptr(n, textures, residences);
        }
        
        private static delegate* unmanaged<int, TextureHandle*, float*, void> _PrioritizeTextures_fnptr = &PrioritizeTextures_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Set texture residence priority. </summary>
        /// <param name="n"> Specifies the number of textures to be prioritized. </param>
        /// <param name="textures"> Specifies an array containing the names of the textures to be prioritized. </param>
        /// <param name="priorities"> Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPrioritizeTextures.xml" /></remarks>
        public static void PrioritizeTextures(int n, TextureHandle* textures, float* priorities) => _PrioritizeTextures_fnptr(n, textures, priorities);
        [UnmanagedCallersOnly]
        private static void PrioritizeTextures_Lazy(int n, TextureHandle* textures, float* priorities)
        {
            _PrioritizeTextures_fnptr = (delegate* unmanaged<int, TextureHandle*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPrioritizeTextures");
            _PrioritizeTextures_fnptr(n, textures, priorities);
        }
        
        private static delegate* unmanaged<byte, void> _Indexub_fnptr = &Indexub_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexub(byte c) => _Indexub_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexub_Lazy(byte c)
        {
            _Indexub_fnptr = (delegate* unmanaged<byte, void>)GLLoader.BindingsContext.GetProcAddress("glIndexub");
            _Indexub_fnptr(c);
        }
        
        private static delegate* unmanaged<byte*, void> _Indexubv_fnptr = &Indexubv_Lazy;
        public static void Indexubv(byte* c) => _Indexubv_fnptr(c);
        [UnmanagedCallersOnly]
        private static void Indexubv_Lazy(byte* c)
        {
            _Indexubv_fnptr = (delegate* unmanaged<byte*, void>)GLLoader.BindingsContext.GetProcAddress("glIndexubv");
            _Indexubv_fnptr(c);
        }
        
        private static delegate* unmanaged<void> _PopClientAttrib_fnptr = &PopClientAttrib_Lazy;
        public static void PopClientAttrib() => _PopClientAttrib_fnptr();
        [UnmanagedCallersOnly]
        private static void PopClientAttrib_Lazy()
        {
            _PopClientAttrib_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPopClientAttrib");
            _PopClientAttrib_fnptr();
        }
        
        private static delegate* unmanaged<ClientAttribMask, void> _PushClientAttrib_fnptr = &PushClientAttrib_Lazy;
        /// <summary> <b>[requires: v1.1]</b> Push and pop the client attribute stack. </summary>
        /// <param name="mask"> Specifies a mask that indicates which attributes to save. Values for mask are listed below. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushClientAttrib.xml" /></remarks>
        public static void PushClientAttrib(ClientAttribMask mask) => _PushClientAttrib_fnptr(mask);
        [UnmanagedCallersOnly]
        private static void PushClientAttrib_Lazy(ClientAttribMask mask)
        {
            _PushClientAttrib_fnptr = (delegate* unmanaged<ClientAttribMask, void>)GLLoader.BindingsContext.GetProcAddress("glPushClientAttrib");
            _PushClientAttrib_fnptr(mask);
        }
        
        private static delegate* unmanaged<PrimitiveType, uint, uint, int, DrawElementsType, void*, void> _DrawRangeElements_fnptr = &DrawRangeElements_Lazy;
        /// <summary> <b>[requires: v1.2]</b> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElements.xhtml" /></remarks>
        public static void DrawRangeElements(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => _DrawRangeElements_fnptr(mode, start, end, count, type, indices);
        [UnmanagedCallersOnly]
        private static void DrawRangeElements_Lazy(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices)
        {
            _DrawRangeElements_fnptr = (delegate* unmanaged<PrimitiveType, uint, uint, int, DrawElementsType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawRangeElements");
            _DrawRangeElements_fnptr(mode, start, end, count, type, indices);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TexImage3D_fnptr = &TexImage3D_Lazy;
        /// <summary> <b>[requires: v1.2]</b> Specify a three-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3D.xhtml" /></remarks>
        public static void TexImage3D(TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => _TexImage3D_fnptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void TexImage3D_Lazy(TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels)
        {
            _TexImage3D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage3D");
            _TexImage3D_fnptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TexSubImage3D_fnptr = &TexSubImage3D_Lazy;
        /// <summary> <b>[requires: v1.2]</b> Specify a three-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage3D. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
        public static void TexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => _TexSubImage3D_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void TexSubImage3D_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels)
        {
            _TexSubImage3D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexSubImage3D");
            _TexSubImage3D_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, int, void> _CopyTexSubImage3D_fnptr = &CopyTexSubImage3D_Lazy;
        /// <summary> <b>[requires: v1.2]</b> Copy a three-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage3D function. Must be GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
        public static void CopyTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTexSubImage3D_fnptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        [UnmanagedCallersOnly]
        private static void CopyTexSubImage3D_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
        {
            _CopyTexSubImage3D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexSubImage3D");
            _CopyTexSubImage3D_fnptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }
        
        private static delegate* unmanaged<TextureUnit, void> _ActiveTexture_fnptr = &ActiveTexture_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Select active texture unit. </summary>
        /// <param name="texture"> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from zero to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS minus one. The initial value is GL_TEXTURE0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveTexture.xhtml" /></remarks>
        public static void ActiveTexture(TextureUnit texture) => _ActiveTexture_fnptr(texture);
        [UnmanagedCallersOnly]
        private static void ActiveTexture_Lazy(TextureUnit texture)
        {
            _ActiveTexture_fnptr = (delegate* unmanaged<TextureUnit, void>)GLLoader.BindingsContext.GetProcAddress("glActiveTexture");
            _ActiveTexture_fnptr(texture);
        }
        
        private static delegate* unmanaged<float, byte, void> _SampleCoverage_fnptr = &SampleCoverage_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Specify multisample coverage parameters. </summary>
        /// <param name="value"> Specify a single floating-point sample coverage value. The value is clamped to the range 0 1 . The initial value is 1.0. </param>
        /// <param name="invert"> Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleCoverage.xhtml" /></remarks>
        public static void SampleCoverage(float value, byte invert) => _SampleCoverage_fnptr(value, invert);
        [UnmanagedCallersOnly]
        private static void SampleCoverage_Lazy(float value, byte invert)
        {
            _SampleCoverage_fnptr = (delegate* unmanaged<float, byte, void>)GLLoader.BindingsContext.GetProcAddress("glSampleCoverage");
            _SampleCoverage_fnptr(value, invert);
        }
        
        private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, void*, void> _CompressedTexImage3D_fnptr = &CompressedTexImage3D_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Specify a three-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage3D.xhtml" /></remarks>
        public static void CompressedTexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => _CompressedTexImage3D_fnptr(target, level, internalformat, width, height, depth, border, imageSize, data);
        [UnmanagedCallersOnly]
        private static void CompressedTexImage3D_Lazy(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
        {
            _CompressedTexImage3D_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexImage3D");
            _CompressedTexImage3D_fnptr(target, level, internalformat, width, height, depth, border, imageSize, data);
        }
        
        private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, void*, void> _CompressedTexImage2D_fnptr = &CompressedTexImage2D_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Specify a two-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage2D.xhtml" /></remarks>
        public static void CompressedTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => _CompressedTexImage2D_fnptr(target, level, internalformat, width, height, border, imageSize, data);
        [UnmanagedCallersOnly]
        private static void CompressedTexImage2D_Lazy(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
        {
            _CompressedTexImage2D_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexImage2D");
            _CompressedTexImage2D_fnptr(target, level, internalformat, width, height, border, imageSize, data);
        }
        
        private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, void*, void> _CompressedTexImage1D_fnptr = &CompressedTexImage1D_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Specify a one-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage1D.xhtml" /></remarks>
        public static void CompressedTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => _CompressedTexImage1D_fnptr(target, level, internalformat, width, border, imageSize, data);
        [UnmanagedCallersOnly]
        private static void CompressedTexImage1D_Lazy(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data)
        {
            _CompressedTexImage1D_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexImage1D");
            _CompressedTexImage1D_fnptr(target, level, internalformat, width, border, imageSize, data);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTexSubImage3D_fnptr = &CompressedTexSubImage3D_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage3D function. Must be GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
        public static void CompressedTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => _CompressedTexSubImage3D_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        [UnmanagedCallersOnly]
        private static void CompressedTexSubImage3D_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data)
        {
            _CompressedTexSubImage3D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexSubImage3D");
            _CompressedTexSubImage3D_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTexSubImage2D_fnptr = &CompressedTexSubImage2D_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
        public static void CompressedTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => _CompressedTexSubImage2D_fnptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        [UnmanagedCallersOnly]
        private static void CompressedTexSubImage2D_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data)
        {
            _CompressedTexSubImage2D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexSubImage2D");
            _CompressedTexSubImage2D_fnptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, int, InternalFormat, int, void*, void> _CompressedTexSubImage1D_fnptr = &CompressedTexSubImage1D_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="target">Specifies the target, to which the texture is bound, for glCompressedTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
        public static void CompressedTexSubImage1D(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => _CompressedTexSubImage1D_fnptr(target, level, xoffset, width, format, imageSize, data);
        [UnmanagedCallersOnly]
        private static void CompressedTexSubImage1D_Lazy(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data)
        {
            _CompressedTexSubImage1D_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexSubImage1D");
            _CompressedTexSubImage1D_fnptr(target, level, xoffset, width, format, imageSize, data);
        }
        
        private static delegate* unmanaged<TextureTarget, int, void*, void> _GetCompressedTexImage_fnptr = &GetCompressedTexImage_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetCompressedTexImage(TextureTarget target, int level, void* img) => _GetCompressedTexImage_fnptr(target, level, img);
        [UnmanagedCallersOnly]
        private static void GetCompressedTexImage_Lazy(TextureTarget target, int level, void* img)
        {
            _GetCompressedTexImage_fnptr = (delegate* unmanaged<TextureTarget, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCompressedTexImage");
            _GetCompressedTexImage_fnptr(target, level, img);
        }
        
        private static delegate* unmanaged<TextureUnit, void> _ClientActiveTexture_fnptr = &ClientActiveTexture_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Select active texture unit. </summary>
        /// <param name="texture"> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to the value of GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. The initial value is GL_TEXTURE0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClientActiveTexture.xml" /></remarks>
        public static void ClientActiveTexture(TextureUnit texture) => _ClientActiveTexture_fnptr(texture);
        [UnmanagedCallersOnly]
        private static void ClientActiveTexture_Lazy(TextureUnit texture)
        {
            _ClientActiveTexture_fnptr = (delegate* unmanaged<TextureUnit, void>)GLLoader.BindingsContext.GetProcAddress("glClientActiveTexture");
            _ClientActiveTexture_fnptr(texture);
        }
        
        private static delegate* unmanaged<TextureUnit, double, void> _MultiTexCoord1d_fnptr = &MultiTexCoord1d_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1d(TextureUnit target, double s) => _MultiTexCoord1d_fnptr(target, s);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord1d_Lazy(TextureUnit target, double s)
        {
            _MultiTexCoord1d_fnptr = (delegate* unmanaged<TextureUnit, double, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1d");
            _MultiTexCoord1d_fnptr(target, s);
        }
        
        private static delegate* unmanaged<TextureUnit, double*, void> _MultiTexCoord1dv_fnptr = &MultiTexCoord1dv_Lazy;
        public static void MultiTexCoord1dv(TextureUnit target, double* v) => _MultiTexCoord1dv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord1dv_Lazy(TextureUnit target, double* v)
        {
            _MultiTexCoord1dv_fnptr = (delegate* unmanaged<TextureUnit, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1dv");
            _MultiTexCoord1dv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, float, void> _MultiTexCoord1f_fnptr = &MultiTexCoord1f_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1f(TextureUnit target, float s) => _MultiTexCoord1f_fnptr(target, s);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord1f_Lazy(TextureUnit target, float s)
        {
            _MultiTexCoord1f_fnptr = (delegate* unmanaged<TextureUnit, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1f");
            _MultiTexCoord1f_fnptr(target, s);
        }
        
        private static delegate* unmanaged<TextureUnit, float*, void> _MultiTexCoord1fv_fnptr = &MultiTexCoord1fv_Lazy;
        public static void MultiTexCoord1fv(TextureUnit target, float* v) => _MultiTexCoord1fv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord1fv_Lazy(TextureUnit target, float* v)
        {
            _MultiTexCoord1fv_fnptr = (delegate* unmanaged<TextureUnit, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1fv");
            _MultiTexCoord1fv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, int, void> _MultiTexCoord1i_fnptr = &MultiTexCoord1i_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1i(TextureUnit target, int s) => _MultiTexCoord1i_fnptr(target, s);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord1i_Lazy(TextureUnit target, int s)
        {
            _MultiTexCoord1i_fnptr = (delegate* unmanaged<TextureUnit, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1i");
            _MultiTexCoord1i_fnptr(target, s);
        }
        
        private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord1iv_fnptr = &MultiTexCoord1iv_Lazy;
        public static void MultiTexCoord1iv(TextureUnit target, int* v) => _MultiTexCoord1iv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord1iv_Lazy(TextureUnit target, int* v)
        {
            _MultiTexCoord1iv_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1iv");
            _MultiTexCoord1iv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, short, void> _MultiTexCoord1s_fnptr = &MultiTexCoord1s_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1s(TextureUnit target, short s) => _MultiTexCoord1s_fnptr(target, s);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord1s_Lazy(TextureUnit target, short s)
        {
            _MultiTexCoord1s_fnptr = (delegate* unmanaged<TextureUnit, short, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1s");
            _MultiTexCoord1s_fnptr(target, s);
        }
        
        private static delegate* unmanaged<TextureUnit, short*, void> _MultiTexCoord1sv_fnptr = &MultiTexCoord1sv_Lazy;
        public static void MultiTexCoord1sv(TextureUnit target, short* v) => _MultiTexCoord1sv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord1sv_Lazy(TextureUnit target, short* v)
        {
            _MultiTexCoord1sv_fnptr = (delegate* unmanaged<TextureUnit, short*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1sv");
            _MultiTexCoord1sv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, double, double, void> _MultiTexCoord2d_fnptr = &MultiTexCoord2d_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2d(TextureUnit target, double s, double t) => _MultiTexCoord2d_fnptr(target, s, t);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord2d_Lazy(TextureUnit target, double s, double t)
        {
            _MultiTexCoord2d_fnptr = (delegate* unmanaged<TextureUnit, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2d");
            _MultiTexCoord2d_fnptr(target, s, t);
        }
        
        private static delegate* unmanaged<TextureUnit, double*, void> _MultiTexCoord2dv_fnptr = &MultiTexCoord2dv_Lazy;
        public static void MultiTexCoord2dv(TextureUnit target, double* v) => _MultiTexCoord2dv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord2dv_Lazy(TextureUnit target, double* v)
        {
            _MultiTexCoord2dv_fnptr = (delegate* unmanaged<TextureUnit, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2dv");
            _MultiTexCoord2dv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, float, float, void> _MultiTexCoord2f_fnptr = &MultiTexCoord2f_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2f(TextureUnit target, float s, float t) => _MultiTexCoord2f_fnptr(target, s, t);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord2f_Lazy(TextureUnit target, float s, float t)
        {
            _MultiTexCoord2f_fnptr = (delegate* unmanaged<TextureUnit, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2f");
            _MultiTexCoord2f_fnptr(target, s, t);
        }
        
        private static delegate* unmanaged<TextureUnit, float*, void> _MultiTexCoord2fv_fnptr = &MultiTexCoord2fv_Lazy;
        public static void MultiTexCoord2fv(TextureUnit target, float* v) => _MultiTexCoord2fv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord2fv_Lazy(TextureUnit target, float* v)
        {
            _MultiTexCoord2fv_fnptr = (delegate* unmanaged<TextureUnit, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2fv");
            _MultiTexCoord2fv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, int, int, void> _MultiTexCoord2i_fnptr = &MultiTexCoord2i_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2i(TextureUnit target, int s, int t) => _MultiTexCoord2i_fnptr(target, s, t);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord2i_Lazy(TextureUnit target, int s, int t)
        {
            _MultiTexCoord2i_fnptr = (delegate* unmanaged<TextureUnit, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2i");
            _MultiTexCoord2i_fnptr(target, s, t);
        }
        
        private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord2iv_fnptr = &MultiTexCoord2iv_Lazy;
        public static void MultiTexCoord2iv(TextureUnit target, int* v) => _MultiTexCoord2iv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord2iv_Lazy(TextureUnit target, int* v)
        {
            _MultiTexCoord2iv_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2iv");
            _MultiTexCoord2iv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, short, short, void> _MultiTexCoord2s_fnptr = &MultiTexCoord2s_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2s(TextureUnit target, short s, short t) => _MultiTexCoord2s_fnptr(target, s, t);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord2s_Lazy(TextureUnit target, short s, short t)
        {
            _MultiTexCoord2s_fnptr = (delegate* unmanaged<TextureUnit, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2s");
            _MultiTexCoord2s_fnptr(target, s, t);
        }
        
        private static delegate* unmanaged<TextureUnit, short*, void> _MultiTexCoord2sv_fnptr = &MultiTexCoord2sv_Lazy;
        public static void MultiTexCoord2sv(TextureUnit target, short* v) => _MultiTexCoord2sv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord2sv_Lazy(TextureUnit target, short* v)
        {
            _MultiTexCoord2sv_fnptr = (delegate* unmanaged<TextureUnit, short*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2sv");
            _MultiTexCoord2sv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, double, double, double, void> _MultiTexCoord3d_fnptr = &MultiTexCoord3d_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3d(TextureUnit target, double s, double t, double r) => _MultiTexCoord3d_fnptr(target, s, t, r);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord3d_Lazy(TextureUnit target, double s, double t, double r)
        {
            _MultiTexCoord3d_fnptr = (delegate* unmanaged<TextureUnit, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3d");
            _MultiTexCoord3d_fnptr(target, s, t, r);
        }
        
        private static delegate* unmanaged<TextureUnit, double*, void> _MultiTexCoord3dv_fnptr = &MultiTexCoord3dv_Lazy;
        public static void MultiTexCoord3dv(TextureUnit target, double* v) => _MultiTexCoord3dv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord3dv_Lazy(TextureUnit target, double* v)
        {
            _MultiTexCoord3dv_fnptr = (delegate* unmanaged<TextureUnit, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3dv");
            _MultiTexCoord3dv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, float, float, float, void> _MultiTexCoord3f_fnptr = &MultiTexCoord3f_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3f(TextureUnit target, float s, float t, float r) => _MultiTexCoord3f_fnptr(target, s, t, r);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord3f_Lazy(TextureUnit target, float s, float t, float r)
        {
            _MultiTexCoord3f_fnptr = (delegate* unmanaged<TextureUnit, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3f");
            _MultiTexCoord3f_fnptr(target, s, t, r);
        }
        
        private static delegate* unmanaged<TextureUnit, float*, void> _MultiTexCoord3fv_fnptr = &MultiTexCoord3fv_Lazy;
        public static void MultiTexCoord3fv(TextureUnit target, float* v) => _MultiTexCoord3fv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord3fv_Lazy(TextureUnit target, float* v)
        {
            _MultiTexCoord3fv_fnptr = (delegate* unmanaged<TextureUnit, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3fv");
            _MultiTexCoord3fv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, int, int, int, void> _MultiTexCoord3i_fnptr = &MultiTexCoord3i_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3i(TextureUnit target, int s, int t, int r) => _MultiTexCoord3i_fnptr(target, s, t, r);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord3i_Lazy(TextureUnit target, int s, int t, int r)
        {
            _MultiTexCoord3i_fnptr = (delegate* unmanaged<TextureUnit, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3i");
            _MultiTexCoord3i_fnptr(target, s, t, r);
        }
        
        private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord3iv_fnptr = &MultiTexCoord3iv_Lazy;
        public static void MultiTexCoord3iv(TextureUnit target, int* v) => _MultiTexCoord3iv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord3iv_Lazy(TextureUnit target, int* v)
        {
            _MultiTexCoord3iv_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3iv");
            _MultiTexCoord3iv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, short, short, short, void> _MultiTexCoord3s_fnptr = &MultiTexCoord3s_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3s(TextureUnit target, short s, short t, short r) => _MultiTexCoord3s_fnptr(target, s, t, r);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord3s_Lazy(TextureUnit target, short s, short t, short r)
        {
            _MultiTexCoord3s_fnptr = (delegate* unmanaged<TextureUnit, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3s");
            _MultiTexCoord3s_fnptr(target, s, t, r);
        }
        
        private static delegate* unmanaged<TextureUnit, short*, void> _MultiTexCoord3sv_fnptr = &MultiTexCoord3sv_Lazy;
        public static void MultiTexCoord3sv(TextureUnit target, short* v) => _MultiTexCoord3sv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord3sv_Lazy(TextureUnit target, short* v)
        {
            _MultiTexCoord3sv_fnptr = (delegate* unmanaged<TextureUnit, short*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3sv");
            _MultiTexCoord3sv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, double, double, double, double, void> _MultiTexCoord4d_fnptr = &MultiTexCoord4d_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4d(TextureUnit target, double s, double t, double r, double q) => _MultiTexCoord4d_fnptr(target, s, t, r, q);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord4d_Lazy(TextureUnit target, double s, double t, double r, double q)
        {
            _MultiTexCoord4d_fnptr = (delegate* unmanaged<TextureUnit, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4d");
            _MultiTexCoord4d_fnptr(target, s, t, r, q);
        }
        
        private static delegate* unmanaged<TextureUnit, double*, void> _MultiTexCoord4dv_fnptr = &MultiTexCoord4dv_Lazy;
        public static void MultiTexCoord4dv(TextureUnit target, double* v) => _MultiTexCoord4dv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord4dv_Lazy(TextureUnit target, double* v)
        {
            _MultiTexCoord4dv_fnptr = (delegate* unmanaged<TextureUnit, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4dv");
            _MultiTexCoord4dv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, float, float, float, float, void> _MultiTexCoord4f_fnptr = &MultiTexCoord4f_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4f(TextureUnit target, float s, float t, float r, float q) => _MultiTexCoord4f_fnptr(target, s, t, r, q);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord4f_Lazy(TextureUnit target, float s, float t, float r, float q)
        {
            _MultiTexCoord4f_fnptr = (delegate* unmanaged<TextureUnit, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4f");
            _MultiTexCoord4f_fnptr(target, s, t, r, q);
        }
        
        private static delegate* unmanaged<TextureUnit, float*, void> _MultiTexCoord4fv_fnptr = &MultiTexCoord4fv_Lazy;
        public static void MultiTexCoord4fv(TextureUnit target, float* v) => _MultiTexCoord4fv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord4fv_Lazy(TextureUnit target, float* v)
        {
            _MultiTexCoord4fv_fnptr = (delegate* unmanaged<TextureUnit, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4fv");
            _MultiTexCoord4fv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, int, int, int, int, void> _MultiTexCoord4i_fnptr = &MultiTexCoord4i_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4i(TextureUnit target, int s, int t, int r, int q) => _MultiTexCoord4i_fnptr(target, s, t, r, q);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord4i_Lazy(TextureUnit target, int s, int t, int r, int q)
        {
            _MultiTexCoord4i_fnptr = (delegate* unmanaged<TextureUnit, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4i");
            _MultiTexCoord4i_fnptr(target, s, t, r, q);
        }
        
        private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord4iv_fnptr = &MultiTexCoord4iv_Lazy;
        public static void MultiTexCoord4iv(TextureUnit target, int* v) => _MultiTexCoord4iv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord4iv_Lazy(TextureUnit target, int* v)
        {
            _MultiTexCoord4iv_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4iv");
            _MultiTexCoord4iv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<TextureUnit, short, short, short, short, void> _MultiTexCoord4s_fnptr = &MultiTexCoord4s_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4s(TextureUnit target, short s, short t, short r, short q) => _MultiTexCoord4s_fnptr(target, s, t, r, q);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord4s_Lazy(TextureUnit target, short s, short t, short r, short q)
        {
            _MultiTexCoord4s_fnptr = (delegate* unmanaged<TextureUnit, short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4s");
            _MultiTexCoord4s_fnptr(target, s, t, r, q);
        }
        
        private static delegate* unmanaged<TextureUnit, short*, void> _MultiTexCoord4sv_fnptr = &MultiTexCoord4sv_Lazy;
        public static void MultiTexCoord4sv(TextureUnit target, short* v) => _MultiTexCoord4sv_fnptr(target, v);
        [UnmanagedCallersOnly]
        private static void MultiTexCoord4sv_Lazy(TextureUnit target, short* v)
        {
            _MultiTexCoord4sv_fnptr = (delegate* unmanaged<TextureUnit, short*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4sv");
            _MultiTexCoord4sv_fnptr(target, v);
        }
        
        private static delegate* unmanaged<float*, void> _LoadTransposeMatrixf_fnptr = &LoadTransposeMatrixf_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Replace the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadTransposeMatrix.xml" /></remarks>
        public static void LoadTransposeMatrixf(float* m) => _LoadTransposeMatrixf_fnptr(m);
        [UnmanagedCallersOnly]
        private static void LoadTransposeMatrixf_Lazy(float* m)
        {
            _LoadTransposeMatrixf_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glLoadTransposeMatrixf");
            _LoadTransposeMatrixf_fnptr(m);
        }
        
        private static delegate* unmanaged<double*, void> _LoadTransposeMatrixd_fnptr = &LoadTransposeMatrixd_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Replace the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadTransposeMatrix.xml" /></remarks>
        public static void LoadTransposeMatrixd(double* m) => _LoadTransposeMatrixd_fnptr(m);
        [UnmanagedCallersOnly]
        private static void LoadTransposeMatrixd_Lazy(double* m)
        {
            _LoadTransposeMatrixd_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glLoadTransposeMatrixd");
            _LoadTransposeMatrixd_fnptr(m);
        }
        
        private static delegate* unmanaged<float*, void> _MultTransposeMatrixf_fnptr = &MultTransposeMatrixf_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Multiply the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultTransposeMatrix.xml" /></remarks>
        public static void MultTransposeMatrixf(float* m) => _MultTransposeMatrixf_fnptr(m);
        [UnmanagedCallersOnly]
        private static void MultTransposeMatrixf_Lazy(float* m)
        {
            _MultTransposeMatrixf_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultTransposeMatrixf");
            _MultTransposeMatrixf_fnptr(m);
        }
        
        private static delegate* unmanaged<double*, void> _MultTransposeMatrixd_fnptr = &MultTransposeMatrixd_Lazy;
        /// <summary> <b>[requires: v1.3]</b> Multiply the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultTransposeMatrix.xml" /></remarks>
        public static void MultTransposeMatrixd(double* m) => _MultTransposeMatrixd_fnptr(m);
        [UnmanagedCallersOnly]
        private static void MultTransposeMatrixd_Lazy(double* m)
        {
            _MultTransposeMatrixd_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultTransposeMatrixd");
            _MultTransposeMatrixd_fnptr(m);
        }
        
        private static delegate* unmanaged<BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void> _BlendFuncSeparate_fnptr = &BlendFuncSeparate_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="srcRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dstRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="srcAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dstAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml" /></remarks>
        public static void BlendFuncSeparate(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => _BlendFuncSeparate_fnptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        [UnmanagedCallersOnly]
        private static void BlendFuncSeparate_Lazy(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha)
        {
            _BlendFuncSeparate_fnptr = (delegate* unmanaged<BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFuncSeparate");
            _BlendFuncSeparate_fnptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        }
        
        private static delegate* unmanaged<PrimitiveType, int*, int*, int, void> _MultiDrawArrays_fnptr = &MultiDrawArrays_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Render multiple sets of primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Points to an array of starting indices in the enabled arrays. </param>
        /// <param name="count"> Points to an array of the number of indices to be rendered. </param>
        /// <param name="drawcount"> Specifies the size of the first and count </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArrays.xhtml" /></remarks>
        public static void MultiDrawArrays(PrimitiveType mode, int* first, int* count, int drawcount) => _MultiDrawArrays_fnptr(mode, first, count, drawcount);
        [UnmanagedCallersOnly]
        private static void MultiDrawArrays_Lazy(PrimitiveType mode, int* first, int* count, int drawcount)
        {
            _MultiDrawArrays_fnptr = (delegate* unmanaged<PrimitiveType, int*, int*, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawArrays");
            _MultiDrawArrays_fnptr(mode, first, count, drawcount);
        }
        
        private static delegate* unmanaged<PrimitiveType, int*, DrawElementsType, void**, int, void> _MultiDrawElements_fnptr = &MultiDrawElements_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Render multiple sets of primitives by specifying indices of array data elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count and indices arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElements.xhtml" /></remarks>
        public static void MultiDrawElements(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount) => _MultiDrawElements_fnptr(mode, count, type, indices, drawcount);
        [UnmanagedCallersOnly]
        private static void MultiDrawElements_Lazy(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount)
        {
            _MultiDrawElements_fnptr = (delegate* unmanaged<PrimitiveType, int*, DrawElementsType, void**, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElements");
            _MultiDrawElements_fnptr(mode, count, type, indices, drawcount);
        }
        
        private static delegate* unmanaged<PointParameterNameARB, float, void> _PointParameterf_fnptr = &PointParameterf_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameterf(PointParameterNameARB pname, float param) => _PointParameterf_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void PointParameterf_Lazy(PointParameterNameARB pname, float param)
        {
            _PointParameterf_fnptr = (delegate* unmanaged<PointParameterNameARB, float, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterf");
            _PointParameterf_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<PointParameterNameARB, float*, void> _PointParameterfv_fnptr = &PointParameterfv_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameterfv(PointParameterNameARB pname, float* parameters) => _PointParameterfv_fnptr(pname, parameters);
        [UnmanagedCallersOnly]
        private static void PointParameterfv_Lazy(PointParameterNameARB pname, float* parameters)
        {
            _PointParameterfv_fnptr = (delegate* unmanaged<PointParameterNameARB, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterfv");
            _PointParameterfv_fnptr(pname, parameters);
        }
        
        private static delegate* unmanaged<PointParameterNameARB, int, void> _PointParameteri_fnptr = &PointParameteri_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameteri(PointParameterNameARB pname, int param) => _PointParameteri_fnptr(pname, param);
        [UnmanagedCallersOnly]
        private static void PointParameteri_Lazy(PointParameterNameARB pname, int param)
        {
            _PointParameteri_fnptr = (delegate* unmanaged<PointParameterNameARB, int, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameteri");
            _PointParameteri_fnptr(pname, param);
        }
        
        private static delegate* unmanaged<PointParameterNameARB, int*, void> _PointParameteriv_fnptr = &PointParameteriv_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameteriv(PointParameterNameARB pname, int* parameters) => _PointParameteriv_fnptr(pname, parameters);
        [UnmanagedCallersOnly]
        private static void PointParameteriv_Lazy(PointParameterNameARB pname, int* parameters)
        {
            _PointParameteriv_fnptr = (delegate* unmanaged<PointParameterNameARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameteriv");
            _PointParameteriv_fnptr(pname, parameters);
        }
        
        private static delegate* unmanaged<float, void> _FogCoordf_fnptr = &FogCoordf_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current fog coordinates. </summary>
        /// <param name="coord"> Specify the fog distance. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFogCoord.xml" /></remarks>
        public static void FogCoordf(float coord) => _FogCoordf_fnptr(coord);
        [UnmanagedCallersOnly]
        private static void FogCoordf_Lazy(float coord)
        {
            _FogCoordf_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordf");
            _FogCoordf_fnptr(coord);
        }
        
        private static delegate* unmanaged<float*, void> _FogCoordfv_fnptr = &FogCoordfv_Lazy;
        public static void FogCoordfv(float* coord) => _FogCoordfv_fnptr(coord);
        [UnmanagedCallersOnly]
        private static void FogCoordfv_Lazy(float* coord)
        {
            _FogCoordfv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordfv");
            _FogCoordfv_fnptr(coord);
        }
        
        private static delegate* unmanaged<double, void> _FogCoordd_fnptr = &FogCoordd_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current fog coordinates. </summary>
        /// <param name="coord"> Specify the fog distance. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFogCoord.xml" /></remarks>
        public static void FogCoordd(double coord) => _FogCoordd_fnptr(coord);
        [UnmanagedCallersOnly]
        private static void FogCoordd_Lazy(double coord)
        {
            _FogCoordd_fnptr = (delegate* unmanaged<double, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordd");
            _FogCoordd_fnptr(coord);
        }
        
        private static delegate* unmanaged<double*, void> _FogCoorddv_fnptr = &FogCoorddv_Lazy;
        public static void FogCoorddv(double* coord) => _FogCoorddv_fnptr(coord);
        [UnmanagedCallersOnly]
        private static void FogCoorddv_Lazy(double* coord)
        {
            _FogCoorddv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoorddv");
            _FogCoorddv_fnptr(coord);
        }
        
        private static delegate* unmanaged<FogPointerTypeEXT, int, void*, void> _FogCoordPointer_fnptr = &FogCoordPointer_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Define an array of fog coordinates. </summary>
        /// <param name="type"> Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFogCoordPointer.xml" /></remarks>
        public static void FogCoordPointer(FogPointerTypeEXT type, int stride, void* pointer) => _FogCoordPointer_fnptr(type, stride, pointer);
        [UnmanagedCallersOnly]
        private static void FogCoordPointer_Lazy(FogPointerTypeEXT type, int stride, void* pointer)
        {
            _FogCoordPointer_fnptr = (delegate* unmanaged<FogPointerTypeEXT, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordPointer");
            _FogCoordPointer_fnptr(type, stride, pointer);
        }
        
        private static delegate* unmanaged<sbyte, sbyte, sbyte, void> _SecondaryColor3b_fnptr = &SecondaryColor3b_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3b(sbyte red, sbyte green, sbyte blue) => _SecondaryColor3b_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3b_Lazy(sbyte red, sbyte green, sbyte blue)
        {
            _SecondaryColor3b_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3b");
            _SecondaryColor3b_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<sbyte*, void> _SecondaryColor3bv_fnptr = &SecondaryColor3bv_Lazy;
        public static void SecondaryColor3bv(sbyte* v) => _SecondaryColor3bv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3bv_Lazy(sbyte* v)
        {
            _SecondaryColor3bv_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3bv");
            _SecondaryColor3bv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, void> _SecondaryColor3d_fnptr = &SecondaryColor3d_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3d(double red, double green, double blue) => _SecondaryColor3d_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3d_Lazy(double red, double green, double blue)
        {
            _SecondaryColor3d_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3d");
            _SecondaryColor3d_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<double*, void> _SecondaryColor3dv_fnptr = &SecondaryColor3dv_Lazy;
        public static void SecondaryColor3dv(double* v) => _SecondaryColor3dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3dv_Lazy(double* v)
        {
            _SecondaryColor3dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3dv");
            _SecondaryColor3dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, void> _SecondaryColor3f_fnptr = &SecondaryColor3f_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3f(float red, float green, float blue) => _SecondaryColor3f_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3f_Lazy(float red, float green, float blue)
        {
            _SecondaryColor3f_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3f");
            _SecondaryColor3f_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<float*, void> _SecondaryColor3fv_fnptr = &SecondaryColor3fv_Lazy;
        public static void SecondaryColor3fv(float* v) => _SecondaryColor3fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3fv_Lazy(float* v)
        {
            _SecondaryColor3fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3fv");
            _SecondaryColor3fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, void> _SecondaryColor3i_fnptr = &SecondaryColor3i_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3i(int red, int green, int blue) => _SecondaryColor3i_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3i_Lazy(int red, int green, int blue)
        {
            _SecondaryColor3i_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3i");
            _SecondaryColor3i_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<int*, void> _SecondaryColor3iv_fnptr = &SecondaryColor3iv_Lazy;
        public static void SecondaryColor3iv(int* v) => _SecondaryColor3iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3iv_Lazy(int* v)
        {
            _SecondaryColor3iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3iv");
            _SecondaryColor3iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, void> _SecondaryColor3s_fnptr = &SecondaryColor3s_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3s(short red, short green, short blue) => _SecondaryColor3s_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3s_Lazy(short red, short green, short blue)
        {
            _SecondaryColor3s_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3s");
            _SecondaryColor3s_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<short*, void> _SecondaryColor3sv_fnptr = &SecondaryColor3sv_Lazy;
        public static void SecondaryColor3sv(short* v) => _SecondaryColor3sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3sv_Lazy(short* v)
        {
            _SecondaryColor3sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3sv");
            _SecondaryColor3sv_fnptr(v);
        }
        
        private static delegate* unmanaged<byte, byte, byte, void> _SecondaryColor3ub_fnptr = &SecondaryColor3ub_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3ub(byte red, byte green, byte blue) => _SecondaryColor3ub_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3ub_Lazy(byte red, byte green, byte blue)
        {
            _SecondaryColor3ub_fnptr = (delegate* unmanaged<byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3ub");
            _SecondaryColor3ub_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<byte*, void> _SecondaryColor3ubv_fnptr = &SecondaryColor3ubv_Lazy;
        public static void SecondaryColor3ubv(byte* v) => _SecondaryColor3ubv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3ubv_Lazy(byte* v)
        {
            _SecondaryColor3ubv_fnptr = (delegate* unmanaged<byte*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3ubv");
            _SecondaryColor3ubv_fnptr(v);
        }
        
        private static delegate* unmanaged<uint, uint, uint, void> _SecondaryColor3ui_fnptr = &SecondaryColor3ui_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3ui(uint red, uint green, uint blue) => _SecondaryColor3ui_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3ui_Lazy(uint red, uint green, uint blue)
        {
            _SecondaryColor3ui_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3ui");
            _SecondaryColor3ui_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<uint*, void> _SecondaryColor3uiv_fnptr = &SecondaryColor3uiv_Lazy;
        public static void SecondaryColor3uiv(uint* v) => _SecondaryColor3uiv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3uiv_Lazy(uint* v)
        {
            _SecondaryColor3uiv_fnptr = (delegate* unmanaged<uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3uiv");
            _SecondaryColor3uiv_fnptr(v);
        }
        
        private static delegate* unmanaged<ushort, ushort, ushort, void> _SecondaryColor3us_fnptr = &SecondaryColor3us_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3us(ushort red, ushort green, ushort blue) => _SecondaryColor3us_fnptr(red, green, blue);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3us_Lazy(ushort red, ushort green, ushort blue)
        {
            _SecondaryColor3us_fnptr = (delegate* unmanaged<ushort, ushort, ushort, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3us");
            _SecondaryColor3us_fnptr(red, green, blue);
        }
        
        private static delegate* unmanaged<ushort*, void> _SecondaryColor3usv_fnptr = &SecondaryColor3usv_Lazy;
        public static void SecondaryColor3usv(ushort* v) => _SecondaryColor3usv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void SecondaryColor3usv_Lazy(ushort* v)
        {
            _SecondaryColor3usv_fnptr = (delegate* unmanaged<ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3usv");
            _SecondaryColor3usv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, ColorPointerType, int, void*, void> _SecondaryColorPointer_fnptr = &SecondaryColorPointer_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Define an array of secondary colors. </summary>
        /// <param name="size"> Specifies the number of components per color. Must be 3. </param>
        /// <param name="type"> Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first component of the first color element in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColorPointer.xml" /></remarks>
        public static void SecondaryColorPointer(int size, ColorPointerType type, int stride, void* pointer) => _SecondaryColorPointer_fnptr(size, type, stride, pointer);
        [UnmanagedCallersOnly]
        private static void SecondaryColorPointer_Lazy(int size, ColorPointerType type, int stride, void* pointer)
        {
            _SecondaryColorPointer_fnptr = (delegate* unmanaged<int, ColorPointerType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColorPointer");
            _SecondaryColorPointer_fnptr(size, type, stride, pointer);
        }
        
        private static delegate* unmanaged<double, double, void> _WindowPos2d_fnptr = &WindowPos2d_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2d(double x, double y) => _WindowPos2d_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void WindowPos2d_Lazy(double x, double y)
        {
            _WindowPos2d_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2d");
            _WindowPos2d_fnptr(x, y);
        }
        
        private static delegate* unmanaged<double*, void> _WindowPos2dv_fnptr = &WindowPos2dv_Lazy;
        public static void WindowPos2dv(double* v) => _WindowPos2dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void WindowPos2dv_Lazy(double* v)
        {
            _WindowPos2dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2dv");
            _WindowPos2dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, void> _WindowPos2f_fnptr = &WindowPos2f_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2f(float x, float y) => _WindowPos2f_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void WindowPos2f_Lazy(float x, float y)
        {
            _WindowPos2f_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2f");
            _WindowPos2f_fnptr(x, y);
        }
        
        private static delegate* unmanaged<float*, void> _WindowPos2fv_fnptr = &WindowPos2fv_Lazy;
        public static void WindowPos2fv(float* v) => _WindowPos2fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void WindowPos2fv_Lazy(float* v)
        {
            _WindowPos2fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2fv");
            _WindowPos2fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, void> _WindowPos2i_fnptr = &WindowPos2i_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2i(int x, int y) => _WindowPos2i_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void WindowPos2i_Lazy(int x, int y)
        {
            _WindowPos2i_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2i");
            _WindowPos2i_fnptr(x, y);
        }
        
        private static delegate* unmanaged<int*, void> _WindowPos2iv_fnptr = &WindowPos2iv_Lazy;
        public static void WindowPos2iv(int* v) => _WindowPos2iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void WindowPos2iv_Lazy(int* v)
        {
            _WindowPos2iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2iv");
            _WindowPos2iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, void> _WindowPos2s_fnptr = &WindowPos2s_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2s(short x, short y) => _WindowPos2s_fnptr(x, y);
        [UnmanagedCallersOnly]
        private static void WindowPos2s_Lazy(short x, short y)
        {
            _WindowPos2s_fnptr = (delegate* unmanaged<short, short, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2s");
            _WindowPos2s_fnptr(x, y);
        }
        
        private static delegate* unmanaged<short*, void> _WindowPos2sv_fnptr = &WindowPos2sv_Lazy;
        public static void WindowPos2sv(short* v) => _WindowPos2sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void WindowPos2sv_Lazy(short* v)
        {
            _WindowPos2sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2sv");
            _WindowPos2sv_fnptr(v);
        }
        
        private static delegate* unmanaged<double, double, double, void> _WindowPos3d_fnptr = &WindowPos3d_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3d(double x, double y, double z) => _WindowPos3d_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void WindowPos3d_Lazy(double x, double y, double z)
        {
            _WindowPos3d_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3d");
            _WindowPos3d_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<double*, void> _WindowPos3dv_fnptr = &WindowPos3dv_Lazy;
        public static void WindowPos3dv(double* v) => _WindowPos3dv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void WindowPos3dv_Lazy(double* v)
        {
            _WindowPos3dv_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3dv");
            _WindowPos3dv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, void> _WindowPos3f_fnptr = &WindowPos3f_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3f(float x, float y, float z) => _WindowPos3f_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void WindowPos3f_Lazy(float x, float y, float z)
        {
            _WindowPos3f_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3f");
            _WindowPos3f_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<float*, void> _WindowPos3fv_fnptr = &WindowPos3fv_Lazy;
        public static void WindowPos3fv(float* v) => _WindowPos3fv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void WindowPos3fv_Lazy(float* v)
        {
            _WindowPos3fv_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3fv");
            _WindowPos3fv_fnptr(v);
        }
        
        private static delegate* unmanaged<int, int, int, void> _WindowPos3i_fnptr = &WindowPos3i_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3i(int x, int y, int z) => _WindowPos3i_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void WindowPos3i_Lazy(int x, int y, int z)
        {
            _WindowPos3i_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3i");
            _WindowPos3i_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<int*, void> _WindowPos3iv_fnptr = &WindowPos3iv_Lazy;
        public static void WindowPos3iv(int* v) => _WindowPos3iv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void WindowPos3iv_Lazy(int* v)
        {
            _WindowPos3iv_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3iv");
            _WindowPos3iv_fnptr(v);
        }
        
        private static delegate* unmanaged<short, short, short, void> _WindowPos3s_fnptr = &WindowPos3s_Lazy;
        /// <summary> <b>[requires: v1.4]</b> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3s(short x, short y, short z) => _WindowPos3s_fnptr(x, y, z);
        [UnmanagedCallersOnly]
        private static void WindowPos3s_Lazy(short x, short y, short z)
        {
            _WindowPos3s_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3s");
            _WindowPos3s_fnptr(x, y, z);
        }
        
        private static delegate* unmanaged<short*, void> _WindowPos3sv_fnptr = &WindowPos3sv_Lazy;
        public static void WindowPos3sv(short* v) => _WindowPos3sv_fnptr(v);
        [UnmanagedCallersOnly]
        private static void WindowPos3sv_Lazy(short* v)
        {
            _WindowPos3sv_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3sv");
            _WindowPos3sv_fnptr(v);
        }
        
        private static delegate* unmanaged<float, float, float, float, void> _BlendColor_fnptr = &BlendColor_Lazy;
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> Set the blend color. </summary>
        /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml" /></remarks>
        public static void BlendColor(float red, float green, float blue, float alpha) => _BlendColor_fnptr(red, green, blue, alpha);
        [UnmanagedCallersOnly]
        private static void BlendColor_Lazy(float red, float green, float blue, float alpha)
        {
            _BlendColor_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glBlendColor");
            _BlendColor_fnptr(red, green, blue, alpha);
        }
        
        private static delegate* unmanaged<BlendEquationModeEXT, void> _BlendEquation_fnptr = &BlendEquation_Lazy;
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
        public static void BlendEquation(BlendEquationModeEXT mode) => _BlendEquation_fnptr(mode);
        [UnmanagedCallersOnly]
        private static void BlendEquation_Lazy(BlendEquationModeEXT mode)
        {
            _BlendEquation_fnptr = (delegate* unmanaged<BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquation");
            _BlendEquation_fnptr(mode);
        }
        
        private static delegate* unmanaged<int, QueryHandle*, void> _GenQueries_fnptr = &GenQueries_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Generate query object names. </summary>
        /// <param name="n"> Specifies the number of query object names to be generated. </param>
        /// <param name="ids"> Specifies an array in which the generated query object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenQueries.xhtml" /></remarks>
        public static void GenQueries(int n, QueryHandle* ids) => _GenQueries_fnptr(n, ids);
        [UnmanagedCallersOnly]
        private static void GenQueries_Lazy(int n, QueryHandle* ids)
        {
            _GenQueries_fnptr = (delegate* unmanaged<int, QueryHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenQueries");
            _GenQueries_fnptr(n, ids);
        }
        
        private static delegate* unmanaged<int, QueryHandle*, void> _DeleteQueries_fnptr = &DeleteQueries_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Delete named query objects. </summary>
        /// <param name="n"> Specifies the number of query objects to be deleted. </param>
        /// <param name="ids"> Specifies an array of query objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteQueries.xhtml" /></remarks>
        public static void DeleteQueries(int n, QueryHandle* ids) => _DeleteQueries_fnptr(n, ids);
        [UnmanagedCallersOnly]
        private static void DeleteQueries_Lazy(int n, QueryHandle* ids)
        {
            _DeleteQueries_fnptr = (delegate* unmanaged<int, QueryHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteQueries");
            _DeleteQueries_fnptr(n, ids);
        }
        
        private static delegate* unmanaged<QueryHandle, byte> _IsQuery_fnptr = &IsQuery_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Determine if a name corresponds to a query object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsQuery.xhtml" /></remarks>
        public static byte IsQuery(QueryHandle id) => _IsQuery_fnptr(id);
        [UnmanagedCallersOnly]
        private static byte IsQuery_Lazy(QueryHandle id)
        {
            _IsQuery_fnptr = (delegate* unmanaged<QueryHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsQuery");
            return _IsQuery_fnptr(id);
        }
        
        private static delegate* unmanaged<QueryTarget, QueryHandle, void> _BeginQuery_fnptr = &BeginQuery_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml" /></remarks>
        public static void BeginQuery(QueryTarget target, QueryHandle id) => _BeginQuery_fnptr(target, id);
        [UnmanagedCallersOnly]
        private static void BeginQuery_Lazy(QueryTarget target, QueryHandle id)
        {
            _BeginQuery_fnptr = (delegate* unmanaged<QueryTarget, QueryHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBeginQuery");
            _BeginQuery_fnptr(target, id);
        }
        
        private static delegate* unmanaged<QueryTarget, void> _EndQuery_fnptr = &EndQuery_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml" /></remarks>
        public static void EndQuery(QueryTarget target) => _EndQuery_fnptr(target);
        [UnmanagedCallersOnly]
        private static void EndQuery_Lazy(QueryTarget target)
        {
            _EndQuery_fnptr = (delegate* unmanaged<QueryTarget, void>)GLLoader.BindingsContext.GetProcAddress("glEndQuery");
            _EndQuery_fnptr(target);
        }
        
        private static delegate* unmanaged<QueryTarget, QueryParameterName, int*, void> _GetQueryiv_fnptr = &GetQueryiv_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Return parameters of a query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryiv.xhtml" /></remarks>
        public static void GetQueryiv(QueryTarget target, QueryParameterName pname, int* parameters) => _GetQueryiv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetQueryiv_Lazy(QueryTarget target, QueryParameterName pname, int* parameters)
        {
            _GetQueryiv_fnptr = (delegate* unmanaged<QueryTarget, QueryParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryiv");
            _GetQueryiv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, int*, void> _GetQueryObjectiv_fnptr = &GetQueryObjectiv_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectiv(QueryHandle id, QueryObjectParameterName pname, int* parameters) => _GetQueryObjectiv_fnptr(id, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetQueryObjectiv_Lazy(QueryHandle id, QueryObjectParameterName pname, int* parameters)
        {
            _GetQueryObjectiv_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjectiv");
            _GetQueryObjectiv_fnptr(id, pname, parameters);
        }
        
        private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, uint*, void> _GetQueryObjectuiv_fnptr = &GetQueryObjectuiv_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectuiv(QueryHandle id, QueryObjectParameterName pname, uint* parameters) => _GetQueryObjectuiv_fnptr(id, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetQueryObjectuiv_Lazy(QueryHandle id, QueryObjectParameterName pname, uint* parameters)
        {
            _GetQueryObjectuiv_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjectuiv");
            _GetQueryObjectuiv_fnptr(id, pname, parameters);
        }
        
        private static delegate* unmanaged<BufferTargetARB, BufferHandle, void> _BindBuffer_fnptr = &BindBuffer_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Bind a named buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml" /></remarks>
        public static void BindBuffer(BufferTargetARB target, BufferHandle buffer) => _BindBuffer_fnptr(target, buffer);
        [UnmanagedCallersOnly]
        private static void BindBuffer_Lazy(BufferTargetARB target, BufferHandle buffer)
        {
            _BindBuffer_fnptr = (delegate* unmanaged<BufferTargetARB, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindBuffer");
            _BindBuffer_fnptr(target, buffer);
        }
        
        private static delegate* unmanaged<int, BufferHandle*, void> _DeleteBuffers_fnptr = &DeleteBuffers_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Delete named buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to be deleted. </param>
        /// <param name="buffers"> Specifies an array of buffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml" /></remarks>
        public static void DeleteBuffers(int n, BufferHandle* buffers) => _DeleteBuffers_fnptr(n, buffers);
        [UnmanagedCallersOnly]
        private static void DeleteBuffers_Lazy(int n, BufferHandle* buffers)
        {
            _DeleteBuffers_fnptr = (delegate* unmanaged<int, BufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteBuffers");
            _DeleteBuffers_fnptr(n, buffers);
        }
        
        private static delegate* unmanaged<int, BufferHandle*, void> _GenBuffers_fnptr = &GenBuffers_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Generate buffer object names. </summary>
        /// <param name="n"> Specifies the number of buffer object names to be generated. </param>
        /// <param name="buffers"> Specifies an array in which the generated buffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml" /></remarks>
        public static void GenBuffers(int n, BufferHandle* buffers) => _GenBuffers_fnptr(n, buffers);
        [UnmanagedCallersOnly]
        private static void GenBuffers_Lazy(int n, BufferHandle* buffers)
        {
            _GenBuffers_fnptr = (delegate* unmanaged<int, BufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenBuffers");
            _GenBuffers_fnptr(n, buffers);
        }
        
        private static delegate* unmanaged<BufferHandle, byte> _IsBuffer_fnptr = &IsBuffer_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Determine if a name corresponds to a buffer object. </summary>
        /// <param name="buffer"> Specifies a value that may be the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsBuffer.xhtml" /></remarks>
        public static byte IsBuffer(BufferHandle buffer) => _IsBuffer_fnptr(buffer);
        [UnmanagedCallersOnly]
        private static byte IsBuffer_Lazy(BufferHandle buffer)
        {
            _IsBuffer_fnptr = (delegate* unmanaged<BufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsBuffer");
            return _IsBuffer_fnptr(buffer);
        }
        
        private static delegate* unmanaged<BufferTargetARB, nint, void*, BufferUsageARB, void> _BufferData_fnptr = &BufferData_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Creates and initializes a buffer object's data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
        public static void BufferData(BufferTargetARB target, nint size, void* data, BufferUsageARB usage) => _BufferData_fnptr(target, size, data, usage);
        [UnmanagedCallersOnly]
        private static void BufferData_Lazy(BufferTargetARB target, nint size, void* data, BufferUsageARB usage)
        {
            _BufferData_fnptr = (delegate* unmanaged<BufferTargetARB, nint, void*, BufferUsageARB, void>)GLLoader.BindingsContext.GetProcAddress("glBufferData");
            _BufferData_fnptr(target, size, data, usage);
        }
        
        private static delegate* unmanaged<BufferTargetARB, IntPtr, nint, void*, void> _BufferSubData_fnptr = &BufferSubData_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Updates a subset of a buffer object's data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
        public static void BufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => _BufferSubData_fnptr(target, offset, size, data);
        [UnmanagedCallersOnly]
        private static void BufferSubData_Lazy(BufferTargetARB target, IntPtr offset, nint size, void* data)
        {
            _BufferSubData_fnptr = (delegate* unmanaged<BufferTargetARB, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glBufferSubData");
            _BufferSubData_fnptr(target, offset, size, data);
        }
        
        private static delegate* unmanaged<BufferTargetARB, IntPtr, nint, void*, void> _GetBufferSubData_fnptr = &GetBufferSubData_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Returns a subset of a buffer object's data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
        public static void GetBufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => _GetBufferSubData_fnptr(target, offset, size, data);
        [UnmanagedCallersOnly]
        private static void GetBufferSubData_Lazy(BufferTargetARB target, IntPtr offset, nint size, void* data)
        {
            _GetBufferSubData_fnptr = (delegate* unmanaged<BufferTargetARB, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetBufferSubData");
            _GetBufferSubData_fnptr(target, offset, size, data);
        }
        
        private static delegate* unmanaged<BufferTargetARB, BufferAccessARB, void*> _MapBuffer_fnptr = &MapBuffer_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Map all of a buffer object's data store into the client's address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
        public static void* MapBuffer(BufferTargetARB target, BufferAccessARB access) => _MapBuffer_fnptr(target, access);
        [UnmanagedCallersOnly]
        private static void* MapBuffer_Lazy(BufferTargetARB target, BufferAccessARB access)
        {
            _MapBuffer_fnptr = (delegate* unmanaged<BufferTargetARB, BufferAccessARB, void*>)GLLoader.BindingsContext.GetProcAddress("glMapBuffer");
            return _MapBuffer_fnptr(target, access);
        }
        
        private static delegate* unmanaged<BufferTargetARB, byte> _UnmapBuffer_fnptr = &UnmapBuffer_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Release the mapping of a buffer object's data store into the client's address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glUnmapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
        public static byte UnmapBuffer(BufferTargetARB target) => _UnmapBuffer_fnptr(target);
        [UnmanagedCallersOnly]
        private static byte UnmapBuffer_Lazy(BufferTargetARB target)
        {
            _UnmapBuffer_fnptr = (delegate* unmanaged<BufferTargetARB, byte>)GLLoader.BindingsContext.GetProcAddress("glUnmapBuffer");
            return _UnmapBuffer_fnptr(target);
        }
        
        private static delegate* unmanaged<BufferTargetARB, BufferPNameARB, int*, void> _GetBufferParameteriv_fnptr = &GetBufferParameteriv_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="value"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="data"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetBufferParameteriv(BufferTargetARB target, BufferPNameARB pname, int* parameters) => _GetBufferParameteriv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetBufferParameteriv_Lazy(BufferTargetARB target, BufferPNameARB pname, int* parameters)
        {
            _GetBufferParameteriv_fnptr = (delegate* unmanaged<BufferTargetARB, BufferPNameARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetBufferParameteriv");
            _GetBufferParameteriv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<BufferTargetARB, BufferPointerNameARB, void**, void> _GetBufferPointerv_fnptr = &GetBufferPointerv_Lazy;
        /// <summary> <b>[requires: v1.5]</b> Return the pointer to a mapped buffer object's data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
        public static void GetBufferPointerv(BufferTargetARB target, BufferPointerNameARB pname, void** parameters) => _GetBufferPointerv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetBufferPointerv_Lazy(BufferTargetARB target, BufferPointerNameARB pname, void** parameters)
        {
            _GetBufferPointerv_fnptr = (delegate* unmanaged<BufferTargetARB, BufferPointerNameARB, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetBufferPointerv");
            _GetBufferPointerv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<BlendEquationModeEXT, BlendEquationModeEXT, void> _BlendEquationSeparate_fnptr = &BlendEquationSeparate_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml" /></remarks>
        public static void BlendEquationSeparate(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparate_fnptr(modeRGB, modeAlpha);
        [UnmanagedCallersOnly]
        private static void BlendEquationSeparate_Lazy(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha)
        {
            _BlendEquationSeparate_fnptr = (delegate* unmanaged<BlendEquationModeEXT, BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquationSeparate");
            _BlendEquationSeparate_fnptr(modeRGB, modeAlpha);
        }
        
        private static delegate* unmanaged<int, DrawBufferMode*, void> _DrawBuffers_fnptr = &DrawBuffers_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
        public static void DrawBuffers(int n, DrawBufferMode* bufs) => _DrawBuffers_fnptr(n, bufs);
        [UnmanagedCallersOnly]
        private static void DrawBuffers_Lazy(int n, DrawBufferMode* bufs)
        {
            _DrawBuffers_fnptr = (delegate* unmanaged<int, DrawBufferMode*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawBuffers");
            _DrawBuffers_fnptr(n, bufs);
        }
        
        private static delegate* unmanaged<StencilFaceDirection, StencilOp, StencilOp, StencilOp, void> _StencilOpSeparate_fnptr = &StencilOpSeparate_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Set front and/or back stencil test actions. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="sfail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="dpfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="dppass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOpSeparate.xhtml" /></remarks>
        public static void StencilOpSeparate(StencilFaceDirection face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => _StencilOpSeparate_fnptr(face, sfail, dpfail, dppass);
        [UnmanagedCallersOnly]
        private static void StencilOpSeparate_Lazy(StencilFaceDirection face, StencilOp sfail, StencilOp dpfail, StencilOp dppass)
        {
            _StencilOpSeparate_fnptr = (delegate* unmanaged<StencilFaceDirection, StencilOp, StencilOp, StencilOp, void>)GLLoader.BindingsContext.GetProcAddress("glStencilOpSeparate");
            _StencilOpSeparate_fnptr(face, sfail, dpfail, dppass);
        }
        
        private static delegate* unmanaged<StencilFaceDirection, StencilFunction, int, uint, void> _StencilFuncSeparate_fnptr = &StencilFuncSeparate_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Set front and/or back function and reference value for stencil testing. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFuncSeparate.xhtml" /></remarks>
        public static void StencilFuncSeparate(StencilFaceDirection face, StencilFunction func, int reference, uint mask) => _StencilFuncSeparate_fnptr(face, func, reference, mask);
        [UnmanagedCallersOnly]
        private static void StencilFuncSeparate_Lazy(StencilFaceDirection face, StencilFunction func, int reference, uint mask)
        {
            _StencilFuncSeparate_fnptr = (delegate* unmanaged<StencilFaceDirection, StencilFunction, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glStencilFuncSeparate");
            _StencilFuncSeparate_fnptr(face, func, reference, mask);
        }
        
        private static delegate* unmanaged<StencilFaceDirection, uint, void> _StencilMaskSeparate_fnptr = &StencilMaskSeparate_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Control the front and/or back writing of individual bits in the stencil planes. </summary>
        /// <param name="face"> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMaskSeparate.xhtml" /></remarks>
        public static void StencilMaskSeparate(StencilFaceDirection face, uint mask) => _StencilMaskSeparate_fnptr(face, mask);
        [UnmanagedCallersOnly]
        private static void StencilMaskSeparate_Lazy(StencilFaceDirection face, uint mask)
        {
            _StencilMaskSeparate_fnptr = (delegate* unmanaged<StencilFaceDirection, uint, void>)GLLoader.BindingsContext.GetProcAddress("glStencilMaskSeparate");
            _StencilMaskSeparate_fnptr(face, mask);
        }
        
        private static delegate* unmanaged<ProgramHandle, ShaderHandle, void> _AttachShader_fnptr = &AttachShader_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Attaches a shader object to a program object. </summary>
        /// <param name="program">Specifies the program object to which a shader object will be attached.</param>
        /// <param name="shader">Specifies the shader object that is to be attached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glAttachShader.xhtml" /></remarks>
        public static void AttachShader(ProgramHandle program, ShaderHandle shader) => _AttachShader_fnptr(program, shader);
        [UnmanagedCallersOnly]
        private static void AttachShader_Lazy(ProgramHandle program, ShaderHandle shader)
        {
            _AttachShader_fnptr = (delegate* unmanaged<ProgramHandle, ShaderHandle, void>)GLLoader.BindingsContext.GetProcAddress("glAttachShader");
            _AttachShader_fnptr(program, shader);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, byte*, void> _BindAttribLocation_fnptr = &BindAttribLocation_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Associates a generic vertex attribute index with a named attribute variable. </summary>
        /// <param name="program">Specifies the handle of the program object in which the association is to be made.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be bound.</param>
        /// <param name="name">Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindAttribLocation.xhtml" /></remarks>
        public static void BindAttribLocation(ProgramHandle program, uint index, byte* name) => _BindAttribLocation_fnptr(program, index, name);
        [UnmanagedCallersOnly]
        private static void BindAttribLocation_Lazy(ProgramHandle program, uint index, byte* name)
        {
            _BindAttribLocation_fnptr = (delegate* unmanaged<ProgramHandle, uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glBindAttribLocation");
            _BindAttribLocation_fnptr(program, index, name);
        }
        
        private static delegate* unmanaged<ShaderHandle, void> _CompileShader_fnptr = &CompileShader_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Compiles a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be compiled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompileShader.xhtml" /></remarks>
        public static void CompileShader(ShaderHandle shader) => _CompileShader_fnptr(shader);
        [UnmanagedCallersOnly]
        private static void CompileShader_Lazy(ShaderHandle shader)
        {
            _CompileShader_fnptr = (delegate* unmanaged<ShaderHandle, void>)GLLoader.BindingsContext.GetProcAddress("glCompileShader");
            _CompileShader_fnptr(shader);
        }
        
        private static delegate* unmanaged<int> _CreateProgram_fnptr = &CreateProgram_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Creates a program object. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml" /></remarks>
        public static ProgramHandle CreateProgram() => (ProgramHandle) _CreateProgram_fnptr();
        [UnmanagedCallersOnly]
        private static int CreateProgram_Lazy()
        {
            _CreateProgram_fnptr = (delegate* unmanaged<int>)GLLoader.BindingsContext.GetProcAddress("glCreateProgram");
            return _CreateProgram_fnptr();
        }
        
        private static delegate* unmanaged<ShaderType, int> _CreateShader_fnptr = &CreateShader_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Creates a shader object. </summary>
        /// <param name="shaderType">Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml" /></remarks>
        public static ShaderHandle CreateShader(ShaderType type) => (ShaderHandle) _CreateShader_fnptr(type);
        [UnmanagedCallersOnly]
        private static int CreateShader_Lazy(ShaderType type)
        {
            _CreateShader_fnptr = (delegate* unmanaged<ShaderType, int>)GLLoader.BindingsContext.GetProcAddress("glCreateShader");
            return _CreateShader_fnptr(type);
        }
        
        private static delegate* unmanaged<ProgramHandle, void> _DeleteProgram_fnptr = &DeleteProgram_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Deletes a program object. </summary>
        /// <param name="program">Specifies the program object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml" /></remarks>
        public static void DeleteProgram(ProgramHandle program) => _DeleteProgram_fnptr(program);
        [UnmanagedCallersOnly]
        private static void DeleteProgram_Lazy(ProgramHandle program)
        {
            _DeleteProgram_fnptr = (delegate* unmanaged<ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteProgram");
            _DeleteProgram_fnptr(program);
        }
        
        private static delegate* unmanaged<ShaderHandle, void> _DeleteShader_fnptr = &DeleteShader_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Deletes a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml" /></remarks>
        public static void DeleteShader(ShaderHandle shader) => _DeleteShader_fnptr(shader);
        [UnmanagedCallersOnly]
        private static void DeleteShader_Lazy(ShaderHandle shader)
        {
            _DeleteShader_fnptr = (delegate* unmanaged<ShaderHandle, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteShader");
            _DeleteShader_fnptr(shader);
        }
        
        private static delegate* unmanaged<ProgramHandle, ShaderHandle, void> _DetachShader_fnptr = &DetachShader_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Detaches a shader object from a program object to which it is attached. </summary>
        /// <param name="program">Specifies the program object from which to detach the shader object.</param>
        /// <param name="shader">Specifies the shader object to be detached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDetachShader.xhtml" /></remarks>
        public static void DetachShader(ProgramHandle program, ShaderHandle shader) => _DetachShader_fnptr(program, shader);
        [UnmanagedCallersOnly]
        private static void DetachShader_Lazy(ProgramHandle program, ShaderHandle shader)
        {
            _DetachShader_fnptr = (delegate* unmanaged<ProgramHandle, ShaderHandle, void>)GLLoader.BindingsContext.GetProcAddress("glDetachShader");
            _DetachShader_fnptr(program, shader);
        }
        
        private static delegate* unmanaged<uint, void> _DisableVertexAttribArray_fnptr = &DisableVertexAttribArray_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void DisableVertexAttribArray(uint index) => _DisableVertexAttribArray_fnptr(index);
        [UnmanagedCallersOnly]
        private static void DisableVertexAttribArray_Lazy(uint index)
        {
            _DisableVertexAttribArray_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisableVertexAttribArray");
            _DisableVertexAttribArray_fnptr(index);
        }
        
        private static delegate* unmanaged<uint, void> _EnableVertexAttribArray_fnptr = &EnableVertexAttribArray_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void EnableVertexAttribArray(uint index) => _EnableVertexAttribArray_fnptr(index);
        [UnmanagedCallersOnly]
        private static void EnableVertexAttribArray_Lazy(uint index)
        {
            _EnableVertexAttribArray_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnableVertexAttribArray");
            _EnableVertexAttribArray_fnptr(index);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, int, int*, int*, AttributeType*, byte*, void> _GetActiveAttrib_fnptr = &GetActiveAttrib_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns information about an active attribute variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the attribute variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute variable.</param>
        /// <param name="type">Returns the data type of the attribute variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the attribute variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAttrib.xhtml" /></remarks>
        public static void GetActiveAttrib(ProgramHandle program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => _GetActiveAttrib_fnptr(program, index, bufSize, length, size, type, name);
        [UnmanagedCallersOnly]
        private static void GetActiveAttrib_Lazy(ProgramHandle program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name)
        {
            _GetActiveAttrib_fnptr = (delegate* unmanaged<ProgramHandle, uint, int, int*, int*, AttributeType*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveAttrib");
            _GetActiveAttrib_fnptr(program, index, bufSize, length, size, type, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, int, int*, int*, UniformType*, byte*, void> _GetActiveUniform_fnptr = &GetActiveUniform_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns information about an active uniform variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform variable.</param>
        /// <param name="type">Returns the data type of the uniform variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniform.xhtml" /></remarks>
        public static void GetActiveUniform(ProgramHandle program, uint index, int bufSize, int* length, int* size, UniformType* type, byte* name) => _GetActiveUniform_fnptr(program, index, bufSize, length, size, type, name);
        [UnmanagedCallersOnly]
        private static void GetActiveUniform_Lazy(ProgramHandle program, uint index, int bufSize, int* length, int* size, UniformType* type, byte* name)
        {
            _GetActiveUniform_fnptr = (delegate* unmanaged<ProgramHandle, uint, int, int*, int*, UniformType*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniform");
            _GetActiveUniform_fnptr(program, index, bufSize, length, size, type, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int*, ShaderHandle*, void> _GetAttachedShaders_fnptr = &GetAttachedShaders_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns the handles of the shader objects attached to a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned in shaders.</param>
        /// <param name="shaders">Specifies an array that is used to return the names of attached shader objects.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml" /></remarks>
        public static void GetAttachedShaders(ProgramHandle program, int maxCount, int* count, ShaderHandle* shaders) => _GetAttachedShaders_fnptr(program, maxCount, count, shaders);
        [UnmanagedCallersOnly]
        private static void GetAttachedShaders_Lazy(ProgramHandle program, int maxCount, int* count, ShaderHandle* shaders)
        {
            _GetAttachedShaders_fnptr = (delegate* unmanaged<ProgramHandle, int, int*, ShaderHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGetAttachedShaders");
            _GetAttachedShaders_fnptr(program, maxCount, count, shaders);
        }
        
        private static delegate* unmanaged<ProgramHandle, byte*, int> _GetAttribLocation_fnptr = &GetAttribLocation_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns the location of an attribute variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttribLocation.xhtml" /></remarks>
        public static int GetAttribLocation(ProgramHandle program, byte* name) => _GetAttribLocation_fnptr(program, name);
        [UnmanagedCallersOnly]
        private static int GetAttribLocation_Lazy(ProgramHandle program, byte* name)
        {
            _GetAttribLocation_fnptr = (delegate* unmanaged<ProgramHandle, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetAttribLocation");
            return _GetAttribLocation_fnptr(program, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, ProgramPropertyARB, int*, void> _GetProgramiv_fnptr = &GetProgramiv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns a parameter from a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgram.xhtml" /></remarks>
        public static void GetProgramiv(ProgramHandle program, ProgramPropertyARB pname, int* parameters) => _GetProgramiv_fnptr(program, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetProgramiv_Lazy(ProgramHandle program, ProgramPropertyARB pname, int* parameters)
        {
            _GetProgramiv_fnptr = (delegate* unmanaged<ProgramHandle, ProgramPropertyARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramiv");
            _GetProgramiv_fnptr(program, pname, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int*, byte*, void> _GetProgramInfoLog_fnptr = &GetProgramInfoLog_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns the information log for a program object. </summary>
        /// <param name="program">Specifies the program object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml" /></remarks>
        public static void GetProgramInfoLog(ProgramHandle program, int bufSize, int* length, byte* infoLog) => _GetProgramInfoLog_fnptr(program, bufSize, length, infoLog);
        [UnmanagedCallersOnly]
        private static void GetProgramInfoLog_Lazy(ProgramHandle program, int bufSize, int* length, byte* infoLog)
        {
            _GetProgramInfoLog_fnptr = (delegate* unmanaged<ProgramHandle, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramInfoLog");
            _GetProgramInfoLog_fnptr(program, bufSize, length, infoLog);
        }
        
        private static delegate* unmanaged<ShaderHandle, ShaderParameterName, int*, void> _GetShaderiv_fnptr = &GetShaderiv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns a parameter from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShader.xhtml" /></remarks>
        public static void GetShaderiv(ShaderHandle shader, ShaderParameterName pname, int* parameters) => _GetShaderiv_fnptr(shader, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetShaderiv_Lazy(ShaderHandle shader, ShaderParameterName pname, int* parameters)
        {
            _GetShaderiv_fnptr = (delegate* unmanaged<ShaderHandle, ShaderParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetShaderiv");
            _GetShaderiv_fnptr(shader, pname, parameters);
        }
        
        private static delegate* unmanaged<ShaderHandle, int, int*, byte*, void> _GetShaderInfoLog_fnptr = &GetShaderInfoLog_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns the information log for a shader object. </summary>
        /// <param name="shader">Specifies the shader object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml" /></remarks>
        public static void GetShaderInfoLog(ShaderHandle shader, int bufSize, int* length, byte* infoLog) => _GetShaderInfoLog_fnptr(shader, bufSize, length, infoLog);
        [UnmanagedCallersOnly]
        private static void GetShaderInfoLog_Lazy(ShaderHandle shader, int bufSize, int* length, byte* infoLog)
        {
            _GetShaderInfoLog_fnptr = (delegate* unmanaged<ShaderHandle, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetShaderInfoLog");
            _GetShaderInfoLog_fnptr(shader, bufSize, length, infoLog);
        }
        
        private static delegate* unmanaged<ShaderHandle, int, int*, byte*, void> _GetShaderSource_fnptr = &GetShaderSource_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns the source code string from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in source (excluding the null terminator).</param>
        /// <param name="source">Specifies an array of characters that is used to return the source code string.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderSource.xhtml" /></remarks>
        public static void GetShaderSource(ShaderHandle shader, int bufSize, int* length, byte* source) => _GetShaderSource_fnptr(shader, bufSize, length, source);
        [UnmanagedCallersOnly]
        private static void GetShaderSource_Lazy(ShaderHandle shader, int bufSize, int* length, byte* source)
        {
            _GetShaderSource_fnptr = (delegate* unmanaged<ShaderHandle, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetShaderSource");
            _GetShaderSource_fnptr(shader, bufSize, length, source);
        }
        
        private static delegate* unmanaged<ProgramHandle, byte*, int> _GetUniformLocation_fnptr = &GetUniformLocation_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns the location of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml" /></remarks>
        public static int GetUniformLocation(ProgramHandle program, byte* name) => _GetUniformLocation_fnptr(program, name);
        [UnmanagedCallersOnly]
        private static int GetUniformLocation_Lazy(ProgramHandle program, byte* name)
        {
            _GetUniformLocation_fnptr = (delegate* unmanaged<ProgramHandle, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetUniformLocation");
            return _GetUniformLocation_fnptr(program, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, float*, void> _GetUniformfv_fnptr = &GetUniformfv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformfv(ProgramHandle program, int location, float* parameters) => _GetUniformfv_fnptr(program, location, parameters);
        [UnmanagedCallersOnly]
        private static void GetUniformfv_Lazy(ProgramHandle program, int location, float* parameters)
        {
            _GetUniformfv_fnptr = (delegate* unmanaged<ProgramHandle, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformfv");
            _GetUniformfv_fnptr(program, location, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int*, void> _GetUniformiv_fnptr = &GetUniformiv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformiv(ProgramHandle program, int location, int* parameters) => _GetUniformiv_fnptr(program, location, parameters);
        [UnmanagedCallersOnly]
        private static void GetUniformiv_Lazy(ProgramHandle program, int location, int* parameters)
        {
            _GetUniformiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformiv");
            _GetUniformiv_fnptr(program, location, parameters);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPropertyARB, double*, void> _GetVertexAttribdv_fnptr = &GetVertexAttribdv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribdv(uint index, VertexAttribPropertyARB pname, double* parameters) => _GetVertexAttribdv_fnptr(index, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetVertexAttribdv_Lazy(uint index, VertexAttribPropertyARB pname, double* parameters)
        {
            _GetVertexAttribdv_fnptr = (delegate* unmanaged<uint, VertexAttribPropertyARB, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribdv");
            _GetVertexAttribdv_fnptr(index, pname, parameters);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPropertyARB, float*, void> _GetVertexAttribfv_fnptr = &GetVertexAttribfv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribfv(uint index, VertexAttribPropertyARB pname, float* parameters) => _GetVertexAttribfv_fnptr(index, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetVertexAttribfv_Lazy(uint index, VertexAttribPropertyARB pname, float* parameters)
        {
            _GetVertexAttribfv_fnptr = (delegate* unmanaged<uint, VertexAttribPropertyARB, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribfv");
            _GetVertexAttribfv_fnptr(index, pname, parameters);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPropertyARB, int*, void> _GetVertexAttribiv_fnptr = &GetVertexAttribiv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribiv(uint index, VertexAttribPropertyARB pname, int* parameters) => _GetVertexAttribiv_fnptr(index, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetVertexAttribiv_Lazy(uint index, VertexAttribPropertyARB pname, int* parameters)
        {
            _GetVertexAttribiv_fnptr = (delegate* unmanaged<uint, VertexAttribPropertyARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribiv");
            _GetVertexAttribiv_fnptr(index, pname, parameters);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPointerPropertyARB, void**, void> _GetVertexAttribPointerv_fnptr = &GetVertexAttribPointerv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Return the address of the specified generic vertex attribute pointer. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be returned.</param>
        /// <param name="pname">Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.</param>
        /// <param name="pointer">Returns the pointer value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttribPointerv.xhtml" /></remarks>
        public static void GetVertexAttribPointerv(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => _GetVertexAttribPointerv_fnptr(index, pname, pointer);
        [UnmanagedCallersOnly]
        private static void GetVertexAttribPointerv_Lazy(uint index, VertexAttribPointerPropertyARB pname, void** pointer)
        {
            _GetVertexAttribPointerv_fnptr = (delegate* unmanaged<uint, VertexAttribPointerPropertyARB, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribPointerv");
            _GetVertexAttribPointerv_fnptr(index, pname, pointer);
        }
        
        private static delegate* unmanaged<ProgramHandle, byte> _IsProgram_fnptr = &IsProgram_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Determines if a name corresponds to a program object. </summary>
        /// <param name="program">Specifies a potential program object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgram.xhtml" /></remarks>
        public static byte IsProgram(ProgramHandle program) => _IsProgram_fnptr(program);
        [UnmanagedCallersOnly]
        private static byte IsProgram_Lazy(ProgramHandle program)
        {
            _IsProgram_fnptr = (delegate* unmanaged<ProgramHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsProgram");
            return _IsProgram_fnptr(program);
        }
        
        private static delegate* unmanaged<ShaderHandle, byte> _IsShader_fnptr = &IsShader_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Determines if a name corresponds to a shader object. </summary>
        /// <param name="shader">Specifies a potential shader object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsShader.xhtml" /></remarks>
        public static byte IsShader(ShaderHandle shader) => _IsShader_fnptr(shader);
        [UnmanagedCallersOnly]
        private static byte IsShader_Lazy(ShaderHandle shader)
        {
            _IsShader_fnptr = (delegate* unmanaged<ShaderHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsShader");
            return _IsShader_fnptr(shader);
        }
        
        private static delegate* unmanaged<ProgramHandle, void> _LinkProgram_fnptr = &LinkProgram_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Links a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be linked.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml" /></remarks>
        public static void LinkProgram(ProgramHandle program) => _LinkProgram_fnptr(program);
        [UnmanagedCallersOnly]
        private static void LinkProgram_Lazy(ProgramHandle program)
        {
            _LinkProgram_fnptr = (delegate* unmanaged<ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glLinkProgram");
            _LinkProgram_fnptr(program);
        }
        
        private static delegate* unmanaged<ShaderHandle, int, byte**, int*, void> _ShaderSource_fnptr = &ShaderSource_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Replaces the source code in a shader object. </summary>
        /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the string and length arrays.</param>
        /// <param name="str">Specifies an array of pointers to strings containing the source code to be loaded into the shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderSource.xhtml" /></remarks>
        public static void ShaderSource(ShaderHandle shader, int count, byte** str, int* length) => _ShaderSource_fnptr(shader, count, str, length);
        [UnmanagedCallersOnly]
        private static void ShaderSource_Lazy(ShaderHandle shader, int count, byte** str, int* length)
        {
            _ShaderSource_fnptr = (delegate* unmanaged<ShaderHandle, int, byte**, int*, void>)GLLoader.BindingsContext.GetProcAddress("glShaderSource");
            _ShaderSource_fnptr(shader, count, str, length);
        }
        
        private static delegate* unmanaged<ProgramHandle, void> _UseProgram_fnptr = &UseProgram_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Installs a program object as part of current rendering state. </summary>
        /// <param name="program">Specifies the handle of the program object whose executables are to be used as part of current rendering state.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgram.xhtml" /></remarks>
        public static void UseProgram(ProgramHandle program) => _UseProgram_fnptr(program);
        [UnmanagedCallersOnly]
        private static void UseProgram_Lazy(ProgramHandle program)
        {
            _UseProgram_fnptr = (delegate* unmanaged<ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glUseProgram");
            _UseProgram_fnptr(program);
        }
        
        private static delegate* unmanaged<int, float, void> _Uniform1f_fnptr = &Uniform1f_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1f(int location, float v0) => _Uniform1f_fnptr(location, v0);
        [UnmanagedCallersOnly]
        private static void Uniform1f_Lazy(int location, float v0)
        {
            _Uniform1f_fnptr = (delegate* unmanaged<int, float, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1f");
            _Uniform1f_fnptr(location, v0);
        }
        
        private static delegate* unmanaged<int, float, float, void> _Uniform2f_fnptr = &Uniform2f_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2f(int location, float v0, float v1) => _Uniform2f_fnptr(location, v0, v1);
        [UnmanagedCallersOnly]
        private static void Uniform2f_Lazy(int location, float v0, float v1)
        {
            _Uniform2f_fnptr = (delegate* unmanaged<int, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2f");
            _Uniform2f_fnptr(location, v0, v1);
        }
        
        private static delegate* unmanaged<int, float, float, float, void> _Uniform3f_fnptr = &Uniform3f_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3f(int location, float v0, float v1, float v2) => _Uniform3f_fnptr(location, v0, v1, v2);
        [UnmanagedCallersOnly]
        private static void Uniform3f_Lazy(int location, float v0, float v1, float v2)
        {
            _Uniform3f_fnptr = (delegate* unmanaged<int, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3f");
            _Uniform3f_fnptr(location, v0, v1, v2);
        }
        
        private static delegate* unmanaged<int, float, float, float, float, void> _Uniform4f_fnptr = &Uniform4f_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4f(int location, float v0, float v1, float v2, float v3) => _Uniform4f_fnptr(location, v0, v1, v2, v3);
        [UnmanagedCallersOnly]
        private static void Uniform4f_Lazy(int location, float v0, float v1, float v2, float v3)
        {
            _Uniform4f_fnptr = (delegate* unmanaged<int, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4f");
            _Uniform4f_fnptr(location, v0, v1, v2, v3);
        }
        
        private static delegate* unmanaged<int, int, void> _Uniform1i_fnptr = &Uniform1i_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1i(int location, int v0) => _Uniform1i_fnptr(location, v0);
        [UnmanagedCallersOnly]
        private static void Uniform1i_Lazy(int location, int v0)
        {
            _Uniform1i_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1i");
            _Uniform1i_fnptr(location, v0);
        }
        
        private static delegate* unmanaged<int, int, int, void> _Uniform2i_fnptr = &Uniform2i_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2i(int location, int v0, int v1) => _Uniform2i_fnptr(location, v0, v1);
        [UnmanagedCallersOnly]
        private static void Uniform2i_Lazy(int location, int v0, int v1)
        {
            _Uniform2i_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2i");
            _Uniform2i_fnptr(location, v0, v1);
        }
        
        private static delegate* unmanaged<int, int, int, int, void> _Uniform3i_fnptr = &Uniform3i_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3i(int location, int v0, int v1, int v2) => _Uniform3i_fnptr(location, v0, v1, v2);
        [UnmanagedCallersOnly]
        private static void Uniform3i_Lazy(int location, int v0, int v1, int v2)
        {
            _Uniform3i_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3i");
            _Uniform3i_fnptr(location, v0, v1, v2);
        }
        
        private static delegate* unmanaged<int, int, int, int, int, void> _Uniform4i_fnptr = &Uniform4i_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4i(int location, int v0, int v1, int v2, int v3) => _Uniform4i_fnptr(location, v0, v1, v2, v3);
        [UnmanagedCallersOnly]
        private static void Uniform4i_Lazy(int location, int v0, int v1, int v2, int v3)
        {
            _Uniform4i_fnptr = (delegate* unmanaged<int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4i");
            _Uniform4i_fnptr(location, v0, v1, v2, v3);
        }
        
        private static delegate* unmanaged<int, int, float*, void> _Uniform1fv_fnptr = &Uniform1fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1fv(int location, int count, float* value) => _Uniform1fv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform1fv_Lazy(int location, int count, float* value)
        {
            _Uniform1fv_fnptr = (delegate* unmanaged<int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1fv");
            _Uniform1fv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, float*, void> _Uniform2fv_fnptr = &Uniform2fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2fv(int location, int count, float* value) => _Uniform2fv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform2fv_Lazy(int location, int count, float* value)
        {
            _Uniform2fv_fnptr = (delegate* unmanaged<int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2fv");
            _Uniform2fv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, float*, void> _Uniform3fv_fnptr = &Uniform3fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3fv(int location, int count, float* value) => _Uniform3fv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform3fv_Lazy(int location, int count, float* value)
        {
            _Uniform3fv_fnptr = (delegate* unmanaged<int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3fv");
            _Uniform3fv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, float*, void> _Uniform4fv_fnptr = &Uniform4fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4fv(int location, int count, float* value) => _Uniform4fv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform4fv_Lazy(int location, int count, float* value)
        {
            _Uniform4fv_fnptr = (delegate* unmanaged<int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4fv");
            _Uniform4fv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, int*, void> _Uniform1iv_fnptr = &Uniform1iv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1iv(int location, int count, int* value) => _Uniform1iv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform1iv_Lazy(int location, int count, int* value)
        {
            _Uniform1iv_fnptr = (delegate* unmanaged<int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1iv");
            _Uniform1iv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, int*, void> _Uniform2iv_fnptr = &Uniform2iv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2iv(int location, int count, int* value) => _Uniform2iv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform2iv_Lazy(int location, int count, int* value)
        {
            _Uniform2iv_fnptr = (delegate* unmanaged<int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2iv");
            _Uniform2iv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, int*, void> _Uniform3iv_fnptr = &Uniform3iv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3iv(int location, int count, int* value) => _Uniform3iv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform3iv_Lazy(int location, int count, int* value)
        {
            _Uniform3iv_fnptr = (delegate* unmanaged<int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3iv");
            _Uniform3iv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, int*, void> _Uniform4iv_fnptr = &Uniform4iv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4iv(int location, int count, int* value) => _Uniform4iv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform4iv_Lazy(int location, int count, int* value)
        {
            _Uniform4iv_fnptr = (delegate* unmanaged<int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4iv");
            _Uniform4iv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix2fv_fnptr = &UniformMatrix2fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2fv(int location, int count, byte transpose, float* value) => _UniformMatrix2fv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix2fv_Lazy(int location, int count, byte transpose, float* value)
        {
            _UniformMatrix2fv_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2fv");
            _UniformMatrix2fv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix3fv_fnptr = &UniformMatrix3fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3fv(int location, int count, byte transpose, float* value) => _UniformMatrix3fv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix3fv_Lazy(int location, int count, byte transpose, float* value)
        {
            _UniformMatrix3fv_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3fv");
            _UniformMatrix3fv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix4fv_fnptr = &UniformMatrix4fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4fv(int location, int count, byte transpose, float* value) => _UniformMatrix4fv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix4fv_Lazy(int location, int count, byte transpose, float* value)
        {
            _UniformMatrix4fv_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4fv");
            _UniformMatrix4fv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, void> _ValidateProgram_fnptr = &ValidateProgram_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Validates a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be validated.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgram.xhtml" /></remarks>
        public static void ValidateProgram(ProgramHandle program) => _ValidateProgram_fnptr(program);
        [UnmanagedCallersOnly]
        private static void ValidateProgram_Lazy(ProgramHandle program)
        {
            _ValidateProgram_fnptr = (delegate* unmanaged<ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glValidateProgram");
            _ValidateProgram_fnptr(program);
        }
        
        private static delegate* unmanaged<uint, double, void> _VertexAttrib1d_fnptr = &VertexAttrib1d_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1d(uint index, double x) => _VertexAttrib1d_fnptr(index, x);
        [UnmanagedCallersOnly]
        private static void VertexAttrib1d_Lazy(uint index, double x)
        {
            _VertexAttrib1d_fnptr = (delegate* unmanaged<uint, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1d");
            _VertexAttrib1d_fnptr(index, x);
        }
        
        private static delegate* unmanaged<uint, double*, void> _VertexAttrib1dv_fnptr = &VertexAttrib1dv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1dv(uint index, double* v) => _VertexAttrib1dv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib1dv_Lazy(uint index, double* v)
        {
            _VertexAttrib1dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1dv");
            _VertexAttrib1dv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, float, void> _VertexAttrib1f_fnptr = &VertexAttrib1f_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1f(uint index, float x) => _VertexAttrib1f_fnptr(index, x);
        [UnmanagedCallersOnly]
        private static void VertexAttrib1f_Lazy(uint index, float x)
        {
            _VertexAttrib1f_fnptr = (delegate* unmanaged<uint, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1f");
            _VertexAttrib1f_fnptr(index, x);
        }
        
        private static delegate* unmanaged<uint, float*, void> _VertexAttrib1fv_fnptr = &VertexAttrib1fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1fv(uint index, float* v) => _VertexAttrib1fv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib1fv_Lazy(uint index, float* v)
        {
            _VertexAttrib1fv_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1fv");
            _VertexAttrib1fv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, short, void> _VertexAttrib1s_fnptr = &VertexAttrib1s_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1s(uint index, short x) => _VertexAttrib1s_fnptr(index, x);
        [UnmanagedCallersOnly]
        private static void VertexAttrib1s_Lazy(uint index, short x)
        {
            _VertexAttrib1s_fnptr = (delegate* unmanaged<uint, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1s");
            _VertexAttrib1s_fnptr(index, x);
        }
        
        private static delegate* unmanaged<uint, short*, void> _VertexAttrib1sv_fnptr = &VertexAttrib1sv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1sv(uint index, short* v) => _VertexAttrib1sv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib1sv_Lazy(uint index, short* v)
        {
            _VertexAttrib1sv_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1sv");
            _VertexAttrib1sv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, double, double, void> _VertexAttrib2d_fnptr = &VertexAttrib2d_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2d(uint index, double x, double y) => _VertexAttrib2d_fnptr(index, x, y);
        [UnmanagedCallersOnly]
        private static void VertexAttrib2d_Lazy(uint index, double x, double y)
        {
            _VertexAttrib2d_fnptr = (delegate* unmanaged<uint, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2d");
            _VertexAttrib2d_fnptr(index, x, y);
        }
        
        private static delegate* unmanaged<uint, double*, void> _VertexAttrib2dv_fnptr = &VertexAttrib2dv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2dv(uint index, double* v) => _VertexAttrib2dv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib2dv_Lazy(uint index, double* v)
        {
            _VertexAttrib2dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2dv");
            _VertexAttrib2dv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, float, float, void> _VertexAttrib2f_fnptr = &VertexAttrib2f_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2f(uint index, float x, float y) => _VertexAttrib2f_fnptr(index, x, y);
        [UnmanagedCallersOnly]
        private static void VertexAttrib2f_Lazy(uint index, float x, float y)
        {
            _VertexAttrib2f_fnptr = (delegate* unmanaged<uint, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2f");
            _VertexAttrib2f_fnptr(index, x, y);
        }
        
        private static delegate* unmanaged<uint, float*, void> _VertexAttrib2fv_fnptr = &VertexAttrib2fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2fv(uint index, float* v) => _VertexAttrib2fv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib2fv_Lazy(uint index, float* v)
        {
            _VertexAttrib2fv_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2fv");
            _VertexAttrib2fv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, short, short, void> _VertexAttrib2s_fnptr = &VertexAttrib2s_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2s(uint index, short x, short y) => _VertexAttrib2s_fnptr(index, x, y);
        [UnmanagedCallersOnly]
        private static void VertexAttrib2s_Lazy(uint index, short x, short y)
        {
            _VertexAttrib2s_fnptr = (delegate* unmanaged<uint, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2s");
            _VertexAttrib2s_fnptr(index, x, y);
        }
        
        private static delegate* unmanaged<uint, short*, void> _VertexAttrib2sv_fnptr = &VertexAttrib2sv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2sv(uint index, short* v) => _VertexAttrib2sv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib2sv_Lazy(uint index, short* v)
        {
            _VertexAttrib2sv_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2sv");
            _VertexAttrib2sv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, double, double, double, void> _VertexAttrib3d_fnptr = &VertexAttrib3d_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3d(uint index, double x, double y, double z) => _VertexAttrib3d_fnptr(index, x, y, z);
        [UnmanagedCallersOnly]
        private static void VertexAttrib3d_Lazy(uint index, double x, double y, double z)
        {
            _VertexAttrib3d_fnptr = (delegate* unmanaged<uint, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3d");
            _VertexAttrib3d_fnptr(index, x, y, z);
        }
        
        private static delegate* unmanaged<uint, double*, void> _VertexAttrib3dv_fnptr = &VertexAttrib3dv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3dv(uint index, double* v) => _VertexAttrib3dv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib3dv_Lazy(uint index, double* v)
        {
            _VertexAttrib3dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3dv");
            _VertexAttrib3dv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, float, float, float, void> _VertexAttrib3f_fnptr = &VertexAttrib3f_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3f(uint index, float x, float y, float z) => _VertexAttrib3f_fnptr(index, x, y, z);
        [UnmanagedCallersOnly]
        private static void VertexAttrib3f_Lazy(uint index, float x, float y, float z)
        {
            _VertexAttrib3f_fnptr = (delegate* unmanaged<uint, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3f");
            _VertexAttrib3f_fnptr(index, x, y, z);
        }
        
        private static delegate* unmanaged<uint, float*, void> _VertexAttrib3fv_fnptr = &VertexAttrib3fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3fv(uint index, float* v) => _VertexAttrib3fv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib3fv_Lazy(uint index, float* v)
        {
            _VertexAttrib3fv_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3fv");
            _VertexAttrib3fv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, short, short, short, void> _VertexAttrib3s_fnptr = &VertexAttrib3s_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3s(uint index, short x, short y, short z) => _VertexAttrib3s_fnptr(index, x, y, z);
        [UnmanagedCallersOnly]
        private static void VertexAttrib3s_Lazy(uint index, short x, short y, short z)
        {
            _VertexAttrib3s_fnptr = (delegate* unmanaged<uint, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3s");
            _VertexAttrib3s_fnptr(index, x, y, z);
        }
        
        private static delegate* unmanaged<uint, short*, void> _VertexAttrib3sv_fnptr = &VertexAttrib3sv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3sv(uint index, short* v) => _VertexAttrib3sv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib3sv_Lazy(uint index, short* v)
        {
            _VertexAttrib3sv_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3sv");
            _VertexAttrib3sv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, sbyte*, void> _VertexAttrib4Nbv_fnptr = &VertexAttrib4Nbv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nbv(uint index, sbyte* v) => _VertexAttrib4Nbv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4Nbv_Lazy(uint index, sbyte* v)
        {
            _VertexAttrib4Nbv_fnptr = (delegate* unmanaged<uint, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4Nbv");
            _VertexAttrib4Nbv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, int*, void> _VertexAttrib4Niv_fnptr = &VertexAttrib4Niv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Niv(uint index, int* v) => _VertexAttrib4Niv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4Niv_Lazy(uint index, int* v)
        {
            _VertexAttrib4Niv_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4Niv");
            _VertexAttrib4Niv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, short*, void> _VertexAttrib4Nsv_fnptr = &VertexAttrib4Nsv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nsv(uint index, short* v) => _VertexAttrib4Nsv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4Nsv_Lazy(uint index, short* v)
        {
            _VertexAttrib4Nsv_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4Nsv");
            _VertexAttrib4Nsv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, byte, byte, byte, byte, void> _VertexAttrib4Nub_fnptr = &VertexAttrib4Nub_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nub(uint index, byte x, byte y, byte z, byte w) => _VertexAttrib4Nub_fnptr(index, x, y, z, w);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4Nub_Lazy(uint index, byte x, byte y, byte z, byte w)
        {
            _VertexAttrib4Nub_fnptr = (delegate* unmanaged<uint, byte, byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4Nub");
            _VertexAttrib4Nub_fnptr(index, x, y, z, w);
        }
        
        private static delegate* unmanaged<uint, byte*, void> _VertexAttrib4Nubv_fnptr = &VertexAttrib4Nubv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nubv(uint index, byte* v) => _VertexAttrib4Nubv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4Nubv_Lazy(uint index, byte* v)
        {
            _VertexAttrib4Nubv_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4Nubv");
            _VertexAttrib4Nubv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, uint*, void> _VertexAttrib4Nuiv_fnptr = &VertexAttrib4Nuiv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nuiv(uint index, uint* v) => _VertexAttrib4Nuiv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4Nuiv_Lazy(uint index, uint* v)
        {
            _VertexAttrib4Nuiv_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4Nuiv");
            _VertexAttrib4Nuiv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, ushort*, void> _VertexAttrib4Nusv_fnptr = &VertexAttrib4Nusv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nusv(uint index, ushort* v) => _VertexAttrib4Nusv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4Nusv_Lazy(uint index, ushort* v)
        {
            _VertexAttrib4Nusv_fnptr = (delegate* unmanaged<uint, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4Nusv");
            _VertexAttrib4Nusv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, sbyte*, void> _VertexAttrib4bv_fnptr = &VertexAttrib4bv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4bv(uint index, sbyte* v) => _VertexAttrib4bv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4bv_Lazy(uint index, sbyte* v)
        {
            _VertexAttrib4bv_fnptr = (delegate* unmanaged<uint, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4bv");
            _VertexAttrib4bv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, double, double, double, double, void> _VertexAttrib4d_fnptr = &VertexAttrib4d_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4d(uint index, double x, double y, double z, double w) => _VertexAttrib4d_fnptr(index, x, y, z, w);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4d_Lazy(uint index, double x, double y, double z, double w)
        {
            _VertexAttrib4d_fnptr = (delegate* unmanaged<uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4d");
            _VertexAttrib4d_fnptr(index, x, y, z, w);
        }
        
        private static delegate* unmanaged<uint, double*, void> _VertexAttrib4dv_fnptr = &VertexAttrib4dv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4dv(uint index, double* v) => _VertexAttrib4dv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4dv_Lazy(uint index, double* v)
        {
            _VertexAttrib4dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4dv");
            _VertexAttrib4dv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, float, float, float, float, void> _VertexAttrib4f_fnptr = &VertexAttrib4f_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4f(uint index, float x, float y, float z, float w) => _VertexAttrib4f_fnptr(index, x, y, z, w);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4f_Lazy(uint index, float x, float y, float z, float w)
        {
            _VertexAttrib4f_fnptr = (delegate* unmanaged<uint, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4f");
            _VertexAttrib4f_fnptr(index, x, y, z, w);
        }
        
        private static delegate* unmanaged<uint, float*, void> _VertexAttrib4fv_fnptr = &VertexAttrib4fv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4fv(uint index, float* v) => _VertexAttrib4fv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4fv_Lazy(uint index, float* v)
        {
            _VertexAttrib4fv_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4fv");
            _VertexAttrib4fv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, int*, void> _VertexAttrib4iv_fnptr = &VertexAttrib4iv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4iv(uint index, int* v) => _VertexAttrib4iv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4iv_Lazy(uint index, int* v)
        {
            _VertexAttrib4iv_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4iv");
            _VertexAttrib4iv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, short, short, short, short, void> _VertexAttrib4s_fnptr = &VertexAttrib4s_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4s(uint index, short x, short y, short z, short w) => _VertexAttrib4s_fnptr(index, x, y, z, w);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4s_Lazy(uint index, short x, short y, short z, short w)
        {
            _VertexAttrib4s_fnptr = (delegate* unmanaged<uint, short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4s");
            _VertexAttrib4s_fnptr(index, x, y, z, w);
        }
        
        private static delegate* unmanaged<uint, short*, void> _VertexAttrib4sv_fnptr = &VertexAttrib4sv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4sv(uint index, short* v) => _VertexAttrib4sv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4sv_Lazy(uint index, short* v)
        {
            _VertexAttrib4sv_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4sv");
            _VertexAttrib4sv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, byte*, void> _VertexAttrib4ubv_fnptr = &VertexAttrib4ubv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4ubv(uint index, byte* v) => _VertexAttrib4ubv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4ubv_Lazy(uint index, byte* v)
        {
            _VertexAttrib4ubv_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4ubv");
            _VertexAttrib4ubv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, uint*, void> _VertexAttrib4uiv_fnptr = &VertexAttrib4uiv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4uiv(uint index, uint* v) => _VertexAttrib4uiv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4uiv_Lazy(uint index, uint* v)
        {
            _VertexAttrib4uiv_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4uiv");
            _VertexAttrib4uiv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, ushort*, void> _VertexAttrib4usv_fnptr = &VertexAttrib4usv_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4usv(uint index, ushort* v) => _VertexAttrib4usv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttrib4usv_Lazy(uint index, ushort* v)
        {
            _VertexAttrib4usv_fnptr = (delegate* unmanaged<uint, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4usv");
            _VertexAttrib4usv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, int, VertexAttribPointerType, byte, int, void*, void> _VertexAttribPointer_fnptr = &VertexAttribPointer_Lazy;
        /// <summary> <b>[requires: v2.0]</b> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribPointer(uint index, int size, VertexAttribPointerType type, byte normalized, int stride, void* pointer) => _VertexAttribPointer_fnptr(index, size, type, normalized, stride, pointer);
        [UnmanagedCallersOnly]
        private static void VertexAttribPointer_Lazy(uint index, int size, VertexAttribPointerType type, byte normalized, int stride, void* pointer)
        {
            _VertexAttribPointer_fnptr = (delegate* unmanaged<uint, int, VertexAttribPointerType, byte, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribPointer");
            _VertexAttribPointer_fnptr(index, size, type, normalized, stride, pointer);
        }
        
        private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix2x3fv_fnptr = &UniformMatrix2x3fv_Lazy;
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2x3fv(int location, int count, byte transpose, float* value) => _UniformMatrix2x3fv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix2x3fv_Lazy(int location, int count, byte transpose, float* value)
        {
            _UniformMatrix2x3fv_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2x3fv");
            _UniformMatrix2x3fv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix3x2fv_fnptr = &UniformMatrix3x2fv_Lazy;
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3x2fv(int location, int count, byte transpose, float* value) => _UniformMatrix3x2fv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix3x2fv_Lazy(int location, int count, byte transpose, float* value)
        {
            _UniformMatrix3x2fv_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3x2fv");
            _UniformMatrix3x2fv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix2x4fv_fnptr = &UniformMatrix2x4fv_Lazy;
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2x4fv(int location, int count, byte transpose, float* value) => _UniformMatrix2x4fv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix2x4fv_Lazy(int location, int count, byte transpose, float* value)
        {
            _UniformMatrix2x4fv_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2x4fv");
            _UniformMatrix2x4fv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix4x2fv_fnptr = &UniformMatrix4x2fv_Lazy;
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4x2fv(int location, int count, byte transpose, float* value) => _UniformMatrix4x2fv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix4x2fv_Lazy(int location, int count, byte transpose, float* value)
        {
            _UniformMatrix4x2fv_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4x2fv");
            _UniformMatrix4x2fv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix3x4fv_fnptr = &UniformMatrix3x4fv_Lazy;
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3x4fv(int location, int count, byte transpose, float* value) => _UniformMatrix3x4fv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix3x4fv_Lazy(int location, int count, byte transpose, float* value)
        {
            _UniformMatrix3x4fv_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3x4fv");
            _UniformMatrix3x4fv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix4x3fv_fnptr = &UniformMatrix4x3fv_Lazy;
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4x3fv(int location, int count, byte transpose, float* value) => _UniformMatrix4x3fv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix4x3fv_Lazy(int location, int count, byte transpose, float* value)
        {
            _UniformMatrix4x3fv_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4x3fv");
            _UniformMatrix4x3fv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<uint, byte, byte, byte, byte, void> _ColorMaski_fnptr = &ColorMaski_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="buf"> For glColorMaski, specifies the index of the draw buffer whose color mask to set. </param>
        /// <param name="red"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="green"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="blue"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="alpha"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml" /></remarks>
        public static void ColorMaski(uint index, byte r, byte g, byte b, byte a) => _ColorMaski_fnptr(index, r, g, b, a);
        [UnmanagedCallersOnly]
        private static void ColorMaski_Lazy(uint index, byte r, byte g, byte b, byte a)
        {
            _ColorMaski_fnptr = (delegate* unmanaged<uint, byte, byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glColorMaski");
            _ColorMaski_fnptr(index, r, g, b, a);
        }
        
        private static delegate* unmanaged<BufferTargetARB, uint, byte*, void> _GetBooleani_v_fnptr = &GetBooleani_v_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetBooleani_v(BufferTargetARB target, uint index, byte* data) => _GetBooleani_v_fnptr(target, index, data);
        [UnmanagedCallersOnly]
        private static void GetBooleani_v_Lazy(BufferTargetARB target, uint index, byte* data)
        {
            _GetBooleani_v_fnptr = (delegate* unmanaged<BufferTargetARB, uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetBooleani_v");
            _GetBooleani_v_fnptr(target, index, data);
        }
        
        private static delegate* unmanaged<GetPName, uint, int*, void> _GetIntegeri_v_fnptr = &GetIntegeri_v_Lazy;
        /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetIntegeri_v(GetPName target, uint index, int* data) => _GetIntegeri_v_fnptr(target, index, data);
        [UnmanagedCallersOnly]
        private static void GetIntegeri_v_Lazy(GetPName target, uint index, int* data)
        {
            _GetIntegeri_v_fnptr = (delegate* unmanaged<GetPName, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetIntegeri_v");
            _GetIntegeri_v_fnptr(target, index, data);
        }
        
        private static delegate* unmanaged<EnableCap, uint, void> _Enablei_fnptr = &Enablei_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Enablei(EnableCap target, uint index) => _Enablei_fnptr(target, index);
        [UnmanagedCallersOnly]
        private static void Enablei_Lazy(EnableCap target, uint index)
        {
            _Enablei_fnptr = (delegate* unmanaged<EnableCap, uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnablei");
            _Enablei_fnptr(target, index);
        }
        
        private static delegate* unmanaged<EnableCap, uint, void> _Disablei_fnptr = &Disablei_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Disablei(EnableCap target, uint index) => _Disablei_fnptr(target, index);
        [UnmanagedCallersOnly]
        private static void Disablei_Lazy(EnableCap target, uint index)
        {
            _Disablei_fnptr = (delegate* unmanaged<EnableCap, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisablei");
            _Disablei_fnptr(target, index);
        }
        
        private static delegate* unmanaged<EnableCap, uint, byte> _IsEnabledi_fnptr = &IsEnabledi_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Test whether a capability is enabled. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml" /></remarks>
        public static byte IsEnabledi(EnableCap target, uint index) => _IsEnabledi_fnptr(target, index);
        [UnmanagedCallersOnly]
        private static byte IsEnabledi_Lazy(EnableCap target, uint index)
        {
            _IsEnabledi_fnptr = (delegate* unmanaged<EnableCap, uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsEnabledi");
            return _IsEnabledi_fnptr(target, index);
        }
        
        private static delegate* unmanaged<PrimitiveType, void> _BeginTransformFeedback_fnptr = &BeginTransformFeedback_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Start transform feedback operation. </summary>
        /// <param name="primitiveMode"> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml" /></remarks>
        public static void BeginTransformFeedback(PrimitiveType primitiveMode) => _BeginTransformFeedback_fnptr(primitiveMode);
        [UnmanagedCallersOnly]
        private static void BeginTransformFeedback_Lazy(PrimitiveType primitiveMode)
        {
            _BeginTransformFeedback_fnptr = (delegate* unmanaged<PrimitiveType, void>)GLLoader.BindingsContext.GetProcAddress("glBeginTransformFeedback");
            _BeginTransformFeedback_fnptr(primitiveMode);
        }
        
        private static delegate* unmanaged<void> _EndTransformFeedback_fnptr = &EndTransformFeedback_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Start transform feedback operation. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml" /></remarks>
        public static void EndTransformFeedback() => _EndTransformFeedback_fnptr();
        [UnmanagedCallersOnly]
        private static void EndTransformFeedback_Lazy()
        {
            _EndTransformFeedback_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndTransformFeedback");
            _EndTransformFeedback_fnptr();
        }
        
        private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, nint, void> _BindBufferRange_fnptr = &BindBufferRange_Lazy;
        /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Bind a range within a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
        /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml" /></remarks>
        public static void BindBufferRange(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size) => _BindBufferRange_fnptr(target, index, buffer, offset, size);
        [UnmanagedCallersOnly]
        private static void BindBufferRange_Lazy(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size)
        {
            _BindBufferRange_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferRange");
            _BindBufferRange_fnptr(target, index, buffer, offset, size);
        }
        
        private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, void> _BindBufferBase_fnptr = &BindBufferBase_Lazy;
        /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Bind a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml" /></remarks>
        public static void BindBufferBase(BufferTargetARB target, uint index, BufferHandle buffer) => _BindBufferBase_fnptr(target, index, buffer);
        [UnmanagedCallersOnly]
        private static void BindBufferBase_Lazy(BufferTargetARB target, uint index, BufferHandle buffer)
        {
            _BindBufferBase_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferBase");
            _BindBufferBase_fnptr(target, index, buffer);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, byte**, TransformFeedbackBufferMode, void> _TransformFeedbackVaryings_fnptr = &TransformFeedbackVaryings_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify values to record in transform feedback buffers. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="count"> The number of varying variables used for transform feedback. </param>
        /// <param name="varyings"> An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback. </param>
        /// <param name="bufferMode"> Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackVaryings.xhtml" /></remarks>
        public static void TransformFeedbackVaryings(ProgramHandle program, int count, byte** varyings, TransformFeedbackBufferMode bufferMode) => _TransformFeedbackVaryings_fnptr(program, count, varyings, bufferMode);
        [UnmanagedCallersOnly]
        private static void TransformFeedbackVaryings_Lazy(ProgramHandle program, int count, byte** varyings, TransformFeedbackBufferMode bufferMode)
        {
            _TransformFeedbackVaryings_fnptr = (delegate* unmanaged<ProgramHandle, int, byte**, TransformFeedbackBufferMode, void>)GLLoader.BindingsContext.GetProcAddress("glTransformFeedbackVaryings");
            _TransformFeedbackVaryings_fnptr(program, count, varyings, bufferMode);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, int, int*, int*, AttributeType*, byte*, void> _GetTransformFeedbackVarying_fnptr = &GetTransformFeedbackVarying_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Retrieve information about varying variables selected for transform feedback. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="index"> The index of the varying variable whose information to retrieve. </param>
        /// <param name="bufSize"> The maximum number of characters, including the null terminator, that may be written into name. </param>
        /// <param name="length"> The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned. </param>
        /// <param name="size"> The address of a variable that will receive the size of the varying. </param>
        /// <param name="type"> The address of a variable that will receive the type of the varying. </param>
        /// <param name="name"> The address of a buffer into which will be written the name of the varying. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedbackVarying.xhtml" /></remarks>
        public static void GetTransformFeedbackVarying(ProgramHandle program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => _GetTransformFeedbackVarying_fnptr(program, index, bufSize, length, size, type, name);
        [UnmanagedCallersOnly]
        private static void GetTransformFeedbackVarying_Lazy(ProgramHandle program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name)
        {
            _GetTransformFeedbackVarying_fnptr = (delegate* unmanaged<ProgramHandle, uint, int, int*, int*, AttributeType*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTransformFeedbackVarying");
            _GetTransformFeedbackVarying_fnptr(program, index, bufSize, length, size, type, name);
        }
        
        private static delegate* unmanaged<ClampColorTargetARB, ClampColorModeARB, void> _ClampColor_fnptr = &ClampColor_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify whether data read via glReadPixels should be clamped. </summary>
        /// <param name="target"> Target for color clamping. target must be GL_CLAMP_READ_COLOR. </param>
        /// <param name="clamp"> Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClampColor.xhtml" /></remarks>
        public static void ClampColor(ClampColorTargetARB target, ClampColorModeARB clamp) => _ClampColor_fnptr(target, clamp);
        [UnmanagedCallersOnly]
        private static void ClampColor_Lazy(ClampColorTargetARB target, ClampColorModeARB clamp)
        {
            _ClampColor_fnptr = (delegate* unmanaged<ClampColorTargetARB, ClampColorModeARB, void>)GLLoader.BindingsContext.GetProcAddress("glClampColor");
            _ClampColor_fnptr(target, clamp);
        }
        
        private static delegate* unmanaged<uint, ConditionalRenderMode, void> _BeginConditionalRender_fnptr = &BeginConditionalRender_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Start conditional rendering. </summary>
        /// <param name="id"> Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded. </param>
        /// <param name="mode"> Specifies how glBeginConditionalRender interprets the results of the occlusion query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml" /></remarks>
        public static void BeginConditionalRender(uint id, ConditionalRenderMode mode) => _BeginConditionalRender_fnptr(id, mode);
        [UnmanagedCallersOnly]
        private static void BeginConditionalRender_Lazy(uint id, ConditionalRenderMode mode)
        {
            _BeginConditionalRender_fnptr = (delegate* unmanaged<uint, ConditionalRenderMode, void>)GLLoader.BindingsContext.GetProcAddress("glBeginConditionalRender");
            _BeginConditionalRender_fnptr(id, mode);
        }
        
        private static delegate* unmanaged<void> _EndConditionalRender_fnptr = &EndConditionalRender_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Start conditional rendering. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml" /></remarks>
        public static void EndConditionalRender() => _EndConditionalRender_fnptr();
        [UnmanagedCallersOnly]
        private static void EndConditionalRender_Lazy()
        {
            _EndConditionalRender_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndConditionalRender");
            _EndConditionalRender_fnptr();
        }
        
        private static delegate* unmanaged<uint, int, VertexAttribIType, int, void*, void> _VertexAttribIPointer_fnptr = &VertexAttribIPointer_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribIPointer(uint index, int size, VertexAttribIType type, int stride, void* pointer) => _VertexAttribIPointer_fnptr(index, size, type, stride, pointer);
        [UnmanagedCallersOnly]
        private static void VertexAttribIPointer_Lazy(uint index, int size, VertexAttribIType type, int stride, void* pointer)
        {
            _VertexAttribIPointer_fnptr = (delegate* unmanaged<uint, int, VertexAttribIType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribIPointer");
            _VertexAttribIPointer_fnptr(index, size, type, stride, pointer);
        }
        
        private static delegate* unmanaged<uint, VertexAttribEnum, int*, void> _GetVertexAttribIiv_fnptr = &GetVertexAttribIiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribIiv(uint index, VertexAttribEnum pname, int* parameters) => _GetVertexAttribIiv_fnptr(index, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetVertexAttribIiv_Lazy(uint index, VertexAttribEnum pname, int* parameters)
        {
            _GetVertexAttribIiv_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribIiv");
            _GetVertexAttribIiv_fnptr(index, pname, parameters);
        }
        
        private static delegate* unmanaged<uint, VertexAttribEnum, uint*, void> _GetVertexAttribIuiv_fnptr = &GetVertexAttribIuiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribIuiv(uint index, VertexAttribEnum pname, uint* parameters) => _GetVertexAttribIuiv_fnptr(index, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetVertexAttribIuiv_Lazy(uint index, VertexAttribEnum pname, uint* parameters)
        {
            _GetVertexAttribIuiv_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribIuiv");
            _GetVertexAttribIuiv_fnptr(index, pname, parameters);
        }
        
        private static delegate* unmanaged<uint, int, void> _VertexAttribI1i_fnptr = &VertexAttribI1i_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1i(uint index, int x) => _VertexAttribI1i_fnptr(index, x);
        [UnmanagedCallersOnly]
        private static void VertexAttribI1i_Lazy(uint index, int x)
        {
            _VertexAttribI1i_fnptr = (delegate* unmanaged<uint, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1i");
            _VertexAttribI1i_fnptr(index, x);
        }
        
        private static delegate* unmanaged<uint, int, int, void> _VertexAttribI2i_fnptr = &VertexAttribI2i_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2i(uint index, int x, int y) => _VertexAttribI2i_fnptr(index, x, y);
        [UnmanagedCallersOnly]
        private static void VertexAttribI2i_Lazy(uint index, int x, int y)
        {
            _VertexAttribI2i_fnptr = (delegate* unmanaged<uint, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2i");
            _VertexAttribI2i_fnptr(index, x, y);
        }
        
        private static delegate* unmanaged<uint, int, int, int, void> _VertexAttribI3i_fnptr = &VertexAttribI3i_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3i(uint index, int x, int y, int z) => _VertexAttribI3i_fnptr(index, x, y, z);
        [UnmanagedCallersOnly]
        private static void VertexAttribI3i_Lazy(uint index, int x, int y, int z)
        {
            _VertexAttribI3i_fnptr = (delegate* unmanaged<uint, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3i");
            _VertexAttribI3i_fnptr(index, x, y, z);
        }
        
        private static delegate* unmanaged<uint, int, int, int, int, void> _VertexAttribI4i_fnptr = &VertexAttribI4i_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4i(uint index, int x, int y, int z, int w) => _VertexAttribI4i_fnptr(index, x, y, z, w);
        [UnmanagedCallersOnly]
        private static void VertexAttribI4i_Lazy(uint index, int x, int y, int z, int w)
        {
            _VertexAttribI4i_fnptr = (delegate* unmanaged<uint, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4i");
            _VertexAttribI4i_fnptr(index, x, y, z, w);
        }
        
        private static delegate* unmanaged<uint, uint, void> _VertexAttribI1ui_fnptr = &VertexAttribI1ui_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1ui(uint index, uint x) => _VertexAttribI1ui_fnptr(index, x);
        [UnmanagedCallersOnly]
        private static void VertexAttribI1ui_Lazy(uint index, uint x)
        {
            _VertexAttribI1ui_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1ui");
            _VertexAttribI1ui_fnptr(index, x);
        }
        
        private static delegate* unmanaged<uint, uint, uint, void> _VertexAttribI2ui_fnptr = &VertexAttribI2ui_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2ui(uint index, uint x, uint y) => _VertexAttribI2ui_fnptr(index, x, y);
        [UnmanagedCallersOnly]
        private static void VertexAttribI2ui_Lazy(uint index, uint x, uint y)
        {
            _VertexAttribI2ui_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2ui");
            _VertexAttribI2ui_fnptr(index, x, y);
        }
        
        private static delegate* unmanaged<uint, uint, uint, uint, void> _VertexAttribI3ui_fnptr = &VertexAttribI3ui_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3ui(uint index, uint x, uint y, uint z) => _VertexAttribI3ui_fnptr(index, x, y, z);
        [UnmanagedCallersOnly]
        private static void VertexAttribI3ui_Lazy(uint index, uint x, uint y, uint z)
        {
            _VertexAttribI3ui_fnptr = (delegate* unmanaged<uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3ui");
            _VertexAttribI3ui_fnptr(index, x, y, z);
        }
        
        private static delegate* unmanaged<uint, uint, uint, uint, uint, void> _VertexAttribI4ui_fnptr = &VertexAttribI4ui_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w) => _VertexAttribI4ui_fnptr(index, x, y, z, w);
        [UnmanagedCallersOnly]
        private static void VertexAttribI4ui_Lazy(uint index, uint x, uint y, uint z, uint w)
        {
            _VertexAttribI4ui_fnptr = (delegate* unmanaged<uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4ui");
            _VertexAttribI4ui_fnptr(index, x, y, z, w);
        }
        
        private static delegate* unmanaged<uint, int*, void> _VertexAttribI1iv_fnptr = &VertexAttribI1iv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1iv(uint index, int* v) => _VertexAttribI1iv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI1iv_Lazy(uint index, int* v)
        {
            _VertexAttribI1iv_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1iv");
            _VertexAttribI1iv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, int*, void> _VertexAttribI2iv_fnptr = &VertexAttribI2iv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2iv(uint index, int* v) => _VertexAttribI2iv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI2iv_Lazy(uint index, int* v)
        {
            _VertexAttribI2iv_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2iv");
            _VertexAttribI2iv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, int*, void> _VertexAttribI3iv_fnptr = &VertexAttribI3iv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3iv(uint index, int* v) => _VertexAttribI3iv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI3iv_Lazy(uint index, int* v)
        {
            _VertexAttribI3iv_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3iv");
            _VertexAttribI3iv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, int*, void> _VertexAttribI4iv_fnptr = &VertexAttribI4iv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4iv(uint index, int* v) => _VertexAttribI4iv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI4iv_Lazy(uint index, int* v)
        {
            _VertexAttribI4iv_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4iv");
            _VertexAttribI4iv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, uint*, void> _VertexAttribI1uiv_fnptr = &VertexAttribI1uiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1uiv(uint index, uint* v) => _VertexAttribI1uiv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI1uiv_Lazy(uint index, uint* v)
        {
            _VertexAttribI1uiv_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1uiv");
            _VertexAttribI1uiv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, uint*, void> _VertexAttribI2uiv_fnptr = &VertexAttribI2uiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2uiv(uint index, uint* v) => _VertexAttribI2uiv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI2uiv_Lazy(uint index, uint* v)
        {
            _VertexAttribI2uiv_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2uiv");
            _VertexAttribI2uiv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, uint*, void> _VertexAttribI3uiv_fnptr = &VertexAttribI3uiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3uiv(uint index, uint* v) => _VertexAttribI3uiv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI3uiv_Lazy(uint index, uint* v)
        {
            _VertexAttribI3uiv_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3uiv");
            _VertexAttribI3uiv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, uint*, void> _VertexAttribI4uiv_fnptr = &VertexAttribI4uiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4uiv(uint index, uint* v) => _VertexAttribI4uiv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI4uiv_Lazy(uint index, uint* v)
        {
            _VertexAttribI4uiv_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4uiv");
            _VertexAttribI4uiv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, sbyte*, void> _VertexAttribI4bv_fnptr = &VertexAttribI4bv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4bv(uint index, sbyte* v) => _VertexAttribI4bv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI4bv_Lazy(uint index, sbyte* v)
        {
            _VertexAttribI4bv_fnptr = (delegate* unmanaged<uint, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4bv");
            _VertexAttribI4bv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, short*, void> _VertexAttribI4sv_fnptr = &VertexAttribI4sv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4sv(uint index, short* v) => _VertexAttribI4sv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI4sv_Lazy(uint index, short* v)
        {
            _VertexAttribI4sv_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4sv");
            _VertexAttribI4sv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, byte*, void> _VertexAttribI4ubv_fnptr = &VertexAttribI4ubv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4ubv(uint index, byte* v) => _VertexAttribI4ubv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI4ubv_Lazy(uint index, byte* v)
        {
            _VertexAttribI4ubv_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4ubv");
            _VertexAttribI4ubv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, ushort*, void> _VertexAttribI4usv_fnptr = &VertexAttribI4usv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4usv(uint index, ushort* v) => _VertexAttribI4usv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribI4usv_Lazy(uint index, ushort* v)
        {
            _VertexAttribI4usv_fnptr = (delegate* unmanaged<uint, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4usv");
            _VertexAttribI4usv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, uint*, void> _GetUniformuiv_fnptr = &GetUniformuiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformuiv(ProgramHandle program, int location, uint* parameters) => _GetUniformuiv_fnptr(program, location, parameters);
        [UnmanagedCallersOnly]
        private static void GetUniformuiv_Lazy(ProgramHandle program, int location, uint* parameters)
        {
            _GetUniformuiv_fnptr = (delegate* unmanaged<ProgramHandle, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformuiv");
            _GetUniformuiv_fnptr(program, location, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, byte*, void> _BindFragDataLocation_fnptr = &BindFragDataLocation_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Bind a user-defined varying out variable to a fragment shader color number. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocation.xhtml" /></remarks>
        public static void BindFragDataLocation(ProgramHandle program, uint color, byte* name) => _BindFragDataLocation_fnptr(program, color, name);
        [UnmanagedCallersOnly]
        private static void BindFragDataLocation_Lazy(ProgramHandle program, uint color, byte* name)
        {
            _BindFragDataLocation_fnptr = (delegate* unmanaged<ProgramHandle, uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glBindFragDataLocation");
            _BindFragDataLocation_fnptr(program, color, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, byte*, int> _GetFragDataLocation_fnptr = &GetFragDataLocation_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Query the bindings of color numbers to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataLocation.xhtml" /></remarks>
        public static int GetFragDataLocation(ProgramHandle program, byte* name) => _GetFragDataLocation_fnptr(program, name);
        [UnmanagedCallersOnly]
        private static int GetFragDataLocation_Lazy(ProgramHandle program, byte* name)
        {
            _GetFragDataLocation_fnptr = (delegate* unmanaged<ProgramHandle, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetFragDataLocation");
            return _GetFragDataLocation_fnptr(program, name);
        }
        
        private static delegate* unmanaged<int, uint, void> _Uniform1ui_fnptr = &Uniform1ui_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1ui(int location, uint v0) => _Uniform1ui_fnptr(location, v0);
        [UnmanagedCallersOnly]
        private static void Uniform1ui_Lazy(int location, uint v0)
        {
            _Uniform1ui_fnptr = (delegate* unmanaged<int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1ui");
            _Uniform1ui_fnptr(location, v0);
        }
        
        private static delegate* unmanaged<int, uint, uint, void> _Uniform2ui_fnptr = &Uniform2ui_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2ui(int location, uint v0, uint v1) => _Uniform2ui_fnptr(location, v0, v1);
        [UnmanagedCallersOnly]
        private static void Uniform2ui_Lazy(int location, uint v0, uint v1)
        {
            _Uniform2ui_fnptr = (delegate* unmanaged<int, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2ui");
            _Uniform2ui_fnptr(location, v0, v1);
        }
        
        private static delegate* unmanaged<int, uint, uint, uint, void> _Uniform3ui_fnptr = &Uniform3ui_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3ui(int location, uint v0, uint v1, uint v2) => _Uniform3ui_fnptr(location, v0, v1, v2);
        [UnmanagedCallersOnly]
        private static void Uniform3ui_Lazy(int location, uint v0, uint v1, uint v2)
        {
            _Uniform3ui_fnptr = (delegate* unmanaged<int, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3ui");
            _Uniform3ui_fnptr(location, v0, v1, v2);
        }
        
        private static delegate* unmanaged<int, uint, uint, uint, uint, void> _Uniform4ui_fnptr = &Uniform4ui_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3) => _Uniform4ui_fnptr(location, v0, v1, v2, v3);
        [UnmanagedCallersOnly]
        private static void Uniform4ui_Lazy(int location, uint v0, uint v1, uint v2, uint v3)
        {
            _Uniform4ui_fnptr = (delegate* unmanaged<int, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4ui");
            _Uniform4ui_fnptr(location, v0, v1, v2, v3);
        }
        
        private static delegate* unmanaged<int, int, uint*, void> _Uniform1uiv_fnptr = &Uniform1uiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1uiv(int location, int count, uint* value) => _Uniform1uiv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform1uiv_Lazy(int location, int count, uint* value)
        {
            _Uniform1uiv_fnptr = (delegate* unmanaged<int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1uiv");
            _Uniform1uiv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, uint*, void> _Uniform2uiv_fnptr = &Uniform2uiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2uiv(int location, int count, uint* value) => _Uniform2uiv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform2uiv_Lazy(int location, int count, uint* value)
        {
            _Uniform2uiv_fnptr = (delegate* unmanaged<int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2uiv");
            _Uniform2uiv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, uint*, void> _Uniform3uiv_fnptr = &Uniform3uiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3uiv(int location, int count, uint* value) => _Uniform3uiv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform3uiv_Lazy(int location, int count, uint* value)
        {
            _Uniform3uiv_fnptr = (delegate* unmanaged<int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3uiv");
            _Uniform3uiv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, uint*, void> _Uniform4uiv_fnptr = &Uniform4uiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4uiv(int location, int count, uint* value) => _Uniform4uiv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform4uiv_Lazy(int location, int count, uint* value)
        {
            _Uniform4uiv_fnptr = (delegate* unmanaged<int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4uiv");
            _Uniform4uiv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<TextureTarget, TextureParameterName, int*, void> _TexParameterIiv_fnptr = &TexParameterIiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterIiv(TextureTarget target, TextureParameterName pname, int* parameters) => _TexParameterIiv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TexParameterIiv_Lazy(TextureTarget target, TextureParameterName pname, int* parameters)
        {
            _TexParameterIiv_fnptr = (delegate* unmanaged<TextureTarget, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameterIiv");
            _TexParameterIiv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, TextureParameterName, uint*, void> _TexParameterIuiv_fnptr = &TexParameterIuiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterIuiv(TextureTarget target, TextureParameterName pname, uint* parameters) => _TexParameterIuiv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TexParameterIuiv_Lazy(TextureTarget target, TextureParameterName pname, uint* parameters)
        {
            _TexParameterIuiv_fnptr = (delegate* unmanaged<TextureTarget, TextureParameterName, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameterIuiv");
            _TexParameterIuiv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void> _GetTexParameterIiv_fnptr = &GetTexParameterIiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterIiv(TextureTarget target, GetTextureParameter pname, int* parameters) => _GetTexParameterIiv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexParameterIiv_Lazy(TextureTarget target, GetTextureParameter pname, int* parameters)
        {
            _GetTexParameterIiv_fnptr = (delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexParameterIiv");
            _GetTexParameterIiv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, GetTextureParameter, uint*, void> _GetTexParameterIuiv_fnptr = &GetTexParameterIuiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterIuiv(TextureTarget target, GetTextureParameter pname, uint* parameters) => _GetTexParameterIuiv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTexParameterIuiv_Lazy(TextureTarget target, GetTextureParameter pname, uint* parameters)
        {
            _GetTexParameterIuiv_fnptr = (delegate* unmanaged<TextureTarget, GetTextureParameter, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexParameterIuiv");
            _GetTexParameterIuiv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<Buffer, int, int*, void> _ClearBufferiv_fnptr = &ClearBufferiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferiv(Buffer buffer, int drawbuffer, int* value) => _ClearBufferiv_fnptr(buffer, drawbuffer, value);
        [UnmanagedCallersOnly]
        private static void ClearBufferiv_Lazy(Buffer buffer, int drawbuffer, int* value)
        {
            _ClearBufferiv_fnptr = (delegate* unmanaged<Buffer, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glClearBufferiv");
            _ClearBufferiv_fnptr(buffer, drawbuffer, value);
        }
        
        private static delegate* unmanaged<Buffer, int, uint*, void> _ClearBufferuiv_fnptr = &ClearBufferuiv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferuiv(Buffer buffer, int drawbuffer, uint* value) => _ClearBufferuiv_fnptr(buffer, drawbuffer, value);
        [UnmanagedCallersOnly]
        private static void ClearBufferuiv_Lazy(Buffer buffer, int drawbuffer, uint* value)
        {
            _ClearBufferuiv_fnptr = (delegate* unmanaged<Buffer, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glClearBufferuiv");
            _ClearBufferuiv_fnptr(buffer, drawbuffer, value);
        }
        
        private static delegate* unmanaged<Buffer, int, float*, void> _ClearBufferfv_fnptr = &ClearBufferfv_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferfv(Buffer buffer, int drawbuffer, float* value) => _ClearBufferfv_fnptr(buffer, drawbuffer, value);
        [UnmanagedCallersOnly]
        private static void ClearBufferfv_Lazy(Buffer buffer, int drawbuffer, float* value)
        {
            _ClearBufferfv_fnptr = (delegate* unmanaged<Buffer, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glClearBufferfv");
            _ClearBufferfv_fnptr(buffer, drawbuffer, value);
        }
        
        private static delegate* unmanaged<Buffer, int, float, int, void> _ClearBufferfi_fnptr = &ClearBufferfi_Lazy;
        /// <summary> <b>[requires: v3.0]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferfi(Buffer buffer, int drawbuffer, float depth, int stencil) => _ClearBufferfi_fnptr(buffer, drawbuffer, depth, stencil);
        [UnmanagedCallersOnly]
        private static void ClearBufferfi_Lazy(Buffer buffer, int drawbuffer, float depth, int stencil)
        {
            _ClearBufferfi_fnptr = (delegate* unmanaged<Buffer, int, float, int, void>)GLLoader.BindingsContext.GetProcAddress("glClearBufferfi");
            _ClearBufferfi_fnptr(buffer, drawbuffer, depth, stencil);
        }
        
        private static delegate* unmanaged<StringName, uint, byte*> _GetStringi__fnptr = &GetStringi__Lazy;
        /// <summary> <b>[requires: v3.0]</b> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <param name="index"> For glGetStringi, specifies the index of the string to return. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml" /></remarks>
        public static byte* GetStringi_(StringName name, uint index) => _GetStringi__fnptr(name, index);
        [UnmanagedCallersOnly]
        private static byte* GetStringi__Lazy(StringName name, uint index)
        {
            _GetStringi__fnptr = (delegate* unmanaged<StringName, uint, byte*>)GLLoader.BindingsContext.GetProcAddress("glGetStringi");
            return _GetStringi__fnptr(name, index);
        }
        
        private static delegate* unmanaged<RenderbufferHandle, byte> _IsRenderbuffer_fnptr = &IsRenderbuffer_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Determine if a name corresponds to a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml" /></remarks>
        public static byte IsRenderbuffer(RenderbufferHandle renderbuffer) => _IsRenderbuffer_fnptr(renderbuffer);
        [UnmanagedCallersOnly]
        private static byte IsRenderbuffer_Lazy(RenderbufferHandle renderbuffer)
        {
            _IsRenderbuffer_fnptr = (delegate* unmanaged<RenderbufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsRenderbuffer");
            return _IsRenderbuffer_fnptr(renderbuffer);
        }
        
        private static delegate* unmanaged<RenderbufferTarget, RenderbufferHandle, void> _BindRenderbuffer_fnptr = &BindRenderbuffer_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Bind a renderbuffer to a renderbuffer target. </summary>
        /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml" /></remarks>
        public static void BindRenderbuffer(RenderbufferTarget target, RenderbufferHandle renderbuffer) => _BindRenderbuffer_fnptr(target, renderbuffer);
        [UnmanagedCallersOnly]
        private static void BindRenderbuffer_Lazy(RenderbufferTarget target, RenderbufferHandle renderbuffer)
        {
            _BindRenderbuffer_fnptr = (delegate* unmanaged<RenderbufferTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindRenderbuffer");
            _BindRenderbuffer_fnptr(target, renderbuffer);
        }
        
        private static delegate* unmanaged<int, RenderbufferHandle*, void> _DeleteRenderbuffers_fnptr = &DeleteRenderbuffers_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Delete renderbuffer objects. </summary>
        /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
        /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml" /></remarks>
        public static void DeleteRenderbuffers(int n, RenderbufferHandle* renderbuffers) => _DeleteRenderbuffers_fnptr(n, renderbuffers);
        [UnmanagedCallersOnly]
        private static void DeleteRenderbuffers_Lazy(int n, RenderbufferHandle* renderbuffers)
        {
            _DeleteRenderbuffers_fnptr = (delegate* unmanaged<int, RenderbufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteRenderbuffers");
            _DeleteRenderbuffers_fnptr(n, renderbuffers);
        }
        
        private static delegate* unmanaged<int, RenderbufferHandle*, void> _GenRenderbuffers_fnptr = &GenRenderbuffers_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate renderbuffer object names. </summary>
        /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
        /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml" /></remarks>
        public static void GenRenderbuffers(int n, RenderbufferHandle* renderbuffers) => _GenRenderbuffers_fnptr(n, renderbuffers);
        [UnmanagedCallersOnly]
        private static void GenRenderbuffers_Lazy(int n, RenderbufferHandle* renderbuffers)
        {
            _GenRenderbuffers_fnptr = (delegate* unmanaged<int, RenderbufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenRenderbuffers");
            _GenRenderbuffers_fnptr(n, renderbuffers);
        }
        
        private static delegate* unmanaged<RenderbufferTarget, InternalFormat, int, int, void> _RenderbufferStorage_fnptr = &RenderbufferStorage_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Establish data storage, format and dimensions of a    renderbuffer object's image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
        public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => _RenderbufferStorage_fnptr(target, internalformat, width, height);
        [UnmanagedCallersOnly]
        private static void RenderbufferStorage_Lazy(RenderbufferTarget target, InternalFormat internalformat, int width, int height)
        {
            _RenderbufferStorage_fnptr = (delegate* unmanaged<RenderbufferTarget, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRenderbufferStorage");
            _RenderbufferStorage_fnptr(target, internalformat, width, height);
        }
        
        private static delegate* unmanaged<RenderbufferTarget, RenderbufferParameterName, int*, void> _GetRenderbufferParameteriv_fnptr = &GetRenderbufferParameteriv_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
        public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => _GetRenderbufferParameteriv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetRenderbufferParameteriv_Lazy(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters)
        {
            _GetRenderbufferParameteriv_fnptr = (delegate* unmanaged<RenderbufferTarget, RenderbufferParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetRenderbufferParameteriv");
            _GetRenderbufferParameteriv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<FramebufferHandle, byte> _IsFramebuffer_fnptr = &IsFramebuffer_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Determine if a name corresponds to a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml" /></remarks>
        public static byte IsFramebuffer(FramebufferHandle framebuffer) => _IsFramebuffer_fnptr(framebuffer);
        [UnmanagedCallersOnly]
        private static byte IsFramebuffer_Lazy(FramebufferHandle framebuffer)
        {
            _IsFramebuffer_fnptr = (delegate* unmanaged<FramebufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsFramebuffer");
            return _IsFramebuffer_fnptr(framebuffer);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferHandle, void> _BindFramebuffer_fnptr = &BindFramebuffer_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Bind a framebuffer to a framebuffer target. </summary>
        /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml" /></remarks>
        public static void BindFramebuffer(FramebufferTarget target, FramebufferHandle framebuffer) => _BindFramebuffer_fnptr(target, framebuffer);
        [UnmanagedCallersOnly]
        private static void BindFramebuffer_Lazy(FramebufferTarget target, FramebufferHandle framebuffer)
        {
            _BindFramebuffer_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindFramebuffer");
            _BindFramebuffer_fnptr(target, framebuffer);
        }
        
        private static delegate* unmanaged<int, FramebufferHandle*, void> _DeleteFramebuffers_fnptr = &DeleteFramebuffers_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Delete framebuffer objects. </summary>
        /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
        /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml" /></remarks>
        public static void DeleteFramebuffers(int n, FramebufferHandle* framebuffers) => _DeleteFramebuffers_fnptr(n, framebuffers);
        [UnmanagedCallersOnly]
        private static void DeleteFramebuffers_Lazy(int n, FramebufferHandle* framebuffers)
        {
            _DeleteFramebuffers_fnptr = (delegate* unmanaged<int, FramebufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteFramebuffers");
            _DeleteFramebuffers_fnptr(n, framebuffers);
        }
        
        private static delegate* unmanaged<int, FramebufferHandle*, void> _GenFramebuffers_fnptr = &GenFramebuffers_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate framebuffer object names. </summary>
        /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
        /// <param name="ids"> Specifies an array in which the generated framebuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml" /></remarks>
        public static void GenFramebuffers(int n, FramebufferHandle* framebuffers) => _GenFramebuffers_fnptr(n, framebuffers);
        [UnmanagedCallersOnly]
        private static void GenFramebuffers_Lazy(int n, FramebufferHandle* framebuffers)
        {
            _GenFramebuffers_fnptr = (delegate* unmanaged<int, FramebufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenFramebuffers");
            _GenFramebuffers_fnptr(n, framebuffers);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferStatus> _CheckFramebufferStatus_fnptr = &CheckFramebufferStatus_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Check the completeness status of a framebuffer. </summary>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
        public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => _CheckFramebufferStatus_fnptr(target);
        [UnmanagedCallersOnly]
        private static FramebufferStatus CheckFramebufferStatus_Lazy(FramebufferTarget target)
        {
            _CheckFramebufferStatus_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferStatus>)GLLoader.BindingsContext.GetProcAddress("glCheckFramebufferStatus");
            return _CheckFramebufferStatus_fnptr(target);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void> _FramebufferTexture1D_fnptr = &FramebufferTexture1D_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => _FramebufferTexture1D_fnptr(target, attachment, textarget, texture, level);
        [UnmanagedCallersOnly]
        private static void FramebufferTexture1D_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level)
        {
            _FramebufferTexture1D_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture1D");
            _FramebufferTexture1D_fnptr(target, attachment, textarget, texture, level);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void> _FramebufferTexture2D_fnptr = &FramebufferTexture2D_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => _FramebufferTexture2D_fnptr(target, attachment, textarget, texture, level);
        [UnmanagedCallersOnly]
        private static void FramebufferTexture2D_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level)
        {
            _FramebufferTexture2D_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture2D");
            _FramebufferTexture2D_fnptr(target, attachment, textarget, texture, level);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, int, void> _FramebufferTexture3D_fnptr = &FramebufferTexture3D_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset) => _FramebufferTexture3D_fnptr(target, attachment, textarget, texture, level, zoffset);
        [UnmanagedCallersOnly]
        private static void FramebufferTexture3D_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset)
        {
            _FramebufferTexture3D_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture3D");
            _FramebufferTexture3D_fnptr(target, attachment, textarget, texture, level, zoffset);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void> _FramebufferRenderbuffer_fnptr = &FramebufferRenderbuffer_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
        public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => _FramebufferRenderbuffer_fnptr(target, attachment, renderbuffertarget, renderbuffer);
        [UnmanagedCallersOnly]
        private static void FramebufferRenderbuffer_Lazy(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer)
        {
            _FramebufferRenderbuffer_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferRenderbuffer");
            _FramebufferRenderbuffer_fnptr(target, attachment, renderbuffertarget, renderbuffer);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void> _GetFramebufferAttachmentParameteriv_fnptr = &GetFramebufferAttachmentParameteriv_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
        public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => _GetFramebufferAttachmentParameteriv_fnptr(target, attachment, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetFramebufferAttachmentParameteriv_Lazy(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters)
        {
            _GetFramebufferAttachmentParameteriv_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFramebufferAttachmentParameteriv");
            _GetFramebufferAttachmentParameteriv_fnptr(target, attachment, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, void> _GenerateMipmap_fnptr = &GenerateMipmap_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate mipmaps for a specified texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
        public static void GenerateMipmap(TextureTarget target) => _GenerateMipmap_fnptr(target);
        [UnmanagedCallersOnly]
        private static void GenerateMipmap_Lazy(TextureTarget target)
        {
            _GenerateMipmap_fnptr = (delegate* unmanaged<TextureTarget, void>)GLLoader.BindingsContext.GetProcAddress("glGenerateMipmap");
            _GenerateMipmap_fnptr(target);
        }
        
        private static delegate* unmanaged<int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void> _BlitFramebuffer_fnptr = &BlitFramebuffer_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
        public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => _BlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        [UnmanagedCallersOnly]
        private static void BlitFramebuffer_Lazy(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter)
        {
            _BlitFramebuffer_fnptr = (delegate* unmanaged<int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void>)GLLoader.BindingsContext.GetProcAddress("glBlitFramebuffer");
            _BlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        
        private static delegate* unmanaged<RenderbufferTarget, int, InternalFormat, int, int, void> _RenderbufferStorageMultisample_fnptr = &RenderbufferStorageMultisample_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object's image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
        public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisample_fnptr(target, samples, internalformat, width, height);
        [UnmanagedCallersOnly]
        private static void RenderbufferStorageMultisample_Lazy(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height)
        {
            _RenderbufferStorageMultisample_fnptr = (delegate* unmanaged<RenderbufferTarget, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRenderbufferStorageMultisample");
            _RenderbufferStorageMultisample_fnptr(target, samples, internalformat, width, height);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void> _FramebufferTextureLayer_fnptr = &FramebufferTextureLayer_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
        public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => _FramebufferTextureLayer_fnptr(target, attachment, texture, level, layer);
        [UnmanagedCallersOnly]
        private static void FramebufferTextureLayer_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer)
        {
            _FramebufferTextureLayer_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureLayer");
            _FramebufferTextureLayer_fnptr(target, attachment, texture, level, layer);
        }
        
        private static delegate* unmanaged<BufferTargetARB, IntPtr, nint, MapBufferAccessMask, void*> _MapBufferRange_fnptr = &MapBufferRange_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> Map all or part of a buffer object's data store into the client's address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
        public static void* MapBufferRange(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access) => _MapBufferRange_fnptr(target, offset, length, access);
        [UnmanagedCallersOnly]
        private static void* MapBufferRange_Lazy(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access)
        {
            _MapBufferRange_fnptr = (delegate* unmanaged<BufferTargetARB, IntPtr, nint, MapBufferAccessMask, void*>)GLLoader.BindingsContext.GetProcAddress("glMapBufferRange");
            return _MapBufferRange_fnptr(target, offset, length, access);
        }
        
        private static delegate* unmanaged<BufferTargetARB, IntPtr, nint, void> _FlushMappedBufferRange_fnptr = &FlushMappedBufferRange_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
        public static void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, nint length) => _FlushMappedBufferRange_fnptr(target, offset, length);
        [UnmanagedCallersOnly]
        private static void FlushMappedBufferRange_Lazy(BufferTargetARB target, IntPtr offset, nint length)
        {
            _FlushMappedBufferRange_fnptr = (delegate* unmanaged<BufferTargetARB, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glFlushMappedBufferRange");
            _FlushMappedBufferRange_fnptr(target, offset, length);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, void> _BindVertexArray_fnptr = &BindVertexArray_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Bind a vertex array object. </summary>
        /// <param name="array"> Specifies the name of the vertex array to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" /></remarks>
        public static void BindVertexArray(VertexArrayHandle array) => _BindVertexArray_fnptr(array);
        [UnmanagedCallersOnly]
        private static void BindVertexArray_Lazy(VertexArrayHandle array)
        {
            _BindVertexArray_fnptr = (delegate* unmanaged<VertexArrayHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindVertexArray");
            _BindVertexArray_fnptr(array);
        }
        
        private static delegate* unmanaged<int, VertexArrayHandle*, void> _DeleteVertexArrays_fnptr = &DeleteVertexArrays_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Delete vertex array objects. </summary>
        /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
        /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml" /></remarks>
        public static void DeleteVertexArrays(int n, VertexArrayHandle* arrays) => _DeleteVertexArrays_fnptr(n, arrays);
        [UnmanagedCallersOnly]
        private static void DeleteVertexArrays_Lazy(int n, VertexArrayHandle* arrays)
        {
            _DeleteVertexArrays_fnptr = (delegate* unmanaged<int, VertexArrayHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteVertexArrays");
            _DeleteVertexArrays_fnptr(n, arrays);
        }
        
        private static delegate* unmanaged<int, VertexArrayHandle*, void> _GenVertexArrays_fnptr = &GenVertexArrays_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Generate vertex array object names. </summary>
        /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
        /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" /></remarks>
        public static void GenVertexArrays(int n, VertexArrayHandle* arrays) => _GenVertexArrays_fnptr(n, arrays);
        [UnmanagedCallersOnly]
        private static void GenVertexArrays_Lazy(int n, VertexArrayHandle* arrays)
        {
            _GenVertexArrays_fnptr = (delegate* unmanaged<int, VertexArrayHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenVertexArrays");
            _GenVertexArrays_fnptr(n, arrays);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, byte> _IsVertexArray_fnptr = &IsVertexArray_Lazy;
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Determine if a name corresponds to a vertex array object. </summary>
        /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml" /></remarks>
        public static byte IsVertexArray(VertexArrayHandle array) => _IsVertexArray_fnptr(array);
        [UnmanagedCallersOnly]
        private static byte IsVertexArray_Lazy(VertexArrayHandle array)
        {
            _IsVertexArray_fnptr = (delegate* unmanaged<VertexArrayHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsVertexArray");
            return _IsVertexArray_fnptr(array);
        }
        
        private static delegate* unmanaged<PrimitiveType, int, int, int, void> _DrawArraysInstanced_fnptr = &DrawArraysInstanced_Lazy;
        /// <summary> <b>[requires: v3.1]</b> Draw multiple instances of a range of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstanced.xhtml" /></remarks>
        public static void DrawArraysInstanced(PrimitiveType mode, int first, int count, int instancecount) => _DrawArraysInstanced_fnptr(mode, first, count, instancecount);
        [UnmanagedCallersOnly]
        private static void DrawArraysInstanced_Lazy(PrimitiveType mode, int first, int count, int instancecount)
        {
            _DrawArraysInstanced_fnptr = (delegate* unmanaged<PrimitiveType, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawArraysInstanced");
            _DrawArraysInstanced_fnptr(mode, first, count, instancecount);
        }
        
        private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void> _DrawElementsInstanced_fnptr = &DrawElementsInstanced_Lazy;
        /// <summary> <b>[requires: v3.1]</b> Draw multiple instances of a set of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstanced.xhtml" /></remarks>
        public static void DrawElementsInstanced(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount) => _DrawElementsInstanced_fnptr(mode, count, type, indices, instancecount);
        [UnmanagedCallersOnly]
        private static void DrawElementsInstanced_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount)
        {
            _DrawElementsInstanced_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsInstanced");
            _DrawElementsInstanced_fnptr(mode, count, type, indices, instancecount);
        }
        
        private static delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, void> _TexBuffer_fnptr = &TexBuffer_Lazy;
        /// <summary> <b>[requires: v3.1]</b> Attach a buffer object's data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
        public static void TexBuffer(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer) => _TexBuffer_fnptr(target, internalformat, buffer);
        [UnmanagedCallersOnly]
        private static void TexBuffer_Lazy(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer)
        {
            _TexBuffer_fnptr = (delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTexBuffer");
            _TexBuffer_fnptr(target, internalformat, buffer);
        }
        
        private static delegate* unmanaged<uint, void> _PrimitiveRestartIndex_fnptr = &PrimitiveRestartIndex_Lazy;
        /// <summary> <b>[requires: v3.1]</b> Specify the primitive restart index. </summary>
        /// <param name="index"> Specifies the value to be interpreted as the primitive restart index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPrimitiveRestartIndex.xhtml" /></remarks>
        public static void PrimitiveRestartIndex(uint index) => _PrimitiveRestartIndex_fnptr(index);
        [UnmanagedCallersOnly]
        private static void PrimitiveRestartIndex_Lazy(uint index)
        {
            _PrimitiveRestartIndex_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glPrimitiveRestartIndex");
            _PrimitiveRestartIndex_fnptr(index);
        }
        
        private static delegate* unmanaged<CopyBufferSubDataTarget, CopyBufferSubDataTarget, IntPtr, IntPtr, nint, void> _CopyBufferSubData_fnptr = &CopyBufferSubData_Lazy;
        /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
        /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
        public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => _CopyBufferSubData_fnptr(readTarget, writeTarget, readOffset, writeOffset, size);
        [UnmanagedCallersOnly]
        private static void CopyBufferSubData_Lazy(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size)
        {
            _CopyBufferSubData_fnptr = (delegate* unmanaged<CopyBufferSubDataTarget, CopyBufferSubDataTarget, IntPtr, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glCopyBufferSubData");
            _CopyBufferSubData_fnptr(readTarget, writeTarget, readOffset, writeOffset, size);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, byte**, uint*, void> _GetUniformIndices_fnptr = &GetUniformIndices_Lazy;
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
        /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
        /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
        /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml" /></remarks>
        public static void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, uint* uniformIndices) => _GetUniformIndices_fnptr(program, uniformCount, uniformNames, uniformIndices);
        [UnmanagedCallersOnly]
        private static void GetUniformIndices_Lazy(ProgramHandle program, int uniformCount, byte** uniformNames, uint* uniformIndices)
        {
            _GetUniformIndices_fnptr = (delegate* unmanaged<ProgramHandle, int, byte**, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformIndices");
            _GetUniformIndices_fnptr(program, uniformCount, uniformNames, uniformIndices);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, uint*, UniformPName, int*, void> _GetActiveUniformsiv_fnptr = &GetActiveUniformsiv_Lazy;
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Returns information about several active uniform variables for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
        /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
        /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
        /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml" /></remarks>
        public static void GetActiveUniformsiv(ProgramHandle program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => _GetActiveUniformsiv_fnptr(program, uniformCount, uniformIndices, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetActiveUniformsiv_Lazy(ProgramHandle program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters)
        {
            _GetActiveUniformsiv_fnptr = (delegate* unmanaged<ProgramHandle, int, uint*, UniformPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniformsiv");
            _GetActiveUniformsiv_fnptr(program, uniformCount, uniformIndices, pname, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, int, int*, byte*, void> _GetActiveUniformName_fnptr = &GetActiveUniformName_Lazy;
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Query the name of an active uniform. </summary>
        /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
        /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
        /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
        /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
        /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml" /></remarks>
        public static void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => _GetActiveUniformName_fnptr(program, uniformIndex, bufSize, length, uniformName);
        [UnmanagedCallersOnly]
        private static void GetActiveUniformName_Lazy(ProgramHandle program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
        {
            _GetActiveUniformName_fnptr = (delegate* unmanaged<ProgramHandle, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniformName");
            _GetActiveUniformName_fnptr(program, uniformIndex, bufSize, length, uniformName);
        }
        
        private static delegate* unmanaged<ProgramHandle, byte*, uint> _GetUniformBlockIndex_fnptr = &GetUniformBlockIndex_Lazy;
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml" /></remarks>
        public static uint GetUniformBlockIndex(ProgramHandle program, byte* uniformBlockName) => _GetUniformBlockIndex_fnptr(program, uniformBlockName);
        [UnmanagedCallersOnly]
        private static uint GetUniformBlockIndex_Lazy(ProgramHandle program, byte* uniformBlockName)
        {
            _GetUniformBlockIndex_fnptr = (delegate* unmanaged<ProgramHandle, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetUniformBlockIndex");
            return _GetUniformBlockIndex_fnptr(program, uniformBlockName);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, UniformBlockPName, int*, void> _GetActiveUniformBlockiv_fnptr = &GetActiveUniformBlockiv_Lazy;
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Query information about an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="pname"> Specifies the name of the parameter to query. </param>
        /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml" /></remarks>
        public static void GetActiveUniformBlockiv(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => _GetActiveUniformBlockiv_fnptr(program, uniformBlockIndex, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetActiveUniformBlockiv_Lazy(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters)
        {
            _GetActiveUniformBlockiv_fnptr = (delegate* unmanaged<ProgramHandle, uint, UniformBlockPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniformBlockiv");
            _GetActiveUniformBlockiv_fnptr(program, uniformBlockIndex, pname, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, int, int*, byte*, void> _GetActiveUniformBlockName_fnptr = &GetActiveUniformBlockName_Lazy;
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the name of an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml" /></remarks>
        public static void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => _GetActiveUniformBlockName_fnptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
        [UnmanagedCallersOnly]
        private static void GetActiveUniformBlockName_Lazy(ProgramHandle program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
        {
            _GetActiveUniformBlockName_fnptr = (delegate* unmanaged<ProgramHandle, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniformBlockName");
            _GetActiveUniformBlockName_fnptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, uint, void> _UniformBlockBinding_fnptr = &UniformBlockBinding_Lazy;
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Assign a binding point to an active uniform block. </summary>
        /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
        /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
        /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml" /></remarks>
        public static void UniformBlockBinding(ProgramHandle program, uint uniformBlockIndex, uint uniformBlockBinding) => _UniformBlockBinding_fnptr(program, uniformBlockIndex, uniformBlockBinding);
        [UnmanagedCallersOnly]
        private static void UniformBlockBinding_Lazy(ProgramHandle program, uint uniformBlockIndex, uint uniformBlockBinding)
        {
            _UniformBlockBinding_fnptr = (delegate* unmanaged<ProgramHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniformBlockBinding");
            _UniformBlockBinding_fnptr(program, uniformBlockIndex, uniformBlockBinding);
        }
        
        private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void> _DrawElementsBaseVertex_fnptr = &DrawElementsBaseVertex_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml" /></remarks>
        public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => _DrawElementsBaseVertex_fnptr(mode, count, type, indices, basevertex);
        [UnmanagedCallersOnly]
        private static void DrawElementsBaseVertex_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex)
        {
            _DrawElementsBaseVertex_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsBaseVertex");
            _DrawElementsBaseVertex_fnptr(mode, count, type, indices, basevertex);
        }
        
        private static delegate* unmanaged<PrimitiveType, uint, uint, int, DrawElementsType, void*, int, void> _DrawRangeElementsBaseVertex_fnptr = &DrawRangeElementsBaseVertex_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml" /></remarks>
        public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => _DrawRangeElementsBaseVertex_fnptr(mode, start, end, count, type, indices, basevertex);
        [UnmanagedCallersOnly]
        private static void DrawRangeElementsBaseVertex_Lazy(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex)
        {
            _DrawRangeElementsBaseVertex_fnptr = (delegate* unmanaged<PrimitiveType, uint, uint, int, DrawElementsType, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawRangeElementsBaseVertex");
            _DrawRangeElementsBaseVertex_fnptr(mode, start, end, count, type, indices, basevertex);
        }
        
        private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, int, void> _DrawElementsInstancedBaseVertex_fnptr = &DrawElementsInstancedBaseVertex_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => _DrawElementsInstancedBaseVertex_fnptr(mode, count, type, indices, instancecount, basevertex);
        [UnmanagedCallersOnly]
        private static void DrawElementsInstancedBaseVertex_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex)
        {
            _DrawElementsInstancedBaseVertex_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsInstancedBaseVertex");
            _DrawElementsInstancedBaseVertex_fnptr(mode, count, type, indices, instancecount, basevertex);
        }
        
        private static delegate* unmanaged<PrimitiveType, int*, DrawElementsType, void**, int, int*, void> _MultiDrawElementsBaseVertex_fnptr = &MultiDrawElementsBaseVertex_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
        /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml" /></remarks>
        public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => _MultiDrawElementsBaseVertex_fnptr(mode, count, type, indices, drawcount, basevertex);
        [UnmanagedCallersOnly]
        private static void MultiDrawElementsBaseVertex_Lazy(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex)
        {
            _MultiDrawElementsBaseVertex_fnptr = (delegate* unmanaged<PrimitiveType, int*, DrawElementsType, void**, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsBaseVertex");
            _MultiDrawElementsBaseVertex_fnptr(mode, count, type, indices, drawcount, basevertex);
        }
        
        private static delegate* unmanaged<VertexProvokingMode, void> _ProvokingVertex_fnptr = &ProvokingVertex_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex]</b> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
        /// <param name="provokeMode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml" /></remarks>
        public static void ProvokingVertex(VertexProvokingMode mode) => _ProvokingVertex_fnptr(mode);
        [UnmanagedCallersOnly]
        private static void ProvokingVertex_Lazy(VertexProvokingMode mode)
        {
            _ProvokingVertex_fnptr = (delegate* unmanaged<VertexProvokingMode, void>)GLLoader.BindingsContext.GetProcAddress("glProvokingVertex");
            _ProvokingVertex_fnptr(mode);
        }
        
        private static delegate* unmanaged<SyncCondition, SyncBehaviorFlags, IntPtr> _FenceSync_fnptr = &FenceSync_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Create a new sync object and insert it into the GL command stream. </summary>
        /// <param name="condition"> Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
        /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml" /></remarks>
        public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) _FenceSync_fnptr(condition, flags);
        [UnmanagedCallersOnly]
        private static IntPtr FenceSync_Lazy(SyncCondition condition, SyncBehaviorFlags flags)
        {
            _FenceSync_fnptr = (delegate* unmanaged<SyncCondition, SyncBehaviorFlags, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glFenceSync");
            return _FenceSync_fnptr(condition, flags);
        }
        
        private static delegate* unmanaged<GLSync, byte> _IsSync_fnptr = &IsSync_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Determine if a name corresponds to a sync object. </summary>
        /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml" /></remarks>
        public static byte IsSync(GLSync sync) => _IsSync_fnptr(sync);
        [UnmanagedCallersOnly]
        private static byte IsSync_Lazy(GLSync sync)
        {
            _IsSync_fnptr = (delegate* unmanaged<GLSync, byte>)GLLoader.BindingsContext.GetProcAddress("glIsSync");
            return _IsSync_fnptr(sync);
        }
        
        private static delegate* unmanaged<GLSync, void> _DeleteSync_fnptr = &DeleteSync_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Delete a sync object. </summary>
        /// <param name="sync"> The sync object to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml" /></remarks>
        public static void DeleteSync(GLSync sync) => _DeleteSync_fnptr(sync);
        [UnmanagedCallersOnly]
        private static void DeleteSync_Lazy(GLSync sync)
        {
            _DeleteSync_fnptr = (delegate* unmanaged<GLSync, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteSync");
            _DeleteSync_fnptr(sync);
        }
        
        private static delegate* unmanaged<GLSync, SyncObjectMask, ulong, SyncStatus> _ClientWaitSync_fnptr = &ClientWaitSync_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Block and wait for a sync object to become signaled. </summary>
        /// <param name="sync"> The sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
        /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml" /></remarks>
        public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => _ClientWaitSync_fnptr(sync, flags, timeout);
        [UnmanagedCallersOnly]
        private static SyncStatus ClientWaitSync_Lazy(GLSync sync, SyncObjectMask flags, ulong timeout)
        {
            _ClientWaitSync_fnptr = (delegate* unmanaged<GLSync, SyncObjectMask, ulong, SyncStatus>)GLLoader.BindingsContext.GetProcAddress("glClientWaitSync");
            return _ClientWaitSync_fnptr(sync, flags, timeout);
        }
        
        private static delegate* unmanaged<GLSync, SyncBehaviorFlags, ulong, void> _WaitSync_fnptr = &WaitSync_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
        /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
        /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml" /></remarks>
        public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => _WaitSync_fnptr(sync, flags, timeout);
        [UnmanagedCallersOnly]
        private static void WaitSync_Lazy(GLSync sync, SyncBehaviorFlags flags, ulong timeout)
        {
            _WaitSync_fnptr = (delegate* unmanaged<GLSync, SyncBehaviorFlags, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glWaitSync");
            _WaitSync_fnptr(sync, flags, timeout);
        }
        
        private static delegate* unmanaged<GetPName, long*, void> _GetInteger64v_fnptr = &GetInteger64v_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetInteger64v(GetPName pname, long* data) => _GetInteger64v_fnptr(pname, data);
        [UnmanagedCallersOnly]
        private static void GetInteger64v_Lazy(GetPName pname, long* data)
        {
            _GetInteger64v_fnptr = (delegate* unmanaged<GetPName, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInteger64v");
            _GetInteger64v_fnptr(pname, data);
        }
        
        private static delegate* unmanaged<GLSync, SyncParameterName, int, int*, int*, void> _GetSynciv_fnptr = &GetSynciv_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Query the properties of a sync object. </summary>
        /// <param name="sync"> Specifies the sync object whose properties to query. </param>
        /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in values. </param>
        /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
        /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml" /></remarks>
        public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => _GetSynciv_fnptr(sync, pname, count, length, values);
        [UnmanagedCallersOnly]
        private static void GetSynciv_Lazy(GLSync sync, SyncParameterName pname, int count, int* length, int* values)
        {
            _GetSynciv_fnptr = (delegate* unmanaged<GLSync, SyncParameterName, int, int*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSynciv");
            _GetSynciv_fnptr(sync, pname, count, length, values);
        }
        
        private static delegate* unmanaged<GetPName, uint, long*, void> _GetInteger64i_v_fnptr = &GetInteger64i_v_Lazy;
        /// <summary> <b>[requires: v3.2]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetInteger64i_v(GetPName target, uint index, long* data) => _GetInteger64i_v_fnptr(target, index, data);
        [UnmanagedCallersOnly]
        private static void GetInteger64i_v_Lazy(GetPName target, uint index, long* data)
        {
            _GetInteger64i_v_fnptr = (delegate* unmanaged<GetPName, uint, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInteger64i_v");
            _GetInteger64i_v_fnptr(target, index, data);
        }
        
        private static delegate* unmanaged<BufferTargetARB, BufferPNameARB, long*, void> _GetBufferParameteri64v_fnptr = &GetBufferParameteri64v_Lazy;
        /// <summary> <b>[requires: v3.2]</b> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="value"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="data"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetBufferParameteri64v(BufferTargetARB target, BufferPNameARB pname, long* parameters) => _GetBufferParameteri64v_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetBufferParameteri64v_Lazy(BufferTargetARB target, BufferPNameARB pname, long* parameters)
        {
            _GetBufferParameteri64v_fnptr = (delegate* unmanaged<BufferTargetARB, BufferPNameARB, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetBufferParameteri64v");
            _GetBufferParameteri64v_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, void> _FramebufferTexture_fnptr = &FramebufferTexture_Lazy;
        /// <summary> <b>[requires: v3.2]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level) => _FramebufferTexture_fnptr(target, attachment, texture, level);
        [UnmanagedCallersOnly]
        private static void FramebufferTexture_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level)
        {
            _FramebufferTexture_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture");
            _FramebufferTexture_fnptr(target, attachment, texture, level);
        }
        
        private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, byte, void> _TexImage2DMultisample_fnptr = &TexImage2DMultisample_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture's image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> The number of samples in the multisample texture's image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture's image, in texels. </param>
        /// <param name="height"> The height of the multisample texture's image, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml" /></remarks>
        public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, byte fixedsamplelocations) => _TexImage2DMultisample_fnptr(target, samples, internalformat, width, height, fixedsamplelocations);
        [UnmanagedCallersOnly]
        private static void TexImage2DMultisample_Lazy(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, byte fixedsamplelocations)
        {
            _TexImage2DMultisample_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage2DMultisample");
            _TexImage2DMultisample_fnptr(target, samples, internalformat, width, height, fixedsamplelocations);
        }
        
        private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, byte, void> _TexImage3DMultisample_fnptr = &TexImage3DMultisample_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture's image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> The number of samples in the multisample texture's image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture's image, in texels. </param>
        /// <param name="height"> The height of the multisample texture's image, in texels. </param>
        /// <param name="depth">!!missing documentation!!</param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml" /></remarks>
        public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations) => _TexImage3DMultisample_fnptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        [UnmanagedCallersOnly]
        private static void TexImage3DMultisample_Lazy(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations)
        {
            _TexImage3DMultisample_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage3DMultisample");
            _TexImage3DMultisample_fnptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        
        private static delegate* unmanaged<GetMultisamplePNameNV, uint, float*, void> _GetMultisamplefv_fnptr = &GetMultisamplefv_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Retrieve the location of a sample. </summary>
        /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
        /// <param name="index"> Specifies the index of the sample whose position to query. </param>
        /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml" /></remarks>
        public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => _GetMultisamplefv_fnptr(pname, index, val);
        [UnmanagedCallersOnly]
        private static void GetMultisamplefv_Lazy(GetMultisamplePNameNV pname, uint index, float* val)
        {
            _GetMultisamplefv_fnptr = (delegate* unmanaged<GetMultisamplePNameNV, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultisamplefv");
            _GetMultisamplefv_fnptr(pname, index, val);
        }
        
        private static delegate* unmanaged<uint, All, void> _SampleMaski_fnptr = &SampleMaski_Lazy;
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Set the value of a sub-word of the sample mask. </summary>
        /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
        /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml" /></remarks>
        public static void SampleMaski(uint maskNumber, All mask) => _SampleMaski_fnptr(maskNumber, mask);
        [UnmanagedCallersOnly]
        private static void SampleMaski_Lazy(uint maskNumber, All mask)
        {
            _SampleMaski_fnptr = (delegate* unmanaged<uint, All, void>)GLLoader.BindingsContext.GetProcAddress("glSampleMaski");
            _SampleMaski_fnptr(maskNumber, mask);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, uint, byte*, void> _BindFragDataLocationIndexed_fnptr = &BindFragDataLocationIndexed_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml" /></remarks>
        public static void BindFragDataLocationIndexed(ProgramHandle program, uint colorNumber, uint index, byte* name) => _BindFragDataLocationIndexed_fnptr(program, colorNumber, index, name);
        [UnmanagedCallersOnly]
        private static void BindFragDataLocationIndexed_Lazy(ProgramHandle program, uint colorNumber, uint index, byte* name)
        {
            _BindFragDataLocationIndexed_fnptr = (delegate* unmanaged<ProgramHandle, uint, uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glBindFragDataLocationIndexed");
            _BindFragDataLocationIndexed_fnptr(program, colorNumber, index, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, byte*, int> _GetFragDataIndex_fnptr = &GetFragDataIndex_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> Query the bindings of color indices to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml" /></remarks>
        public static int GetFragDataIndex(ProgramHandle program, byte* name) => _GetFragDataIndex_fnptr(program, name);
        [UnmanagedCallersOnly]
        private static int GetFragDataIndex_Lazy(ProgramHandle program, byte* name)
        {
            _GetFragDataIndex_fnptr = (delegate* unmanaged<ProgramHandle, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetFragDataIndex");
            return _GetFragDataIndex_fnptr(program, name);
        }
        
        private static delegate* unmanaged<int, SamplerHandle*, void> _GenSamplers_fnptr = &GenSamplers_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Generate sampler object names. </summary>
        /// <param name="n"> Specifies the number of sampler object names to generate. </param>
        /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml" /></remarks>
        public static void GenSamplers(int count, SamplerHandle* samplers) => _GenSamplers_fnptr(count, samplers);
        [UnmanagedCallersOnly]
        private static void GenSamplers_Lazy(int count, SamplerHandle* samplers)
        {
            _GenSamplers_fnptr = (delegate* unmanaged<int, SamplerHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenSamplers");
            _GenSamplers_fnptr(count, samplers);
        }
        
        private static delegate* unmanaged<int, SamplerHandle*, void> _DeleteSamplers_fnptr = &DeleteSamplers_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Delete named sampler objects. </summary>
        /// <param name="n"> Specifies the number of sampler objects to be deleted. </param>
        /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml" /></remarks>
        public static void DeleteSamplers(int count, SamplerHandle* samplers) => _DeleteSamplers_fnptr(count, samplers);
        [UnmanagedCallersOnly]
        private static void DeleteSamplers_Lazy(int count, SamplerHandle* samplers)
        {
            _DeleteSamplers_fnptr = (delegate* unmanaged<int, SamplerHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteSamplers");
            _DeleteSamplers_fnptr(count, samplers);
        }
        
        private static delegate* unmanaged<SamplerHandle, byte> _IsSampler_fnptr = &IsSampler_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Determine if a name corresponds to a sampler object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a sampler object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml" /></remarks>
        public static byte IsSampler(SamplerHandle sampler) => _IsSampler_fnptr(sampler);
        [UnmanagedCallersOnly]
        private static byte IsSampler_Lazy(SamplerHandle sampler)
        {
            _IsSampler_fnptr = (delegate* unmanaged<SamplerHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsSampler");
            return _IsSampler_fnptr(sampler);
        }
        
        private static delegate* unmanaged<uint, SamplerHandle, void> _BindSampler_fnptr = &BindSampler_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Bind a named sampler to a texturing target. </summary>
        /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
        /// <param name="sampler"> Specifies the name of a sampler. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml" /></remarks>
        public static void BindSampler(uint unit, SamplerHandle sampler) => _BindSampler_fnptr(unit, sampler);
        [UnmanagedCallersOnly]
        private static void BindSampler_Lazy(uint unit, SamplerHandle sampler)
        {
            _BindSampler_fnptr = (delegate* unmanaged<uint, SamplerHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindSampler");
            _BindSampler_fnptr(unit, sampler);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int, void> _SamplerParameteri_fnptr = &SamplerParameteri_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, int param) => _SamplerParameteri_fnptr(sampler, pname, param);
        [UnmanagedCallersOnly]
        private static void SamplerParameteri_Lazy(SamplerHandle sampler, SamplerParameterI pname, int param)
        {
            _SamplerParameteri_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameteri");
            _SamplerParameteri_fnptr(sampler, pname, param);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void> _SamplerParameteriv_fnptr = &SamplerParameteriv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameteriv(SamplerHandle sampler, SamplerParameterI pname, int* param) => _SamplerParameteriv_fnptr(sampler, pname, param);
        [UnmanagedCallersOnly]
        private static void SamplerParameteriv_Lazy(SamplerHandle sampler, SamplerParameterI pname, int* param)
        {
            _SamplerParameteriv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameteriv");
            _SamplerParameteriv_fnptr(sampler, pname, param);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterF, float, void> _SamplerParameterf_fnptr = &SamplerParameterf_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, float param) => _SamplerParameterf_fnptr(sampler, pname, param);
        [UnmanagedCallersOnly]
        private static void SamplerParameterf_Lazy(SamplerHandle sampler, SamplerParameterF pname, float param)
        {
            _SamplerParameterf_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterF, float, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameterf");
            _SamplerParameterf_fnptr(sampler, pname, param);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterF, float*, void> _SamplerParameterfv_fnptr = &SamplerParameterfv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterfv(SamplerHandle sampler, SamplerParameterF pname, float* param) => _SamplerParameterfv_fnptr(sampler, pname, param);
        [UnmanagedCallersOnly]
        private static void SamplerParameterfv_Lazy(SamplerHandle sampler, SamplerParameterF pname, float* param)
        {
            _SamplerParameterfv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterF, float*, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameterfv");
            _SamplerParameterfv_fnptr(sampler, pname, param);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void> _SamplerParameterIiv_fnptr = &SamplerParameterIiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterIiv(SamplerHandle sampler, SamplerParameterI pname, int* param) => _SamplerParameterIiv_fnptr(sampler, pname, param);
        [UnmanagedCallersOnly]
        private static void SamplerParameterIiv_Lazy(SamplerHandle sampler, SamplerParameterI pname, int* param)
        {
            _SamplerParameterIiv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameterIiv");
            _SamplerParameterIiv_fnptr(sampler, pname, param);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterI, uint*, void> _SamplerParameterIuiv_fnptr = &SamplerParameterIuiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterIuiv(SamplerHandle sampler, SamplerParameterI pname, uint* param) => _SamplerParameterIuiv_fnptr(sampler, pname, param);
        [UnmanagedCallersOnly]
        private static void SamplerParameterIuiv_Lazy(SamplerHandle sampler, SamplerParameterI pname, uint* param)
        {
            _SamplerParameterIuiv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameterIuiv");
            _SamplerParameterIuiv_fnptr(sampler, pname, param);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void> _GetSamplerParameteriv_fnptr = &GetSamplerParameteriv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameteriv(SamplerHandle sampler, SamplerParameterI pname, int* parameters) => _GetSamplerParameteriv_fnptr(sampler, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetSamplerParameteriv_Lazy(SamplerHandle sampler, SamplerParameterI pname, int* parameters)
        {
            _GetSamplerParameteriv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSamplerParameteriv");
            _GetSamplerParameteriv_fnptr(sampler, pname, parameters);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void> _GetSamplerParameterIiv_fnptr = &GetSamplerParameterIiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterIiv(SamplerHandle sampler, SamplerParameterI pname, int* parameters) => _GetSamplerParameterIiv_fnptr(sampler, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetSamplerParameterIiv_Lazy(SamplerHandle sampler, SamplerParameterI pname, int* parameters)
        {
            _GetSamplerParameterIiv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSamplerParameterIiv");
            _GetSamplerParameterIiv_fnptr(sampler, pname, parameters);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterF, float*, void> _GetSamplerParameterfv_fnptr = &GetSamplerParameterfv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterfv(SamplerHandle sampler, SamplerParameterF pname, float* parameters) => _GetSamplerParameterfv_fnptr(sampler, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetSamplerParameterfv_Lazy(SamplerHandle sampler, SamplerParameterF pname, float* parameters)
        {
            _GetSamplerParameterfv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterF, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSamplerParameterfv");
            _GetSamplerParameterfv_fnptr(sampler, pname, parameters);
        }
        
        private static delegate* unmanaged<SamplerHandle, SamplerParameterI, uint*, void> _GetSamplerParameterIuiv_fnptr = &GetSamplerParameterIuiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterIuiv(SamplerHandle sampler, SamplerParameterI pname, uint* parameters) => _GetSamplerParameterIuiv_fnptr(sampler, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetSamplerParameterIuiv_Lazy(SamplerHandle sampler, SamplerParameterI pname, uint* parameters)
        {
            _GetSamplerParameterIuiv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSamplerParameterIuiv");
            _GetSamplerParameterIuiv_fnptr(sampler, pname, parameters);
        }
        
        private static delegate* unmanaged<QueryHandle, QueryCounterTarget, void> _QueryCounter_fnptr = &QueryCounter_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
        /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
        /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml" /></remarks>
        public static void QueryCounter(QueryHandle id, QueryCounterTarget target) => _QueryCounter_fnptr(id, target);
        [UnmanagedCallersOnly]
        private static void QueryCounter_Lazy(QueryHandle id, QueryCounterTarget target)
        {
            _QueryCounter_fnptr = (delegate* unmanaged<QueryHandle, QueryCounterTarget, void>)GLLoader.BindingsContext.GetProcAddress("glQueryCounter");
            _QueryCounter_fnptr(id, target);
        }
        
        private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, long*, void> _GetQueryObjecti64v_fnptr = &GetQueryObjecti64v_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjecti64v(QueryHandle id, QueryObjectParameterName pname, long* parameters) => _GetQueryObjecti64v_fnptr(id, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetQueryObjecti64v_Lazy(QueryHandle id, QueryObjectParameterName pname, long* parameters)
        {
            _GetQueryObjecti64v_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjecti64v");
            _GetQueryObjecti64v_fnptr(id, pname, parameters);
        }
        
        private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, ulong*, void> _GetQueryObjectui64v_fnptr = &GetQueryObjectui64v_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectui64v(QueryHandle id, QueryObjectParameterName pname, ulong* parameters) => _GetQueryObjectui64v_fnptr(id, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetQueryObjectui64v_Lazy(QueryHandle id, QueryObjectParameterName pname, ulong* parameters)
        {
            _GetQueryObjectui64v_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjectui64v");
            _GetQueryObjectui64v_fnptr(id, pname, parameters);
        }
        
        private static delegate* unmanaged<uint, uint, void> _VertexAttribDivisor_fnptr = &VertexAttribDivisor_Lazy;
        /// <summary> <b>[requires: v3.3]</b> Modify the rate at which generic vertex attributes advance during instanced rendering. </summary>
        /// <param name="index"> Specify the index of the generic vertex attribute. </param>
        /// <param name="divisor"> Specify the number of instances that will pass between updates of the generic attribute at slot index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribDivisor.xhtml" /></remarks>
        public static void VertexAttribDivisor(uint index, uint divisor) => _VertexAttribDivisor_fnptr(index, divisor);
        [UnmanagedCallersOnly]
        private static void VertexAttribDivisor_Lazy(uint index, uint divisor)
        {
            _VertexAttribDivisor_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribDivisor");
            _VertexAttribDivisor_fnptr(index, divisor);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void> _VertexAttribP1ui_fnptr = &VertexAttribP1ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, byte normalized, uint value) => _VertexAttribP1ui_fnptr(index, type, normalized, value);
        [UnmanagedCallersOnly]
        private static void VertexAttribP1ui_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint value)
        {
            _VertexAttribP1ui_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP1ui");
            _VertexAttribP1ui_fnptr(index, type, normalized, value);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void> _VertexAttribP1uiv_fnptr = &VertexAttribP1uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, byte normalized, uint* value) => _VertexAttribP1uiv_fnptr(index, type, normalized, value);
        [UnmanagedCallersOnly]
        private static void VertexAttribP1uiv_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint* value)
        {
            _VertexAttribP1uiv_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP1uiv");
            _VertexAttribP1uiv_fnptr(index, type, normalized, value);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void> _VertexAttribP2ui_fnptr = &VertexAttribP2ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, byte normalized, uint value) => _VertexAttribP2ui_fnptr(index, type, normalized, value);
        [UnmanagedCallersOnly]
        private static void VertexAttribP2ui_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint value)
        {
            _VertexAttribP2ui_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP2ui");
            _VertexAttribP2ui_fnptr(index, type, normalized, value);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void> _VertexAttribP2uiv_fnptr = &VertexAttribP2uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, byte normalized, uint* value) => _VertexAttribP2uiv_fnptr(index, type, normalized, value);
        [UnmanagedCallersOnly]
        private static void VertexAttribP2uiv_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint* value)
        {
            _VertexAttribP2uiv_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP2uiv");
            _VertexAttribP2uiv_fnptr(index, type, normalized, value);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void> _VertexAttribP3ui_fnptr = &VertexAttribP3ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, byte normalized, uint value) => _VertexAttribP3ui_fnptr(index, type, normalized, value);
        [UnmanagedCallersOnly]
        private static void VertexAttribP3ui_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint value)
        {
            _VertexAttribP3ui_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP3ui");
            _VertexAttribP3ui_fnptr(index, type, normalized, value);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void> _VertexAttribP3uiv_fnptr = &VertexAttribP3uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, byte normalized, uint* value) => _VertexAttribP3uiv_fnptr(index, type, normalized, value);
        [UnmanagedCallersOnly]
        private static void VertexAttribP3uiv_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint* value)
        {
            _VertexAttribP3uiv_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP3uiv");
            _VertexAttribP3uiv_fnptr(index, type, normalized, value);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void> _VertexAttribP4ui_fnptr = &VertexAttribP4ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, byte normalized, uint value) => _VertexAttribP4ui_fnptr(index, type, normalized, value);
        [UnmanagedCallersOnly]
        private static void VertexAttribP4ui_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint value)
        {
            _VertexAttribP4ui_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP4ui");
            _VertexAttribP4ui_fnptr(index, type, normalized, value);
        }
        
        private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void> _VertexAttribP4uiv_fnptr = &VertexAttribP4uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, byte normalized, uint* value) => _VertexAttribP4uiv_fnptr(index, type, normalized, value);
        [UnmanagedCallersOnly]
        private static void VertexAttribP4uiv_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint* value)
        {
            _VertexAttribP4uiv_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP4uiv");
            _VertexAttribP4uiv_fnptr(index, type, normalized, value);
        }
        
        private static delegate* unmanaged<VertexPointerType, uint, void> _VertexP2ui_fnptr = &VertexP2ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexP2ui(VertexPointerType type, uint value) => _VertexP2ui_fnptr(type, value);
        [UnmanagedCallersOnly]
        private static void VertexP2ui_Lazy(VertexPointerType type, uint value)
        {
            _VertexP2ui_fnptr = (delegate* unmanaged<VertexPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP2ui");
            _VertexP2ui_fnptr(type, value);
        }
        
        private static delegate* unmanaged<VertexPointerType, uint*, void> _VertexP2uiv_fnptr = &VertexP2uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexP2uiv(VertexPointerType type, uint* value) => _VertexP2uiv_fnptr(type, value);
        [UnmanagedCallersOnly]
        private static void VertexP2uiv_Lazy(VertexPointerType type, uint* value)
        {
            _VertexP2uiv_fnptr = (delegate* unmanaged<VertexPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP2uiv");
            _VertexP2uiv_fnptr(type, value);
        }
        
        private static delegate* unmanaged<VertexPointerType, uint, void> _VertexP3ui_fnptr = &VertexP3ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexP3ui(VertexPointerType type, uint value) => _VertexP3ui_fnptr(type, value);
        [UnmanagedCallersOnly]
        private static void VertexP3ui_Lazy(VertexPointerType type, uint value)
        {
            _VertexP3ui_fnptr = (delegate* unmanaged<VertexPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP3ui");
            _VertexP3ui_fnptr(type, value);
        }
        
        private static delegate* unmanaged<VertexPointerType, uint*, void> _VertexP3uiv_fnptr = &VertexP3uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexP3uiv(VertexPointerType type, uint* value) => _VertexP3uiv_fnptr(type, value);
        [UnmanagedCallersOnly]
        private static void VertexP3uiv_Lazy(VertexPointerType type, uint* value)
        {
            _VertexP3uiv_fnptr = (delegate* unmanaged<VertexPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP3uiv");
            _VertexP3uiv_fnptr(type, value);
        }
        
        private static delegate* unmanaged<VertexPointerType, uint, void> _VertexP4ui_fnptr = &VertexP4ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexP4ui(VertexPointerType type, uint value) => _VertexP4ui_fnptr(type, value);
        [UnmanagedCallersOnly]
        private static void VertexP4ui_Lazy(VertexPointerType type, uint value)
        {
            _VertexP4ui_fnptr = (delegate* unmanaged<VertexPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP4ui");
            _VertexP4ui_fnptr(type, value);
        }
        
        private static delegate* unmanaged<VertexPointerType, uint*, void> _VertexP4uiv_fnptr = &VertexP4uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexP4uiv(VertexPointerType type, uint* value) => _VertexP4uiv_fnptr(type, value);
        [UnmanagedCallersOnly]
        private static void VertexP4uiv_Lazy(VertexPointerType type, uint* value)
        {
            _VertexP4uiv_fnptr = (delegate* unmanaged<VertexPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP4uiv");
            _VertexP4uiv_fnptr(type, value);
        }
        
        private static delegate* unmanaged<TexCoordPointerType, uint, void> _TexCoordP1ui_fnptr = &TexCoordP1ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void TexCoordP1ui(TexCoordPointerType type, uint coords) => _TexCoordP1ui_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void TexCoordP1ui_Lazy(TexCoordPointerType type, uint coords)
        {
            _TexCoordP1ui_fnptr = (delegate* unmanaged<TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP1ui");
            _TexCoordP1ui_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<TexCoordPointerType, uint*, void> _TexCoordP1uiv_fnptr = &TexCoordP1uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void TexCoordP1uiv(TexCoordPointerType type, uint* coords) => _TexCoordP1uiv_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void TexCoordP1uiv_Lazy(TexCoordPointerType type, uint* coords)
        {
            _TexCoordP1uiv_fnptr = (delegate* unmanaged<TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP1uiv");
            _TexCoordP1uiv_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<TexCoordPointerType, uint, void> _TexCoordP2ui_fnptr = &TexCoordP2ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void TexCoordP2ui(TexCoordPointerType type, uint coords) => _TexCoordP2ui_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void TexCoordP2ui_Lazy(TexCoordPointerType type, uint coords)
        {
            _TexCoordP2ui_fnptr = (delegate* unmanaged<TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP2ui");
            _TexCoordP2ui_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<TexCoordPointerType, uint*, void> _TexCoordP2uiv_fnptr = &TexCoordP2uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void TexCoordP2uiv(TexCoordPointerType type, uint* coords) => _TexCoordP2uiv_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void TexCoordP2uiv_Lazy(TexCoordPointerType type, uint* coords)
        {
            _TexCoordP2uiv_fnptr = (delegate* unmanaged<TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP2uiv");
            _TexCoordP2uiv_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<TexCoordPointerType, uint, void> _TexCoordP3ui_fnptr = &TexCoordP3ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void TexCoordP3ui(TexCoordPointerType type, uint coords) => _TexCoordP3ui_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void TexCoordP3ui_Lazy(TexCoordPointerType type, uint coords)
        {
            _TexCoordP3ui_fnptr = (delegate* unmanaged<TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP3ui");
            _TexCoordP3ui_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<TexCoordPointerType, uint*, void> _TexCoordP3uiv_fnptr = &TexCoordP3uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void TexCoordP3uiv(TexCoordPointerType type, uint* coords) => _TexCoordP3uiv_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void TexCoordP3uiv_Lazy(TexCoordPointerType type, uint* coords)
        {
            _TexCoordP3uiv_fnptr = (delegate* unmanaged<TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP3uiv");
            _TexCoordP3uiv_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<TexCoordPointerType, uint, void> _TexCoordP4ui_fnptr = &TexCoordP4ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void TexCoordP4ui(TexCoordPointerType type, uint coords) => _TexCoordP4ui_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void TexCoordP4ui_Lazy(TexCoordPointerType type, uint coords)
        {
            _TexCoordP4ui_fnptr = (delegate* unmanaged<TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP4ui");
            _TexCoordP4ui_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<TexCoordPointerType, uint*, void> _TexCoordP4uiv_fnptr = &TexCoordP4uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void TexCoordP4uiv(TexCoordPointerType type, uint* coords) => _TexCoordP4uiv_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void TexCoordP4uiv_Lazy(TexCoordPointerType type, uint* coords)
        {
            _TexCoordP4uiv_fnptr = (delegate* unmanaged<TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP4uiv");
            _TexCoordP4uiv_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void> _MultiTexCoordP1ui_fnptr = &MultiTexCoordP1ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void MultiTexCoordP1ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP1ui_fnptr(texture, type, coords);
        [UnmanagedCallersOnly]
        private static void MultiTexCoordP1ui_Lazy(TextureUnit texture, TexCoordPointerType type, uint coords)
        {
            _MultiTexCoordP1ui_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP1ui");
            _MultiTexCoordP1ui_fnptr(texture, type, coords);
        }
        
        private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void> _MultiTexCoordP1uiv_fnptr = &MultiTexCoordP1uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => _MultiTexCoordP1uiv_fnptr(texture, type, coords);
        [UnmanagedCallersOnly]
        private static void MultiTexCoordP1uiv_Lazy(TextureUnit texture, TexCoordPointerType type, uint* coords)
        {
            _MultiTexCoordP1uiv_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP1uiv");
            _MultiTexCoordP1uiv_fnptr(texture, type, coords);
        }
        
        private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void> _MultiTexCoordP2ui_fnptr = &MultiTexCoordP2ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void MultiTexCoordP2ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP2ui_fnptr(texture, type, coords);
        [UnmanagedCallersOnly]
        private static void MultiTexCoordP2ui_Lazy(TextureUnit texture, TexCoordPointerType type, uint coords)
        {
            _MultiTexCoordP2ui_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP2ui");
            _MultiTexCoordP2ui_fnptr(texture, type, coords);
        }
        
        private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void> _MultiTexCoordP2uiv_fnptr = &MultiTexCoordP2uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => _MultiTexCoordP2uiv_fnptr(texture, type, coords);
        [UnmanagedCallersOnly]
        private static void MultiTexCoordP2uiv_Lazy(TextureUnit texture, TexCoordPointerType type, uint* coords)
        {
            _MultiTexCoordP2uiv_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP2uiv");
            _MultiTexCoordP2uiv_fnptr(texture, type, coords);
        }
        
        private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void> _MultiTexCoordP3ui_fnptr = &MultiTexCoordP3ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void MultiTexCoordP3ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP3ui_fnptr(texture, type, coords);
        [UnmanagedCallersOnly]
        private static void MultiTexCoordP3ui_Lazy(TextureUnit texture, TexCoordPointerType type, uint coords)
        {
            _MultiTexCoordP3ui_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP3ui");
            _MultiTexCoordP3ui_fnptr(texture, type, coords);
        }
        
        private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void> _MultiTexCoordP3uiv_fnptr = &MultiTexCoordP3uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => _MultiTexCoordP3uiv_fnptr(texture, type, coords);
        [UnmanagedCallersOnly]
        private static void MultiTexCoordP3uiv_Lazy(TextureUnit texture, TexCoordPointerType type, uint* coords)
        {
            _MultiTexCoordP3uiv_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP3uiv");
            _MultiTexCoordP3uiv_fnptr(texture, type, coords);
        }
        
        private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void> _MultiTexCoordP4ui_fnptr = &MultiTexCoordP4ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void MultiTexCoordP4ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP4ui_fnptr(texture, type, coords);
        [UnmanagedCallersOnly]
        private static void MultiTexCoordP4ui_Lazy(TextureUnit texture, TexCoordPointerType type, uint coords)
        {
            _MultiTexCoordP4ui_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP4ui");
            _MultiTexCoordP4ui_fnptr(texture, type, coords);
        }
        
        private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void> _MultiTexCoordP4uiv_fnptr = &MultiTexCoordP4uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => _MultiTexCoordP4uiv_fnptr(texture, type, coords);
        [UnmanagedCallersOnly]
        private static void MultiTexCoordP4uiv_Lazy(TextureUnit texture, TexCoordPointerType type, uint* coords)
        {
            _MultiTexCoordP4uiv_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP4uiv");
            _MultiTexCoordP4uiv_fnptr(texture, type, coords);
        }
        
        private static delegate* unmanaged<NormalPointerType, uint, void> _NormalP3ui_fnptr = &NormalP3ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void NormalP3ui(NormalPointerType type, uint coords) => _NormalP3ui_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void NormalP3ui_Lazy(NormalPointerType type, uint coords)
        {
            _NormalP3ui_fnptr = (delegate* unmanaged<NormalPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glNormalP3ui");
            _NormalP3ui_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<NormalPointerType, uint*, void> _NormalP3uiv_fnptr = &NormalP3uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void NormalP3uiv(NormalPointerType type, uint* coords) => _NormalP3uiv_fnptr(type, coords);
        [UnmanagedCallersOnly]
        private static void NormalP3uiv_Lazy(NormalPointerType type, uint* coords)
        {
            _NormalP3uiv_fnptr = (delegate* unmanaged<NormalPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glNormalP3uiv");
            _NormalP3uiv_fnptr(type, coords);
        }
        
        private static delegate* unmanaged<ColorPointerType, uint, void> _ColorP3ui_fnptr = &ColorP3ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ColorP3ui(ColorPointerType type, uint color) => _ColorP3ui_fnptr(type, color);
        [UnmanagedCallersOnly]
        private static void ColorP3ui_Lazy(ColorPointerType type, uint color)
        {
            _ColorP3ui_fnptr = (delegate* unmanaged<ColorPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glColorP3ui");
            _ColorP3ui_fnptr(type, color);
        }
        
        private static delegate* unmanaged<ColorPointerType, uint*, void> _ColorP3uiv_fnptr = &ColorP3uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ColorP3uiv(ColorPointerType type, uint* color) => _ColorP3uiv_fnptr(type, color);
        [UnmanagedCallersOnly]
        private static void ColorP3uiv_Lazy(ColorPointerType type, uint* color)
        {
            _ColorP3uiv_fnptr = (delegate* unmanaged<ColorPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glColorP3uiv");
            _ColorP3uiv_fnptr(type, color);
        }
        
        private static delegate* unmanaged<ColorPointerType, uint, void> _ColorP4ui_fnptr = &ColorP4ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ColorP4ui(ColorPointerType type, uint color) => _ColorP4ui_fnptr(type, color);
        [UnmanagedCallersOnly]
        private static void ColorP4ui_Lazy(ColorPointerType type, uint color)
        {
            _ColorP4ui_fnptr = (delegate* unmanaged<ColorPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glColorP4ui");
            _ColorP4ui_fnptr(type, color);
        }
        
        private static delegate* unmanaged<ColorPointerType, uint*, void> _ColorP4uiv_fnptr = &ColorP4uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ColorP4uiv(ColorPointerType type, uint* color) => _ColorP4uiv_fnptr(type, color);
        [UnmanagedCallersOnly]
        private static void ColorP4uiv_Lazy(ColorPointerType type, uint* color)
        {
            _ColorP4uiv_fnptr = (delegate* unmanaged<ColorPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glColorP4uiv");
            _ColorP4uiv_fnptr(type, color);
        }
        
        private static delegate* unmanaged<ColorPointerType, uint, void> _SecondaryColorP3ui_fnptr = &SecondaryColorP3ui_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void SecondaryColorP3ui(ColorPointerType type, uint color) => _SecondaryColorP3ui_fnptr(type, color);
        [UnmanagedCallersOnly]
        private static void SecondaryColorP3ui_Lazy(ColorPointerType type, uint color)
        {
            _SecondaryColorP3ui_fnptr = (delegate* unmanaged<ColorPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColorP3ui");
            _SecondaryColorP3ui_fnptr(type, color);
        }
        
        private static delegate* unmanaged<ColorPointerType, uint*, void> _SecondaryColorP3uiv_fnptr = &SecondaryColorP3uiv_Lazy;
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void SecondaryColorP3uiv(ColorPointerType type, uint* color) => _SecondaryColorP3uiv_fnptr(type, color);
        [UnmanagedCallersOnly]
        private static void SecondaryColorP3uiv_Lazy(ColorPointerType type, uint* color)
        {
            _SecondaryColorP3uiv_fnptr = (delegate* unmanaged<ColorPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColorP3uiv");
            _SecondaryColorP3uiv_fnptr(type, color);
        }
        
        private static delegate* unmanaged<float, void> _MinSampleShading_fnptr = &MinSampleShading_Lazy;
        /// <summary> <b>[requires: v4.0]</b> Specifies minimum rate at which sample shading takes place. </summary>
        /// <param name="value"> Specifies the rate at which samples are shaded within each covered pixel. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMinSampleShading.xhtml" /></remarks>
        public static void MinSampleShading(float value) => _MinSampleShading_fnptr(value);
        [UnmanagedCallersOnly]
        private static void MinSampleShading_Lazy(float value)
        {
            _MinSampleShading_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glMinSampleShading");
            _MinSampleShading_fnptr(value);
        }
        
        private static delegate* unmanaged<uint, BlendEquationModeEXT, void> _BlendEquationi_fnptr = &BlendEquationi_Lazy;
        /// <summary> <b>[requires: v4.0]</b> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="buf"> for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation. </param>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
        public static void BlendEquationi(uint buf, BlendEquationModeEXT mode) => _BlendEquationi_fnptr(buf, mode);
        [UnmanagedCallersOnly]
        private static void BlendEquationi_Lazy(uint buf, BlendEquationModeEXT mode)
        {
            _BlendEquationi_fnptr = (delegate* unmanaged<uint, BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquationi");
            _BlendEquationi_fnptr(buf, mode);
        }
        
        private static delegate* unmanaged<uint, BlendEquationModeEXT, BlendEquationModeEXT, void> _BlendEquationSeparatei_fnptr = &BlendEquationSeparatei_Lazy;
        /// <summary> <b>[requires: v4.0]</b> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="buf"> for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations. </param>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml" /></remarks>
        public static void BlendEquationSeparatei(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparatei_fnptr(buf, modeRGB, modeAlpha);
        [UnmanagedCallersOnly]
        private static void BlendEquationSeparatei_Lazy(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha)
        {
            _BlendEquationSeparatei_fnptr = (delegate* unmanaged<uint, BlendEquationModeEXT, BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquationSeparatei");
            _BlendEquationSeparatei_fnptr(buf, modeRGB, modeAlpha);
        }
        
        private static delegate* unmanaged<uint, BlendingFactor, BlendingFactor, void> _BlendFunci_fnptr = &BlendFunci_Lazy;
        /// <summary> <b>[requires: v4.0]</b> Specify pixel arithmetic. </summary>
        /// <param name="buf"> For glBlendFunci, specifies the index of the draw buffer for which to set the blend function. </param>
        /// <param name="sfactor"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactor"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" /></remarks>
        public static void BlendFunci(uint buf, BlendingFactor src, BlendingFactor dst) => _BlendFunci_fnptr(buf, src, dst);
        [UnmanagedCallersOnly]
        private static void BlendFunci_Lazy(uint buf, BlendingFactor src, BlendingFactor dst)
        {
            _BlendFunci_fnptr = (delegate* unmanaged<uint, BlendingFactor, BlendingFactor, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFunci");
            _BlendFunci_fnptr(buf, src, dst);
        }
        
        private static delegate* unmanaged<uint, BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void> _BlendFuncSeparatei_fnptr = &BlendFuncSeparatei_Lazy;
        /// <summary> <b>[requires: v4.0]</b> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="buf"> For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions. </param>
        /// <param name="srcRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dstRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="srcAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dstAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml" /></remarks>
        public static void BlendFuncSeparatei(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => _BlendFuncSeparatei_fnptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        [UnmanagedCallersOnly]
        private static void BlendFuncSeparatei_Lazy(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha)
        {
            _BlendFuncSeparatei_fnptr = (delegate* unmanaged<uint, BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFuncSeparatei");
            _BlendFuncSeparatei_fnptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        
        private static delegate* unmanaged<PrimitiveType, void*, void> _DrawArraysIndirect_fnptr = &DrawArraysIndirect_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> Render primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml" /></remarks>
        public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => _DrawArraysIndirect_fnptr(mode, indirect);
        [UnmanagedCallersOnly]
        private static void DrawArraysIndirect_Lazy(PrimitiveType mode, void* indirect)
        {
            _DrawArraysIndirect_fnptr = (delegate* unmanaged<PrimitiveType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawArraysIndirect");
            _DrawArraysIndirect_fnptr(mode, indirect);
        }
        
        private static delegate* unmanaged<PrimitiveType, DrawElementsType, void*, void> _DrawElementsIndirect_fnptr = &DrawElementsIndirect_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml" /></remarks>
        public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => _DrawElementsIndirect_fnptr(mode, type, indirect);
        [UnmanagedCallersOnly]
        private static void DrawElementsIndirect_Lazy(PrimitiveType mode, DrawElementsType type, void* indirect)
        {
            _DrawElementsIndirect_fnptr = (delegate* unmanaged<PrimitiveType, DrawElementsType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsIndirect");
            _DrawElementsIndirect_fnptr(mode, type, indirect);
        }
        
        private static delegate* unmanaged<int, double, void> _Uniform1d_fnptr = &Uniform1d_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform1d(int location, double x) => _Uniform1d_fnptr(location, x);
        [UnmanagedCallersOnly]
        private static void Uniform1d_Lazy(int location, double x)
        {
            _Uniform1d_fnptr = (delegate* unmanaged<int, double, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1d");
            _Uniform1d_fnptr(location, x);
        }
        
        private static delegate* unmanaged<int, double, double, void> _Uniform2d_fnptr = &Uniform2d_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform2d(int location, double x, double y) => _Uniform2d_fnptr(location, x, y);
        [UnmanagedCallersOnly]
        private static void Uniform2d_Lazy(int location, double x, double y)
        {
            _Uniform2d_fnptr = (delegate* unmanaged<int, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2d");
            _Uniform2d_fnptr(location, x, y);
        }
        
        private static delegate* unmanaged<int, double, double, double, void> _Uniform3d_fnptr = &Uniform3d_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform3d(int location, double x, double y, double z) => _Uniform3d_fnptr(location, x, y, z);
        [UnmanagedCallersOnly]
        private static void Uniform3d_Lazy(int location, double x, double y, double z)
        {
            _Uniform3d_fnptr = (delegate* unmanaged<int, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3d");
            _Uniform3d_fnptr(location, x, y, z);
        }
        
        private static delegate* unmanaged<int, double, double, double, double, void> _Uniform4d_fnptr = &Uniform4d_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform4d(int location, double x, double y, double z, double w) => _Uniform4d_fnptr(location, x, y, z, w);
        [UnmanagedCallersOnly]
        private static void Uniform4d_Lazy(int location, double x, double y, double z, double w)
        {
            _Uniform4d_fnptr = (delegate* unmanaged<int, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4d");
            _Uniform4d_fnptr(location, x, y, z, w);
        }
        
        private static delegate* unmanaged<int, int, double*, void> _Uniform1dv_fnptr = &Uniform1dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform1dv(int location, int count, double* value) => _Uniform1dv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform1dv_Lazy(int location, int count, double* value)
        {
            _Uniform1dv_fnptr = (delegate* unmanaged<int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1dv");
            _Uniform1dv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, double*, void> _Uniform2dv_fnptr = &Uniform2dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform2dv(int location, int count, double* value) => _Uniform2dv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform2dv_Lazy(int location, int count, double* value)
        {
            _Uniform2dv_fnptr = (delegate* unmanaged<int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2dv");
            _Uniform2dv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, double*, void> _Uniform3dv_fnptr = &Uniform3dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform3dv(int location, int count, double* value) => _Uniform3dv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform3dv_Lazy(int location, int count, double* value)
        {
            _Uniform3dv_fnptr = (delegate* unmanaged<int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3dv");
            _Uniform3dv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, double*, void> _Uniform4dv_fnptr = &Uniform4dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform4dv(int location, int count, double* value) => _Uniform4dv_fnptr(location, count, value);
        [UnmanagedCallersOnly]
        private static void Uniform4dv_Lazy(int location, int count, double* value)
        {
            _Uniform4dv_fnptr = (delegate* unmanaged<int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4dv");
            _Uniform4dv_fnptr(location, count, value);
        }
        
        private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix2dv_fnptr = &UniformMatrix2dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix2dv(int location, int count, byte transpose, double* value) => _UniformMatrix2dv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix2dv_Lazy(int location, int count, byte transpose, double* value)
        {
            _UniformMatrix2dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2dv");
            _UniformMatrix2dv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix3dv_fnptr = &UniformMatrix3dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix3dv(int location, int count, byte transpose, double* value) => _UniformMatrix3dv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix3dv_Lazy(int location, int count, byte transpose, double* value)
        {
            _UniformMatrix3dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3dv");
            _UniformMatrix3dv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix4dv_fnptr = &UniformMatrix4dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix4dv(int location, int count, byte transpose, double* value) => _UniformMatrix4dv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix4dv_Lazy(int location, int count, byte transpose, double* value)
        {
            _UniformMatrix4dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4dv");
            _UniformMatrix4dv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix2x3dv_fnptr = &UniformMatrix2x3dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix2x3dv(int location, int count, byte transpose, double* value) => _UniformMatrix2x3dv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix2x3dv_Lazy(int location, int count, byte transpose, double* value)
        {
            _UniformMatrix2x3dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2x3dv");
            _UniformMatrix2x3dv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix2x4dv_fnptr = &UniformMatrix2x4dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix2x4dv(int location, int count, byte transpose, double* value) => _UniformMatrix2x4dv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix2x4dv_Lazy(int location, int count, byte transpose, double* value)
        {
            _UniformMatrix2x4dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2x4dv");
            _UniformMatrix2x4dv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix3x2dv_fnptr = &UniformMatrix3x2dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix3x2dv(int location, int count, byte transpose, double* value) => _UniformMatrix3x2dv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix3x2dv_Lazy(int location, int count, byte transpose, double* value)
        {
            _UniformMatrix3x2dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3x2dv");
            _UniformMatrix3x2dv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix3x4dv_fnptr = &UniformMatrix3x4dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix3x4dv(int location, int count, byte transpose, double* value) => _UniformMatrix3x4dv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix3x4dv_Lazy(int location, int count, byte transpose, double* value)
        {
            _UniformMatrix3x4dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3x4dv");
            _UniformMatrix3x4dv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix4x2dv_fnptr = &UniformMatrix4x2dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix4x2dv(int location, int count, byte transpose, double* value) => _UniformMatrix4x2dv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix4x2dv_Lazy(int location, int count, byte transpose, double* value)
        {
            _UniformMatrix4x2dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4x2dv");
            _UniformMatrix4x2dv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix4x3dv_fnptr = &UniformMatrix4x3dv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix4x3dv(int location, int count, byte transpose, double* value) => _UniformMatrix4x3dv_fnptr(location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void UniformMatrix4x3dv_Lazy(int location, int count, byte transpose, double* value)
        {
            _UniformMatrix4x3dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4x3dv");
            _UniformMatrix4x3dv_fnptr(location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, double*, void> _GetUniformdv_fnptr = &GetUniformdv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformdv(ProgramHandle program, int location, double* parameters) => _GetUniformdv_fnptr(program, location, parameters);
        [UnmanagedCallersOnly]
        private static void GetUniformdv_Lazy(ProgramHandle program, int location, double* parameters)
        {
            _GetUniformdv_fnptr = (delegate* unmanaged<ProgramHandle, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformdv");
            _GetUniformdv_fnptr(program, location, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, ShaderType, byte*, int> _GetSubroutineUniformLocation_fnptr = &GetSubroutineUniformLocation_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml" /></remarks>
        public static int GetSubroutineUniformLocation(ProgramHandle program, ShaderType shadertype, byte* name) => _GetSubroutineUniformLocation_fnptr(program, shadertype, name);
        [UnmanagedCallersOnly]
        private static int GetSubroutineUniformLocation_Lazy(ProgramHandle program, ShaderType shadertype, byte* name)
        {
            _GetSubroutineUniformLocation_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetSubroutineUniformLocation");
            return _GetSubroutineUniformLocation_fnptr(program, shadertype, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, ShaderType, byte*, uint> _GetSubroutineIndex_fnptr = &GetSubroutineIndex_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml" /></remarks>
        public static uint GetSubroutineIndex(ProgramHandle program, ShaderType shadertype, byte* name) => _GetSubroutineIndex_fnptr(program, shadertype, name);
        [UnmanagedCallersOnly]
        private static uint GetSubroutineIndex_Lazy(ProgramHandle program, ShaderType shadertype, byte* name)
        {
            _GetSubroutineIndex_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetSubroutineIndex");
            return _GetSubroutineIndex_fnptr(program, shadertype, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, ShaderType, uint, SubroutineParameterName, int*, void> _GetActiveSubroutineUniformiv_fnptr = &GetActiveSubroutineUniformiv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query a property of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
        /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml" /></remarks>
        public static void GetActiveSubroutineUniformiv(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => _GetActiveSubroutineUniformiv_fnptr(program, shadertype, index, pname, values);
        [UnmanagedCallersOnly]
        private static void GetActiveSubroutineUniformiv_Lazy(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values)
        {
            _GetActiveSubroutineUniformiv_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, uint, SubroutineParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveSubroutineUniformiv");
            _GetActiveSubroutineUniformiv_fnptr(program, shadertype, index, pname, values);
        }
        
        private static delegate* unmanaged<ProgramHandle, ShaderType, uint, int, int*, byte*, void> _GetActiveSubroutineUniformName_fnptr = &GetActiveSubroutineUniformName_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query the name of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
        /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml" /></remarks>
        public static void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => _GetActiveSubroutineUniformName_fnptr(program, shadertype, index, bufSize, length, name);
        [UnmanagedCallersOnly]
        private static void GetActiveSubroutineUniformName_Lazy(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name)
        {
            _GetActiveSubroutineUniformName_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveSubroutineUniformName");
            _GetActiveSubroutineUniformName_fnptr(program, shadertype, index, bufSize, length, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, ShaderType, uint, int, int*, byte*, void> _GetActiveSubroutineName_fnptr = &GetActiveSubroutineName_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query the name of an active shader subroutine. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
        /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml" /></remarks>
        public static void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => _GetActiveSubroutineName_fnptr(program, shadertype, index, bufSize, length, name);
        [UnmanagedCallersOnly]
        private static void GetActiveSubroutineName_Lazy(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name)
        {
            _GetActiveSubroutineName_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveSubroutineName");
            _GetActiveSubroutineName_fnptr(program, shadertype, index, bufSize, length, name);
        }
        
        private static delegate* unmanaged<ShaderType, int, uint*, void> _UniformSubroutinesuiv_fnptr = &UniformSubroutinesuiv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Load active subroutine uniforms. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
        /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml" /></remarks>
        public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => _UniformSubroutinesuiv_fnptr(shadertype, count, indices);
        [UnmanagedCallersOnly]
        private static void UniformSubroutinesuiv_Lazy(ShaderType shadertype, int count, uint* indices)
        {
            _UniformSubroutinesuiv_fnptr = (delegate* unmanaged<ShaderType, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformSubroutinesuiv");
            _UniformSubroutinesuiv_fnptr(shadertype, count, indices);
        }
        
        private static delegate* unmanaged<ShaderType, int, uint*, void> _GetUniformSubroutineuiv_fnptr = &GetUniformSubroutineuiv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="location"> Specifies the location of the subroutine uniform. </param>
        /// <param name="values"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml" /></remarks>
        public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => _GetUniformSubroutineuiv_fnptr(shadertype, location, parameters);
        [UnmanagedCallersOnly]
        private static void GetUniformSubroutineuiv_Lazy(ShaderType shadertype, int location, uint* parameters)
        {
            _GetUniformSubroutineuiv_fnptr = (delegate* unmanaged<ShaderType, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformSubroutineuiv");
            _GetUniformSubroutineuiv_fnptr(shadertype, location, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, ShaderType, ProgramStagePName, int*, void> _GetProgramStageiv_fnptr = &GetProgramStageiv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
        /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml" /></remarks>
        public static void GetProgramStageiv(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int* values) => _GetProgramStageiv_fnptr(program, shadertype, pname, values);
        [UnmanagedCallersOnly]
        private static void GetProgramStageiv_Lazy(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int* values)
        {
            _GetProgramStageiv_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, ProgramStagePName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramStageiv");
            _GetProgramStageiv_fnptr(program, shadertype, pname, values);
        }
        
        private static delegate* unmanaged<PatchParameterName, int, void> _PatchParameteri_fnptr = &PatchParameteri_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
        public static void PatchParameteri(PatchParameterName pname, int value) => _PatchParameteri_fnptr(pname, value);
        [UnmanagedCallersOnly]
        private static void PatchParameteri_Lazy(PatchParameterName pname, int value)
        {
            _PatchParameteri_fnptr = (delegate* unmanaged<PatchParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glPatchParameteri");
            _PatchParameteri_fnptr(pname, value);
        }
        
        private static delegate* unmanaged<PatchParameterName, float*, void> _PatchParameterfv_fnptr = &PatchParameterfv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
        public static void PatchParameterfv(PatchParameterName pname, float* values) => _PatchParameterfv_fnptr(pname, values);
        [UnmanagedCallersOnly]
        private static void PatchParameterfv_Lazy(PatchParameterName pname, float* values)
        {
            _PatchParameterfv_fnptr = (delegate* unmanaged<PatchParameterName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPatchParameterfv");
            _PatchParameterfv_fnptr(pname, values);
        }
        
        private static delegate* unmanaged<BindTransformFeedbackTarget, TransformFeedbackHandle, void> _BindTransformFeedback_fnptr = &BindTransformFeedback_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Bind a transform feedback object. </summary>
        /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
        /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml" /></remarks>
        public static void BindTransformFeedback(BindTransformFeedbackTarget target, TransformFeedbackHandle id) => _BindTransformFeedback_fnptr(target, id);
        [UnmanagedCallersOnly]
        private static void BindTransformFeedback_Lazy(BindTransformFeedbackTarget target, TransformFeedbackHandle id)
        {
            _BindTransformFeedback_fnptr = (delegate* unmanaged<BindTransformFeedbackTarget, TransformFeedbackHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindTransformFeedback");
            _BindTransformFeedback_fnptr(target, id);
        }
        
        private static delegate* unmanaged<int, TransformFeedbackHandle*, void> _DeleteTransformFeedbacks_fnptr = &DeleteTransformFeedbacks_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Delete transform feedback objects. </summary>
        /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
        /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml" /></remarks>
        public static void DeleteTransformFeedbacks(int n, TransformFeedbackHandle* ids) => _DeleteTransformFeedbacks_fnptr(n, ids);
        [UnmanagedCallersOnly]
        private static void DeleteTransformFeedbacks_Lazy(int n, TransformFeedbackHandle* ids)
        {
            _DeleteTransformFeedbacks_fnptr = (delegate* unmanaged<int, TransformFeedbackHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteTransformFeedbacks");
            _DeleteTransformFeedbacks_fnptr(n, ids);
        }
        
        private static delegate* unmanaged<int, TransformFeedbackHandle*, void> _GenTransformFeedbacks_fnptr = &GenTransformFeedbacks_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Reserve transform feedback object names. </summary>
        /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
        /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml" /></remarks>
        public static void GenTransformFeedbacks(int n, TransformFeedbackHandle* ids) => _GenTransformFeedbacks_fnptr(n, ids);
        [UnmanagedCallersOnly]
        private static void GenTransformFeedbacks_Lazy(int n, TransformFeedbackHandle* ids)
        {
            _GenTransformFeedbacks_fnptr = (delegate* unmanaged<int, TransformFeedbackHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenTransformFeedbacks");
            _GenTransformFeedbacks_fnptr(n, ids);
        }
        
        private static delegate* unmanaged<TransformFeedbackHandle, byte> _IsTransformFeedback_fnptr = &IsTransformFeedback_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Determine if a name corresponds to a transform feedback object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml" /></remarks>
        public static byte IsTransformFeedback(TransformFeedbackHandle id) => _IsTransformFeedback_fnptr(id);
        [UnmanagedCallersOnly]
        private static byte IsTransformFeedback_Lazy(TransformFeedbackHandle id)
        {
            _IsTransformFeedback_fnptr = (delegate* unmanaged<TransformFeedbackHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsTransformFeedback");
            return _IsTransformFeedback_fnptr(id);
        }
        
        private static delegate* unmanaged<void> _PauseTransformFeedback_fnptr = &PauseTransformFeedback_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Pause transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml" /></remarks>
        public static void PauseTransformFeedback() => _PauseTransformFeedback_fnptr();
        [UnmanagedCallersOnly]
        private static void PauseTransformFeedback_Lazy()
        {
            _PauseTransformFeedback_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPauseTransformFeedback");
            _PauseTransformFeedback_fnptr();
        }
        
        private static delegate* unmanaged<void> _ResumeTransformFeedback_fnptr = &ResumeTransformFeedback_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Resume transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml" /></remarks>
        public static void ResumeTransformFeedback() => _ResumeTransformFeedback_fnptr();
        [UnmanagedCallersOnly]
        private static void ResumeTransformFeedback_Lazy()
        {
            _ResumeTransformFeedback_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glResumeTransformFeedback");
            _ResumeTransformFeedback_fnptr();
        }
        
        private static delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, void> _DrawTransformFeedback_fnptr = &DrawTransformFeedback_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Render primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml" /></remarks>
        public static void DrawTransformFeedback(PrimitiveType mode, TransformFeedbackHandle id) => _DrawTransformFeedback_fnptr(mode, id);
        [UnmanagedCallersOnly]
        private static void DrawTransformFeedback_Lazy(PrimitiveType mode, TransformFeedbackHandle id)
        {
            _DrawTransformFeedback_fnptr = (delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTransformFeedback");
            _DrawTransformFeedback_fnptr(mode, id);
        }
        
        private static delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, uint, void> _DrawTransformFeedbackStream_fnptr = &DrawTransformFeedbackStream_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml" /></remarks>
        public static void DrawTransformFeedbackStream(PrimitiveType mode, TransformFeedbackHandle id, uint stream) => _DrawTransformFeedbackStream_fnptr(mode, id, stream);
        [UnmanagedCallersOnly]
        private static void DrawTransformFeedbackStream_Lazy(PrimitiveType mode, TransformFeedbackHandle id, uint stream)
        {
            _DrawTransformFeedbackStream_fnptr = (delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTransformFeedbackStream");
            _DrawTransformFeedbackStream_fnptr(mode, id, stream);
        }
        
        private static delegate* unmanaged<QueryTarget, uint, QueryHandle, void> _BeginQueryIndexed_fnptr = &BeginQueryIndexed_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
        public static void BeginQueryIndexed(QueryTarget target, uint index, QueryHandle id) => _BeginQueryIndexed_fnptr(target, index, id);
        [UnmanagedCallersOnly]
        private static void BeginQueryIndexed_Lazy(QueryTarget target, uint index, QueryHandle id)
        {
            _BeginQueryIndexed_fnptr = (delegate* unmanaged<QueryTarget, uint, QueryHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBeginQueryIndexed");
            _BeginQueryIndexed_fnptr(target, index, id);
        }
        
        private static delegate* unmanaged<QueryTarget, uint, void> _EndQueryIndexed_fnptr = &EndQueryIndexed_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
        public static void EndQueryIndexed(QueryTarget target, uint index) => _EndQueryIndexed_fnptr(target, index);
        [UnmanagedCallersOnly]
        private static void EndQueryIndexed_Lazy(QueryTarget target, uint index)
        {
            _EndQueryIndexed_fnptr = (delegate* unmanaged<QueryTarget, uint, void>)GLLoader.BindingsContext.GetProcAddress("glEndQueryIndexed");
            _EndQueryIndexed_fnptr(target, index);
        }
        
        private static delegate* unmanaged<QueryTarget, uint, QueryParameterName, int*, void> _GetQueryIndexediv_fnptr = &GetQueryIndexediv_Lazy;
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Return parameters of an indexed query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="index"> Specifies the index of the query object target. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml" /></remarks>
        public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => _GetQueryIndexediv_fnptr(target, index, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetQueryIndexediv_Lazy(QueryTarget target, uint index, QueryParameterName pname, int* parameters)
        {
            _GetQueryIndexediv_fnptr = (delegate* unmanaged<QueryTarget, uint, QueryParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryIndexediv");
            _GetQueryIndexediv_fnptr(target, index, pname, parameters);
        }
        
        private static delegate* unmanaged<void> _ReleaseShaderCompiler_fnptr = &ReleaseShaderCompiler_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Release resources consumed by the implementation's shader compiler. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml" /></remarks>
        public static void ReleaseShaderCompiler() => _ReleaseShaderCompiler_fnptr();
        [UnmanagedCallersOnly]
        private static void ReleaseShaderCompiler_Lazy()
        {
            _ReleaseShaderCompiler_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glReleaseShaderCompiler");
            _ReleaseShaderCompiler_fnptr();
        }
        
        private static delegate* unmanaged<int, ShaderHandle*, ShaderBinaryFormat, void*, int, void> _ShaderBinary_fnptr = &ShaderBinary_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Load pre-compiled shader binaries. </summary>
        /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
        /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
        /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
        /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
        /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml" /></remarks>
        public static void ShaderBinary(int count, ShaderHandle* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => _ShaderBinary_fnptr(count, shaders, binaryFormat, binary, length);
        [UnmanagedCallersOnly]
        private static void ShaderBinary_Lazy(int count, ShaderHandle* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length)
        {
            _ShaderBinary_fnptr = (delegate* unmanaged<int, ShaderHandle*, ShaderBinaryFormat, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glShaderBinary");
            _ShaderBinary_fnptr(count, shaders, binaryFormat, binary, length);
        }
        
        private static delegate* unmanaged<ShaderType, PrecisionType, int*, int*, void> _GetShaderPrecisionFormat_fnptr = &GetShaderPrecisionFormat_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
        /// <param name="shaderType"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="precisionType"> Specifies the numeric format whose precision and range to query. </param>
        /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned. </param>
        /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml" /></remarks>
        public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => _GetShaderPrecisionFormat_fnptr(shadertype, precisiontype, range, precision);
        [UnmanagedCallersOnly]
        private static void GetShaderPrecisionFormat_Lazy(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision)
        {
            _GetShaderPrecisionFormat_fnptr = (delegate* unmanaged<ShaderType, PrecisionType, int*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetShaderPrecisionFormat");
            _GetShaderPrecisionFormat_fnptr(shadertype, precisiontype, range, precision);
        }
        
        private static delegate* unmanaged<float, float, void> _DepthRangef_fnptr = &DepthRangef_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
        public static void DepthRangef(float n, float f) => _DepthRangef_fnptr(n, f);
        [UnmanagedCallersOnly]
        private static void DepthRangef_Lazy(float n, float f)
        {
            _DepthRangef_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangef");
            _DepthRangef_fnptr(n, f);
        }
        
        private static delegate* unmanaged<float, void> _ClearDepthf_fnptr = &ClearDepthf_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Specify the clear value for the depth buffer. </summary>
        /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
        public static void ClearDepthf(float d) => _ClearDepthf_fnptr(d);
        [UnmanagedCallersOnly]
        private static void ClearDepthf_Lazy(float d)
        {
            _ClearDepthf_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glClearDepthf");
            _ClearDepthf_fnptr(d);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int*, All*, void*, void> _GetProgramBinary_fnptr = &GetProgramBinary_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> Return a binary representation of a program object's compiled and linked executable source. </summary>
        /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
        /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
        /// <param name="binary"> Specifies the address an array into which the GL will return program's binary representation. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml" /></remarks>
        public static void GetProgramBinary(ProgramHandle program, int bufSize, int* length, All* binaryFormat, void* binary) => _GetProgramBinary_fnptr(program, bufSize, length, binaryFormat, binary);
        [UnmanagedCallersOnly]
        private static void GetProgramBinary_Lazy(ProgramHandle program, int bufSize, int* length, All* binaryFormat, void* binary)
        {
            _GetProgramBinary_fnptr = (delegate* unmanaged<ProgramHandle, int, int*, All*, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramBinary");
            _GetProgramBinary_fnptr(program, bufSize, length, binaryFormat, binary);
        }
        
        private static delegate* unmanaged<ProgramHandle, All, void*, int, void> _ProgramBinary_fnptr = &ProgramBinary_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> Load a program object with a program binary. </summary>
        /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
        /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
        /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
        /// <param name="length"> Specifies the number of bytes contained in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml" /></remarks>
        public static void ProgramBinary(ProgramHandle program, All binaryFormat, void* binary, int length) => _ProgramBinary_fnptr(program, binaryFormat, binary, length);
        [UnmanagedCallersOnly]
        private static void ProgramBinary_Lazy(ProgramHandle program, All binaryFormat, void* binary, int length)
        {
            _ProgramBinary_fnptr = (delegate* unmanaged<ProgramHandle, All, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramBinary");
            _ProgramBinary_fnptr(program, binaryFormat, binary, length);
        }
        
        private static delegate* unmanaged<ProgramHandle, ProgramParameterPName, int, void> _ProgramParameteri_fnptr = &ProgramParameteri_Lazy;
        /// <summary> <b>[requires: v4.1 | v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects]</b> Specify a parameter for a program object. </summary>
        /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the name of the parameter to modify. </param>
        /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml" /></remarks>
        public static void ProgramParameteri(ProgramHandle program, ProgramParameterPName pname, int value) => _ProgramParameteri_fnptr(program, pname, value);
        [UnmanagedCallersOnly]
        private static void ProgramParameteri_Lazy(ProgramHandle program, ProgramParameterPName pname, int value)
        {
            _ProgramParameteri_fnptr = (delegate* unmanaged<ProgramHandle, ProgramParameterPName, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameteri");
            _ProgramParameteri_fnptr(program, pname, value);
        }
        
        private static delegate* unmanaged<ProgramPipelineHandle, UseProgramStageMask, ProgramHandle, void> _UseProgramStages_fnptr = &UseProgramStages_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Bind stages of a program object to a program pipeline. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
        /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
        /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml" /></remarks>
        public static void UseProgramStages(ProgramPipelineHandle pipeline, UseProgramStageMask stages, ProgramHandle program) => _UseProgramStages_fnptr(pipeline, stages, program);
        [UnmanagedCallersOnly]
        private static void UseProgramStages_Lazy(ProgramPipelineHandle pipeline, UseProgramStageMask stages, ProgramHandle program)
        {
            _UseProgramStages_fnptr = (delegate* unmanaged<ProgramPipelineHandle, UseProgramStageMask, ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glUseProgramStages");
            _UseProgramStages_fnptr(pipeline, stages, program);
        }
        
        private static delegate* unmanaged<ProgramPipelineHandle, ProgramHandle, void> _ActiveShaderProgram_fnptr = &ActiveShaderProgram_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Set the active program object for a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
        /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml" /></remarks>
        public static void ActiveShaderProgram(ProgramPipelineHandle pipeline, ProgramHandle program) => _ActiveShaderProgram_fnptr(pipeline, program);
        [UnmanagedCallersOnly]
        private static void ActiveShaderProgram_Lazy(ProgramPipelineHandle pipeline, ProgramHandle program)
        {
            _ActiveShaderProgram_fnptr = (delegate* unmanaged<ProgramPipelineHandle, ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glActiveShaderProgram");
            _ActiveShaderProgram_fnptr(pipeline, program);
        }
        
        private static delegate* unmanaged<ShaderType, int, byte**, int> _CreateShaderProgramv_fnptr = &CreateShaderProgramv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Create a stand-alone program from an array of null-terminated source code strings. </summary>
        /// <param name="type"> Specifies the type of shader to create. </param>
        /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
        /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml" /></remarks>
        public static ProgramHandle CreateShaderProgramv(ShaderType type, int count, byte** strings) => (ProgramHandle) _CreateShaderProgramv_fnptr(type, count, strings);
        [UnmanagedCallersOnly]
        private static int CreateShaderProgramv_Lazy(ShaderType type, int count, byte** strings)
        {
            _CreateShaderProgramv_fnptr = (delegate* unmanaged<ShaderType, int, byte**, int>)GLLoader.BindingsContext.GetProcAddress("glCreateShaderProgramv");
            return _CreateShaderProgramv_fnptr(type, count, strings);
        }
        
        private static delegate* unmanaged<ProgramPipelineHandle, void> _BindProgramPipeline_fnptr = &BindProgramPipeline_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Bind a program pipeline to the current context. </summary>
        /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml" /></remarks>
        public static void BindProgramPipeline(ProgramPipelineHandle pipeline) => _BindProgramPipeline_fnptr(pipeline);
        [UnmanagedCallersOnly]
        private static void BindProgramPipeline_Lazy(ProgramPipelineHandle pipeline)
        {
            _BindProgramPipeline_fnptr = (delegate* unmanaged<ProgramPipelineHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindProgramPipeline");
            _BindProgramPipeline_fnptr(pipeline);
        }
        
        private static delegate* unmanaged<int, ProgramPipelineHandle*, void> _DeleteProgramPipelines_fnptr = &DeleteProgramPipelines_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Delete program pipeline objects. </summary>
        /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
        /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml" /></remarks>
        public static void DeleteProgramPipelines(int n, ProgramPipelineHandle* pipelines) => _DeleteProgramPipelines_fnptr(n, pipelines);
        [UnmanagedCallersOnly]
        private static void DeleteProgramPipelines_Lazy(int n, ProgramPipelineHandle* pipelines)
        {
            _DeleteProgramPipelines_fnptr = (delegate* unmanaged<int, ProgramPipelineHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteProgramPipelines");
            _DeleteProgramPipelines_fnptr(n, pipelines);
        }
        
        private static delegate* unmanaged<int, ProgramPipelineHandle*, void> _GenProgramPipelines_fnptr = &GenProgramPipelines_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Reserve program pipeline object names. </summary>
        /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
        /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml" /></remarks>
        public static void GenProgramPipelines(int n, ProgramPipelineHandle* pipelines) => _GenProgramPipelines_fnptr(n, pipelines);
        [UnmanagedCallersOnly]
        private static void GenProgramPipelines_Lazy(int n, ProgramPipelineHandle* pipelines)
        {
            _GenProgramPipelines_fnptr = (delegate* unmanaged<int, ProgramPipelineHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenProgramPipelines");
            _GenProgramPipelines_fnptr(n, pipelines);
        }
        
        private static delegate* unmanaged<ProgramPipelineHandle, byte> _IsProgramPipeline_fnptr = &IsProgramPipeline_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Determine if a name corresponds to a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml" /></remarks>
        public static byte IsProgramPipeline(ProgramPipelineHandle pipeline) => _IsProgramPipeline_fnptr(pipeline);
        [UnmanagedCallersOnly]
        private static byte IsProgramPipeline_Lazy(ProgramPipelineHandle pipeline)
        {
            _IsProgramPipeline_fnptr = (delegate* unmanaged<ProgramPipelineHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsProgramPipeline");
            return _IsProgramPipeline_fnptr(pipeline);
        }
        
        private static delegate* unmanaged<ProgramPipelineHandle, PipelineParameterName, int*, void> _GetProgramPipelineiv_fnptr = &GetProgramPipelineiv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Retrieve properties of a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
        /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml" /></remarks>
        public static void GetProgramPipelineiv(ProgramPipelineHandle pipeline, PipelineParameterName pname, int* parameters) => _GetProgramPipelineiv_fnptr(pipeline, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetProgramPipelineiv_Lazy(ProgramPipelineHandle pipeline, PipelineParameterName pname, int* parameters)
        {
            _GetProgramPipelineiv_fnptr = (delegate* unmanaged<ProgramPipelineHandle, PipelineParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramPipelineiv");
            _GetProgramPipelineiv_fnptr(pipeline, pname, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, void> _ProgramUniform1i_fnptr = &ProgramUniform1i_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1i(ProgramHandle program, int location, int v0) => _ProgramUniform1i_fnptr(program, location, v0);
        [UnmanagedCallersOnly]
        private static void ProgramUniform1i_Lazy(ProgramHandle program, int location, int v0)
        {
            _ProgramUniform1i_fnptr = (delegate* unmanaged<ProgramHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1i");
            _ProgramUniform1i_fnptr(program, location, v0);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform1iv_fnptr = &ProgramUniform1iv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1iv(ProgramHandle program, int location, int count, int* value) => _ProgramUniform1iv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform1iv_Lazy(ProgramHandle program, int location, int count, int* value)
        {
            _ProgramUniform1iv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1iv");
            _ProgramUniform1iv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, float, void> _ProgramUniform1f_fnptr = &ProgramUniform1f_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1f(ProgramHandle program, int location, float v0) => _ProgramUniform1f_fnptr(program, location, v0);
        [UnmanagedCallersOnly]
        private static void ProgramUniform1f_Lazy(ProgramHandle program, int location, float v0)
        {
            _ProgramUniform1f_fnptr = (delegate* unmanaged<ProgramHandle, int, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1f");
            _ProgramUniform1f_fnptr(program, location, v0);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform1fv_fnptr = &ProgramUniform1fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1fv(ProgramHandle program, int location, int count, float* value) => _ProgramUniform1fv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform1fv_Lazy(ProgramHandle program, int location, int count, float* value)
        {
            _ProgramUniform1fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1fv");
            _ProgramUniform1fv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, double, void> _ProgramUniform1d_fnptr = &ProgramUniform1d_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform1d(ProgramHandle program, int location, double v0) => _ProgramUniform1d_fnptr(program, location, v0);
        [UnmanagedCallersOnly]
        private static void ProgramUniform1d_Lazy(ProgramHandle program, int location, double v0)
        {
            _ProgramUniform1d_fnptr = (delegate* unmanaged<ProgramHandle, int, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1d");
            _ProgramUniform1d_fnptr(program, location, v0);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform1dv_fnptr = &ProgramUniform1dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform1dv(ProgramHandle program, int location, int count, double* value) => _ProgramUniform1dv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform1dv_Lazy(ProgramHandle program, int location, int count, double* value)
        {
            _ProgramUniform1dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1dv");
            _ProgramUniform1dv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, uint, void> _ProgramUniform1ui_fnptr = &ProgramUniform1ui_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1ui(ProgramHandle program, int location, uint v0) => _ProgramUniform1ui_fnptr(program, location, v0);
        [UnmanagedCallersOnly]
        private static void ProgramUniform1ui_Lazy(ProgramHandle program, int location, uint v0)
        {
            _ProgramUniform1ui_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1ui");
            _ProgramUniform1ui_fnptr(program, location, v0);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform1uiv_fnptr = &ProgramUniform1uiv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1uiv(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform1uiv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform1uiv_Lazy(ProgramHandle program, int location, int count, uint* value)
        {
            _ProgramUniform1uiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1uiv");
            _ProgramUniform1uiv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, int, void> _ProgramUniform2i_fnptr = &ProgramUniform2i_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2i(ProgramHandle program, int location, int v0, int v1) => _ProgramUniform2i_fnptr(program, location, v0, v1);
        [UnmanagedCallersOnly]
        private static void ProgramUniform2i_Lazy(ProgramHandle program, int location, int v0, int v1)
        {
            _ProgramUniform2i_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2i");
            _ProgramUniform2i_fnptr(program, location, v0, v1);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform2iv_fnptr = &ProgramUniform2iv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2iv(ProgramHandle program, int location, int count, int* value) => _ProgramUniform2iv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform2iv_Lazy(ProgramHandle program, int location, int count, int* value)
        {
            _ProgramUniform2iv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2iv");
            _ProgramUniform2iv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, float, float, void> _ProgramUniform2f_fnptr = &ProgramUniform2f_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2f(ProgramHandle program, int location, float v0, float v1) => _ProgramUniform2f_fnptr(program, location, v0, v1);
        [UnmanagedCallersOnly]
        private static void ProgramUniform2f_Lazy(ProgramHandle program, int location, float v0, float v1)
        {
            _ProgramUniform2f_fnptr = (delegate* unmanaged<ProgramHandle, int, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2f");
            _ProgramUniform2f_fnptr(program, location, v0, v1);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform2fv_fnptr = &ProgramUniform2fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2fv(ProgramHandle program, int location, int count, float* value) => _ProgramUniform2fv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform2fv_Lazy(ProgramHandle program, int location, int count, float* value)
        {
            _ProgramUniform2fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2fv");
            _ProgramUniform2fv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, double, double, void> _ProgramUniform2d_fnptr = &ProgramUniform2d_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform2d(ProgramHandle program, int location, double v0, double v1) => _ProgramUniform2d_fnptr(program, location, v0, v1);
        [UnmanagedCallersOnly]
        private static void ProgramUniform2d_Lazy(ProgramHandle program, int location, double v0, double v1)
        {
            _ProgramUniform2d_fnptr = (delegate* unmanaged<ProgramHandle, int, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2d");
            _ProgramUniform2d_fnptr(program, location, v0, v1);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform2dv_fnptr = &ProgramUniform2dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform2dv(ProgramHandle program, int location, int count, double* value) => _ProgramUniform2dv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform2dv_Lazy(ProgramHandle program, int location, int count, double* value)
        {
            _ProgramUniform2dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2dv");
            _ProgramUniform2dv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, uint, uint, void> _ProgramUniform2ui_fnptr = &ProgramUniform2ui_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2ui(ProgramHandle program, int location, uint v0, uint v1) => _ProgramUniform2ui_fnptr(program, location, v0, v1);
        [UnmanagedCallersOnly]
        private static void ProgramUniform2ui_Lazy(ProgramHandle program, int location, uint v0, uint v1)
        {
            _ProgramUniform2ui_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2ui");
            _ProgramUniform2ui_fnptr(program, location, v0, v1);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform2uiv_fnptr = &ProgramUniform2uiv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2uiv(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform2uiv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform2uiv_Lazy(ProgramHandle program, int location, int count, uint* value)
        {
            _ProgramUniform2uiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2uiv");
            _ProgramUniform2uiv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, int, int, void> _ProgramUniform3i_fnptr = &ProgramUniform3i_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3i(ProgramHandle program, int location, int v0, int v1, int v2) => _ProgramUniform3i_fnptr(program, location, v0, v1, v2);
        [UnmanagedCallersOnly]
        private static void ProgramUniform3i_Lazy(ProgramHandle program, int location, int v0, int v1, int v2)
        {
            _ProgramUniform3i_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3i");
            _ProgramUniform3i_fnptr(program, location, v0, v1, v2);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform3iv_fnptr = &ProgramUniform3iv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3iv(ProgramHandle program, int location, int count, int* value) => _ProgramUniform3iv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform3iv_Lazy(ProgramHandle program, int location, int count, int* value)
        {
            _ProgramUniform3iv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3iv");
            _ProgramUniform3iv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, float, float, float, void> _ProgramUniform3f_fnptr = &ProgramUniform3f_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3f(ProgramHandle program, int location, float v0, float v1, float v2) => _ProgramUniform3f_fnptr(program, location, v0, v1, v2);
        [UnmanagedCallersOnly]
        private static void ProgramUniform3f_Lazy(ProgramHandle program, int location, float v0, float v1, float v2)
        {
            _ProgramUniform3f_fnptr = (delegate* unmanaged<ProgramHandle, int, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3f");
            _ProgramUniform3f_fnptr(program, location, v0, v1, v2);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform3fv_fnptr = &ProgramUniform3fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3fv(ProgramHandle program, int location, int count, float* value) => _ProgramUniform3fv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform3fv_Lazy(ProgramHandle program, int location, int count, float* value)
        {
            _ProgramUniform3fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3fv");
            _ProgramUniform3fv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, double, double, double, void> _ProgramUniform3d_fnptr = &ProgramUniform3d_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform3d(ProgramHandle program, int location, double v0, double v1, double v2) => _ProgramUniform3d_fnptr(program, location, v0, v1, v2);
        [UnmanagedCallersOnly]
        private static void ProgramUniform3d_Lazy(ProgramHandle program, int location, double v0, double v1, double v2)
        {
            _ProgramUniform3d_fnptr = (delegate* unmanaged<ProgramHandle, int, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3d");
            _ProgramUniform3d_fnptr(program, location, v0, v1, v2);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform3dv_fnptr = &ProgramUniform3dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform3dv(ProgramHandle program, int location, int count, double* value) => _ProgramUniform3dv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform3dv_Lazy(ProgramHandle program, int location, int count, double* value)
        {
            _ProgramUniform3dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3dv");
            _ProgramUniform3dv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, uint, uint, uint, void> _ProgramUniform3ui_fnptr = &ProgramUniform3ui_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3ui(ProgramHandle program, int location, uint v0, uint v1, uint v2) => _ProgramUniform3ui_fnptr(program, location, v0, v1, v2);
        [UnmanagedCallersOnly]
        private static void ProgramUniform3ui_Lazy(ProgramHandle program, int location, uint v0, uint v1, uint v2)
        {
            _ProgramUniform3ui_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3ui");
            _ProgramUniform3ui_fnptr(program, location, v0, v1, v2);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform3uiv_fnptr = &ProgramUniform3uiv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3uiv(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform3uiv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform3uiv_Lazy(ProgramHandle program, int location, int count, uint* value)
        {
            _ProgramUniform3uiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3uiv");
            _ProgramUniform3uiv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, int, int, int, void> _ProgramUniform4i_fnptr = &ProgramUniform4i_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4i(ProgramHandle program, int location, int v0, int v1, int v2, int v3) => _ProgramUniform4i_fnptr(program, location, v0, v1, v2, v3);
        [UnmanagedCallersOnly]
        private static void ProgramUniform4i_Lazy(ProgramHandle program, int location, int v0, int v1, int v2, int v3)
        {
            _ProgramUniform4i_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4i");
            _ProgramUniform4i_fnptr(program, location, v0, v1, v2, v3);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform4iv_fnptr = &ProgramUniform4iv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4iv(ProgramHandle program, int location, int count, int* value) => _ProgramUniform4iv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform4iv_Lazy(ProgramHandle program, int location, int count, int* value)
        {
            _ProgramUniform4iv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4iv");
            _ProgramUniform4iv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, float, float, float, float, void> _ProgramUniform4f_fnptr = &ProgramUniform4f_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4f(ProgramHandle program, int location, float v0, float v1, float v2, float v3) => _ProgramUniform4f_fnptr(program, location, v0, v1, v2, v3);
        [UnmanagedCallersOnly]
        private static void ProgramUniform4f_Lazy(ProgramHandle program, int location, float v0, float v1, float v2, float v3)
        {
            _ProgramUniform4f_fnptr = (delegate* unmanaged<ProgramHandle, int, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4f");
            _ProgramUniform4f_fnptr(program, location, v0, v1, v2, v3);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform4fv_fnptr = &ProgramUniform4fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4fv(ProgramHandle program, int location, int count, float* value) => _ProgramUniform4fv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform4fv_Lazy(ProgramHandle program, int location, int count, float* value)
        {
            _ProgramUniform4fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4fv");
            _ProgramUniform4fv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, double, double, double, double, void> _ProgramUniform4d_fnptr = &ProgramUniform4d_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform4d(ProgramHandle program, int location, double v0, double v1, double v2, double v3) => _ProgramUniform4d_fnptr(program, location, v0, v1, v2, v3);
        [UnmanagedCallersOnly]
        private static void ProgramUniform4d_Lazy(ProgramHandle program, int location, double v0, double v1, double v2, double v3)
        {
            _ProgramUniform4d_fnptr = (delegate* unmanaged<ProgramHandle, int, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4d");
            _ProgramUniform4d_fnptr(program, location, v0, v1, v2, v3);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform4dv_fnptr = &ProgramUniform4dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform4dv(ProgramHandle program, int location, int count, double* value) => _ProgramUniform4dv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform4dv_Lazy(ProgramHandle program, int location, int count, double* value)
        {
            _ProgramUniform4dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4dv");
            _ProgramUniform4dv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, uint, uint, uint, uint, void> _ProgramUniform4ui_fnptr = &ProgramUniform4ui_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4ui(ProgramHandle program, int location, uint v0, uint v1, uint v2, uint v3) => _ProgramUniform4ui_fnptr(program, location, v0, v1, v2, v3);
        [UnmanagedCallersOnly]
        private static void ProgramUniform4ui_Lazy(ProgramHandle program, int location, uint v0, uint v1, uint v2, uint v3)
        {
            _ProgramUniform4ui_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4ui");
            _ProgramUniform4ui_fnptr(program, location, v0, v1, v2, v3);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform4uiv_fnptr = &ProgramUniform4uiv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4uiv(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform4uiv_fnptr(program, location, count, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniform4uiv_Lazy(ProgramHandle program, int location, int count, uint* value)
        {
            _ProgramUniform4uiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4uiv");
            _ProgramUniform4uiv_fnptr(program, location, count, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix2fv_fnptr = &ProgramUniformMatrix2fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix2fv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix2fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
        {
            _ProgramUniformMatrix2fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2fv");
            _ProgramUniformMatrix2fv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix3fv_fnptr = &ProgramUniformMatrix3fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix3fv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix3fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
        {
            _ProgramUniformMatrix3fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3fv");
            _ProgramUniformMatrix3fv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix4fv_fnptr = &ProgramUniformMatrix4fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix4fv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix4fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
        {
            _ProgramUniformMatrix4fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4fv");
            _ProgramUniformMatrix4fv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix2dv_fnptr = &ProgramUniformMatrix2dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix2dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix2dv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix2dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
        {
            _ProgramUniformMatrix2dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2dv");
            _ProgramUniformMatrix2dv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix3dv_fnptr = &ProgramUniformMatrix3dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix3dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix3dv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix3dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
        {
            _ProgramUniformMatrix3dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3dv");
            _ProgramUniformMatrix3dv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix4dv_fnptr = &ProgramUniformMatrix4dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix4dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix4dv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix4dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
        {
            _ProgramUniformMatrix4dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4dv");
            _ProgramUniformMatrix4dv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix2x3fv_fnptr = &ProgramUniformMatrix2x3fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2x3fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix2x3fv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix2x3fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
        {
            _ProgramUniformMatrix2x3fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x3fv");
            _ProgramUniformMatrix2x3fv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix3x2fv_fnptr = &ProgramUniformMatrix3x2fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3x2fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix3x2fv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix3x2fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
        {
            _ProgramUniformMatrix3x2fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x2fv");
            _ProgramUniformMatrix3x2fv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix2x4fv_fnptr = &ProgramUniformMatrix2x4fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2x4fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix2x4fv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix2x4fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
        {
            _ProgramUniformMatrix2x4fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x4fv");
            _ProgramUniformMatrix2x4fv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix4x2fv_fnptr = &ProgramUniformMatrix4x2fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4x2fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix4x2fv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix4x2fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
        {
            _ProgramUniformMatrix4x2fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x2fv");
            _ProgramUniformMatrix4x2fv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix3x4fv_fnptr = &ProgramUniformMatrix3x4fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3x4fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix3x4fv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix3x4fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
        {
            _ProgramUniformMatrix3x4fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x4fv");
            _ProgramUniformMatrix3x4fv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix4x3fv_fnptr = &ProgramUniformMatrix4x3fv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4x3fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix4x3fv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix4x3fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
        {
            _ProgramUniformMatrix4x3fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x3fv");
            _ProgramUniformMatrix4x3fv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix2x3dv_fnptr = &ProgramUniformMatrix2x3dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix2x3dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix2x3dv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix2x3dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
        {
            _ProgramUniformMatrix2x3dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x3dv");
            _ProgramUniformMatrix2x3dv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix3x2dv_fnptr = &ProgramUniformMatrix3x2dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix3x2dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix3x2dv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix3x2dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
        {
            _ProgramUniformMatrix3x2dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x2dv");
            _ProgramUniformMatrix3x2dv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix2x4dv_fnptr = &ProgramUniformMatrix2x4dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix2x4dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix2x4dv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix2x4dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
        {
            _ProgramUniformMatrix2x4dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x4dv");
            _ProgramUniformMatrix2x4dv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix4x2dv_fnptr = &ProgramUniformMatrix4x2dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix4x2dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix4x2dv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix4x2dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
        {
            _ProgramUniformMatrix4x2dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x2dv");
            _ProgramUniformMatrix4x2dv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix3x4dv_fnptr = &ProgramUniformMatrix3x4dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix3x4dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix3x4dv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix3x4dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
        {
            _ProgramUniformMatrix3x4dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x4dv");
            _ProgramUniformMatrix3x4dv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix4x3dv_fnptr = &ProgramUniformMatrix4x3dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix4x3dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix4x3dv_fnptr(program, location, count, transpose, value);
        [UnmanagedCallersOnly]
        private static void ProgramUniformMatrix4x3dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
        {
            _ProgramUniformMatrix4x3dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x3dv");
            _ProgramUniformMatrix4x3dv_fnptr(program, location, count, transpose, value);
        }
        
        private static delegate* unmanaged<ProgramPipelineHandle, void> _ValidateProgramPipeline_fnptr = &ValidateProgramPipeline_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Validate a program pipeline object against current GL state. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml" /></remarks>
        public static void ValidateProgramPipeline(ProgramPipelineHandle pipeline) => _ValidateProgramPipeline_fnptr(pipeline);
        [UnmanagedCallersOnly]
        private static void ValidateProgramPipeline_Lazy(ProgramPipelineHandle pipeline)
        {
            _ValidateProgramPipeline_fnptr = (delegate* unmanaged<ProgramPipelineHandle, void>)GLLoader.BindingsContext.GetProcAddress("glValidateProgramPipeline");
            _ValidateProgramPipeline_fnptr(pipeline);
        }
        
        private static delegate* unmanaged<ProgramPipelineHandle, int, int*, byte*, void> _GetProgramPipelineInfoLog_fnptr = &GetProgramPipelineInfoLog_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Retrieve the info log string from a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
        /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
        /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
        /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml" /></remarks>
        public static void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, int* length, byte* infoLog) => _GetProgramPipelineInfoLog_fnptr(pipeline, bufSize, length, infoLog);
        [UnmanagedCallersOnly]
        private static void GetProgramPipelineInfoLog_Lazy(ProgramPipelineHandle pipeline, int bufSize, int* length, byte* infoLog)
        {
            _GetProgramPipelineInfoLog_fnptr = (delegate* unmanaged<ProgramPipelineHandle, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramPipelineInfoLog");
            _GetProgramPipelineInfoLog_fnptr(pipeline, bufSize, length, infoLog);
        }
        
        private static delegate* unmanaged<uint, double, void> _VertexAttribL1d_fnptr = &VertexAttribL1d_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL1d(uint index, double x) => _VertexAttribL1d_fnptr(index, x);
        [UnmanagedCallersOnly]
        private static void VertexAttribL1d_Lazy(uint index, double x)
        {
            _VertexAttribL1d_fnptr = (delegate* unmanaged<uint, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1d");
            _VertexAttribL1d_fnptr(index, x);
        }
        
        private static delegate* unmanaged<uint, double, double, void> _VertexAttribL2d_fnptr = &VertexAttribL2d_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL2d(uint index, double x, double y) => _VertexAttribL2d_fnptr(index, x, y);
        [UnmanagedCallersOnly]
        private static void VertexAttribL2d_Lazy(uint index, double x, double y)
        {
            _VertexAttribL2d_fnptr = (delegate* unmanaged<uint, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2d");
            _VertexAttribL2d_fnptr(index, x, y);
        }
        
        private static delegate* unmanaged<uint, double, double, double, void> _VertexAttribL3d_fnptr = &VertexAttribL3d_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL3d(uint index, double x, double y, double z) => _VertexAttribL3d_fnptr(index, x, y, z);
        [UnmanagedCallersOnly]
        private static void VertexAttribL3d_Lazy(uint index, double x, double y, double z)
        {
            _VertexAttribL3d_fnptr = (delegate* unmanaged<uint, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3d");
            _VertexAttribL3d_fnptr(index, x, y, z);
        }
        
        private static delegate* unmanaged<uint, double, double, double, double, void> _VertexAttribL4d_fnptr = &VertexAttribL4d_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => _VertexAttribL4d_fnptr(index, x, y, z, w);
        [UnmanagedCallersOnly]
        private static void VertexAttribL4d_Lazy(uint index, double x, double y, double z, double w)
        {
            _VertexAttribL4d_fnptr = (delegate* unmanaged<uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4d");
            _VertexAttribL4d_fnptr(index, x, y, z, w);
        }
        
        private static delegate* unmanaged<uint, double*, void> _VertexAttribL1dv_fnptr = &VertexAttribL1dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL1dv(uint index, double* v) => _VertexAttribL1dv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribL1dv_Lazy(uint index, double* v)
        {
            _VertexAttribL1dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1dv");
            _VertexAttribL1dv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, double*, void> _VertexAttribL2dv_fnptr = &VertexAttribL2dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL2dv(uint index, double* v) => _VertexAttribL2dv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribL2dv_Lazy(uint index, double* v)
        {
            _VertexAttribL2dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2dv");
            _VertexAttribL2dv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, double*, void> _VertexAttribL3dv_fnptr = &VertexAttribL3dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL3dv(uint index, double* v) => _VertexAttribL3dv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribL3dv_Lazy(uint index, double* v)
        {
            _VertexAttribL3dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3dv");
            _VertexAttribL3dv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, double*, void> _VertexAttribL4dv_fnptr = &VertexAttribL4dv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL4dv(uint index, double* v) => _VertexAttribL4dv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void VertexAttribL4dv_Lazy(uint index, double* v)
        {
            _VertexAttribL4dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4dv");
            _VertexAttribL4dv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, int, VertexAttribLType, int, void*, void> _VertexAttribLPointer_fnptr = &VertexAttribLPointer_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => _VertexAttribLPointer_fnptr(index, size, type, stride, pointer);
        [UnmanagedCallersOnly]
        private static void VertexAttribLPointer_Lazy(uint index, int size, VertexAttribLType type, int stride, void* pointer)
        {
            _VertexAttribLPointer_fnptr = (delegate* unmanaged<uint, int, VertexAttribLType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribLPointer");
            _VertexAttribLPointer_fnptr(index, size, type, stride, pointer);
        }
        
        private static delegate* unmanaged<uint, VertexAttribEnum, double*, void> _GetVertexAttribLdv_fnptr = &GetVertexAttribLdv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => _GetVertexAttribLdv_fnptr(index, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetVertexAttribLdv_Lazy(uint index, VertexAttribEnum pname, double* parameters)
        {
            _GetVertexAttribLdv_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribLdv");
            _GetVertexAttribLdv_fnptr(index, pname, parameters);
        }
        
        private static delegate* unmanaged<uint, int, float*, void> _ViewportArrayv_fnptr = &ViewportArrayv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set multiple viewports. </summary>
        /// <param name="first"> Specify the first viewport to set. </param>
        /// <param name="count"> Specify the number of viewports to set. </param>
        /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml" /></remarks>
        public static void ViewportArrayv(uint first, int count, float* v) => _ViewportArrayv_fnptr(first, count, v);
        [UnmanagedCallersOnly]
        private static void ViewportArrayv_Lazy(uint first, int count, float* v)
        {
            _ViewportArrayv_fnptr = (delegate* unmanaged<uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glViewportArrayv");
            _ViewportArrayv_fnptr(first, count, v);
        }
        
        private static delegate* unmanaged<uint, float, float, float, float, void> _ViewportIndexedf_fnptr = &ViewportIndexedf_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
        public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => _ViewportIndexedf_fnptr(index, x, y, w, h);
        [UnmanagedCallersOnly]
        private static void ViewportIndexedf_Lazy(uint index, float x, float y, float w, float h)
        {
            _ViewportIndexedf_fnptr = (delegate* unmanaged<uint, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glViewportIndexedf");
            _ViewportIndexedf_fnptr(index, x, y, w, h);
        }
        
        private static delegate* unmanaged<uint, float*, void> _ViewportIndexedfv_fnptr = &ViewportIndexedfv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
        public static void ViewportIndexedfv(uint index, float* v) => _ViewportIndexedfv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void ViewportIndexedfv_Lazy(uint index, float* v)
        {
            _ViewportIndexedfv_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glViewportIndexedfv");
            _ViewportIndexedfv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, int, int*, void> _ScissorArrayv_fnptr = &ScissorArrayv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for multiple viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
        /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
        /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml" /></remarks>
        public static void ScissorArrayv(uint first, int count, int* v) => _ScissorArrayv_fnptr(first, count, v);
        [UnmanagedCallersOnly]
        private static void ScissorArrayv_Lazy(uint first, int count, int* v)
        {
            _ScissorArrayv_fnptr = (delegate* unmanaged<uint, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glScissorArrayv");
            _ScissorArrayv_fnptr(first, count, v);
        }
        
        private static delegate* unmanaged<uint, int, int, int, int, void> _ScissorIndexed_fnptr = &ScissorIndexed_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
        public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => _ScissorIndexed_fnptr(index, left, bottom, width, height);
        [UnmanagedCallersOnly]
        private static void ScissorIndexed_Lazy(uint index, int left, int bottom, int width, int height)
        {
            _ScissorIndexed_fnptr = (delegate* unmanaged<uint, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glScissorIndexed");
            _ScissorIndexed_fnptr(index, left, bottom, width, height);
        }
        
        private static delegate* unmanaged<uint, int*, void> _ScissorIndexedv_fnptr = &ScissorIndexedv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
        public static void ScissorIndexedv(uint index, int* v) => _ScissorIndexedv_fnptr(index, v);
        [UnmanagedCallersOnly]
        private static void ScissorIndexedv_Lazy(uint index, int* v)
        {
            _ScissorIndexedv_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glScissorIndexedv");
            _ScissorIndexedv_fnptr(index, v);
        }
        
        private static delegate* unmanaged<uint, int, double*, void> _DepthRangeArrayv_fnptr = &DepthRangeArrayv_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
        /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
        /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml" /></remarks>
        public static void DepthRangeArrayv(uint first, int count, double* v) => _DepthRangeArrayv_fnptr(first, count, v);
        [UnmanagedCallersOnly]
        private static void DepthRangeArrayv_Lazy(uint first, int count, double* v)
        {
            _DepthRangeArrayv_fnptr = (delegate* unmanaged<uint, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangeArrayv");
            _DepthRangeArrayv_fnptr(first, count, v);
        }
        
        private static delegate* unmanaged<uint, double, double, void> _DepthRangeIndexed_fnptr = &DepthRangeIndexed_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml" /></remarks>
        public static void DepthRangeIndexed(uint index, double n, double f) => _DepthRangeIndexed_fnptr(index, n, f);
        [UnmanagedCallersOnly]
        private static void DepthRangeIndexed_Lazy(uint index, double n, double f)
        {
            _DepthRangeIndexed_fnptr = (delegate* unmanaged<uint, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangeIndexed");
            _DepthRangeIndexed_fnptr(index, n, f);
        }
        
        private static delegate* unmanaged<GetPName, uint, float*, void> _GetFloati_v_fnptr = &GetFloati_v_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetFloati_v(GetPName target, uint index, float* data) => _GetFloati_v_fnptr(target, index, data);
        [UnmanagedCallersOnly]
        private static void GetFloati_v_Lazy(GetPName target, uint index, float* data)
        {
            _GetFloati_v_fnptr = (delegate* unmanaged<GetPName, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFloati_v");
            _GetFloati_v_fnptr(target, index, data);
        }
        
        private static delegate* unmanaged<GetPName, uint, double*, void> _GetDoublei_v_fnptr = &GetDoublei_v_Lazy;
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetDoublei_v(GetPName target, uint index, double* data) => _GetDoublei_v_fnptr(target, index, data);
        [UnmanagedCallersOnly]
        private static void GetDoublei_v_Lazy(GetPName target, uint index, double* data)
        {
            _GetDoublei_v_fnptr = (delegate* unmanaged<GetPName, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetDoublei_v");
            _GetDoublei_v_fnptr(target, index, data);
        }
        
        private static delegate* unmanaged<PrimitiveType, int, int, int, uint, void> _DrawArraysInstancedBaseInstance_fnptr = &DrawArraysInstancedBaseInstance_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml" /></remarks>
        public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => _DrawArraysInstancedBaseInstance_fnptr(mode, first, count, instancecount, baseinstance);
        [UnmanagedCallersOnly]
        private static void DrawArraysInstancedBaseInstance_Lazy(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
        {
            _DrawArraysInstancedBaseInstance_fnptr = (delegate* unmanaged<PrimitiveType, int, int, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawArraysInstancedBaseInstance");
            _DrawArraysInstancedBaseInstance_fnptr(mode, first, count, instancecount, baseinstance);
        }
        
        private static delegate* unmanaged<PrimitiveType, int, PrimitiveType, void*, int, uint, void> _DrawElementsInstancedBaseInstance_fnptr = &DrawElementsInstancedBaseInstance_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, PrimitiveType type, void* indices, int instancecount, uint baseinstance) => _DrawElementsInstancedBaseInstance_fnptr(mode, count, type, indices, instancecount, baseinstance);
        [UnmanagedCallersOnly]
        private static void DrawElementsInstancedBaseInstance_Lazy(PrimitiveType mode, int count, PrimitiveType type, void* indices, int instancecount, uint baseinstance)
        {
            _DrawElementsInstancedBaseInstance_fnptr = (delegate* unmanaged<PrimitiveType, int, PrimitiveType, void*, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsInstancedBaseInstance");
            _DrawElementsInstancedBaseInstance_fnptr(mode, count, type, indices, instancecount, baseinstance);
        }
        
        private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, int, uint, void> _DrawElementsInstancedBaseVertexBaseInstance_fnptr = &DrawElementsInstancedBaseVertexBaseInstance_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => _DrawElementsInstancedBaseVertexBaseInstance_fnptr(mode, count, type, indices, instancecount, basevertex, baseinstance);
        [UnmanagedCallersOnly]
        private static void DrawElementsInstancedBaseVertexBaseInstance_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
        {
            _DrawElementsInstancedBaseVertexBaseInstance_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsInstancedBaseVertexBaseInstance");
            _DrawElementsInstancedBaseVertexBaseInstance_fnptr(mode, count, type, indices, instancecount, basevertex, baseinstance);
        }
        
        private static delegate* unmanaged<TextureTarget, InternalFormat, InternalFormatPName, int, int*, void> _GetInternalformativ_fnptr = &GetInternalformativ_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
        public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => _GetInternalformativ_fnptr(target, internalformat, pname, count, parameters);
        [UnmanagedCallersOnly]
        private static void GetInternalformativ_Lazy(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters)
        {
            _GetInternalformativ_fnptr = (delegate* unmanaged<TextureTarget, InternalFormat, InternalFormatPName, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInternalformativ");
            _GetInternalformativ_fnptr(target, internalformat, pname, count, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, AtomicCounterBufferPName, int*, void> _GetActiveAtomicCounterBufferiv_fnptr = &GetActiveAtomicCounterBufferiv_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters]</b> Retrieve information about the set of active atomic counter buffers for a program. </summary>
        /// <param name="program"> The name of a program object from which to retrieve information. </param>
        /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
        /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml" /></remarks>
        public static void GetActiveAtomicCounterBufferiv(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => _GetActiveAtomicCounterBufferiv_fnptr(program, bufferIndex, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetActiveAtomicCounterBufferiv_Lazy(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters)
        {
            _GetActiveAtomicCounterBufferiv_fnptr = (delegate* unmanaged<ProgramHandle, uint, AtomicCounterBufferPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveAtomicCounterBufferiv");
            _GetActiveAtomicCounterBufferiv_fnptr(program, bufferIndex, pname, parameters);
        }
        
        private static delegate* unmanaged<uint, TextureHandle, int, byte, int, BufferAccessARB, InternalFormat, void> _BindImageTexture_fnptr = &BindImageTexture_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> Bind a level of a texture to an image unit. </summary>
        /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
        /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
        /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
        /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
        /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
        /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
        /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml" /></remarks>
        public static void BindImageTexture(uint unit, TextureHandle texture, int level, byte layered, int layer, BufferAccessARB access, InternalFormat format) => _BindImageTexture_fnptr(unit, texture, level, layered, layer, access, format);
        [UnmanagedCallersOnly]
        private static void BindImageTexture_Lazy(uint unit, TextureHandle texture, int level, byte layered, int layer, BufferAccessARB access, InternalFormat format)
        {
            _BindImageTexture_fnptr = (delegate* unmanaged<uint, TextureHandle, int, byte, int, BufferAccessARB, InternalFormat, void>)GLLoader.BindingsContext.GetProcAddress("glBindImageTexture");
            _BindImageTexture_fnptr(unit, texture, level, layered, layer, access, format);
        }
        
        private static delegate* unmanaged<MemoryBarrierMask, void> _MemoryBarrier_fnptr = &MemoryBarrier_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
        public static void MemoryBarrier(MemoryBarrierMask barriers) => _MemoryBarrier_fnptr(barriers);
        [UnmanagedCallersOnly]
        private static void MemoryBarrier_Lazy(MemoryBarrierMask barriers)
        {
            _MemoryBarrier_fnptr = (delegate* unmanaged<MemoryBarrierMask, void>)GLLoader.BindingsContext.GetProcAddress("glMemoryBarrier");
            _MemoryBarrier_fnptr(barriers);
        }
        
        private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, void> _TexStorage1D_fnptr = &TexStorage1D_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
        public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => _TexStorage1D_fnptr(target, levels, internalformat, width);
        [UnmanagedCallersOnly]
        private static void TexStorage1D_Lazy(TextureTarget target, int levels, SizedInternalFormat internalformat, int width)
        {
            _TexStorage1D_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage1D");
            _TexStorage1D_fnptr(target, levels, internalformat, width);
        }
        
        private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, void> _TexStorage2D_fnptr = &TexStorage2D_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
        public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => _TexStorage2D_fnptr(target, levels, internalformat, width, height);
        [UnmanagedCallersOnly]
        private static void TexStorage2D_Lazy(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height)
        {
            _TexStorage2D_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage2D");
            _TexStorage2D_fnptr(target, levels, internalformat, width, height);
        }
        
        private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, void> _TexStorage3D_fnptr = &TexStorage3D_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
        public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => _TexStorage3D_fnptr(target, levels, internalformat, width, height, depth);
        [UnmanagedCallersOnly]
        private static void TexStorage3D_Lazy(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth)
        {
            _TexStorage3D_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage3D");
            _TexStorage3D_fnptr(target, levels, internalformat, width, height, depth);
        }
        
        private static delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, int, void> _DrawTransformFeedbackInstanced_fnptr = &DrawTransformFeedbackInstanced_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml" /></remarks>
        public static void DrawTransformFeedbackInstanced(PrimitiveType mode, TransformFeedbackHandle id, int instancecount) => _DrawTransformFeedbackInstanced_fnptr(mode, id, instancecount);
        [UnmanagedCallersOnly]
        private static void DrawTransformFeedbackInstanced_Lazy(PrimitiveType mode, TransformFeedbackHandle id, int instancecount)
        {
            _DrawTransformFeedbackInstanced_fnptr = (delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTransformFeedbackInstanced");
            _DrawTransformFeedbackInstanced_fnptr(mode, id, instancecount);
        }
        
        private static delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, uint, int, void> _DrawTransformFeedbackStreamInstanced_fnptr = &DrawTransformFeedbackStreamInstanced_Lazy;
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml" /></remarks>
        public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, TransformFeedbackHandle id, uint stream, int instancecount) => _DrawTransformFeedbackStreamInstanced_fnptr(mode, id, stream, instancecount);
        [UnmanagedCallersOnly]
        private static void DrawTransformFeedbackStreamInstanced_Lazy(PrimitiveType mode, TransformFeedbackHandle id, uint stream, int instancecount)
        {
            _DrawTransformFeedbackStreamInstanced_fnptr = (delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, uint, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTransformFeedbackStreamInstanced");
            _DrawTransformFeedbackStreamInstanced_fnptr(mode, id, stream, instancecount);
        }
        
        private static delegate* unmanaged<BufferStorageTarget, SizedInternalFormat, PixelFormat, PixelType, void*, void> _ClearBufferData_fnptr = &ClearBufferData_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> Fill a buffer object's data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
        public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => _ClearBufferData_fnptr(target, internalformat, format, type, data);
        [UnmanagedCallersOnly]
        private static void ClearBufferData_Lazy(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data)
        {
            _ClearBufferData_fnptr = (delegate* unmanaged<BufferStorageTarget, SizedInternalFormat, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearBufferData");
            _ClearBufferData_fnptr(target, internalformat, format, type, data);
        }
        
        private static delegate* unmanaged<BufferTargetARB, SizedInternalFormat, IntPtr, nint, PixelFormat, PixelType, void*, void> _ClearBufferSubData_fnptr = &ClearBufferSubData_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> Fill all or part of buffer object's data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object's data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
        public static void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => _ClearBufferSubData_fnptr(target, internalformat, offset, size, format, type, data);
        [UnmanagedCallersOnly]
        private static void ClearBufferSubData_Lazy(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data)
        {
            _ClearBufferSubData_fnptr = (delegate* unmanaged<BufferTargetARB, SizedInternalFormat, IntPtr, nint, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearBufferSubData");
            _ClearBufferSubData_fnptr(target, internalformat, offset, size, format, type, data);
        }
        
        private static delegate* unmanaged<uint, uint, uint, void> _DispatchCompute_fnptr = &DispatchCompute_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> Launch one or more compute work groups. </summary>
        /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
        /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
        /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml" /></remarks>
        public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => _DispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
        [UnmanagedCallersOnly]
        private static void DispatchCompute_Lazy(uint num_groups_x, uint num_groups_y, uint num_groups_z)
        {
            _DispatchCompute_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDispatchCompute");
            _DispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
        }
        
        private static delegate* unmanaged<IntPtr, void> _DispatchComputeIndirect_fnptr = &DispatchComputeIndirect_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> Launch one or more compute work groups using parameters stored in a buffer. </summary>
        /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml" /></remarks>
        public static void DispatchComputeIndirect(IntPtr indirect) => _DispatchComputeIndirect_fnptr(indirect);
        [UnmanagedCallersOnly]
        private static void DispatchComputeIndirect_Lazy(IntPtr indirect)
        {
            _DispatchComputeIndirect_fnptr = (delegate* unmanaged<IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glDispatchComputeIndirect");
            _DispatchComputeIndirect_fnptr(indirect);
        }
        
        private static delegate* unmanaged<uint, CopyImageSubDataTarget, int, int, int, int, uint, CopyImageSubDataTarget, int, int, int, int, int, int, int, void> _CopyImageSubData_fnptr = &CopyImageSubData_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image]</b> Perform a raw data copy between two images. </summary>
        /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
        /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
        /// <param name="srcLevel"> The mipmap level to read from the source. </param>
        /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
        /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
        /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
        /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
        /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
        /// <param name="dstLevel">!!missing documentation!!</param>
        /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
        /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
        /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
        /// <param name="srcWidth"> The width of the region to be copied. </param>
        /// <param name="srcHeight"> The height of the region to be copied. </param>
        /// <param name="srcDepth"> The depth of the region to be copied. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml" /></remarks>
        public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => _CopyImageSubData_fnptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        [UnmanagedCallersOnly]
        private static void CopyImageSubData_Lazy(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
        {
            _CopyImageSubData_fnptr = (delegate* unmanaged<uint, CopyImageSubDataTarget, int, int, int, int, uint, CopyImageSubDataTarget, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyImageSubData");
            _CopyImageSubData_fnptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferParameterName, int, void> _FramebufferParameteri_fnptr = &FramebufferParameteri_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> Set a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
        public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => _FramebufferParameteri_fnptr(target, pname, param);
        [UnmanagedCallersOnly]
        private static void FramebufferParameteri_Lazy(FramebufferTarget target, FramebufferParameterName pname, int param)
        {
            _FramebufferParameteri_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferParameteri");
            _FramebufferParameteri_fnptr(target, pname, param);
        }
        
        private static delegate* unmanaged<FramebufferTarget, FramebufferAttachmentParameterName, int*, void> _GetFramebufferParameteriv_fnptr = &GetFramebufferParameteriv_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> Query a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
        public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => _GetFramebufferParameteriv_fnptr(target, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetFramebufferParameteriv_Lazy(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters)
        {
            _GetFramebufferParameteriv_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachmentParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFramebufferParameteriv");
            _GetFramebufferParameteriv_fnptr(target, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, InternalFormat, InternalFormatPName, int, long*, void> _GetInternalformati64v_fnptr = &GetInternalformati64v_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
        public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => _GetInternalformati64v_fnptr(target, internalformat, pname, count, parameters);
        [UnmanagedCallersOnly]
        private static void GetInternalformati64v_Lazy(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters)
        {
            _GetInternalformati64v_fnptr = (delegate* unmanaged<TextureTarget, InternalFormat, InternalFormatPName, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInternalformati64v");
            _GetInternalformati64v_fnptr(target, internalformat, pname, count, parameters);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, void> _InvalidateTexSubImage_fnptr = &InvalidateTexSubImage_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate a region of a texture image. </summary>
        /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
        /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
        /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
        /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
        /// <param name="width"> The width of the region to be invalidated. </param>
        /// <param name="height"> The height of the region to be invalidated. </param>
        /// <param name="depth"> The depth of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml" /></remarks>
        public static void InvalidateTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => _InvalidateTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
        [UnmanagedCallersOnly]
        private static void InvalidateTexSubImage_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth)
        {
            _InvalidateTexSubImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateTexSubImage");
            _InvalidateTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
        }
        
        private static delegate* unmanaged<TextureHandle, int, void> _InvalidateTexImage_fnptr = &InvalidateTexImage_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the entirety a texture image. </summary>
        /// <param name="texture"> The name of a texture object to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml" /></remarks>
        public static void InvalidateTexImage(TextureHandle texture, int level) => _InvalidateTexImage_fnptr(texture, level);
        [UnmanagedCallersOnly]
        private static void InvalidateTexImage_Lazy(TextureHandle texture, int level)
        {
            _InvalidateTexImage_fnptr = (delegate* unmanaged<TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateTexImage");
            _InvalidateTexImage_fnptr(texture, level);
        }
        
        private static delegate* unmanaged<BufferHandle, IntPtr, nint, void> _InvalidateBufferSubData_fnptr = &InvalidateBufferSubData_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate a region of a buffer object's data store. </summary>
        /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
        /// <param name="offset"> The offset within the buffer's data store of the start of the range to be invalidated. </param>
        /// <param name="length"> The length of the range within the buffer's data store to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml" /></remarks>
        public static void InvalidateBufferSubData(BufferHandle buffer, IntPtr offset, nint length) => _InvalidateBufferSubData_fnptr(buffer, offset, length);
        [UnmanagedCallersOnly]
        private static void InvalidateBufferSubData_Lazy(BufferHandle buffer, IntPtr offset, nint length)
        {
            _InvalidateBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateBufferSubData");
            _InvalidateBufferSubData_fnptr(buffer, offset, length);
        }
        
        private static delegate* unmanaged<BufferHandle, void> _InvalidateBufferData_fnptr = &InvalidateBufferData_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of a buffer object's data store. </summary>
        /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml" /></remarks>
        public static void InvalidateBufferData(BufferHandle buffer) => _InvalidateBufferData_fnptr(buffer);
        [UnmanagedCallersOnly]
        private static void InvalidateBufferData_Lazy(BufferHandle buffer)
        {
            _InvalidateBufferData_fnptr = (delegate* unmanaged<BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateBufferData");
            _InvalidateBufferData_fnptr(buffer);
        }
        
        private static delegate* unmanaged<FramebufferTarget, int, InvalidateFramebufferAttachment*, void> _InvalidateFramebuffer_fnptr = &InvalidateFramebuffer_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of some or all of a framebuffer's attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
        public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => _InvalidateFramebuffer_fnptr(target, numAttachments, attachments);
        [UnmanagedCallersOnly]
        private static void InvalidateFramebuffer_Lazy(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments)
        {
            _InvalidateFramebuffer_fnptr = (delegate* unmanaged<FramebufferTarget, int, InvalidateFramebufferAttachment*, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateFramebuffer");
            _InvalidateFramebuffer_fnptr(target, numAttachments, attachments);
        }
        
        private static delegate* unmanaged<FramebufferTarget, int, InvalidateFramebufferAttachment*, int, int, int, int, void> _InvalidateSubFramebuffer_fnptr = &InvalidateSubFramebuffer_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of a region of some or all of a framebuffer's attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
        public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => _InvalidateSubFramebuffer_fnptr(target, numAttachments, attachments, x, y, width, height);
        [UnmanagedCallersOnly]
        private static void InvalidateSubFramebuffer_Lazy(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height)
        {
            _InvalidateSubFramebuffer_fnptr = (delegate* unmanaged<FramebufferTarget, int, InvalidateFramebufferAttachment*, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateSubFramebuffer");
            _InvalidateSubFramebuffer_fnptr(target, numAttachments, attachments, x, y, width, height);
        }
        
        private static delegate* unmanaged<PrimitiveType, void*, int, int, void> _MultiDrawArraysIndirect_fnptr = &MultiDrawArraysIndirect_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml" /></remarks>
        public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => _MultiDrawArraysIndirect_fnptr(mode, indirect, drawcount, stride);
        [UnmanagedCallersOnly]
        private static void MultiDrawArraysIndirect_Lazy(PrimitiveType mode, void* indirect, int drawcount, int stride)
        {
            _MultiDrawArraysIndirect_fnptr = (delegate* unmanaged<PrimitiveType, void*, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawArraysIndirect");
            _MultiDrawArraysIndirect_fnptr(mode, indirect, drawcount, stride);
        }
        
        private static delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, void> _MultiDrawElementsIndirect_fnptr = &MultiDrawElementsIndirect_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml" /></remarks>
        public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => _MultiDrawElementsIndirect_fnptr(mode, type, indirect, drawcount, stride);
        [UnmanagedCallersOnly]
        private static void MultiDrawElementsIndirect_Lazy(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride)
        {
            _MultiDrawElementsIndirect_fnptr = (delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsIndirect");
            _MultiDrawElementsIndirect_fnptr(mode, type, indirect, drawcount, stride);
        }
        
        private static delegate* unmanaged<ProgramHandle, ProgramInterface, ProgramInterfacePName, int*, void> _GetProgramInterfaceiv_fnptr = &GetProgramInterfaceiv_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query a property of an interface in a program. </summary>
        /// <param name="program"> The name of a program object whose interface to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program to query. </param>
        /// <param name="pname"> The name of the parameter within programInterface to query. </param>
        /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml" /></remarks>
        public static void GetProgramInterfaceiv(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => _GetProgramInterfaceiv_fnptr(program, programInterface, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetProgramInterfaceiv_Lazy(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters)
        {
            _GetProgramInterfaceiv_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, ProgramInterfacePName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramInterfaceiv");
            _GetProgramInterfaceiv_fnptr(program, programInterface, pname, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, uint> _GetProgramResourceIndex_fnptr = &GetProgramResourceIndex_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the index of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the index of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml" /></remarks>
        public static uint GetProgramResourceIndex(ProgramHandle program, ProgramInterface programInterface, byte* name) => _GetProgramResourceIndex_fnptr(program, programInterface, name);
        [UnmanagedCallersOnly]
        private static uint GetProgramResourceIndex_Lazy(ProgramHandle program, ProgramInterface programInterface, byte* name)
        {
            _GetProgramResourceIndex_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceIndex");
            return _GetProgramResourceIndex_fnptr(program, programInterface, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, int*, byte*, void> _GetProgramResourceName_fnptr = &GetProgramResourceName_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the name of an indexed resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
        /// <param name="index"> The index of the resource within programInterface of program. </param>
        /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
        /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
        /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml" /></remarks>
        public static void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => _GetProgramResourceName_fnptr(program, programInterface, index, bufSize, length, name);
        [UnmanagedCallersOnly]
        private static void GetProgramResourceName_Lazy(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
        {
            _GetProgramResourceName_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceName");
            _GetProgramResourceName_fnptr(program, programInterface, index, bufSize, length, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, ProgramResourceProperty*, int, int*, int*, void> _GetProgramResourceiv_fnptr = &GetProgramResourceiv_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Retrieve values for multiple properties of a single active resource within a program object. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="index">!!missing documentation!!</param>
        /// <param name="propCount">!!missing documentation!!</param>
        /// <param name="props">!!missing documentation!!</param>
        /// <param name="bufSize">!!missing documentation!!</param>
        /// <param name="length">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml" /></remarks>
        public static void GetProgramResourceiv(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => _GetProgramResourceiv_fnptr(program, programInterface, index, propCount, props, count, length, parameters);
        [UnmanagedCallersOnly]
        private static void GetProgramResourceiv_Lazy(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters)
        {
            _GetProgramResourceiv_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, ProgramResourceProperty*, int, int*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceiv");
            _GetProgramResourceiv_fnptr(program, programInterface, index, propCount, props, count, length, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, int> _GetProgramResourceLocation_fnptr = &GetProgramResourceLocation_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the location of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml" /></remarks>
        public static int GetProgramResourceLocation(ProgramHandle program, ProgramInterface programInterface, byte* name) => _GetProgramResourceLocation_fnptr(program, programInterface, name);
        [UnmanagedCallersOnly]
        private static int GetProgramResourceLocation_Lazy(ProgramHandle program, ProgramInterface programInterface, byte* name)
        {
            _GetProgramResourceLocation_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceLocation");
            return _GetProgramResourceLocation_fnptr(program, programInterface, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, int> _GetProgramResourceLocationIndex_fnptr = &GetProgramResourceLocationIndex_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the fragment color index of a named variable within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml" /></remarks>
        public static int GetProgramResourceLocationIndex(ProgramHandle program, ProgramInterface programInterface, byte* name) => _GetProgramResourceLocationIndex_fnptr(program, programInterface, name);
        [UnmanagedCallersOnly]
        private static int GetProgramResourceLocationIndex_Lazy(ProgramHandle program, ProgramInterface programInterface, byte* name)
        {
            _GetProgramResourceLocationIndex_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceLocationIndex");
            return _GetProgramResourceLocationIndex_fnptr(program, programInterface, name);
        }
        
        private static delegate* unmanaged<ProgramHandle, uint, uint, void> _ShaderStorageBlockBinding_fnptr = &ShaderStorageBlockBinding_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object]</b> Change an active shader storage block binding. </summary>
        /// <param name="program"> The name of the program containing the block whose binding to change. </param>
        /// <param name="storageBlockIndex"> The index storage block within the program. </param>
        /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml" /></remarks>
        public static void ShaderStorageBlockBinding(ProgramHandle program, uint storageBlockIndex, uint storageBlockBinding) => _ShaderStorageBlockBinding_fnptr(program, storageBlockIndex, storageBlockBinding);
        [UnmanagedCallersOnly]
        private static void ShaderStorageBlockBinding_Lazy(ProgramHandle program, uint storageBlockIndex, uint storageBlockBinding)
        {
            _ShaderStorageBlockBinding_fnptr = (delegate* unmanaged<ProgramHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glShaderStorageBlockBinding");
            _ShaderStorageBlockBinding_fnptr(program, storageBlockIndex, storageBlockBinding);
        }
        
        private static delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, IntPtr, nint, void> _TexBufferRange_fnptr = &TexBufferRange_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range]</b> Attach a range of a buffer object's data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer's data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer's data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
        public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => _TexBufferRange_fnptr(target, internalformat, buffer, offset, size);
        [UnmanagedCallersOnly]
        private static void TexBufferRange_Lazy(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size)
        {
            _TexBufferRange_fnptr = (delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glTexBufferRange");
            _TexBufferRange_fnptr(target, internalformat, buffer, offset, size);
        }
        
        private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, byte, void> _TexStorage2DMultisample_fnptr = &TexStorage2DMultisample_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
        public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations) => _TexStorage2DMultisample_fnptr(target, samples, internalformat, width, height, fixedsamplelocations);
        [UnmanagedCallersOnly]
        private static void TexStorage2DMultisample_Lazy(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations)
        {
            _TexStorage2DMultisample_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage2DMultisample");
            _TexStorage2DMultisample_fnptr(target, samples, internalformat, width, height, fixedsamplelocations);
        }
        
        private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, byte, void> _TexStorage3DMultisample_fnptr = &TexStorage3DMultisample_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
        public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations) => _TexStorage3DMultisample_fnptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        [UnmanagedCallersOnly]
        private static void TexStorage3DMultisample_Lazy(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations)
        {
            _TexStorage3DMultisample_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage3DMultisample");
            _TexStorage3DMultisample_fnptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        
        private static delegate* unmanaged<TextureHandle, TextureTarget, TextureHandle, SizedInternalFormat, uint, uint, uint, uint, void> _TextureView_fnptr = &TextureView_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view]</b> Initialize a texture as a data alias of another texture's data store. </summary>
        /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
        /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
        /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
        /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
        /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
        /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
        /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
        /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml" /></remarks>
        public static void TextureView(TextureHandle texture, TextureTarget target, TextureHandle origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => _TextureView_fnptr(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
        [UnmanagedCallersOnly]
        private static void TextureView_Lazy(TextureHandle texture, TextureTarget target, TextureHandle origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers)
        {
            _TextureView_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, TextureHandle, SizedInternalFormat, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTextureView");
            _TextureView_fnptr(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
        }
        
        private static delegate* unmanaged<uint, BufferHandle, IntPtr, int, void> _BindVertexBuffer_fnptr = &BindVertexBuffer_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
        public static void BindVertexBuffer(uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => _BindVertexBuffer_fnptr(bindingindex, buffer, offset, stride);
        [UnmanagedCallersOnly]
        private static void BindVertexBuffer_Lazy(uint bindingindex, BufferHandle buffer, IntPtr offset, int stride)
        {
            _BindVertexBuffer_fnptr = (delegate* unmanaged<uint, BufferHandle, IntPtr, int, void>)GLLoader.BindingsContext.GetProcAddress("glBindVertexBuffer");
            _BindVertexBuffer_fnptr(bindingindex, buffer, offset, stride);
        }
        
        private static delegate* unmanaged<uint, int, VertexAttribType, byte, uint, void> _VertexAttribFormat_fnptr = &VertexAttribFormat_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset) => _VertexAttribFormat_fnptr(attribindex, size, type, normalized, relativeoffset);
        [UnmanagedCallersOnly]
        private static void VertexAttribFormat_Lazy(uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset)
        {
            _VertexAttribFormat_fnptr = (delegate* unmanaged<uint, int, VertexAttribType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribFormat");
            _VertexAttribFormat_fnptr(attribindex, size, type, normalized, relativeoffset);
        }
        
        private static delegate* unmanaged<uint, int, VertexAttribIType, uint, void> _VertexAttribIFormat_fnptr = &VertexAttribIFormat_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => _VertexAttribIFormat_fnptr(attribindex, size, type, relativeoffset);
        [UnmanagedCallersOnly]
        private static void VertexAttribIFormat_Lazy(uint attribindex, int size, VertexAttribIType type, uint relativeoffset)
        {
            _VertexAttribIFormat_fnptr = (delegate* unmanaged<uint, int, VertexAttribIType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribIFormat");
            _VertexAttribIFormat_fnptr(attribindex, size, type, relativeoffset);
        }
        
        private static delegate* unmanaged<uint, int, VertexAttribLType, uint, void> _VertexAttribLFormat_fnptr = &VertexAttribLFormat_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => _VertexAttribLFormat_fnptr(attribindex, size, type, relativeoffset);
        [UnmanagedCallersOnly]
        private static void VertexAttribLFormat_Lazy(uint attribindex, int size, VertexAttribLType type, uint relativeoffset)
        {
            _VertexAttribLFormat_fnptr = (delegate* unmanaged<uint, int, VertexAttribLType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribLFormat");
            _VertexAttribLFormat_fnptr(attribindex, size, type, relativeoffset);
        }
        
        private static delegate* unmanaged<uint, uint, void> _VertexAttribBinding_fnptr = &VertexAttribBinding_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
        public static void VertexAttribBinding(uint attribindex, uint bindingindex) => _VertexAttribBinding_fnptr(attribindex, bindingindex);
        [UnmanagedCallersOnly]
        private static void VertexAttribBinding_Lazy(uint attribindex, uint bindingindex)
        {
            _VertexAttribBinding_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribBinding");
            _VertexAttribBinding_fnptr(attribindex, bindingindex);
        }
        
        private static delegate* unmanaged<uint, uint, void> _VertexBindingDivisor_fnptr = &VertexBindingDivisor_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
        public static void VertexBindingDivisor(uint bindingindex, uint divisor) => _VertexBindingDivisor_fnptr(bindingindex, divisor);
        [UnmanagedCallersOnly]
        private static void VertexBindingDivisor_Lazy(uint bindingindex, uint divisor)
        {
            _VertexBindingDivisor_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexBindingDivisor");
            _VertexBindingDivisor_fnptr(bindingindex, divisor);
        }
        
        private static delegate* unmanaged<DebugSource, DebugType, DebugSeverity, int, uint*, byte, void> _DebugMessageControl_fnptr = &DebugMessageControl_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Control the reporting of debug messages in a debug context. </summary>
        /// <param name="source"> The source of debug messages to enable or disable. </param>
        /// <param name="type"> The type of debug messages to enable or disable. </param>
        /// <param name="severity"> The severity of debug messages to enable or disable. </param>
        /// <param name="count"> The length of the array ids. </param>
        /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
        /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml" /></remarks>
        public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, byte enabled) => _DebugMessageControl_fnptr(source, type, severity, count, ids, enabled);
        [UnmanagedCallersOnly]
        private static void DebugMessageControl_Lazy(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, byte enabled)
        {
            _DebugMessageControl_fnptr = (delegate* unmanaged<DebugSource, DebugType, DebugSeverity, int, uint*, byte, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageControl");
            _DebugMessageControl_fnptr(source, type, severity, count, ids, enabled);
        }
        
        private static delegate* unmanaged<DebugSource, DebugType, uint, DebugSeverity, int, byte*, void> _DebugMessageInsert_fnptr = &DebugMessageInsert_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Inject an application-supplied message into the debug message queue. </summary>
        /// <param name="source"> The source of the debug message to insert. </param>
        /// <param name="type"> The type of the debug message insert. </param>
        /// <param name="id"> The user-supplied identifier of the message to insert. </param>
        /// <param name="severity"> The severity of the debug messages to insert. </param>
        /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
        /// <param name="message"> The address of a character array containing the message to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml" /></remarks>
        public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => _DebugMessageInsert_fnptr(source, type, id, severity, length, buf);
        [UnmanagedCallersOnly]
        private static void DebugMessageInsert_Lazy(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf)
        {
            _DebugMessageInsert_fnptr = (delegate* unmanaged<DebugSource, DebugType, uint, DebugSeverity, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageInsert");
            _DebugMessageInsert_fnptr(source, type, id, severity, length, buf);
        }
        
        private static delegate* unmanaged<IntPtr, void*, void> _DebugMessageCallback_fnptr = &DebugMessageCallback_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Specify a callback to receive debugging messages from the GL. </summary>
        /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
        /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml" /></remarks>
        public static void DebugMessageCallback(IntPtr callback, void* userParam) => _DebugMessageCallback_fnptr(callback, userParam);
        [UnmanagedCallersOnly]
        private static void DebugMessageCallback_Lazy(IntPtr callback, void* userParam)
        {
            _DebugMessageCallback_fnptr = (delegate* unmanaged<IntPtr, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageCallback");
            _DebugMessageCallback_fnptr(callback, userParam);
        }
        
        private static delegate* unmanaged<uint, int, DebugSource*, DebugType*, uint*, DebugSeverity*, int*, byte*, uint> _GetDebugMessageLog_fnptr = &GetDebugMessageLog_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve messages from the debug message log. </summary>
        /// <param name="count"> The number of debug messages to retrieve from the log. </param>
        /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
        /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
        /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
        /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
        /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
        /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
        /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml" /></remarks>
        public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => _GetDebugMessageLog_fnptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
        [UnmanagedCallersOnly]
        private static uint GetDebugMessageLog_Lazy(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog)
        {
            _GetDebugMessageLog_fnptr = (delegate* unmanaged<uint, int, DebugSource*, DebugType*, uint*, DebugSeverity*, int*, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetDebugMessageLog");
            return _GetDebugMessageLog_fnptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
        }
        
        private static delegate* unmanaged<DebugSource, uint, int, byte*, void> _PushDebugGroup_fnptr = &PushDebugGroup_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Push a named debug group into the command stream. </summary>
        /// <param name="source"> The source of the debug message. </param>
        /// <param name="id"> The identifier of the message. </param>
        /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
        /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml" /></remarks>
        public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => _PushDebugGroup_fnptr(source, id, length, message);
        [UnmanagedCallersOnly]
        private static void PushDebugGroup_Lazy(DebugSource source, uint id, int length, byte* message)
        {
            _PushDebugGroup_fnptr = (delegate* unmanaged<DebugSource, uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glPushDebugGroup");
            _PushDebugGroup_fnptr(source, id, length, message);
        }
        
        private static delegate* unmanaged<void> _PopDebugGroup_fnptr = &PopDebugGroup_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Pop the active debug group. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml" /></remarks>
        public static void PopDebugGroup() => _PopDebugGroup_fnptr();
        [UnmanagedCallersOnly]
        private static void PopDebugGroup_Lazy()
        {
            _PopDebugGroup_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPopDebugGroup");
            _PopDebugGroup_fnptr();
        }
        
        private static delegate* unmanaged<ObjectIdentifier, uint, int, byte*, void> _ObjectLabel_fnptr = &ObjectLabel_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Label a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object to label. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml" /></remarks>
        public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => _ObjectLabel_fnptr(identifier, name, length, label);
        [UnmanagedCallersOnly]
        private static void ObjectLabel_Lazy(ObjectIdentifier identifier, uint name, int length, byte* label)
        {
            _ObjectLabel_fnptr = (delegate* unmanaged<ObjectIdentifier, uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glObjectLabel");
            _ObjectLabel_fnptr(identifier, name, length, label);
        }
        
        private static delegate* unmanaged<ObjectIdentifier, uint, int, int*, byte*, void> _GetObjectLabel_fnptr = &GetObjectLabel_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve the label of a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml" /></remarks>
        public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => _GetObjectLabel_fnptr(identifier, name, bufSize, length, label);
        [UnmanagedCallersOnly]
        private static void GetObjectLabel_Lazy(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label)
        {
            _GetObjectLabel_fnptr = (delegate* unmanaged<ObjectIdentifier, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectLabel");
            _GetObjectLabel_fnptr(identifier, name, bufSize, length, label);
        }
        
        private static delegate* unmanaged<void*, int, byte*, void> _ObjectPtrLabel_fnptr = &ObjectPtrLabel_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Label a sync object identified by a pointer. </summary>
        /// <param name="ptr"> A pointer identifying a sync object. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml" /></remarks>
        public static void ObjectPtrLabel(void* ptr, int length, byte* label) => _ObjectPtrLabel_fnptr(ptr, length, label);
        [UnmanagedCallersOnly]
        private static void ObjectPtrLabel_Lazy(void* ptr, int length, byte* label)
        {
            _ObjectPtrLabel_fnptr = (delegate* unmanaged<void*, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glObjectPtrLabel");
            _ObjectPtrLabel_fnptr(ptr, length, label);
        }
        
        private static delegate* unmanaged<void*, int, int*, byte*, void> _GetObjectPtrLabel_fnptr = &GetObjectPtrLabel_Lazy;
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve the label of a sync object identified by a pointer. </summary>
        /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml" /></remarks>
        public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => _GetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
        [UnmanagedCallersOnly]
        private static void GetObjectPtrLabel_Lazy(void* ptr, int bufSize, int* length, byte* label)
        {
            _GetObjectPtrLabel_fnptr = (delegate* unmanaged<void*, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectPtrLabel");
            _GetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
        }
        
        private static delegate* unmanaged<BufferStorageTarget, nint, void*, BufferStorageMask, void> _BufferStorage_fnptr = &BufferStorage_Lazy;
        /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage]</b> Creates and initializes a buffer object's immutable data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
        public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => _BufferStorage_fnptr(target, size, data, flags);
        [UnmanagedCallersOnly]
        private static void BufferStorage_Lazy(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags)
        {
            _BufferStorage_fnptr = (delegate* unmanaged<BufferStorageTarget, nint, void*, BufferStorageMask, void>)GLLoader.BindingsContext.GetProcAddress("glBufferStorage");
            _BufferStorage_fnptr(target, size, data, flags);
        }
        
        private static delegate* unmanaged<TextureHandle, int, PixelFormat, PixelType, void*, void> _ClearTexImage_fnptr = &ClearTexImage_Lazy;
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> Fills all a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml" /></remarks>
        public static void ClearTexImage(TextureHandle texture, int level, PixelFormat format, PixelType type, void* data) => _ClearTexImage_fnptr(texture, level, format, type, data);
        [UnmanagedCallersOnly]
        private static void ClearTexImage_Lazy(TextureHandle texture, int level, PixelFormat format, PixelType type, void* data)
        {
            _ClearTexImage_fnptr = (delegate* unmanaged<TextureHandle, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearTexImage");
            _ClearTexImage_fnptr(texture, level, format, type, data);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _ClearTexSubImage_fnptr = &ClearTexSubImage_Lazy;
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> Fills all or part of a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
        /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
        /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
        /// <param name="width"> The width of the region to be cleared. </param>
        /// <param name="height"> The height of the region to be cleared. </param>
        /// <param name="depth"> The depth of the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml" /></remarks>
        public static void ClearTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => _ClearTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
        [UnmanagedCallersOnly]
        private static void ClearTexSubImage_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data)
        {
            _ClearTexSubImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearTexSubImage");
            _ClearTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
        }
        
        private static delegate* unmanaged<BufferTargetARB, uint, int, BufferHandle*, void> _BindBuffersBase_fnptr = &BindBuffersBase_Lazy;
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml" /></remarks>
        public static void BindBuffersBase(BufferTargetARB target, uint first, int count, BufferHandle* buffers) => _BindBuffersBase_fnptr(target, first, count, buffers);
        [UnmanagedCallersOnly]
        private static void BindBuffersBase_Lazy(BufferTargetARB target, uint first, int count, BufferHandle* buffers)
        {
            _BindBuffersBase_fnptr = (delegate* unmanaged<BufferTargetARB, uint, int, BufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glBindBuffersBase");
            _BindBuffersBase_fnptr(target, first, count, buffers);
        }
        
        private static delegate* unmanaged<BufferTargetARB, uint, int, BufferHandle*, IntPtr*, nint*, void> _BindBuffersRange_fnptr = &BindBuffersRange_Lazy;
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml" /></remarks>
        public static void BindBuffersRange(BufferTargetARB target, uint first, int count, BufferHandle* buffers, IntPtr* offsets, nint* sizes) => _BindBuffersRange_fnptr(target, first, count, buffers, offsets, sizes);
        [UnmanagedCallersOnly]
        private static void BindBuffersRange_Lazy(BufferTargetARB target, uint first, int count, BufferHandle* buffers, IntPtr* offsets, nint* sizes)
        {
            _BindBuffersRange_fnptr = (delegate* unmanaged<BufferTargetARB, uint, int, BufferHandle*, IntPtr*, nint*, void>)GLLoader.BindingsContext.GetProcAddress("glBindBuffersRange");
            _BindBuffersRange_fnptr(target, first, count, buffers, offsets, sizes);
        }
        
        private static delegate* unmanaged<uint, int, TextureHandle*, void> _BindTextures_fnptr = &BindTextures_Lazy;
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named textures to a sequence of consecutive texture units. </summary>
        /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml" /></remarks>
        public static void BindTextures(uint first, int count, TextureHandle* textures) => _BindTextures_fnptr(first, count, textures);
        [UnmanagedCallersOnly]
        private static void BindTextures_Lazy(uint first, int count, TextureHandle* textures)
        {
            _BindTextures_fnptr = (delegate* unmanaged<uint, int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glBindTextures");
            _BindTextures_fnptr(first, count, textures);
        }
        
        private static delegate* unmanaged<uint, int, SamplerHandle*, void> _BindSamplers_fnptr = &BindSamplers_Lazy;
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
        /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
        /// <param name="count"> Specifies the number of samplers to bind. </param>
        /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml" /></remarks>
        public static void BindSamplers(uint first, int count, SamplerHandle* samplers) => _BindSamplers_fnptr(first, count, samplers);
        [UnmanagedCallersOnly]
        private static void BindSamplers_Lazy(uint first, int count, SamplerHandle* samplers)
        {
            _BindSamplers_fnptr = (delegate* unmanaged<uint, int, SamplerHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glBindSamplers");
            _BindSamplers_fnptr(first, count, samplers);
        }
        
        private static delegate* unmanaged<uint, int, TextureHandle*, void> _BindImageTextures_fnptr = &BindImageTextures_Lazy;
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named texture images to a sequence of consecutive image units. </summary>
        /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml" /></remarks>
        public static void BindImageTextures(uint first, int count, TextureHandle* textures) => _BindImageTextures_fnptr(first, count, textures);
        [UnmanagedCallersOnly]
        private static void BindImageTextures_Lazy(uint first, int count, TextureHandle* textures)
        {
            _BindImageTextures_fnptr = (delegate* unmanaged<uint, int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glBindImageTextures");
            _BindImageTextures_fnptr(first, count, textures);
        }
        
        private static delegate* unmanaged<uint, int, BufferHandle*, IntPtr*, int*, void> _BindVertexBuffers_fnptr = &BindVertexBuffers_Lazy;
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
        public static void BindVertexBuffers(uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides) => _BindVertexBuffers_fnptr(first, count, buffers, offsets, strides);
        [UnmanagedCallersOnly]
        private static void BindVertexBuffers_Lazy(uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides)
        {
            _BindVertexBuffers_fnptr = (delegate* unmanaged<uint, int, BufferHandle*, IntPtr*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glBindVertexBuffers");
            _BindVertexBuffers_fnptr(first, count, buffers, offsets, strides);
        }
        
        private static delegate* unmanaged<ClipControlOrigin, ClipControlDepth, void> _ClipControl_fnptr = &ClipControl_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control]</b> Control clip coordinate to window coordinate behavior. </summary>
        /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
        /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml" /></remarks>
        public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => _ClipControl_fnptr(origin, depth);
        [UnmanagedCallersOnly]
        private static void ClipControl_Lazy(ClipControlOrigin origin, ClipControlDepth depth)
        {
            _ClipControl_fnptr = (delegate* unmanaged<ClipControlOrigin, ClipControlDepth, void>)GLLoader.BindingsContext.GetProcAddress("glClipControl");
            _ClipControl_fnptr(origin, depth);
        }
        
        private static delegate* unmanaged<int, TransformFeedbackHandle*, void> _CreateTransformFeedbacks_fnptr = &CreateTransformFeedbacks_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create transform feedback objects. </summary>
        /// <param name="n"> Number of transform feedback objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml" /></remarks>
        public static void CreateTransformFeedbacks(int n, TransformFeedbackHandle* ids) => _CreateTransformFeedbacks_fnptr(n, ids);
        [UnmanagedCallersOnly]
        private static void CreateTransformFeedbacks_Lazy(int n, TransformFeedbackHandle* ids)
        {
            _CreateTransformFeedbacks_fnptr = (delegate* unmanaged<int, TransformFeedbackHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateTransformFeedbacks");
            _CreateTransformFeedbacks_fnptr(n, ids);
        }
        
        private static delegate* unmanaged<TransformFeedbackHandle, uint, BufferHandle, void> _TransformFeedbackBufferBase_fnptr = &TransformFeedbackBufferBase_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml" /></remarks>
        public static void TransformFeedbackBufferBase(TransformFeedbackHandle xfb, uint index, BufferHandle buffer) => _TransformFeedbackBufferBase_fnptr(xfb, index, buffer);
        [UnmanagedCallersOnly]
        private static void TransformFeedbackBufferBase_Lazy(TransformFeedbackHandle xfb, uint index, BufferHandle buffer)
        {
            _TransformFeedbackBufferBase_fnptr = (delegate* unmanaged<TransformFeedbackHandle, uint, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTransformFeedbackBufferBase");
            _TransformFeedbackBufferBase_fnptr(xfb, index, buffer);
        }
        
        private static delegate* unmanaged<TransformFeedbackHandle, uint, BufferHandle, IntPtr, nint, void> _TransformFeedbackBufferRange_fnptr = &TransformFeedbackBufferRange_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a range within a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
        /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml" /></remarks>
        public static void TransformFeedbackBufferRange(TransformFeedbackHandle xfb, uint index, BufferHandle buffer, IntPtr offset, nint size) => _TransformFeedbackBufferRange_fnptr(xfb, index, buffer, offset, size);
        [UnmanagedCallersOnly]
        private static void TransformFeedbackBufferRange_Lazy(TransformFeedbackHandle xfb, uint index, BufferHandle buffer, IntPtr offset, nint size)
        {
            _TransformFeedbackBufferRange_fnptr = (delegate* unmanaged<TransformFeedbackHandle, uint, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glTransformFeedbackBufferRange");
            _TransformFeedbackBufferRange_fnptr(xfb, index, buffer, offset, size);
        }
        
        private static delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, int*, void> _GetTransformFeedbackiv_fnptr = &GetTransformFeedbackiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbackiv(TransformFeedbackHandle xfb, TransformFeedbackPName pname, int* param) => _GetTransformFeedbackiv_fnptr(xfb, pname, param);
        [UnmanagedCallersOnly]
        private static void GetTransformFeedbackiv_Lazy(TransformFeedbackHandle xfb, TransformFeedbackPName pname, int* param)
        {
            _GetTransformFeedbackiv_fnptr = (delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTransformFeedbackiv");
            _GetTransformFeedbackiv_fnptr(xfb, pname, param);
        }
        
        private static delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, uint, int*, void> _GetTransformFeedbacki_v_fnptr = &GetTransformFeedbacki_v_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbacki_v(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, int* param) => _GetTransformFeedbacki_v_fnptr(xfb, pname, index, param);
        [UnmanagedCallersOnly]
        private static void GetTransformFeedbacki_v_Lazy(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, int* param)
        {
            _GetTransformFeedbacki_v_fnptr = (delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTransformFeedbacki_v");
            _GetTransformFeedbacki_v_fnptr(xfb, pname, index, param);
        }
        
        private static delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, uint, long*, void> _GetTransformFeedbacki64_v_fnptr = &GetTransformFeedbacki64_v_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbacki64_v(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, long* param) => _GetTransformFeedbacki64_v_fnptr(xfb, pname, index, param);
        [UnmanagedCallersOnly]
        private static void GetTransformFeedbacki64_v_Lazy(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, long* param)
        {
            _GetTransformFeedbacki64_v_fnptr = (delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, uint, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTransformFeedbacki64_v");
            _GetTransformFeedbacki64_v_fnptr(xfb, pname, index, param);
        }
        
        private static delegate* unmanaged<int, BufferHandle*, void> _CreateBuffers_fnptr = &CreateBuffers_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to create. </param>
        /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml" /></remarks>
        public static void CreateBuffers(int n, BufferHandle* buffers) => _CreateBuffers_fnptr(n, buffers);
        [UnmanagedCallersOnly]
        private static void CreateBuffers_Lazy(int n, BufferHandle* buffers)
        {
            _CreateBuffers_fnptr = (delegate* unmanaged<int, BufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateBuffers");
            _CreateBuffers_fnptr(n, buffers);
        }
        
        private static delegate* unmanaged<BufferHandle, nint, void*, BufferStorageMask, void> _NamedBufferStorage_fnptr = &NamedBufferStorage_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Creates and initializes a buffer object's immutable data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
        public static void NamedBufferStorage(BufferHandle buffer, nint size, void* data, BufferStorageMask flags) => _NamedBufferStorage_fnptr(buffer, size, data, flags);
        [UnmanagedCallersOnly]
        private static void NamedBufferStorage_Lazy(BufferHandle buffer, nint size, void* data, BufferStorageMask flags)
        {
            _NamedBufferStorage_fnptr = (delegate* unmanaged<BufferHandle, nint, void*, BufferStorageMask, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferStorage");
            _NamedBufferStorage_fnptr(buffer, size, data, flags);
        }
        
        private static delegate* unmanaged<BufferHandle, nint, void*, VertexBufferObjectUsage, void> _NamedBufferData_fnptr = &NamedBufferData_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Creates and initializes a buffer object's data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
        public static void NamedBufferData(BufferHandle buffer, nint size, void* data, VertexBufferObjectUsage usage) => _NamedBufferData_fnptr(buffer, size, data, usage);
        [UnmanagedCallersOnly]
        private static void NamedBufferData_Lazy(BufferHandle buffer, nint size, void* data, VertexBufferObjectUsage usage)
        {
            _NamedBufferData_fnptr = (delegate* unmanaged<BufferHandle, nint, void*, VertexBufferObjectUsage, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferData");
            _NamedBufferData_fnptr(buffer, size, data, usage);
        }
        
        private static delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void> _NamedBufferSubData_fnptr = &NamedBufferSubData_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Updates a subset of a buffer object's data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
        public static void NamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, void* data) => _NamedBufferSubData_fnptr(buffer, offset, size, data);
        [UnmanagedCallersOnly]
        private static void NamedBufferSubData_Lazy(BufferHandle buffer, IntPtr offset, nint size, void* data)
        {
            _NamedBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferSubData");
            _NamedBufferSubData_fnptr(buffer, offset, size, data);
        }
        
        private static delegate* unmanaged<BufferHandle, BufferHandle, IntPtr, IntPtr, nint, void> _CopyNamedBufferSubData_fnptr = &CopyNamedBufferSubData_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
        public static void CopyNamedBufferSubData(BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => _CopyNamedBufferSubData_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
        [UnmanagedCallersOnly]
        private static void CopyNamedBufferSubData_Lazy(BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size)
        {
            _CopyNamedBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, BufferHandle, IntPtr, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glCopyNamedBufferSubData");
            _CopyNamedBufferSubData_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
        }
        
        private static delegate* unmanaged<BufferHandle, SizedInternalFormat, PixelFormat, PixelType, void*, void> _ClearNamedBufferData_fnptr = &ClearNamedBufferData_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Fill a buffer object's data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
        public static void ClearNamedBufferData(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => _ClearNamedBufferData_fnptr(buffer, internalformat, format, type, data);
        [UnmanagedCallersOnly]
        private static void ClearNamedBufferData_Lazy(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data)
        {
            _ClearNamedBufferData_fnptr = (delegate* unmanaged<BufferHandle, SizedInternalFormat, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedBufferData");
            _ClearNamedBufferData_fnptr(buffer, internalformat, format, type, data);
        }
        
        private static delegate* unmanaged<BufferHandle, SizedInternalFormat, IntPtr, nint, PixelFormat, PixelType, void*, void> _ClearNamedBufferSubData_fnptr = &ClearNamedBufferSubData_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Fill all or part of buffer object's data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object's data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
        public static void ClearNamedBufferSubData(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => _ClearNamedBufferSubData_fnptr(buffer, internalformat, offset, size, format, type, data);
        [UnmanagedCallersOnly]
        private static void ClearNamedBufferSubData_Lazy(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data)
        {
            _ClearNamedBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, SizedInternalFormat, IntPtr, nint, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedBufferSubData");
            _ClearNamedBufferSubData_fnptr(buffer, internalformat, offset, size, format, type, data);
        }
        
        private static delegate* unmanaged<BufferHandle, BufferAccessARB, void*> _MapNamedBuffer_fnptr = &MapNamedBuffer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Map all of a buffer object's data store into the client's address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
        public static void* MapNamedBuffer(BufferHandle buffer, BufferAccessARB access) => _MapNamedBuffer_fnptr(buffer, access);
        [UnmanagedCallersOnly]
        private static void* MapNamedBuffer_Lazy(BufferHandle buffer, BufferAccessARB access)
        {
            _MapNamedBuffer_fnptr = (delegate* unmanaged<BufferHandle, BufferAccessARB, void*>)GLLoader.BindingsContext.GetProcAddress("glMapNamedBuffer");
            return _MapNamedBuffer_fnptr(buffer, access);
        }
        
        private static delegate* unmanaged<BufferHandle, IntPtr, nint, MapBufferAccessMask, void*> _MapNamedBufferRange_fnptr = &MapNamedBufferRange_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Map all or part of a buffer object's data store into the client's address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
        public static void* MapNamedBufferRange(BufferHandle buffer, IntPtr offset, nint length, MapBufferAccessMask access) => _MapNamedBufferRange_fnptr(buffer, offset, length, access);
        [UnmanagedCallersOnly]
        private static void* MapNamedBufferRange_Lazy(BufferHandle buffer, IntPtr offset, nint length, MapBufferAccessMask access)
        {
            _MapNamedBufferRange_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, MapBufferAccessMask, void*>)GLLoader.BindingsContext.GetProcAddress("glMapNamedBufferRange");
            return _MapNamedBufferRange_fnptr(buffer, offset, length, access);
        }
        
        private static delegate* unmanaged<BufferHandle, byte> _UnmapNamedBuffer_fnptr = &UnmapNamedBuffer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Release the mapping of a buffer object's data store into the client's address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
        public static byte UnmapNamedBuffer(BufferHandle buffer) => _UnmapNamedBuffer_fnptr(buffer);
        [UnmanagedCallersOnly]
        private static byte UnmapNamedBuffer_Lazy(BufferHandle buffer)
        {
            _UnmapNamedBuffer_fnptr = (delegate* unmanaged<BufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glUnmapNamedBuffer");
            return _UnmapNamedBuffer_fnptr(buffer);
        }
        
        private static delegate* unmanaged<BufferHandle, IntPtr, nint, void> _FlushMappedNamedBufferRange_fnptr = &FlushMappedNamedBufferRange_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
        public static void FlushMappedNamedBufferRange(BufferHandle buffer, IntPtr offset, nint length) => _FlushMappedNamedBufferRange_fnptr(buffer, offset, length);
        [UnmanagedCallersOnly]
        private static void FlushMappedNamedBufferRange_Lazy(BufferHandle buffer, IntPtr offset, nint length)
        {
            _FlushMappedNamedBufferRange_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glFlushMappedNamedBufferRange");
            _FlushMappedNamedBufferRange_fnptr(buffer, offset, length);
        }
        
        private static delegate* unmanaged<BufferHandle, BufferPNameARB, int*, void> _GetNamedBufferParameteriv_fnptr = &GetNamedBufferParameteriv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetNamedBufferParameteriv(BufferHandle buffer, BufferPNameARB pname, int* parameters) => _GetNamedBufferParameteriv_fnptr(buffer, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetNamedBufferParameteriv_Lazy(BufferHandle buffer, BufferPNameARB pname, int* parameters)
        {
            _GetNamedBufferParameteriv_fnptr = (delegate* unmanaged<BufferHandle, BufferPNameARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferParameteriv");
            _GetNamedBufferParameteriv_fnptr(buffer, pname, parameters);
        }
        
        private static delegate* unmanaged<BufferHandle, BufferPNameARB, long*, void> _GetNamedBufferParameteri64v_fnptr = &GetNamedBufferParameteri64v_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetNamedBufferParameteri64v(BufferHandle buffer, BufferPNameARB pname, long* parameters) => _GetNamedBufferParameteri64v_fnptr(buffer, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetNamedBufferParameteri64v_Lazy(BufferHandle buffer, BufferPNameARB pname, long* parameters)
        {
            _GetNamedBufferParameteri64v_fnptr = (delegate* unmanaged<BufferHandle, BufferPNameARB, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferParameteri64v");
            _GetNamedBufferParameteri64v_fnptr(buffer, pname, parameters);
        }
        
        private static delegate* unmanaged<BufferHandle, BufferPointerNameARB, void**, void> _GetNamedBufferPointerv_fnptr = &GetNamedBufferPointerv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return the pointer to a mapped buffer object's data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
        public static void GetNamedBufferPointerv(BufferHandle buffer, BufferPointerNameARB pname, void** parameters) => _GetNamedBufferPointerv_fnptr(buffer, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetNamedBufferPointerv_Lazy(BufferHandle buffer, BufferPointerNameARB pname, void** parameters)
        {
            _GetNamedBufferPointerv_fnptr = (delegate* unmanaged<BufferHandle, BufferPointerNameARB, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferPointerv");
            _GetNamedBufferPointerv_fnptr(buffer, pname, parameters);
        }
        
        private static delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void> _GetNamedBufferSubData_fnptr = &GetNamedBufferSubData_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Returns a subset of a buffer object's data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
        public static void GetNamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, void* data) => _GetNamedBufferSubData_fnptr(buffer, offset, size, data);
        [UnmanagedCallersOnly]
        private static void GetNamedBufferSubData_Lazy(BufferHandle buffer, IntPtr offset, nint size, void* data)
        {
            _GetNamedBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferSubData");
            _GetNamedBufferSubData_fnptr(buffer, offset, size, data);
        }
        
        private static delegate* unmanaged<int, FramebufferHandle*, void> _CreateFramebuffers_fnptr = &CreateFramebuffers_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create framebuffer objects. </summary>
        /// <param name="n"> Number of framebuffer objects to create. </param>
        /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml" /></remarks>
        public static void CreateFramebuffers(int n, FramebufferHandle* framebuffers) => _CreateFramebuffers_fnptr(n, framebuffers);
        [UnmanagedCallersOnly]
        private static void CreateFramebuffers_Lazy(int n, FramebufferHandle* framebuffers)
        {
            _CreateFramebuffers_fnptr = (delegate* unmanaged<int, FramebufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateFramebuffers");
            _CreateFramebuffers_fnptr(n, framebuffers);
        }
        
        private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void> _NamedFramebufferRenderbuffer_fnptr = &NamedFramebufferRenderbuffer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
        public static void NamedFramebufferRenderbuffer(FramebufferHandle framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => _NamedFramebufferRenderbuffer_fnptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
        [UnmanagedCallersOnly]
        private static void NamedFramebufferRenderbuffer_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer)
        {
            _NamedFramebufferRenderbuffer_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferRenderbuffer");
            _NamedFramebufferRenderbuffer_fnptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
        }
        
        private static delegate* unmanaged<FramebufferHandle, FramebufferParameterName, int, void> _NamedFramebufferParameteri_fnptr = &NamedFramebufferParameteri_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
        public static void NamedFramebufferParameteri(FramebufferHandle framebuffer, FramebufferParameterName pname, int param) => _NamedFramebufferParameteri_fnptr(framebuffer, pname, param);
        [UnmanagedCallersOnly]
        private static void NamedFramebufferParameteri_Lazy(FramebufferHandle framebuffer, FramebufferParameterName pname, int param)
        {
            _NamedFramebufferParameteri_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferParameteri");
            _NamedFramebufferParameteri_fnptr(framebuffer, pname, param);
        }
        
        private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, void> _NamedFramebufferTexture_fnptr = &NamedFramebufferTexture_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void NamedFramebufferTexture(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level) => _NamedFramebufferTexture_fnptr(framebuffer, attachment, texture, level);
        [UnmanagedCallersOnly]
        private static void NamedFramebufferTexture_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level)
        {
            _NamedFramebufferTexture_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTexture");
            _NamedFramebufferTexture_fnptr(framebuffer, attachment, texture, level);
        }
        
        private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, int, void> _NamedFramebufferTextureLayer_fnptr = &NamedFramebufferTextureLayer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
        public static void NamedFramebufferTextureLayer(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => _NamedFramebufferTextureLayer_fnptr(framebuffer, attachment, texture, level, layer);
        [UnmanagedCallersOnly]
        private static void NamedFramebufferTextureLayer_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, int layer)
        {
            _NamedFramebufferTextureLayer_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTextureLayer");
            _NamedFramebufferTextureLayer_fnptr(framebuffer, attachment, texture, level, layer);
        }
        
        private static delegate* unmanaged<FramebufferHandle, ColorBuffer, void> _NamedFramebufferDrawBuffer_fnptr = &NamedFramebufferDrawBuffer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify which color buffers are to be drawn into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
        public static void NamedFramebufferDrawBuffer(FramebufferHandle framebuffer, ColorBuffer buf) => _NamedFramebufferDrawBuffer_fnptr(framebuffer, buf);
        [UnmanagedCallersOnly]
        private static void NamedFramebufferDrawBuffer_Lazy(FramebufferHandle framebuffer, ColorBuffer buf)
        {
            _NamedFramebufferDrawBuffer_fnptr = (delegate* unmanaged<FramebufferHandle, ColorBuffer, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferDrawBuffer");
            _NamedFramebufferDrawBuffer_fnptr(framebuffer, buf);
        }
        
        private static delegate* unmanaged<FramebufferHandle, int, ColorBuffer*, void> _NamedFramebufferDrawBuffers_fnptr = &NamedFramebufferDrawBuffers_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
        public static void NamedFramebufferDrawBuffers(FramebufferHandle framebuffer, int n, ColorBuffer* bufs) => _NamedFramebufferDrawBuffers_fnptr(framebuffer, n, bufs);
        [UnmanagedCallersOnly]
        private static void NamedFramebufferDrawBuffers_Lazy(FramebufferHandle framebuffer, int n, ColorBuffer* bufs)
        {
            _NamedFramebufferDrawBuffers_fnptr = (delegate* unmanaged<FramebufferHandle, int, ColorBuffer*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferDrawBuffers");
            _NamedFramebufferDrawBuffers_fnptr(framebuffer, n, bufs);
        }
        
        private static delegate* unmanaged<FramebufferHandle, ColorBuffer, void> _NamedFramebufferReadBuffer_fnptr = &NamedFramebufferReadBuffer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Select a color buffer source for pixels. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
        /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
        public static void NamedFramebufferReadBuffer(FramebufferHandle framebuffer, ColorBuffer src) => _NamedFramebufferReadBuffer_fnptr(framebuffer, src);
        [UnmanagedCallersOnly]
        private static void NamedFramebufferReadBuffer_Lazy(FramebufferHandle framebuffer, ColorBuffer src)
        {
            _NamedFramebufferReadBuffer_fnptr = (delegate* unmanaged<FramebufferHandle, ColorBuffer, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferReadBuffer");
            _NamedFramebufferReadBuffer_fnptr(framebuffer, src);
        }
        
        private static delegate* unmanaged<FramebufferHandle, int, FramebufferAttachment*, void> _InvalidateNamedFramebufferData_fnptr = &InvalidateNamedFramebufferData_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Invalidate the content of some or all of a framebuffer's attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
        public static void InvalidateNamedFramebufferData(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments) => _InvalidateNamedFramebufferData_fnptr(framebuffer, numAttachments, attachments);
        [UnmanagedCallersOnly]
        private static void InvalidateNamedFramebufferData_Lazy(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments)
        {
            _InvalidateNamedFramebufferData_fnptr = (delegate* unmanaged<FramebufferHandle, int, FramebufferAttachment*, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateNamedFramebufferData");
            _InvalidateNamedFramebufferData_fnptr(framebuffer, numAttachments, attachments);
        }
        
        private static delegate* unmanaged<FramebufferHandle, int, FramebufferAttachment*, int, int, int, int, void> _InvalidateNamedFramebufferSubData_fnptr = &InvalidateNamedFramebufferSubData_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Invalidate the content of a region of some or all of a framebuffer's attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
        public static void InvalidateNamedFramebufferSubData(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => _InvalidateNamedFramebufferSubData_fnptr(framebuffer, numAttachments, attachments, x, y, width, height);
        [UnmanagedCallersOnly]
        private static void InvalidateNamedFramebufferSubData_Lazy(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height)
        {
            _InvalidateNamedFramebufferSubData_fnptr = (delegate* unmanaged<FramebufferHandle, int, FramebufferAttachment*, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateNamedFramebufferSubData");
            _InvalidateNamedFramebufferSubData_fnptr(framebuffer, numAttachments, attachments, x, y, width, height);
        }
        
        private static delegate* unmanaged<FramebufferHandle, Buffer, int, int*, void> _ClearNamedFramebufferiv_fnptr = &ClearNamedFramebufferiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferiv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, int* value) => _ClearNamedFramebufferiv_fnptr(framebuffer, buffer, drawbuffer, value);
        [UnmanagedCallersOnly]
        private static void ClearNamedFramebufferiv_Lazy(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, int* value)
        {
            _ClearNamedFramebufferiv_fnptr = (delegate* unmanaged<FramebufferHandle, Buffer, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedFramebufferiv");
            _ClearNamedFramebufferiv_fnptr(framebuffer, buffer, drawbuffer, value);
        }
        
        private static delegate* unmanaged<FramebufferHandle, Buffer, int, uint*, void> _ClearNamedFramebufferuiv_fnptr = &ClearNamedFramebufferuiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferuiv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, uint* value) => _ClearNamedFramebufferuiv_fnptr(framebuffer, buffer, drawbuffer, value);
        [UnmanagedCallersOnly]
        private static void ClearNamedFramebufferuiv_Lazy(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, uint* value)
        {
            _ClearNamedFramebufferuiv_fnptr = (delegate* unmanaged<FramebufferHandle, Buffer, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedFramebufferuiv");
            _ClearNamedFramebufferuiv_fnptr(framebuffer, buffer, drawbuffer, value);
        }
        
        private static delegate* unmanaged<FramebufferHandle, Buffer, int, float*, void> _ClearNamedFramebufferfv_fnptr = &ClearNamedFramebufferfv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferfv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float* value) => _ClearNamedFramebufferfv_fnptr(framebuffer, buffer, drawbuffer, value);
        [UnmanagedCallersOnly]
        private static void ClearNamedFramebufferfv_Lazy(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float* value)
        {
            _ClearNamedFramebufferfv_fnptr = (delegate* unmanaged<FramebufferHandle, Buffer, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedFramebufferfv");
            _ClearNamedFramebufferfv_fnptr(framebuffer, buffer, drawbuffer, value);
        }
        
        private static delegate* unmanaged<FramebufferHandle, Buffer, int, float, int, void> _ClearNamedFramebufferfi_fnptr = &ClearNamedFramebufferfi_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferfi(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => _ClearNamedFramebufferfi_fnptr(framebuffer, buffer, drawbuffer, depth, stencil);
        [UnmanagedCallersOnly]
        private static void ClearNamedFramebufferfi_Lazy(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil)
        {
            _ClearNamedFramebufferfi_fnptr = (delegate* unmanaged<FramebufferHandle, Buffer, int, float, int, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedFramebufferfi");
            _ClearNamedFramebufferfi_fnptr(framebuffer, buffer, drawbuffer, depth, stencil);
        }
        
        private static delegate* unmanaged<FramebufferHandle, FramebufferHandle, int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void> _BlitNamedFramebuffer_fnptr = &BlitNamedFramebuffer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
        public static void BlitNamedFramebuffer(FramebufferHandle readFramebuffer, FramebufferHandle drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => _BlitNamedFramebuffer_fnptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        [UnmanagedCallersOnly]
        private static void BlitNamedFramebuffer_Lazy(FramebufferHandle readFramebuffer, FramebufferHandle drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter)
        {
            _BlitNamedFramebuffer_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferHandle, int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void>)GLLoader.BindingsContext.GetProcAddress("glBlitNamedFramebuffer");
            _BlitNamedFramebuffer_fnptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        
        private static delegate* unmanaged<FramebufferHandle, FramebufferTarget, FramebufferStatus> _CheckNamedFramebufferStatus_fnptr = &CheckNamedFramebufferStatus_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Check the completeness status of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
        public static FramebufferStatus CheckNamedFramebufferStatus(FramebufferHandle framebuffer, FramebufferTarget target) => _CheckNamedFramebufferStatus_fnptr(framebuffer, target);
        [UnmanagedCallersOnly]
        private static FramebufferStatus CheckNamedFramebufferStatus_Lazy(FramebufferHandle framebuffer, FramebufferTarget target)
        {
            _CheckNamedFramebufferStatus_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferTarget, FramebufferStatus>)GLLoader.BindingsContext.GetProcAddress("glCheckNamedFramebufferStatus");
            return _CheckNamedFramebufferStatus_fnptr(framebuffer, target);
        }
        
        private static delegate* unmanaged<FramebufferHandle, GetFramebufferParameter, int*, void> _GetNamedFramebufferParameteriv_fnptr = &GetNamedFramebufferParameteriv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="param">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
        public static void GetNamedFramebufferParameteriv(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* param) => _GetNamedFramebufferParameteriv_fnptr(framebuffer, pname, param);
        [UnmanagedCallersOnly]
        private static void GetNamedFramebufferParameteriv_Lazy(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* param)
        {
            _GetNamedFramebufferParameteriv_fnptr = (delegate* unmanaged<FramebufferHandle, GetFramebufferParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedFramebufferParameteriv");
            _GetNamedFramebufferParameteriv_fnptr(framebuffer, pname, param);
        }
        
        private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void> _GetNamedFramebufferAttachmentParameteriv_fnptr = &GetNamedFramebufferAttachmentParameteriv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
        public static void GetNamedFramebufferAttachmentParameteriv(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => _GetNamedFramebufferAttachmentParameteriv_fnptr(framebuffer, attachment, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetNamedFramebufferAttachmentParameteriv_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters)
        {
            _GetNamedFramebufferAttachmentParameteriv_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedFramebufferAttachmentParameteriv");
            _GetNamedFramebufferAttachmentParameteriv_fnptr(framebuffer, attachment, pname, parameters);
        }
        
        private static delegate* unmanaged<int, RenderbufferHandle*, void> _CreateRenderbuffers_fnptr = &CreateRenderbuffers_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create renderbuffer objects. </summary>
        /// <param name="n"> Number of renderbuffer objects to create. </param>
        /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml" /></remarks>
        public static void CreateRenderbuffers(int n, RenderbufferHandle* renderbuffers) => _CreateRenderbuffers_fnptr(n, renderbuffers);
        [UnmanagedCallersOnly]
        private static void CreateRenderbuffers_Lazy(int n, RenderbufferHandle* renderbuffers)
        {
            _CreateRenderbuffers_fnptr = (delegate* unmanaged<int, RenderbufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateRenderbuffers");
            _CreateRenderbuffers_fnptr(n, renderbuffers);
        }
        
        private static delegate* unmanaged<RenderbufferHandle, InternalFormat, int, int, void> _NamedRenderbufferStorage_fnptr = &NamedRenderbufferStorage_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Establish data storage, format and dimensions of a    renderbuffer object's image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
        public static void NamedRenderbufferStorage(RenderbufferHandle renderbuffer, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorage_fnptr(renderbuffer, internalformat, width, height);
        [UnmanagedCallersOnly]
        private static void NamedRenderbufferStorage_Lazy(RenderbufferHandle renderbuffer, InternalFormat internalformat, int width, int height)
        {
            _NamedRenderbufferStorage_fnptr = (delegate* unmanaged<RenderbufferHandle, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedRenderbufferStorage");
            _NamedRenderbufferStorage_fnptr(renderbuffer, internalformat, width, height);
        }
        
        private static delegate* unmanaged<RenderbufferHandle, int, InternalFormat, int, int, void> _NamedRenderbufferStorageMultisample_fnptr = &NamedRenderbufferStorageMultisample_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object's image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
        public static void NamedRenderbufferStorageMultisample(RenderbufferHandle renderbuffer, int samples, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageMultisample_fnptr(renderbuffer, samples, internalformat, width, height);
        [UnmanagedCallersOnly]
        private static void NamedRenderbufferStorageMultisample_Lazy(RenderbufferHandle renderbuffer, int samples, InternalFormat internalformat, int width, int height)
        {
            _NamedRenderbufferStorageMultisample_fnptr = (delegate* unmanaged<RenderbufferHandle, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedRenderbufferStorageMultisample");
            _NamedRenderbufferStorageMultisample_fnptr(renderbuffer, samples, internalformat, width, height);
        }
        
        private static delegate* unmanaged<RenderbufferHandle, RenderbufferParameterName, int*, void> _GetNamedRenderbufferParameteriv_fnptr = &GetNamedRenderbufferParameteriv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
        public static void GetNamedRenderbufferParameteriv(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int* parameters) => _GetNamedRenderbufferParameteriv_fnptr(renderbuffer, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetNamedRenderbufferParameteriv_Lazy(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int* parameters)
        {
            _GetNamedRenderbufferParameteriv_fnptr = (delegate* unmanaged<RenderbufferHandle, RenderbufferParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedRenderbufferParameteriv");
            _GetNamedRenderbufferParameteriv_fnptr(renderbuffer, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureTarget, int, TextureHandle*, void> _CreateTextures_fnptr = &CreateTextures_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create texture objects. </summary>
        /// <param name="target"> Specifies the effective texture target of each created texture. </param>
        /// <param name="n"> Number of texture objects to create. </param>
        /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml" /></remarks>
        public static void CreateTextures(TextureTarget target, int n, TextureHandle* textures) => _CreateTextures_fnptr(target, n, textures);
        [UnmanagedCallersOnly]
        private static void CreateTextures_Lazy(TextureTarget target, int n, TextureHandle* textures)
        {
            _CreateTextures_fnptr = (delegate* unmanaged<TextureTarget, int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateTextures");
            _CreateTextures_fnptr(target, n, textures);
        }
        
        private static delegate* unmanaged<TextureHandle, SizedInternalFormat, BufferHandle, void> _TextureBuffer_fnptr = &TextureBuffer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a buffer object's data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
        public static void TextureBuffer(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer) => _TextureBuffer_fnptr(texture, internalformat, buffer);
        [UnmanagedCallersOnly]
        private static void TextureBuffer_Lazy(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer)
        {
            _TextureBuffer_fnptr = (delegate* unmanaged<TextureHandle, SizedInternalFormat, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTextureBuffer");
            _TextureBuffer_fnptr(texture, internalformat, buffer);
        }
        
        private static delegate* unmanaged<TextureHandle, SizedInternalFormat, BufferHandle, IntPtr, nint, void> _TextureBufferRange_fnptr = &TextureBufferRange_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a range of a buffer object's data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer's data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer's data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
        public static void TextureBufferRange(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => _TextureBufferRange_fnptr(texture, internalformat, buffer, offset, size);
        [UnmanagedCallersOnly]
        private static void TextureBufferRange_Lazy(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size)
        {
            _TextureBufferRange_fnptr = (delegate* unmanaged<TextureHandle, SizedInternalFormat, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glTextureBufferRange");
            _TextureBufferRange_fnptr(texture, internalformat, buffer, offset, size);
        }
        
        private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, void> _TextureStorage1D_fnptr = &TextureStorage1D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
        public static void TextureStorage1D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width) => _TextureStorage1D_fnptr(texture, levels, internalformat, width);
        [UnmanagedCallersOnly]
        private static void TextureStorage1D_Lazy(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width)
        {
            _TextureStorage1D_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage1D");
            _TextureStorage1D_fnptr(texture, levels, internalformat, width);
        }
        
        private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, void> _TextureStorage2D_fnptr = &TextureStorage2D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
        public static void TextureStorage2D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height) => _TextureStorage2D_fnptr(texture, levels, internalformat, width, height);
        [UnmanagedCallersOnly]
        private static void TextureStorage2D_Lazy(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height)
        {
            _TextureStorage2D_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage2D");
            _TextureStorage2D_fnptr(texture, levels, internalformat, width, height);
        }
        
        private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, void> _TextureStorage3D_fnptr = &TextureStorage3D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
        public static void TextureStorage3D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => _TextureStorage3D_fnptr(texture, levels, internalformat, width, height, depth);
        [UnmanagedCallersOnly]
        private static void TextureStorage3D_Lazy(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth)
        {
            _TextureStorage3D_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage3D");
            _TextureStorage3D_fnptr(texture, levels, internalformat, width, height, depth);
        }
        
        private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, byte, void> _TextureStorage2DMultisample_fnptr = &TextureStorage2DMultisample_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
        public static void TextureStorage2DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations) => _TextureStorage2DMultisample_fnptr(texture, samples, internalformat, width, height, fixedsamplelocations);
        [UnmanagedCallersOnly]
        private static void TextureStorage2DMultisample_Lazy(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations)
        {
            _TextureStorage2DMultisample_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage2DMultisample");
            _TextureStorage2DMultisample_fnptr(texture, samples, internalformat, width, height, fixedsamplelocations);
        }
        
        private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, byte, void> _TextureStorage3DMultisample_fnptr = &TextureStorage3DMultisample_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
        public static void TextureStorage3DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations) => _TextureStorage3DMultisample_fnptr(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
        [UnmanagedCallersOnly]
        private static void TextureStorage3DMultisample_Lazy(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations)
        {
            _TextureStorage3DMultisample_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage3DMultisample");
            _TextureStorage3DMultisample_fnptr(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, PixelFormat, PixelType, void*, void> _TextureSubImage1D_fnptr = &TextureSubImage1D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a one-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
        public static void TextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => _TextureSubImage1D_fnptr(texture, level, xoffset, width, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void TextureSubImage1D_Lazy(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels)
        {
            _TextureSubImage1D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureSubImage1D");
            _TextureSubImage1D_fnptr(texture, level, xoffset, width, format, type, pixels);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TextureSubImage2D_fnptr = &TextureSubImage2D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a two-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
        public static void TextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => _TextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void TextureSubImage2D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels)
        {
            _TextureSubImage2D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureSubImage2D");
            _TextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, format, type, pixels);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TextureSubImage3D_fnptr = &TextureSubImage3D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a three-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
        public static void TextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => _TextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        [UnmanagedCallersOnly]
        private static void TextureSubImage3D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels)
        {
            _TextureSubImage3D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureSubImage3D");
            _TextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, InternalFormat, int, void*, void> _CompressedTextureSubImage1D_fnptr = &CompressedTextureSubImage1D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
        public static void CompressedTextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => _CompressedTextureSubImage1D_fnptr(texture, level, xoffset, width, format, imageSize, data);
        [UnmanagedCallersOnly]
        private static void CompressedTextureSubImage1D_Lazy(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data)
        {
            _CompressedTextureSubImage1D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureSubImage1D");
            _CompressedTextureSubImage1D_fnptr(texture, level, xoffset, width, format, imageSize, data);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTextureSubImage2D_fnptr = &CompressedTextureSubImage2D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
        public static void CompressedTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => _CompressedTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
        [UnmanagedCallersOnly]
        private static void CompressedTextureSubImage2D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data)
        {
            _CompressedTextureSubImage2D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureSubImage2D");
            _CompressedTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTextureSubImage3D_fnptr = &CompressedTextureSubImage3D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
        public static void CompressedTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => _CompressedTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        [UnmanagedCallersOnly]
        private static void CompressedTextureSubImage3D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data)
        {
            _CompressedTextureSubImage3D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureSubImage3D");
            _CompressedTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, void> _CopyTextureSubImage1D_fnptr = &CopyTextureSubImage1D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a one-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
        public static void CopyTextureSubImage1D(TextureHandle texture, int level, int xoffset, int x, int y, int width) => _CopyTextureSubImage1D_fnptr(texture, level, xoffset, x, y, width);
        [UnmanagedCallersOnly]
        private static void CopyTextureSubImage1D_Lazy(TextureHandle texture, int level, int xoffset, int x, int y, int width)
        {
            _CopyTextureSubImage1D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureSubImage1D");
            _CopyTextureSubImage1D_fnptr(texture, level, xoffset, x, y, width);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, void> _CopyTextureSubImage2D_fnptr = &CopyTextureSubImage2D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a two-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
        public static void CopyTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, x, y, width, height);
        [UnmanagedCallersOnly]
        private static void CopyTextureSubImage2D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
        {
            _CopyTextureSubImage2D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureSubImage2D");
            _CopyTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, x, y, width, height);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, void> _CopyTextureSubImage3D_fnptr = &CopyTextureSubImage3D_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a three-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
        public static void CopyTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
        [UnmanagedCallersOnly]
        private static void CopyTextureSubImage3D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
        {
            _CopyTextureSubImage3D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureSubImage3D");
            _CopyTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
        }
        
        private static delegate* unmanaged<TextureHandle, TextureParameterName, float, void> _TextureParameterf_fnptr = &TextureParameterf_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterf(TextureHandle texture, TextureParameterName pname, float param) => _TextureParameterf_fnptr(texture, pname, param);
        [UnmanagedCallersOnly]
        private static void TextureParameterf_Lazy(TextureHandle texture, TextureParameterName pname, float param)
        {
            _TextureParameterf_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, float, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterf");
            _TextureParameterf_fnptr(texture, pname, param);
        }
        
        private static delegate* unmanaged<TextureHandle, TextureParameterName, float*, void> _TextureParameterfv_fnptr = &TextureParameterfv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterfv(TextureHandle texture, TextureParameterName pname, float* param) => _TextureParameterfv_fnptr(texture, pname, param);
        [UnmanagedCallersOnly]
        private static void TextureParameterfv_Lazy(TextureHandle texture, TextureParameterName pname, float* param)
        {
            _TextureParameterfv_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterfv");
            _TextureParameterfv_fnptr(texture, pname, param);
        }
        
        private static delegate* unmanaged<TextureHandle, TextureParameterName, int, void> _TextureParameteri_fnptr = &TextureParameteri_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameteri(TextureHandle texture, TextureParameterName pname, int param) => _TextureParameteri_fnptr(texture, pname, param);
        [UnmanagedCallersOnly]
        private static void TextureParameteri_Lazy(TextureHandle texture, TextureParameterName pname, int param)
        {
            _TextureParameteri_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameteri");
            _TextureParameteri_fnptr(texture, pname, param);
        }
        
        private static delegate* unmanaged<TextureHandle, TextureParameterName, int*, void> _TextureParameterIiv_fnptr = &TextureParameterIiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterIiv(TextureHandle texture, TextureParameterName pname, int* parameters) => _TextureParameterIiv_fnptr(texture, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TextureParameterIiv_Lazy(TextureHandle texture, TextureParameterName pname, int* parameters)
        {
            _TextureParameterIiv_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterIiv");
            _TextureParameterIiv_fnptr(texture, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureHandle, TextureParameterName, uint*, void> _TextureParameterIuiv_fnptr = &TextureParameterIuiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterIuiv(TextureHandle texture, TextureParameterName pname, uint* parameters) => _TextureParameterIuiv_fnptr(texture, pname, parameters);
        [UnmanagedCallersOnly]
        private static void TextureParameterIuiv_Lazy(TextureHandle texture, TextureParameterName pname, uint* parameters)
        {
            _TextureParameterIuiv_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterIuiv");
            _TextureParameterIuiv_fnptr(texture, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureHandle, TextureParameterName, int*, void> _TextureParameteriv_fnptr = &TextureParameteriv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameteriv(TextureHandle texture, TextureParameterName pname, int* param) => _TextureParameteriv_fnptr(texture, pname, param);
        [UnmanagedCallersOnly]
        private static void TextureParameteriv_Lazy(TextureHandle texture, TextureParameterName pname, int* param)
        {
            _TextureParameteriv_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameteriv");
            _TextureParameteriv_fnptr(texture, pname, param);
        }
        
        private static delegate* unmanaged<TextureHandle, void> _GenerateTextureMipmap_fnptr = &GenerateTextureMipmap_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Generate mipmaps for a specified texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
        public static void GenerateTextureMipmap(TextureHandle texture) => _GenerateTextureMipmap_fnptr(texture);
        [UnmanagedCallersOnly]
        private static void GenerateTextureMipmap_Lazy(TextureHandle texture)
        {
            _GenerateTextureMipmap_fnptr = (delegate* unmanaged<TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glGenerateTextureMipmap");
            _GenerateTextureMipmap_fnptr(texture);
        }
        
        private static delegate* unmanaged<uint, TextureHandle, void> _BindTextureUnit_fnptr = &BindTextureUnit_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind an existing texture object to the specified texture unit . </summary>
        /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
        /// <param name="texture">Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml" /></remarks>
        public static void BindTextureUnit(uint unit, TextureHandle texture) => _BindTextureUnit_fnptr(unit, texture);
        [UnmanagedCallersOnly]
        private static void BindTextureUnit_Lazy(uint unit, TextureHandle texture)
        {
            _BindTextureUnit_fnptr = (delegate* unmanaged<uint, TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindTextureUnit");
            _BindTextureUnit_fnptr(unit, texture);
        }
        
        private static delegate* unmanaged<TextureHandle, int, PixelFormat, PixelType, int, void*, void> _GetTextureImage_fnptr = &GetTextureImage_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return a texture image. </summary>
        /// <param name="texture"> Specifies the texture object name. </param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetTextureImage(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => _GetTextureImage_fnptr(texture, level, format, type, bufSize, pixels);
        [UnmanagedCallersOnly]
        private static void GetTextureImage_Lazy(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels)
        {
            _GetTextureImage_fnptr = (delegate* unmanaged<TextureHandle, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureImage");
            _GetTextureImage_fnptr(texture, level, format, type, bufSize, pixels);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, void*, void> _GetCompressedTextureImage_fnptr = &GetCompressedTextureImage_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return a compressed texture image. </summary>
        /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetCompressedTextureImage(TextureHandle texture, int level, int bufSize, void* pixels) => _GetCompressedTextureImage_fnptr(texture, level, bufSize, pixels);
        [UnmanagedCallersOnly]
        private static void GetCompressedTextureImage_Lazy(TextureHandle texture, int level, int bufSize, void* pixels)
        {
            _GetCompressedTextureImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCompressedTextureImage");
            _GetCompressedTextureImage_fnptr(texture, level, bufSize, pixels);
        }
        
        private static delegate* unmanaged<TextureHandle, int, GetTextureParameter, float*, void> _GetTextureLevelParameterfv_fnptr = &GetTextureLevelParameterfv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTextureLevelParameterfv(TextureHandle texture, int level, GetTextureParameter pname, float* parameters) => _GetTextureLevelParameterfv_fnptr(texture, level, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTextureLevelParameterfv_Lazy(TextureHandle texture, int level, GetTextureParameter pname, float* parameters)
        {
            _GetTextureLevelParameterfv_fnptr = (delegate* unmanaged<TextureHandle, int, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureLevelParameterfv");
            _GetTextureLevelParameterfv_fnptr(texture, level, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureHandle, int, GetTextureParameter, int*, void> _GetTextureLevelParameteriv_fnptr = &GetTextureLevelParameteriv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTextureLevelParameteriv(TextureHandle texture, int level, GetTextureParameter pname, int* parameters) => _GetTextureLevelParameteriv_fnptr(texture, level, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTextureLevelParameteriv_Lazy(TextureHandle texture, int level, GetTextureParameter pname, int* parameters)
        {
            _GetTextureLevelParameteriv_fnptr = (delegate* unmanaged<TextureHandle, int, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureLevelParameteriv");
            _GetTextureLevelParameteriv_fnptr(texture, level, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureHandle, GetTextureParameter, float*, void> _GetTextureParameterfv_fnptr = &GetTextureParameterfv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterfv(TextureHandle texture, GetTextureParameter pname, float* parameters) => _GetTextureParameterfv_fnptr(texture, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTextureParameterfv_Lazy(TextureHandle texture, GetTextureParameter pname, float* parameters)
        {
            _GetTextureParameterfv_fnptr = (delegate* unmanaged<TextureHandle, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterfv");
            _GetTextureParameterfv_fnptr(texture, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureHandle, GetTextureParameter, int*, void> _GetTextureParameterIiv_fnptr = &GetTextureParameterIiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterIiv(TextureHandle texture, GetTextureParameter pname, int* parameters) => _GetTextureParameterIiv_fnptr(texture, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTextureParameterIiv_Lazy(TextureHandle texture, GetTextureParameter pname, int* parameters)
        {
            _GetTextureParameterIiv_fnptr = (delegate* unmanaged<TextureHandle, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterIiv");
            _GetTextureParameterIiv_fnptr(texture, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureHandle, GetTextureParameter, uint*, void> _GetTextureParameterIuiv_fnptr = &GetTextureParameterIuiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterIuiv(TextureHandle texture, GetTextureParameter pname, uint* parameters) => _GetTextureParameterIuiv_fnptr(texture, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTextureParameterIuiv_Lazy(TextureHandle texture, GetTextureParameter pname, uint* parameters)
        {
            _GetTextureParameterIuiv_fnptr = (delegate* unmanaged<TextureHandle, GetTextureParameter, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterIuiv");
            _GetTextureParameterIuiv_fnptr(texture, pname, parameters);
        }
        
        private static delegate* unmanaged<TextureHandle, GetTextureParameter, int*, void> _GetTextureParameteriv_fnptr = &GetTextureParameteriv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameteriv(TextureHandle texture, GetTextureParameter pname, int* parameters) => _GetTextureParameteriv_fnptr(texture, pname, parameters);
        [UnmanagedCallersOnly]
        private static void GetTextureParameteriv_Lazy(TextureHandle texture, GetTextureParameter pname, int* parameters)
        {
            _GetTextureParameteriv_fnptr = (delegate* unmanaged<TextureHandle, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameteriv");
            _GetTextureParameteriv_fnptr(texture, pname, parameters);
        }
        
        private static delegate* unmanaged<int, VertexArrayHandle*, void> _CreateVertexArrays_fnptr = &CreateVertexArrays_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create vertex array objects. </summary>
        /// <param name="n"> Number of vertex array objects to create. </param>
        /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml" /></remarks>
        public static void CreateVertexArrays(int n, VertexArrayHandle* arrays) => _CreateVertexArrays_fnptr(n, arrays);
        [UnmanagedCallersOnly]
        private static void CreateVertexArrays_Lazy(int n, VertexArrayHandle* arrays)
        {
            _CreateVertexArrays_fnptr = (delegate* unmanaged<int, VertexArrayHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateVertexArrays");
            _CreateVertexArrays_fnptr(n, arrays);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, void> _DisableVertexArrayAttrib_fnptr = &DisableVertexArrayAttrib_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void DisableVertexArrayAttrib(VertexArrayHandle vaobj, uint index) => _DisableVertexArrayAttrib_fnptr(vaobj, index);
        [UnmanagedCallersOnly]
        private static void DisableVertexArrayAttrib_Lazy(VertexArrayHandle vaobj, uint index)
        {
            _DisableVertexArrayAttrib_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisableVertexArrayAttrib");
            _DisableVertexArrayAttrib_fnptr(vaobj, index);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, void> _EnableVertexArrayAttrib_fnptr = &EnableVertexArrayAttrib_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void EnableVertexArrayAttrib(VertexArrayHandle vaobj, uint index) => _EnableVertexArrayAttrib_fnptr(vaobj, index);
        [UnmanagedCallersOnly]
        private static void EnableVertexArrayAttrib_Lazy(VertexArrayHandle vaobj, uint index)
        {
            _EnableVertexArrayAttrib_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnableVertexArrayAttrib");
            _EnableVertexArrayAttrib_fnptr(vaobj, index);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, BufferHandle, void> _VertexArrayElementBuffer_fnptr = &VertexArrayElementBuffer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Configures element array buffer binding of a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
        /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml" /></remarks>
        public static void VertexArrayElementBuffer(VertexArrayHandle vaobj, BufferHandle buffer) => _VertexArrayElementBuffer_fnptr(vaobj, buffer);
        [UnmanagedCallersOnly]
        private static void VertexArrayElementBuffer_Lazy(VertexArrayHandle vaobj, BufferHandle buffer)
        {
            _VertexArrayElementBuffer_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayElementBuffer");
            _VertexArrayElementBuffer_fnptr(vaobj, buffer);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, BufferHandle, IntPtr, int, void> _VertexArrayVertexBuffer_fnptr = &VertexArrayVertexBuffer_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
        public static void VertexArrayVertexBuffer(VertexArrayHandle vaobj, uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => _VertexArrayVertexBuffer_fnptr(vaobj, bindingindex, buffer, offset, stride);
        [UnmanagedCallersOnly]
        private static void VertexArrayVertexBuffer_Lazy(VertexArrayHandle vaobj, uint bindingindex, BufferHandle buffer, IntPtr offset, int stride)
        {
            _VertexArrayVertexBuffer_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, BufferHandle, IntPtr, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexBuffer");
            _VertexArrayVertexBuffer_fnptr(vaobj, bindingindex, buffer, offset, stride);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, int, BufferHandle*, IntPtr*, int*, void> _VertexArrayVertexBuffers_fnptr = &VertexArrayVertexBuffers_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
        public static void VertexArrayVertexBuffers(VertexArrayHandle vaobj, uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides) => _VertexArrayVertexBuffers_fnptr(vaobj, first, count, buffers, offsets, strides);
        [UnmanagedCallersOnly]
        private static void VertexArrayVertexBuffers_Lazy(VertexArrayHandle vaobj, uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides)
        {
            _VertexArrayVertexBuffers_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, BufferHandle*, IntPtr*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexBuffers");
            _VertexArrayVertexBuffers_fnptr(vaobj, first, count, buffers, offsets, strides);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, uint, void> _VertexArrayAttribBinding_fnptr = &VertexArrayAttribBinding_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
        public static void VertexArrayAttribBinding(VertexArrayHandle vaobj, uint attribindex, uint bindingindex) => _VertexArrayAttribBinding_fnptr(vaobj, attribindex, bindingindex);
        [UnmanagedCallersOnly]
        private static void VertexArrayAttribBinding_Lazy(VertexArrayHandle vaobj, uint attribindex, uint bindingindex)
        {
            _VertexArrayAttribBinding_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayAttribBinding");
            _VertexArrayAttribBinding_fnptr(vaobj, attribindex, bindingindex);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribType, byte, uint, void> _VertexArrayAttribFormat_fnptr = &VertexArrayAttribFormat_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset) => _VertexArrayAttribFormat_fnptr(vaobj, attribindex, size, type, normalized, relativeoffset);
        [UnmanagedCallersOnly]
        private static void VertexArrayAttribFormat_Lazy(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset)
        {
            _VertexArrayAttribFormat_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayAttribFormat");
            _VertexArrayAttribFormat_fnptr(vaobj, attribindex, size, type, normalized, relativeoffset);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribIType, uint, void> _VertexArrayAttribIFormat_fnptr = &VertexArrayAttribIFormat_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribIFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => _VertexArrayAttribIFormat_fnptr(vaobj, attribindex, size, type, relativeoffset);
        [UnmanagedCallersOnly]
        private static void VertexArrayAttribIFormat_Lazy(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset)
        {
            _VertexArrayAttribIFormat_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribIType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayAttribIFormat");
            _VertexArrayAttribIFormat_fnptr(vaobj, attribindex, size, type, relativeoffset);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribLType, uint, void> _VertexArrayAttribLFormat_fnptr = &VertexArrayAttribLFormat_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribLFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => _VertexArrayAttribLFormat_fnptr(vaobj, attribindex, size, type, relativeoffset);
        [UnmanagedCallersOnly]
        private static void VertexArrayAttribLFormat_Lazy(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset)
        {
            _VertexArrayAttribLFormat_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribLType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayAttribLFormat");
            _VertexArrayAttribLFormat_fnptr(vaobj, attribindex, size, type, relativeoffset);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, uint, void> _VertexArrayBindingDivisor_fnptr = &VertexArrayBindingDivisor_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
        public static void VertexArrayBindingDivisor(VertexArrayHandle vaobj, uint bindingindex, uint divisor) => _VertexArrayBindingDivisor_fnptr(vaobj, bindingindex, divisor);
        [UnmanagedCallersOnly]
        private static void VertexArrayBindingDivisor_Lazy(VertexArrayHandle vaobj, uint bindingindex, uint divisor)
        {
            _VertexArrayBindingDivisor_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayBindingDivisor");
            _VertexArrayBindingDivisor_fnptr(vaobj, bindingindex, divisor);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, VertexArrayPName, int*, void> _GetVertexArrayiv_fnptr = &GetVertexArrayiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of a vertex array object. </summary>
        /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
        /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml" /></remarks>
        public static void GetVertexArrayiv(VertexArrayHandle vaobj, VertexArrayPName pname, int* param) => _GetVertexArrayiv_fnptr(vaobj, pname, param);
        [UnmanagedCallersOnly]
        private static void GetVertexArrayiv_Lazy(VertexArrayHandle vaobj, VertexArrayPName pname, int* param)
        {
            _GetVertexArrayiv_fnptr = (delegate* unmanaged<VertexArrayHandle, VertexArrayPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayiv");
            _GetVertexArrayiv_fnptr(vaobj, pname, param);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, int*, void> _GetVertexArrayIndexediv_fnptr = &GetVertexArrayIndexediv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
        public static void GetVertexArrayIndexediv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, int* param) => _GetVertexArrayIndexediv_fnptr(vaobj, index, pname, param);
        [UnmanagedCallersOnly]
        private static void GetVertexArrayIndexediv_Lazy(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, int* param)
        {
            _GetVertexArrayIndexediv_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayIndexediv");
            _GetVertexArrayIndexediv_fnptr(vaobj, index, pname, param);
        }
        
        private static delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, long*, void> _GetVertexArrayIndexed64iv_fnptr = &GetVertexArrayIndexed64iv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
        public static void GetVertexArrayIndexed64iv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, long* param) => _GetVertexArrayIndexed64iv_fnptr(vaobj, index, pname, param);
        [UnmanagedCallersOnly]
        private static void GetVertexArrayIndexed64iv_Lazy(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, long* param)
        {
            _GetVertexArrayIndexed64iv_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayIndexed64iv");
            _GetVertexArrayIndexed64iv_fnptr(vaobj, index, pname, param);
        }
        
        private static delegate* unmanaged<int, SamplerHandle*, void> _CreateSamplers_fnptr = &CreateSamplers_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create sampler objects. </summary>
        /// <param name="n"> Number of sampler objects to create. </param>
        /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml" /></remarks>
        public static void CreateSamplers(int n, SamplerHandle* samplers) => _CreateSamplers_fnptr(n, samplers);
        [UnmanagedCallersOnly]
        private static void CreateSamplers_Lazy(int n, SamplerHandle* samplers)
        {
            _CreateSamplers_fnptr = (delegate* unmanaged<int, SamplerHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateSamplers");
            _CreateSamplers_fnptr(n, samplers);
        }
        
        private static delegate* unmanaged<int, ProgramPipelineHandle*, void> _CreateProgramPipelines_fnptr = &CreateProgramPipelines_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create program pipeline objects. </summary>
        /// <param name="n"> Number of program pipeline objects to create. </param>
        /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml" /></remarks>
        public static void CreateProgramPipelines(int n, ProgramPipelineHandle* pipelines) => _CreateProgramPipelines_fnptr(n, pipelines);
        [UnmanagedCallersOnly]
        private static void CreateProgramPipelines_Lazy(int n, ProgramPipelineHandle* pipelines)
        {
            _CreateProgramPipelines_fnptr = (delegate* unmanaged<int, ProgramPipelineHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateProgramPipelines");
            _CreateProgramPipelines_fnptr(n, pipelines);
        }
        
        private static delegate* unmanaged<QueryTarget, int, QueryHandle*, void> _CreateQueries_fnptr = &CreateQueries_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create query objects. </summary>
        /// <param name="target"> Specifies the target of each created query object. </param>
        /// <param name="n"> Number of query objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml" /></remarks>
        public static void CreateQueries(QueryTarget target, int n, QueryHandle* ids) => _CreateQueries_fnptr(target, n, ids);
        [UnmanagedCallersOnly]
        private static void CreateQueries_Lazy(QueryTarget target, int n, QueryHandle* ids)
        {
            _CreateQueries_fnptr = (delegate* unmanaged<QueryTarget, int, QueryHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateQueries");
            _CreateQueries_fnptr(target, n, ids);
        }
        
        private static delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void> _GetQueryBufferObjecti64v_fnptr = &GetQueryBufferObjecti64v_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjecti64v(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjecti64v_fnptr(id, buffer, pname, offset);
        [UnmanagedCallersOnly]
        private static void GetQueryBufferObjecti64v_Lazy(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
        {
            _GetQueryBufferObjecti64v_fnptr = (delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryBufferObjecti64v");
            _GetQueryBufferObjecti64v_fnptr(id, buffer, pname, offset);
        }
        
        private static delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void> _GetQueryBufferObjectiv_fnptr = &GetQueryBufferObjectiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectiv(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjectiv_fnptr(id, buffer, pname, offset);
        [UnmanagedCallersOnly]
        private static void GetQueryBufferObjectiv_Lazy(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
        {
            _GetQueryBufferObjectiv_fnptr = (delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryBufferObjectiv");
            _GetQueryBufferObjectiv_fnptr(id, buffer, pname, offset);
        }
        
        private static delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void> _GetQueryBufferObjectui64v_fnptr = &GetQueryBufferObjectui64v_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectui64v(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjectui64v_fnptr(id, buffer, pname, offset);
        [UnmanagedCallersOnly]
        private static void GetQueryBufferObjectui64v_Lazy(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
        {
            _GetQueryBufferObjectui64v_fnptr = (delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryBufferObjectui64v");
            _GetQueryBufferObjectui64v_fnptr(id, buffer, pname, offset);
        }
        
        private static delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void> _GetQueryBufferObjectuiv_fnptr = &GetQueryBufferObjectuiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectuiv(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjectuiv_fnptr(id, buffer, pname, offset);
        [UnmanagedCallersOnly]
        private static void GetQueryBufferObjectuiv_Lazy(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
        {
            _GetQueryBufferObjectuiv_fnptr = (delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryBufferObjectuiv");
            _GetQueryBufferObjectuiv_fnptr(id, buffer, pname, offset);
        }
        
        private static delegate* unmanaged<MemoryBarrierMask, void> _MemoryBarrierByRegion_fnptr = &MemoryBarrierByRegion_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility]</b> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
        public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => _MemoryBarrierByRegion_fnptr(barriers);
        [UnmanagedCallersOnly]
        private static void MemoryBarrierByRegion_Lazy(MemoryBarrierMask barriers)
        {
            _MemoryBarrierByRegion_fnptr = (delegate* unmanaged<MemoryBarrierMask, void>)GLLoader.BindingsContext.GetProcAddress("glMemoryBarrierByRegion");
            _MemoryBarrierByRegion_fnptr(barriers);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, int, void*, void> _GetTextureSubImage_fnptr = &GetTextureSubImage_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> Retrieve a sub-region of a texture image from a texture    object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml" /></remarks>
        public static void GetTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => _GetTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
        [UnmanagedCallersOnly]
        private static void GetTextureSubImage_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels)
        {
            _GetTextureSubImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureSubImage");
            _GetTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
        }
        
        private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, void*, void> _GetCompressedTextureSubImage_fnptr = &GetCompressedTextureSubImage_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml" /></remarks>
        public static void GetCompressedTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => _GetCompressedTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
        [UnmanagedCallersOnly]
        private static void GetCompressedTextureSubImage_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
        {
            _GetCompressedTextureSubImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCompressedTextureSubImage");
            _GetCompressedTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
        }
        
        private static delegate* unmanaged<GraphicsResetStatus> _GetGraphicsResetStatus_fnptr = &GetGraphicsResetStatus_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Check if the rendering context has not been lost due to software or hardware issues. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml" /></remarks>
        public static GraphicsResetStatus GetGraphicsResetStatus() => _GetGraphicsResetStatus_fnptr();
        [UnmanagedCallersOnly]
        private static GraphicsResetStatus GetGraphicsResetStatus_Lazy()
        {
            _GetGraphicsResetStatus_fnptr = (delegate* unmanaged<GraphicsResetStatus>)GLLoader.BindingsContext.GetProcAddress("glGetGraphicsResetStatus");
            return _GetGraphicsResetStatus_fnptr();
        }
        
        private static delegate* unmanaged<TextureTarget, int, int, void*, void> _GetnCompressedTexImage_fnptr = &GetnCompressedTexImage_Lazy;
        /// <summary> <b>[requires: v4.5]</b> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetnCompressedTexImage(TextureTarget target, int lod, int bufSize, void* pixels) => _GetnCompressedTexImage_fnptr(target, lod, bufSize, pixels);
        [UnmanagedCallersOnly]
        private static void GetnCompressedTexImage_Lazy(TextureTarget target, int lod, int bufSize, void* pixels)
        {
            _GetnCompressedTexImage_fnptr = (delegate* unmanaged<TextureTarget, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnCompressedTexImage");
            _GetnCompressedTexImage_fnptr(target, lod, bufSize, pixels);
        }
        
        private static delegate* unmanaged<TextureTarget, int, PixelFormat, PixelType, int, void*, void> _GetnTexImage_fnptr = &GetnTexImage_Lazy;
        /// <summary> <b>[requires: v4.5]</b> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetnTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => _GetnTexImage_fnptr(target, level, format, type, bufSize, pixels);
        [UnmanagedCallersOnly]
        private static void GetnTexImage_Lazy(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* pixels)
        {
            _GetnTexImage_fnptr = (delegate* unmanaged<TextureTarget, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnTexImage");
            _GetnTexImage_fnptr(target, level, format, type, bufSize, pixels);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _GetnUniformdv_fnptr = &GetnUniformdv_Lazy;
        /// <summary> <b>[requires: v4.5]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformdv(ProgramHandle program, int location, int bufSize, double* parameters) => _GetnUniformdv_fnptr(program, location, bufSize, parameters);
        [UnmanagedCallersOnly]
        private static void GetnUniformdv_Lazy(ProgramHandle program, int location, int bufSize, double* parameters)
        {
            _GetnUniformdv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformdv");
            _GetnUniformdv_fnptr(program, location, bufSize, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _GetnUniformfv_fnptr = &GetnUniformfv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformfv(ProgramHandle program, int location, int bufSize, float* parameters) => _GetnUniformfv_fnptr(program, location, bufSize, parameters);
        [UnmanagedCallersOnly]
        private static void GetnUniformfv_Lazy(ProgramHandle program, int location, int bufSize, float* parameters)
        {
            _GetnUniformfv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformfv");
            _GetnUniformfv_fnptr(program, location, bufSize, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _GetnUniformiv_fnptr = &GetnUniformiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformiv(ProgramHandle program, int location, int bufSize, int* parameters) => _GetnUniformiv_fnptr(program, location, bufSize, parameters);
        [UnmanagedCallersOnly]
        private static void GetnUniformiv_Lazy(ProgramHandle program, int location, int bufSize, int* parameters)
        {
            _GetnUniformiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformiv");
            _GetnUniformiv_fnptr(program, location, bufSize, parameters);
        }
        
        private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _GetnUniformuiv_fnptr = &GetnUniformuiv_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformuiv(ProgramHandle program, int location, int bufSize, uint* parameters) => _GetnUniformuiv_fnptr(program, location, bufSize, parameters);
        [UnmanagedCallersOnly]
        private static void GetnUniformuiv_Lazy(ProgramHandle program, int location, int bufSize, uint* parameters)
        {
            _GetnUniformuiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformuiv");
            _GetnUniformuiv_fnptr(program, location, bufSize, parameters);
        }
        
        private static delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, int, void*, void> _ReadnPixels_fnptr = &ReadnPixels_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
        /// <param name="data">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
        public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => _ReadnPixels_fnptr(x, y, width, height, format, type, bufSize, data);
        [UnmanagedCallersOnly]
        private static void ReadnPixels_Lazy(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data)
        {
            _ReadnPixels_fnptr = (delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glReadnPixels");
            _ReadnPixels_fnptr(x, y, width, height, format, type, bufSize, data);
        }
        
        private static delegate* unmanaged<MapTarget, MapQuery, int, double*, void> _GetnMapdv_fnptr = &GetnMapdv_Lazy;
        public static void GetnMapdv(MapTarget target, MapQuery query, int bufSize, double* v) => _GetnMapdv_fnptr(target, query, bufSize, v);
        [UnmanagedCallersOnly]
        private static void GetnMapdv_Lazy(MapTarget target, MapQuery query, int bufSize, double* v)
        {
            _GetnMapdv_fnptr = (delegate* unmanaged<MapTarget, MapQuery, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnMapdv");
            _GetnMapdv_fnptr(target, query, bufSize, v);
        }
        
        private static delegate* unmanaged<MapTarget, MapQuery, int, float*, void> _GetnMapfv_fnptr = &GetnMapfv_Lazy;
        public static void GetnMapfv(MapTarget target, MapQuery query, int bufSize, float* v) => _GetnMapfv_fnptr(target, query, bufSize, v);
        [UnmanagedCallersOnly]
        private static void GetnMapfv_Lazy(MapTarget target, MapQuery query, int bufSize, float* v)
        {
            _GetnMapfv_fnptr = (delegate* unmanaged<MapTarget, MapQuery, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnMapfv");
            _GetnMapfv_fnptr(target, query, bufSize, v);
        }
        
        private static delegate* unmanaged<MapTarget, MapQuery, int, int*, void> _GetnMapiv_fnptr = &GetnMapiv_Lazy;
        public static void GetnMapiv(MapTarget target, MapQuery query, int bufSize, int* v) => _GetnMapiv_fnptr(target, query, bufSize, v);
        [UnmanagedCallersOnly]
        private static void GetnMapiv_Lazy(MapTarget target, MapQuery query, int bufSize, int* v)
        {
            _GetnMapiv_fnptr = (delegate* unmanaged<MapTarget, MapQuery, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnMapiv");
            _GetnMapiv_fnptr(target, query, bufSize, v);
        }
        
        private static delegate* unmanaged<PixelMap, int, float*, void> _GetnPixelMapfv_fnptr = &GetnPixelMapfv_Lazy;
        public static void GetnPixelMapfv(PixelMap map, int bufSize, float* values) => _GetnPixelMapfv_fnptr(map, bufSize, values);
        [UnmanagedCallersOnly]
        private static void GetnPixelMapfv_Lazy(PixelMap map, int bufSize, float* values)
        {
            _GetnPixelMapfv_fnptr = (delegate* unmanaged<PixelMap, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnPixelMapfv");
            _GetnPixelMapfv_fnptr(map, bufSize, values);
        }
        
        private static delegate* unmanaged<PixelMap, int, uint*, void> _GetnPixelMapuiv_fnptr = &GetnPixelMapuiv_Lazy;
        public static void GetnPixelMapuiv(PixelMap map, int bufSize, uint* values) => _GetnPixelMapuiv_fnptr(map, bufSize, values);
        [UnmanagedCallersOnly]
        private static void GetnPixelMapuiv_Lazy(PixelMap map, int bufSize, uint* values)
        {
            _GetnPixelMapuiv_fnptr = (delegate* unmanaged<PixelMap, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnPixelMapuiv");
            _GetnPixelMapuiv_fnptr(map, bufSize, values);
        }
        
        private static delegate* unmanaged<PixelMap, int, ushort*, void> _GetnPixelMapusv_fnptr = &GetnPixelMapusv_Lazy;
        public static void GetnPixelMapusv(PixelMap map, int bufSize, ushort* values) => _GetnPixelMapusv_fnptr(map, bufSize, values);
        [UnmanagedCallersOnly]
        private static void GetnPixelMapusv_Lazy(PixelMap map, int bufSize, ushort* values)
        {
            _GetnPixelMapusv_fnptr = (delegate* unmanaged<PixelMap, int, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnPixelMapusv");
            _GetnPixelMapusv_fnptr(map, bufSize, values);
        }
        
        private static delegate* unmanaged<int, byte*, void> _GetnPolygonStipple_fnptr = &GetnPolygonStipple_Lazy;
        public static void GetnPolygonStipple(int bufSize, byte* pattern) => _GetnPolygonStipple_fnptr(bufSize, pattern);
        [UnmanagedCallersOnly]
        private static void GetnPolygonStipple_Lazy(int bufSize, byte* pattern)
        {
            _GetnPolygonStipple_fnptr = (delegate* unmanaged<int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnPolygonStipple");
            _GetnPolygonStipple_fnptr(bufSize, pattern);
        }
        
        private static delegate* unmanaged<ColorTableTarget, PixelFormat, PixelType, int, void*, void> _GetnColorTable_fnptr = &GetnColorTable_Lazy;
        public static void GetnColorTable(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, void* table) => _GetnColorTable_fnptr(target, format, type, bufSize, table);
        [UnmanagedCallersOnly]
        private static void GetnColorTable_Lazy(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, void* table)
        {
            _GetnColorTable_fnptr = (delegate* unmanaged<ColorTableTarget, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnColorTable");
            _GetnColorTable_fnptr(target, format, type, bufSize, table);
        }
        
        private static delegate* unmanaged<ConvolutionTarget, PixelFormat, PixelType, int, void*, void> _GetnConvolutionFilter_fnptr = &GetnConvolutionFilter_Lazy;
        public static void GetnConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, void* image) => _GetnConvolutionFilter_fnptr(target, format, type, bufSize, image);
        [UnmanagedCallersOnly]
        private static void GetnConvolutionFilter_Lazy(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, void* image)
        {
            _GetnConvolutionFilter_fnptr = (delegate* unmanaged<ConvolutionTarget, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnConvolutionFilter");
            _GetnConvolutionFilter_fnptr(target, format, type, bufSize, image);
        }
        
        private static delegate* unmanaged<SeparableTarget, PixelFormat, PixelType, int, void*, int, void*, void*, void> _GetnSeparableFilter_fnptr = &GetnSeparableFilter_Lazy;
        public static void GetnSeparableFilter(SeparableTarget target, PixelFormat format, PixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span) => _GetnSeparableFilter_fnptr(target, format, type, rowBufSize, row, columnBufSize, column, span);
        [UnmanagedCallersOnly]
        private static void GetnSeparableFilter_Lazy(SeparableTarget target, PixelFormat format, PixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span)
        {
            _GetnSeparableFilter_fnptr = (delegate* unmanaged<SeparableTarget, PixelFormat, PixelType, int, void*, int, void*, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnSeparableFilter");
            _GetnSeparableFilter_fnptr(target, format, type, rowBufSize, row, columnBufSize, column, span);
        }
        
        private static delegate* unmanaged<HistogramTarget, byte, PixelFormat, PixelType, int, void*, void> _GetnHistogram_fnptr = &GetnHistogram_Lazy;
        public static void GetnHistogram(HistogramTarget target, byte reset, PixelFormat format, PixelType type, int bufSize, void* values) => _GetnHistogram_fnptr(target, reset, format, type, bufSize, values);
        [UnmanagedCallersOnly]
        private static void GetnHistogram_Lazy(HistogramTarget target, byte reset, PixelFormat format, PixelType type, int bufSize, void* values)
        {
            _GetnHistogram_fnptr = (delegate* unmanaged<HistogramTarget, byte, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnHistogram");
            _GetnHistogram_fnptr(target, reset, format, type, bufSize, values);
        }
        
        private static delegate* unmanaged<MinmaxTarget, byte, PixelFormat, PixelType, int, void*, void> _GetnMinmax_fnptr = &GetnMinmax_Lazy;
        public static void GetnMinmax(MinmaxTarget target, byte reset, PixelFormat format, PixelType type, int bufSize, void* values) => _GetnMinmax_fnptr(target, reset, format, type, bufSize, values);
        [UnmanagedCallersOnly]
        private static void GetnMinmax_Lazy(MinmaxTarget target, byte reset, PixelFormat format, PixelType type, int bufSize, void* values)
        {
            _GetnMinmax_fnptr = (delegate* unmanaged<MinmaxTarget, byte, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnMinmax");
            _GetnMinmax_fnptr(target, reset, format, type, bufSize, values);
        }
        
        private static delegate* unmanaged<void> _TextureBarrier_fnptr = &TextureBarrier_Lazy;
        /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier]</b> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml" /></remarks>
        public static void TextureBarrier() => _TextureBarrier_fnptr();
        [UnmanagedCallersOnly]
        private static void TextureBarrier_Lazy()
        {
            _TextureBarrier_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glTextureBarrier");
            _TextureBarrier_fnptr();
        }
        
        private static delegate* unmanaged<ShaderHandle, byte*, uint, uint*, uint*, void> _SpecializeShader_fnptr = &SpecializeShader_Lazy;
        public static void SpecializeShader(ShaderHandle shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => _SpecializeShader_fnptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        [UnmanagedCallersOnly]
        private static void SpecializeShader_Lazy(ShaderHandle shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue)
        {
            _SpecializeShader_fnptr = (delegate* unmanaged<ShaderHandle, byte*, uint, uint*, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSpecializeShader");
            _SpecializeShader_fnptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        }
        
        private static delegate* unmanaged<PrimitiveType, void*, IntPtr, int, int, void> _MultiDrawArraysIndirectCount_fnptr = &MultiDrawArraysIndirectCount_Lazy;
        public static void MultiDrawArraysIndirectCount(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawArraysIndirectCount_fnptr(mode, indirect, drawcount, maxdrawcount, stride);
        [UnmanagedCallersOnly]
        private static void MultiDrawArraysIndirectCount_Lazy(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride)
        {
            _MultiDrawArraysIndirectCount_fnptr = (delegate* unmanaged<PrimitiveType, void*, IntPtr, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawArraysIndirectCount");
            _MultiDrawArraysIndirectCount_fnptr(mode, indirect, drawcount, maxdrawcount, stride);
        }
        
        private static delegate* unmanaged<PrimitiveType, DrawElementsType, void*, IntPtr, int, int, void> _MultiDrawElementsIndirectCount_fnptr = &MultiDrawElementsIndirectCount_Lazy;
        public static void MultiDrawElementsIndirectCount(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawElementsIndirectCount_fnptr(mode, type, indirect, drawcount, maxdrawcount, stride);
        [UnmanagedCallersOnly]
        private static void MultiDrawElementsIndirectCount_Lazy(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride)
        {
            _MultiDrawElementsIndirectCount_fnptr = (delegate* unmanaged<PrimitiveType, DrawElementsType, void*, IntPtr, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsIndirectCount");
            _MultiDrawElementsIndirectCount_fnptr(mode, type, indirect, drawcount, maxdrawcount, stride);
        }
        
        private static delegate* unmanaged<float, float, float, void> _PolygonOffsetClamp_fnptr = &PolygonOffsetClamp_Lazy;
        /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void PolygonOffsetClamp(float factor, float units, float clamp) => _PolygonOffsetClamp_fnptr(factor, units, clamp);
        [UnmanagedCallersOnly]
        private static void PolygonOffsetClamp_Lazy(float factor, float units, float clamp)
        {
            _PolygonOffsetClamp_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glPolygonOffsetClamp");
            _PolygonOffsetClamp_fnptr(factor, units, clamp);
        }
        
        public static unsafe partial class _3DFX
        {
            private static delegate* unmanaged<uint, void> _TbufferMask3DFX_fnptr = &TbufferMask3DFX_Lazy;
            /// <summary> <b>[requires: GL_3DFX_tbuffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TbufferMask3DFX(uint mask) => _TbufferMask3DFX_fnptr(mask);
            [UnmanagedCallersOnly]
            private static void TbufferMask3DFX_Lazy(uint mask)
            {
                _TbufferMask3DFX_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glTbufferMask3DFX");
                _TbufferMask3DFX_fnptr(mask);
            }
            
        }
        public static unsafe partial class AMD
        {
            private static delegate* unmanaged<All, DebugSeverity, int, uint*, byte, void> _DebugMessageEnableAMD_fnptr = &DebugMessageEnableAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageEnableAMD(All category, DebugSeverity severity, int count, uint* ids, byte enabled) => _DebugMessageEnableAMD_fnptr(category, severity, count, ids, enabled);
            [UnmanagedCallersOnly]
            private static void DebugMessageEnableAMD_Lazy(All category, DebugSeverity severity, int count, uint* ids, byte enabled)
            {
                _DebugMessageEnableAMD_fnptr = (delegate* unmanaged<All, DebugSeverity, int, uint*, byte, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageEnableAMD");
                _DebugMessageEnableAMD_fnptr(category, severity, count, ids, enabled);
            }
            
            private static delegate* unmanaged<All, DebugSeverity, uint, int, byte*, void> _DebugMessageInsertAMD_fnptr = &DebugMessageInsertAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageInsertAMD(All category, DebugSeverity severity, uint id, int length, byte* buf) => _DebugMessageInsertAMD_fnptr(category, severity, id, length, buf);
            [UnmanagedCallersOnly]
            private static void DebugMessageInsertAMD_Lazy(All category, DebugSeverity severity, uint id, int length, byte* buf)
            {
                _DebugMessageInsertAMD_fnptr = (delegate* unmanaged<All, DebugSeverity, uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageInsertAMD");
                _DebugMessageInsertAMD_fnptr(category, severity, id, length, buf);
            }
            
            private static delegate* unmanaged<IntPtr, void*, void> _DebugMessageCallbackAMD_fnptr = &DebugMessageCallbackAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageCallbackAMD(IntPtr callback, void* userParam) => _DebugMessageCallbackAMD_fnptr(callback, userParam);
            [UnmanagedCallersOnly]
            private static void DebugMessageCallbackAMD_Lazy(IntPtr callback, void* userParam)
            {
                _DebugMessageCallbackAMD_fnptr = (delegate* unmanaged<IntPtr, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageCallbackAMD");
                _DebugMessageCallbackAMD_fnptr(callback, userParam);
            }
            
            private static delegate* unmanaged<uint, int, All*, uint*, uint*, int*, byte*, uint> _GetDebugMessageLogAMD_fnptr = &GetDebugMessageLogAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GetDebugMessageLogAMD(uint count, int bufSize, All* categories, uint* severities, uint* ids, int* lengths, byte* message) => _GetDebugMessageLogAMD_fnptr(count, bufSize, categories, severities, ids, lengths, message);
            [UnmanagedCallersOnly]
            private static uint GetDebugMessageLogAMD_Lazy(uint count, int bufSize, All* categories, uint* severities, uint* ids, int* lengths, byte* message)
            {
                _GetDebugMessageLogAMD_fnptr = (delegate* unmanaged<uint, int, All*, uint*, uint*, int*, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetDebugMessageLogAMD");
                return _GetDebugMessageLogAMD_fnptr(count, bufSize, categories, severities, ids, lengths, message);
            }
            
            private static delegate* unmanaged<uint, All, All, void> _BlendFuncIndexedAMD_fnptr = &BlendFuncIndexedAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncIndexedAMD(uint buf, All src, All dst) => _BlendFuncIndexedAMD_fnptr(buf, src, dst);
            [UnmanagedCallersOnly]
            private static void BlendFuncIndexedAMD_Lazy(uint buf, All src, All dst)
            {
                _BlendFuncIndexedAMD_fnptr = (delegate* unmanaged<uint, All, All, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFuncIndexedAMD");
                _BlendFuncIndexedAMD_fnptr(buf, src, dst);
            }
            
            private static delegate* unmanaged<uint, BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void> _BlendFuncSeparateIndexedAMD_fnptr = &BlendFuncSeparateIndexedAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncSeparateIndexedAMD(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => _BlendFuncSeparateIndexedAMD_fnptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
            [UnmanagedCallersOnly]
            private static void BlendFuncSeparateIndexedAMD_Lazy(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha)
            {
                _BlendFuncSeparateIndexedAMD_fnptr = (delegate* unmanaged<uint, BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFuncSeparateIndexedAMD");
                _BlendFuncSeparateIndexedAMD_fnptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
            }
            
            private static delegate* unmanaged<uint, BlendEquationModeEXT, void> _BlendEquationIndexedAMD_fnptr = &BlendEquationIndexedAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationIndexedAMD(uint buf, BlendEquationModeEXT mode) => _BlendEquationIndexedAMD_fnptr(buf, mode);
            [UnmanagedCallersOnly]
            private static void BlendEquationIndexedAMD_Lazy(uint buf, BlendEquationModeEXT mode)
            {
                _BlendEquationIndexedAMD_fnptr = (delegate* unmanaged<uint, BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquationIndexedAMD");
                _BlendEquationIndexedAMD_fnptr(buf, mode);
            }
            
            private static delegate* unmanaged<uint, BlendEquationModeEXT, BlendEquationModeEXT, void> _BlendEquationSeparateIndexedAMD_fnptr = &BlendEquationSeparateIndexedAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationSeparateIndexedAMD(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparateIndexedAMD_fnptr(buf, modeRGB, modeAlpha);
            [UnmanagedCallersOnly]
            private static void BlendEquationSeparateIndexedAMD_Lazy(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha)
            {
                _BlendEquationSeparateIndexedAMD_fnptr = (delegate* unmanaged<uint, BlendEquationModeEXT, BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquationSeparateIndexedAMD");
                _BlendEquationSeparateIndexedAMD_fnptr(buf, modeRGB, modeAlpha);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, int, int, InternalFormat, int, int, void> _RenderbufferStorageMultisampleAdvancedAMD_fnptr = &RenderbufferStorageMultisampleAdvancedAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderbufferStorageMultisampleAdvancedAMD(RenderbufferTarget target, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleAdvancedAMD_fnptr(target, samples, storageSamples, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void RenderbufferStorageMultisampleAdvancedAMD_Lazy(RenderbufferTarget target, int samples, int storageSamples, InternalFormat internalformat, int width, int height)
            {
                _RenderbufferStorageMultisampleAdvancedAMD_fnptr = (delegate* unmanaged<RenderbufferTarget, int, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRenderbufferStorageMultisampleAdvancedAMD");
                _RenderbufferStorageMultisampleAdvancedAMD_fnptr(target, samples, storageSamples, internalformat, width, height);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, int, int, InternalFormat, int, int, void> _NamedRenderbufferStorageMultisampleAdvancedAMD_fnptr = &NamedRenderbufferStorageMultisampleAdvancedAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedRenderbufferStorageMultisampleAdvancedAMD(RenderbufferHandle renderbuffer, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageMultisampleAdvancedAMD_fnptr(renderbuffer, samples, storageSamples, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void NamedRenderbufferStorageMultisampleAdvancedAMD_Lazy(RenderbufferHandle renderbuffer, int samples, int storageSamples, InternalFormat internalformat, int width, int height)
            {
                _NamedRenderbufferStorageMultisampleAdvancedAMD_fnptr = (delegate* unmanaged<RenderbufferHandle, int, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedRenderbufferStorageMultisampleAdvancedAMD");
                _NamedRenderbufferStorageMultisampleAdvancedAMD_fnptr(renderbuffer, samples, storageSamples, internalformat, width, height);
            }
            
            private static delegate* unmanaged<FramebufferTarget, uint, uint, float*, void> _FramebufferSamplePositionsfvAMD_fnptr = &FramebufferSamplePositionsfvAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferSamplePositionsfvAMD(FramebufferTarget target, uint numsamples, uint pixelindex, float* values) => _FramebufferSamplePositionsfvAMD_fnptr(target, numsamples, pixelindex, values);
            [UnmanagedCallersOnly]
            private static void FramebufferSamplePositionsfvAMD_Lazy(FramebufferTarget target, uint numsamples, uint pixelindex, float* values)
            {
                _FramebufferSamplePositionsfvAMD_fnptr = (delegate* unmanaged<FramebufferTarget, uint, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferSamplePositionsfvAMD");
                _FramebufferSamplePositionsfvAMD_fnptr(target, numsamples, pixelindex, values);
            }
            
            private static delegate* unmanaged<FramebufferHandle, uint, uint, float*, void> _NamedFramebufferSamplePositionsfvAMD_fnptr = &NamedFramebufferSamplePositionsfvAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferSamplePositionsfvAMD(FramebufferHandle framebuffer, uint numsamples, uint pixelindex, float* values) => _NamedFramebufferSamplePositionsfvAMD_fnptr(framebuffer, numsamples, pixelindex, values);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferSamplePositionsfvAMD_Lazy(FramebufferHandle framebuffer, uint numsamples, uint pixelindex, float* values)
            {
                _NamedFramebufferSamplePositionsfvAMD_fnptr = (delegate* unmanaged<FramebufferHandle, uint, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferSamplePositionsfvAMD");
                _NamedFramebufferSamplePositionsfvAMD_fnptr(framebuffer, numsamples, pixelindex, values);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachmentParameterName, uint, uint, int, float*, void> _GetFramebufferParameterfvAMD_fnptr = &GetFramebufferParameterfvAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFramebufferParameterfvAMD(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, float* values) => _GetFramebufferParameterfvAMD_fnptr(target, pname, numsamples, pixelindex, size, values);
            [UnmanagedCallersOnly]
            private static void GetFramebufferParameterfvAMD_Lazy(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, float* values)
            {
                _GetFramebufferParameterfvAMD_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachmentParameterName, uint, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFramebufferParameterfvAMD");
                _GetFramebufferParameterfvAMD_fnptr(target, pname, numsamples, pixelindex, size, values);
            }
            
            private static delegate* unmanaged<FramebufferHandle, All, uint, uint, int, float*, void> _GetNamedFramebufferParameterfvAMD_fnptr = &GetNamedFramebufferParameterfvAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedFramebufferParameterfvAMD(FramebufferHandle framebuffer, All pname, uint numsamples, uint pixelindex, int size, float* values) => _GetNamedFramebufferParameterfvAMD_fnptr(framebuffer, pname, numsamples, pixelindex, size, values);
            [UnmanagedCallersOnly]
            private static void GetNamedFramebufferParameterfvAMD_Lazy(FramebufferHandle framebuffer, All pname, uint numsamples, uint pixelindex, int size, float* values)
            {
                _GetNamedFramebufferParameterfvAMD_fnptr = (delegate* unmanaged<FramebufferHandle, All, uint, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedFramebufferParameterfvAMD");
                _GetNamedFramebufferParameterfvAMD_fnptr(framebuffer, pname, numsamples, pixelindex, size, values);
            }
            
            private static delegate* unmanaged<int, long, void> _Uniform1i64NV_fnptr = &Uniform1i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64NV(int location, long x) => _Uniform1i64NV_fnptr(location, x);
            [UnmanagedCallersOnly]
            private static void Uniform1i64NV_Lazy(int location, long x)
            {
                _Uniform1i64NV_fnptr = (delegate* unmanaged<int, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1i64NV");
                _Uniform1i64NV_fnptr(location, x);
            }
            
            private static delegate* unmanaged<int, long, long, void> _Uniform2i64NV_fnptr = &Uniform2i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64NV(int location, long x, long y) => _Uniform2i64NV_fnptr(location, x, y);
            [UnmanagedCallersOnly]
            private static void Uniform2i64NV_Lazy(int location, long x, long y)
            {
                _Uniform2i64NV_fnptr = (delegate* unmanaged<int, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2i64NV");
                _Uniform2i64NV_fnptr(location, x, y);
            }
            
            private static delegate* unmanaged<int, long, long, long, void> _Uniform3i64NV_fnptr = &Uniform3i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64NV(int location, long x, long y, long z) => _Uniform3i64NV_fnptr(location, x, y, z);
            [UnmanagedCallersOnly]
            private static void Uniform3i64NV_Lazy(int location, long x, long y, long z)
            {
                _Uniform3i64NV_fnptr = (delegate* unmanaged<int, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3i64NV");
                _Uniform3i64NV_fnptr(location, x, y, z);
            }
            
            private static delegate* unmanaged<int, long, long, long, long, void> _Uniform4i64NV_fnptr = &Uniform4i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64NV(int location, long x, long y, long z, long w) => _Uniform4i64NV_fnptr(location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void Uniform4i64NV_Lazy(int location, long x, long y, long z, long w)
            {
                _Uniform4i64NV_fnptr = (delegate* unmanaged<int, long, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4i64NV");
                _Uniform4i64NV_fnptr(location, x, y, z, w);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform1i64vNV_fnptr = &Uniform1i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64vNV(int location, int count, long* value) => _Uniform1i64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1i64vNV_Lazy(int location, int count, long* value)
            {
                _Uniform1i64vNV_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1i64vNV");
                _Uniform1i64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform2i64vNV_fnptr = &Uniform2i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64vNV(int location, int count, long* value) => _Uniform2i64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2i64vNV_Lazy(int location, int count, long* value)
            {
                _Uniform2i64vNV_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2i64vNV");
                _Uniform2i64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform3i64vNV_fnptr = &Uniform3i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64vNV(int location, int count, long* value) => _Uniform3i64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3i64vNV_Lazy(int location, int count, long* value)
            {
                _Uniform3i64vNV_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3i64vNV");
                _Uniform3i64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform4i64vNV_fnptr = &Uniform4i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64vNV(int location, int count, long* value) => _Uniform4i64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4i64vNV_Lazy(int location, int count, long* value)
            {
                _Uniform4i64vNV_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4i64vNV");
                _Uniform4i64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, ulong, void> _Uniform1ui64NV_fnptr = &Uniform1ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64NV(int location, ulong x) => _Uniform1ui64NV_fnptr(location, x);
            [UnmanagedCallersOnly]
            private static void Uniform1ui64NV_Lazy(int location, ulong x)
            {
                _Uniform1ui64NV_fnptr = (delegate* unmanaged<int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1ui64NV");
                _Uniform1ui64NV_fnptr(location, x);
            }
            
            private static delegate* unmanaged<int, ulong, ulong, void> _Uniform2ui64NV_fnptr = &Uniform2ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64NV(int location, ulong x, ulong y) => _Uniform2ui64NV_fnptr(location, x, y);
            [UnmanagedCallersOnly]
            private static void Uniform2ui64NV_Lazy(int location, ulong x, ulong y)
            {
                _Uniform2ui64NV_fnptr = (delegate* unmanaged<int, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2ui64NV");
                _Uniform2ui64NV_fnptr(location, x, y);
            }
            
            private static delegate* unmanaged<int, ulong, ulong, ulong, void> _Uniform3ui64NV_fnptr = &Uniform3ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z) => _Uniform3ui64NV_fnptr(location, x, y, z);
            [UnmanagedCallersOnly]
            private static void Uniform3ui64NV_Lazy(int location, ulong x, ulong y, ulong z)
            {
                _Uniform3ui64NV_fnptr = (delegate* unmanaged<int, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3ui64NV");
                _Uniform3ui64NV_fnptr(location, x, y, z);
            }
            
            private static delegate* unmanaged<int, ulong, ulong, ulong, ulong, void> _Uniform4ui64NV_fnptr = &Uniform4ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) => _Uniform4ui64NV_fnptr(location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void Uniform4ui64NV_Lazy(int location, ulong x, ulong y, ulong z, ulong w)
            {
                _Uniform4ui64NV_fnptr = (delegate* unmanaged<int, ulong, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4ui64NV");
                _Uniform4ui64NV_fnptr(location, x, y, z, w);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform1ui64vNV_fnptr = &Uniform1ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64vNV(int location, int count, ulong* value) => _Uniform1ui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1ui64vNV_Lazy(int location, int count, ulong* value)
            {
                _Uniform1ui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1ui64vNV");
                _Uniform1ui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform2ui64vNV_fnptr = &Uniform2ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64vNV(int location, int count, ulong* value) => _Uniform2ui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2ui64vNV_Lazy(int location, int count, ulong* value)
            {
                _Uniform2ui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2ui64vNV");
                _Uniform2ui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform3ui64vNV_fnptr = &Uniform3ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64vNV(int location, int count, ulong* value) => _Uniform3ui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3ui64vNV_Lazy(int location, int count, ulong* value)
            {
                _Uniform3ui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3ui64vNV");
                _Uniform3ui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform4ui64vNV_fnptr = &Uniform4ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64vNV(int location, int count, ulong* value) => _Uniform4ui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4ui64vNV_Lazy(int location, int count, ulong* value)
            {
                _Uniform4ui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4ui64vNV");
                _Uniform4ui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long*, void> _GetUniformi64vNV_fnptr = &GetUniformi64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformi64vNV(ProgramHandle program, int location, long* parameters) => _GetUniformi64vNV_fnptr(program, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformi64vNV_Lazy(ProgramHandle program, int location, long* parameters)
            {
                _GetUniformi64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformi64vNV");
                _GetUniformi64vNV_fnptr(program, location, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong*, void> _GetUniformui64vNV_fnptr = &GetUniformui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformui64vNV(ProgramHandle program, int location, ulong* parameters) => _GetUniformui64vNV_fnptr(program, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformui64vNV_Lazy(ProgramHandle program, int location, ulong* parameters)
            {
                _GetUniformui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformui64vNV");
                _GetUniformui64vNV_fnptr(program, location, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, void> _ProgramUniform1i64NV_fnptr = &ProgramUniform1i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64NV(ProgramHandle program, int location, long x) => _ProgramUniform1i64NV_fnptr(program, location, x);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1i64NV_Lazy(ProgramHandle program, int location, long x)
            {
                _ProgramUniform1i64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1i64NV");
                _ProgramUniform1i64NV_fnptr(program, location, x);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, long, void> _ProgramUniform2i64NV_fnptr = &ProgramUniform2i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64NV(ProgramHandle program, int location, long x, long y) => _ProgramUniform2i64NV_fnptr(program, location, x, y);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2i64NV_Lazy(ProgramHandle program, int location, long x, long y)
            {
                _ProgramUniform2i64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2i64NV");
                _ProgramUniform2i64NV_fnptr(program, location, x, y);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, long, long, void> _ProgramUniform3i64NV_fnptr = &ProgramUniform3i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64NV(ProgramHandle program, int location, long x, long y, long z) => _ProgramUniform3i64NV_fnptr(program, location, x, y, z);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3i64NV_Lazy(ProgramHandle program, int location, long x, long y, long z)
            {
                _ProgramUniform3i64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3i64NV");
                _ProgramUniform3i64NV_fnptr(program, location, x, y, z);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, long, long, long, void> _ProgramUniform4i64NV_fnptr = &ProgramUniform4i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64NV(ProgramHandle program, int location, long x, long y, long z, long w) => _ProgramUniform4i64NV_fnptr(program, location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4i64NV_Lazy(ProgramHandle program, int location, long x, long y, long z, long w)
            {
                _ProgramUniform4i64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, long, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4i64NV");
                _ProgramUniform4i64NV_fnptr(program, location, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform1i64vNV_fnptr = &ProgramUniform1i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64vNV(ProgramHandle program, int location, int count, long* value) => _ProgramUniform1i64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1i64vNV_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform1i64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1i64vNV");
                _ProgramUniform1i64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform2i64vNV_fnptr = &ProgramUniform2i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64vNV(ProgramHandle program, int location, int count, long* value) => _ProgramUniform2i64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2i64vNV_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform2i64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2i64vNV");
                _ProgramUniform2i64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform3i64vNV_fnptr = &ProgramUniform3i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64vNV(ProgramHandle program, int location, int count, long* value) => _ProgramUniform3i64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3i64vNV_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform3i64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3i64vNV");
                _ProgramUniform3i64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform4i64vNV_fnptr = &ProgramUniform4i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64vNV(ProgramHandle program, int location, int count, long* value) => _ProgramUniform4i64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4i64vNV_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform4i64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4i64vNV");
                _ProgramUniform4i64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, void> _ProgramUniform1ui64NV_fnptr = &ProgramUniform1ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64NV(ProgramHandle program, int location, ulong x) => _ProgramUniform1ui64NV_fnptr(program, location, x);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1ui64NV_Lazy(ProgramHandle program, int location, ulong x)
            {
                _ProgramUniform1ui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1ui64NV");
                _ProgramUniform1ui64NV_fnptr(program, location, x);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, ulong, void> _ProgramUniform2ui64NV_fnptr = &ProgramUniform2ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64NV(ProgramHandle program, int location, ulong x, ulong y) => _ProgramUniform2ui64NV_fnptr(program, location, x, y);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2ui64NV_Lazy(ProgramHandle program, int location, ulong x, ulong y)
            {
                _ProgramUniform2ui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2ui64NV");
                _ProgramUniform2ui64NV_fnptr(program, location, x, y);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, void> _ProgramUniform3ui64NV_fnptr = &ProgramUniform3ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64NV(ProgramHandle program, int location, ulong x, ulong y, ulong z) => _ProgramUniform3ui64NV_fnptr(program, location, x, y, z);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3ui64NV_Lazy(ProgramHandle program, int location, ulong x, ulong y, ulong z)
            {
                _ProgramUniform3ui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3ui64NV");
                _ProgramUniform3ui64NV_fnptr(program, location, x, y, z);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, ulong, void> _ProgramUniform4ui64NV_fnptr = &ProgramUniform4ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64NV(ProgramHandle program, int location, ulong x, ulong y, ulong z, ulong w) => _ProgramUniform4ui64NV_fnptr(program, location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4ui64NV_Lazy(ProgramHandle program, int location, ulong x, ulong y, ulong z, ulong w)
            {
                _ProgramUniform4ui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4ui64NV");
                _ProgramUniform4ui64NV_fnptr(program, location, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform1ui64vNV_fnptr = &ProgramUniform1ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64vNV(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform1ui64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1ui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform1ui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1ui64vNV");
                _ProgramUniform1ui64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform2ui64vNV_fnptr = &ProgramUniform2ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64vNV(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform2ui64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2ui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform2ui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2ui64vNV");
                _ProgramUniform2ui64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform3ui64vNV_fnptr = &ProgramUniform3ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64vNV(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform3ui64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3ui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform3ui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3ui64vNV");
                _ProgramUniform3ui64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform4ui64vNV_fnptr = &ProgramUniform4ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64vNV(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform4ui64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4ui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform4ui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4ui64vNV");
                _ProgramUniform4ui64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<uint, All, int, void> _VertexAttribParameteriAMD_fnptr = &VertexAttribParameteriAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_interleaved_elements]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribParameteriAMD(uint index, All pname, int param) => _VertexAttribParameteriAMD_fnptr(index, pname, param);
            [UnmanagedCallersOnly]
            private static void VertexAttribParameteriAMD_Lazy(uint index, All pname, int param)
            {
                _VertexAttribParameteriAMD_fnptr = (delegate* unmanaged<uint, All, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribParameteriAMD");
                _VertexAttribParameteriAMD_fnptr(index, pname, param);
            }
            
            private static delegate* unmanaged<PrimitiveType, void*, int, int, void> _MultiDrawArraysIndirectAMD_fnptr = &MultiDrawArraysIndirectAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysIndirectAMD(PrimitiveType mode, void* indirect, int primcount, int stride) => _MultiDrawArraysIndirectAMD_fnptr(mode, indirect, primcount, stride);
            [UnmanagedCallersOnly]
            private static void MultiDrawArraysIndirectAMD_Lazy(PrimitiveType mode, void* indirect, int primcount, int stride)
            {
                _MultiDrawArraysIndirectAMD_fnptr = (delegate* unmanaged<PrimitiveType, void*, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawArraysIndirectAMD");
                _MultiDrawArraysIndirectAMD_fnptr(mode, indirect, primcount, stride);
            }
            
            private static delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, void> _MultiDrawElementsIndirectAMD_fnptr = &MultiDrawElementsIndirectAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsIndirectAMD(PrimitiveType mode, DrawElementsType type, void* indirect, int primcount, int stride) => _MultiDrawElementsIndirectAMD_fnptr(mode, type, indirect, primcount, stride);
            [UnmanagedCallersOnly]
            private static void MultiDrawElementsIndirectAMD_Lazy(PrimitiveType mode, DrawElementsType type, void* indirect, int primcount, int stride)
            {
                _MultiDrawElementsIndirectAMD_fnptr = (delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsIndirectAMD");
                _MultiDrawElementsIndirectAMD_fnptr(mode, type, indirect, primcount, stride);
            }
            
            private static delegate* unmanaged<All, uint, uint*, void> _GenNamesAMD_fnptr = &GenNamesAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenNamesAMD(All identifier, uint num, uint* names) => _GenNamesAMD_fnptr(identifier, num, names);
            [UnmanagedCallersOnly]
            private static void GenNamesAMD_Lazy(All identifier, uint num, uint* names)
            {
                _GenNamesAMD_fnptr = (delegate* unmanaged<All, uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGenNamesAMD");
                _GenNamesAMD_fnptr(identifier, num, names);
            }
            
            private static delegate* unmanaged<All, uint, uint*, void> _DeleteNamesAMD_fnptr = &DeleteNamesAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteNamesAMD(All identifier, uint num, uint* names) => _DeleteNamesAMD_fnptr(identifier, num, names);
            [UnmanagedCallersOnly]
            private static void DeleteNamesAMD_Lazy(All identifier, uint num, uint* names)
            {
                _DeleteNamesAMD_fnptr = (delegate* unmanaged<All, uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteNamesAMD");
                _DeleteNamesAMD_fnptr(identifier, num, names);
            }
            
            private static delegate* unmanaged<All, uint, byte> _IsNameAMD_fnptr = &IsNameAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsNameAMD(All identifier, uint name) => _IsNameAMD_fnptr(identifier, name);
            [UnmanagedCallersOnly]
            private static byte IsNameAMD_Lazy(All identifier, uint name)
            {
                _IsNameAMD_fnptr = (delegate* unmanaged<All, uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsNameAMD");
                return _IsNameAMD_fnptr(identifier, name);
            }
            
            private static delegate* unmanaged<QueryTarget, QueryHandle, All, uint, void> _QueryObjectParameteruiAMD_fnptr = &QueryObjectParameteruiAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_occlusion_query_event]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void QueryObjectParameteruiAMD(QueryTarget target, QueryHandle id, All pname, uint param) => _QueryObjectParameteruiAMD_fnptr(target, id, pname, param);
            [UnmanagedCallersOnly]
            private static void QueryObjectParameteruiAMD_Lazy(QueryTarget target, QueryHandle id, All pname, uint param)
            {
                _QueryObjectParameteruiAMD_fnptr = (delegate* unmanaged<QueryTarget, QueryHandle, All, uint, void>)GLLoader.BindingsContext.GetProcAddress("glQueryObjectParameteruiAMD");
                _QueryObjectParameteruiAMD_fnptr(target, id, pname, param);
            }
            
            private static delegate* unmanaged<int*, int, uint*, void> _GetPerfMonitorGroupsAMD_fnptr = &GetPerfMonitorGroupsAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorGroupsAMD(int* numGroups, int groupsSize, uint* groups) => _GetPerfMonitorGroupsAMD_fnptr(numGroups, groupsSize, groups);
            [UnmanagedCallersOnly]
            private static void GetPerfMonitorGroupsAMD_Lazy(int* numGroups, int groupsSize, uint* groups)
            {
                _GetPerfMonitorGroupsAMD_fnptr = (delegate* unmanaged<int*, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfMonitorGroupsAMD");
                _GetPerfMonitorGroupsAMD_fnptr(numGroups, groupsSize, groups);
            }
            
            private static delegate* unmanaged<uint, int*, int*, int, uint*, void> _GetPerfMonitorCountersAMD_fnptr = &GetPerfMonitorCountersAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorCountersAMD(uint group, int* numCounters, int* maxActiveCounters, int counterSize, uint* counters) => _GetPerfMonitorCountersAMD_fnptr(group, numCounters, maxActiveCounters, counterSize, counters);
            [UnmanagedCallersOnly]
            private static void GetPerfMonitorCountersAMD_Lazy(uint group, int* numCounters, int* maxActiveCounters, int counterSize, uint* counters)
            {
                _GetPerfMonitorCountersAMD_fnptr = (delegate* unmanaged<uint, int*, int*, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfMonitorCountersAMD");
                _GetPerfMonitorCountersAMD_fnptr(group, numCounters, maxActiveCounters, counterSize, counters);
            }
            
            private static delegate* unmanaged<uint, int, int*, byte*, void> _GetPerfMonitorGroupStringAMD_fnptr = &GetPerfMonitorGroupStringAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorGroupStringAMD(uint group, int bufSize, int* length, byte* groupString) => _GetPerfMonitorGroupStringAMD_fnptr(group, bufSize, length, groupString);
            [UnmanagedCallersOnly]
            private static void GetPerfMonitorGroupStringAMD_Lazy(uint group, int bufSize, int* length, byte* groupString)
            {
                _GetPerfMonitorGroupStringAMD_fnptr = (delegate* unmanaged<uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfMonitorGroupStringAMD");
                _GetPerfMonitorGroupStringAMD_fnptr(group, bufSize, length, groupString);
            }
            
            private static delegate* unmanaged<uint, uint, int, int*, byte*, void> _GetPerfMonitorCounterStringAMD_fnptr = &GetPerfMonitorCounterStringAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, int* length, byte* counterString) => _GetPerfMonitorCounterStringAMD_fnptr(group, counter, bufSize, length, counterString);
            [UnmanagedCallersOnly]
            private static void GetPerfMonitorCounterStringAMD_Lazy(uint group, uint counter, int bufSize, int* length, byte* counterString)
            {
                _GetPerfMonitorCounterStringAMD_fnptr = (delegate* unmanaged<uint, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfMonitorCounterStringAMD");
                _GetPerfMonitorCounterStringAMD_fnptr(group, counter, bufSize, length, counterString);
            }
            
            private static delegate* unmanaged<uint, uint, All, void*, void> _GetPerfMonitorCounterInfoAMD_fnptr = &GetPerfMonitorCounterInfoAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorCounterInfoAMD(uint group, uint counter, All pname, void* data) => _GetPerfMonitorCounterInfoAMD_fnptr(group, counter, pname, data);
            [UnmanagedCallersOnly]
            private static void GetPerfMonitorCounterInfoAMD_Lazy(uint group, uint counter, All pname, void* data)
            {
                _GetPerfMonitorCounterInfoAMD_fnptr = (delegate* unmanaged<uint, uint, All, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfMonitorCounterInfoAMD");
                _GetPerfMonitorCounterInfoAMD_fnptr(group, counter, pname, data);
            }
            
            private static delegate* unmanaged<int, uint*, void> _GenPerfMonitorsAMD_fnptr = &GenPerfMonitorsAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenPerfMonitorsAMD(int n, uint* monitors) => _GenPerfMonitorsAMD_fnptr(n, monitors);
            [UnmanagedCallersOnly]
            private static void GenPerfMonitorsAMD_Lazy(int n, uint* monitors)
            {
                _GenPerfMonitorsAMD_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGenPerfMonitorsAMD");
                _GenPerfMonitorsAMD_fnptr(n, monitors);
            }
            
            private static delegate* unmanaged<int, uint*, void> _DeletePerfMonitorsAMD_fnptr = &DeletePerfMonitorsAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeletePerfMonitorsAMD(int n, uint* monitors) => _DeletePerfMonitorsAMD_fnptr(n, monitors);
            [UnmanagedCallersOnly]
            private static void DeletePerfMonitorsAMD_Lazy(int n, uint* monitors)
            {
                _DeletePerfMonitorsAMD_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glDeletePerfMonitorsAMD");
                _DeletePerfMonitorsAMD_fnptr(n, monitors);
            }
            
            private static delegate* unmanaged<uint, byte, uint, int, uint*, void> _SelectPerfMonitorCountersAMD_fnptr = &SelectPerfMonitorCountersAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SelectPerfMonitorCountersAMD(uint monitor, byte enable, uint group, int numCounters, uint* counterList) => _SelectPerfMonitorCountersAMD_fnptr(monitor, enable, group, numCounters, counterList);
            [UnmanagedCallersOnly]
            private static void SelectPerfMonitorCountersAMD_Lazy(uint monitor, byte enable, uint group, int numCounters, uint* counterList)
            {
                _SelectPerfMonitorCountersAMD_fnptr = (delegate* unmanaged<uint, byte, uint, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSelectPerfMonitorCountersAMD");
                _SelectPerfMonitorCountersAMD_fnptr(monitor, enable, group, numCounters, counterList);
            }
            
            private static delegate* unmanaged<uint, void> _BeginPerfMonitorAMD_fnptr = &BeginPerfMonitorAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginPerfMonitorAMD(uint monitor) => _BeginPerfMonitorAMD_fnptr(monitor);
            [UnmanagedCallersOnly]
            private static void BeginPerfMonitorAMD_Lazy(uint monitor)
            {
                _BeginPerfMonitorAMD_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glBeginPerfMonitorAMD");
                _BeginPerfMonitorAMD_fnptr(monitor);
            }
            
            private static delegate* unmanaged<uint, void> _EndPerfMonitorAMD_fnptr = &EndPerfMonitorAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndPerfMonitorAMD(uint monitor) => _EndPerfMonitorAMD_fnptr(monitor);
            [UnmanagedCallersOnly]
            private static void EndPerfMonitorAMD_Lazy(uint monitor)
            {
                _EndPerfMonitorAMD_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glEndPerfMonitorAMD");
                _EndPerfMonitorAMD_fnptr(monitor);
            }
            
            private static delegate* unmanaged<uint, All, int, uint*, int*, void> _GetPerfMonitorCounterDataAMD_fnptr = &GetPerfMonitorCounterDataAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorCounterDataAMD(uint monitor, All pname, int dataSize, uint* data, int* bytesWritten) => _GetPerfMonitorCounterDataAMD_fnptr(monitor, pname, dataSize, data, bytesWritten);
            [UnmanagedCallersOnly]
            private static void GetPerfMonitorCounterDataAMD_Lazy(uint monitor, All pname, int dataSize, uint* data, int* bytesWritten)
            {
                _GetPerfMonitorCounterDataAMD_fnptr = (delegate* unmanaged<uint, All, int, uint*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfMonitorCounterDataAMD");
                _GetPerfMonitorCounterDataAMD_fnptr(monitor, pname, dataSize, data, bytesWritten);
            }
            
            private static delegate* unmanaged<All, uint, float*, void> _SetMultisamplefvAMD_fnptr = &SetMultisamplefvAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetMultisamplefvAMD(All pname, uint index, float* val) => _SetMultisamplefvAMD_fnptr(pname, index, val);
            [UnmanagedCallersOnly]
            private static void SetMultisamplefvAMD_Lazy(All pname, uint index, float* val)
            {
                _SetMultisamplefvAMD_fnptr = (delegate* unmanaged<All, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glSetMultisamplefvAMD");
                _SetMultisamplefvAMD_fnptr(pname, index, val);
            }
            
            private static delegate* unmanaged<TextureTarget, SizedInternalFormat, int, int, int, int, TextureStorageMaskAMD, void> _TexStorageSparseAMD_fnptr = &TexStorageSparseAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_sparse_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageSparseAMD(TextureTarget target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => _TexStorageSparseAMD_fnptr(target, internalFormat, width, height, depth, layers, flags);
            [UnmanagedCallersOnly]
            private static void TexStorageSparseAMD_Lazy(TextureTarget target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags)
            {
                _TexStorageSparseAMD_fnptr = (delegate* unmanaged<TextureTarget, SizedInternalFormat, int, int, int, int, TextureStorageMaskAMD, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorageSparseAMD");
                _TexStorageSparseAMD_fnptr(target, internalFormat, width, height, depth, layers, flags);
            }
            
            private static delegate* unmanaged<TextureHandle, All, SizedInternalFormat, int, int, int, int, TextureStorageMaskAMD, void> _TextureStorageSparseAMD_fnptr = &TextureStorageSparseAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_sparse_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageSparseAMD(TextureHandle texture, All target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => _TextureStorageSparseAMD_fnptr(texture, target, internalFormat, width, height, depth, layers, flags);
            [UnmanagedCallersOnly]
            private static void TextureStorageSparseAMD_Lazy(TextureHandle texture, All target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags)
            {
                _TextureStorageSparseAMD_fnptr = (delegate* unmanaged<TextureHandle, All, SizedInternalFormat, int, int, int, int, TextureStorageMaskAMD, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorageSparseAMD");
                _TextureStorageSparseAMD_fnptr(texture, target, internalFormat, width, height, depth, layers, flags);
            }
            
            private static delegate* unmanaged<StencilFaceDirection, uint, void> _StencilOpValueAMD_fnptr = &StencilOpValueAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_stencil_operation_extended]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilOpValueAMD(StencilFaceDirection face, uint value) => _StencilOpValueAMD_fnptr(face, value);
            [UnmanagedCallersOnly]
            private static void StencilOpValueAMD_Lazy(StencilFaceDirection face, uint value)
            {
                _StencilOpValueAMD_fnptr = (delegate* unmanaged<StencilFaceDirection, uint, void>)GLLoader.BindingsContext.GetProcAddress("glStencilOpValueAMD");
                _StencilOpValueAMD_fnptr(face, value);
            }
            
            private static delegate* unmanaged<float, void> _TessellationFactorAMD_fnptr = &TessellationFactorAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TessellationFactorAMD(float factor) => _TessellationFactorAMD_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void TessellationFactorAMD_Lazy(float factor)
            {
                _TessellationFactorAMD_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glTessellationFactorAMD");
                _TessellationFactorAMD_fnptr(factor);
            }
            
            private static delegate* unmanaged<All, void> _TessellationModeAMD_fnptr = &TessellationModeAMD_Lazy;
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TessellationModeAMD(All mode) => _TessellationModeAMD_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void TessellationModeAMD_Lazy(All mode)
            {
                _TessellationModeAMD_fnptr = (delegate* unmanaged<All, void>)GLLoader.BindingsContext.GetProcAddress("glTessellationModeAMD");
                _TessellationModeAMD_fnptr(mode);
            }
            
        }
        public static unsafe partial class APPLE
        {
            private static delegate* unmanaged<ElementPointerTypeATI, void*, void> _ElementPointerAPPLE_fnptr = &ElementPointerAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ElementPointerAPPLE(ElementPointerTypeATI type, void* pointer) => _ElementPointerAPPLE_fnptr(type, pointer);
            [UnmanagedCallersOnly]
            private static void ElementPointerAPPLE_Lazy(ElementPointerTypeATI type, void* pointer)
            {
                _ElementPointerAPPLE_fnptr = (delegate* unmanaged<ElementPointerTypeATI, void*, void>)GLLoader.BindingsContext.GetProcAddress("glElementPointerAPPLE");
                _ElementPointerAPPLE_fnptr(type, pointer);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, int, void> _DrawElementArrayAPPLE_fnptr = &DrawElementArrayAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawElementArrayAPPLE(PrimitiveType mode, int first, int count) => _DrawElementArrayAPPLE_fnptr(mode, first, count);
            [UnmanagedCallersOnly]
            private static void DrawElementArrayAPPLE_Lazy(PrimitiveType mode, int first, int count)
            {
                _DrawElementArrayAPPLE_fnptr = (delegate* unmanaged<PrimitiveType, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementArrayAPPLE");
                _DrawElementArrayAPPLE_fnptr(mode, first, count);
            }
            
            private static delegate* unmanaged<PrimitiveType, uint, uint, int, int, void> _DrawRangeElementArrayAPPLE_fnptr = &DrawRangeElementArrayAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int first, int count) => _DrawRangeElementArrayAPPLE_fnptr(mode, start, end, first, count);
            [UnmanagedCallersOnly]
            private static void DrawRangeElementArrayAPPLE_Lazy(PrimitiveType mode, uint start, uint end, int first, int count)
            {
                _DrawRangeElementArrayAPPLE_fnptr = (delegate* unmanaged<PrimitiveType, uint, uint, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawRangeElementArrayAPPLE");
                _DrawRangeElementArrayAPPLE_fnptr(mode, start, end, first, count);
            }
            
            private static delegate* unmanaged<PrimitiveType, int*, int*, int, void> _MultiDrawElementArrayAPPLE_fnptr = &MultiDrawElementArrayAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementArrayAPPLE(PrimitiveType mode, int* first, int* count, int primcount) => _MultiDrawElementArrayAPPLE_fnptr(mode, first, count, primcount);
            [UnmanagedCallersOnly]
            private static void MultiDrawElementArrayAPPLE_Lazy(PrimitiveType mode, int* first, int* count, int primcount)
            {
                _MultiDrawElementArrayAPPLE_fnptr = (delegate* unmanaged<PrimitiveType, int*, int*, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementArrayAPPLE");
                _MultiDrawElementArrayAPPLE_fnptr(mode, first, count, primcount);
            }
            
            private static delegate* unmanaged<PrimitiveType, uint, uint, int*, int*, int, void> _MultiDrawRangeElementArrayAPPLE_fnptr = &MultiDrawRangeElementArrayAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int* first, int* count, int primcount) => _MultiDrawRangeElementArrayAPPLE_fnptr(mode, start, end, first, count, primcount);
            [UnmanagedCallersOnly]
            private static void MultiDrawRangeElementArrayAPPLE_Lazy(PrimitiveType mode, uint start, uint end, int* first, int* count, int primcount)
            {
                _MultiDrawRangeElementArrayAPPLE_fnptr = (delegate* unmanaged<PrimitiveType, uint, uint, int*, int*, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawRangeElementArrayAPPLE");
                _MultiDrawRangeElementArrayAPPLE_fnptr(mode, start, end, first, count, primcount);
            }
            
            private static delegate* unmanaged<int, uint*, void> _GenFencesAPPLE_fnptr = &GenFencesAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenFencesAPPLE(int n, uint* fences) => _GenFencesAPPLE_fnptr(n, fences);
            [UnmanagedCallersOnly]
            private static void GenFencesAPPLE_Lazy(int n, uint* fences)
            {
                _GenFencesAPPLE_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGenFencesAPPLE");
                _GenFencesAPPLE_fnptr(n, fences);
            }
            
            private static delegate* unmanaged<int, uint*, void> _DeleteFencesAPPLE_fnptr = &DeleteFencesAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteFencesAPPLE(int n, uint* fences) => _DeleteFencesAPPLE_fnptr(n, fences);
            [UnmanagedCallersOnly]
            private static void DeleteFencesAPPLE_Lazy(int n, uint* fences)
            {
                _DeleteFencesAPPLE_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteFencesAPPLE");
                _DeleteFencesAPPLE_fnptr(n, fences);
            }
            
            private static delegate* unmanaged<uint, void> _SetFenceAPPLE_fnptr = &SetFenceAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetFenceAPPLE(uint fence) => _SetFenceAPPLE_fnptr(fence);
            [UnmanagedCallersOnly]
            private static void SetFenceAPPLE_Lazy(uint fence)
            {
                _SetFenceAPPLE_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glSetFenceAPPLE");
                _SetFenceAPPLE_fnptr(fence);
            }
            
            private static delegate* unmanaged<uint, byte> _IsFenceAPPLE_fnptr = &IsFenceAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsFenceAPPLE(uint fence) => _IsFenceAPPLE_fnptr(fence);
            [UnmanagedCallersOnly]
            private static byte IsFenceAPPLE_Lazy(uint fence)
            {
                _IsFenceAPPLE_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsFenceAPPLE");
                return _IsFenceAPPLE_fnptr(fence);
            }
            
            private static delegate* unmanaged<uint, byte> _TestFenceAPPLE_fnptr = &TestFenceAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte TestFenceAPPLE(uint fence) => _TestFenceAPPLE_fnptr(fence);
            [UnmanagedCallersOnly]
            private static byte TestFenceAPPLE_Lazy(uint fence)
            {
                _TestFenceAPPLE_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glTestFenceAPPLE");
                return _TestFenceAPPLE_fnptr(fence);
            }
            
            private static delegate* unmanaged<uint, void> _FinishFenceAPPLE_fnptr = &FinishFenceAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinishFenceAPPLE(uint fence) => _FinishFenceAPPLE_fnptr(fence);
            [UnmanagedCallersOnly]
            private static void FinishFenceAPPLE_Lazy(uint fence)
            {
                _FinishFenceAPPLE_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glFinishFenceAPPLE");
                _FinishFenceAPPLE_fnptr(fence);
            }
            
            private static delegate* unmanaged<ObjectTypeAPPLE, uint, byte> _TestObjectAPPLE_fnptr = &TestObjectAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte TestObjectAPPLE(ObjectTypeAPPLE obj, uint name) => _TestObjectAPPLE_fnptr(obj, name);
            [UnmanagedCallersOnly]
            private static byte TestObjectAPPLE_Lazy(ObjectTypeAPPLE obj, uint name)
            {
                _TestObjectAPPLE_fnptr = (delegate* unmanaged<ObjectTypeAPPLE, uint, byte>)GLLoader.BindingsContext.GetProcAddress("glTestObjectAPPLE");
                return _TestObjectAPPLE_fnptr(obj, name);
            }
            
            private static delegate* unmanaged<ObjectTypeAPPLE, int, void> _FinishObjectAPPLE_fnptr = &FinishObjectAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinishObjectAPPLE(ObjectTypeAPPLE obj, int name) => _FinishObjectAPPLE_fnptr(obj, name);
            [UnmanagedCallersOnly]
            private static void FinishObjectAPPLE_Lazy(ObjectTypeAPPLE obj, int name)
            {
                _FinishObjectAPPLE_fnptr = (delegate* unmanaged<ObjectTypeAPPLE, int, void>)GLLoader.BindingsContext.GetProcAddress("glFinishObjectAPPLE");
                _FinishObjectAPPLE_fnptr(obj, name);
            }
            
            private static delegate* unmanaged<All, All, int, void> _BufferParameteriAPPLE_fnptr = &BufferParameteriAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferParameteriAPPLE(All target, All pname, int param) => _BufferParameteriAPPLE_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void BufferParameteriAPPLE_Lazy(All target, All pname, int param)
            {
                _BufferParameteriAPPLE_fnptr = (delegate* unmanaged<All, All, int, void>)GLLoader.BindingsContext.GetProcAddress("glBufferParameteriAPPLE");
                _BufferParameteriAPPLE_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<BufferTargetARB, IntPtr, nint, void> _FlushMappedBufferRangeAPPLE_fnptr = &FlushMappedBufferRangeAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushMappedBufferRangeAPPLE(BufferTargetARB target, IntPtr offset, nint size) => _FlushMappedBufferRangeAPPLE_fnptr(target, offset, size);
            [UnmanagedCallersOnly]
            private static void FlushMappedBufferRangeAPPLE_Lazy(BufferTargetARB target, IntPtr offset, nint size)
            {
                _FlushMappedBufferRangeAPPLE_fnptr = (delegate* unmanaged<BufferTargetARB, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glFlushMappedBufferRangeAPPLE");
                _FlushMappedBufferRangeAPPLE_fnptr(target, offset, size);
            }
            
            private static delegate* unmanaged<All, uint, All, All> _ObjectPurgeableAPPLE_fnptr = &ObjectPurgeableAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All ObjectPurgeableAPPLE(All objectType, uint name, All option) => _ObjectPurgeableAPPLE_fnptr(objectType, name, option);
            [UnmanagedCallersOnly]
            private static All ObjectPurgeableAPPLE_Lazy(All objectType, uint name, All option)
            {
                _ObjectPurgeableAPPLE_fnptr = (delegate* unmanaged<All, uint, All, All>)GLLoader.BindingsContext.GetProcAddress("glObjectPurgeableAPPLE");
                return _ObjectPurgeableAPPLE_fnptr(objectType, name, option);
            }
            
            private static delegate* unmanaged<All, uint, All, All> _ObjectUnpurgeableAPPLE_fnptr = &ObjectUnpurgeableAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All ObjectUnpurgeableAPPLE(All objectType, uint name, All option) => _ObjectUnpurgeableAPPLE_fnptr(objectType, name, option);
            [UnmanagedCallersOnly]
            private static All ObjectUnpurgeableAPPLE_Lazy(All objectType, uint name, All option)
            {
                _ObjectUnpurgeableAPPLE_fnptr = (delegate* unmanaged<All, uint, All, All>)GLLoader.BindingsContext.GetProcAddress("glObjectUnpurgeableAPPLE");
                return _ObjectUnpurgeableAPPLE_fnptr(objectType, name, option);
            }
            
            private static delegate* unmanaged<All, uint, All, int*, void> _GetObjectParameterivAPPLE_fnptr = &GetObjectParameterivAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectParameterivAPPLE(All objectType, uint name, All pname, int* parameters) => _GetObjectParameterivAPPLE_fnptr(objectType, name, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetObjectParameterivAPPLE_Lazy(All objectType, uint name, All pname, int* parameters)
            {
                _GetObjectParameterivAPPLE_fnptr = (delegate* unmanaged<All, uint, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectParameterivAPPLE");
                _GetObjectParameterivAPPLE_fnptr(objectType, name, pname, parameters);
            }
            
            private static delegate* unmanaged<All, int, void*, void> _TextureRangeAPPLE_fnptr = &TextureRangeAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_texture_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureRangeAPPLE(All target, int length, void* pointer) => _TextureRangeAPPLE_fnptr(target, length, pointer);
            [UnmanagedCallersOnly]
            private static void TextureRangeAPPLE_Lazy(All target, int length, void* pointer)
            {
                _TextureRangeAPPLE_fnptr = (delegate* unmanaged<All, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureRangeAPPLE");
                _TextureRangeAPPLE_fnptr(target, length, pointer);
            }
            
            private static delegate* unmanaged<All, All, void**, void> _GetTexParameterPointervAPPLE_fnptr = &GetTexParameterPointervAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_texture_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexParameterPointervAPPLE(All target, All pname, void** parameters) => _GetTexParameterPointervAPPLE_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTexParameterPointervAPPLE_Lazy(All target, All pname, void** parameters)
            {
                _GetTexParameterPointervAPPLE_fnptr = (delegate* unmanaged<All, All, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexParameterPointervAPPLE");
                _GetTexParameterPointervAPPLE_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, void> _BindVertexArrayAPPLE_fnptr = &BindVertexArrayAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindVertexArrayAPPLE(VertexArrayHandle array) => _BindVertexArrayAPPLE_fnptr(array);
            [UnmanagedCallersOnly]
            private static void BindVertexArrayAPPLE_Lazy(VertexArrayHandle array)
            {
                _BindVertexArrayAPPLE_fnptr = (delegate* unmanaged<VertexArrayHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindVertexArrayAPPLE");
                _BindVertexArrayAPPLE_fnptr(array);
            }
            
            private static delegate* unmanaged<int, VertexArrayHandle*, void> _DeleteVertexArraysAPPLE_fnptr = &DeleteVertexArraysAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteVertexArraysAPPLE(int n, VertexArrayHandle* arrays) => _DeleteVertexArraysAPPLE_fnptr(n, arrays);
            [UnmanagedCallersOnly]
            private static void DeleteVertexArraysAPPLE_Lazy(int n, VertexArrayHandle* arrays)
            {
                _DeleteVertexArraysAPPLE_fnptr = (delegate* unmanaged<int, VertexArrayHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteVertexArraysAPPLE");
                _DeleteVertexArraysAPPLE_fnptr(n, arrays);
            }
            
            private static delegate* unmanaged<int, VertexArrayHandle*, void> _GenVertexArraysAPPLE_fnptr = &GenVertexArraysAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenVertexArraysAPPLE(int n, VertexArrayHandle* arrays) => _GenVertexArraysAPPLE_fnptr(n, arrays);
            [UnmanagedCallersOnly]
            private static void GenVertexArraysAPPLE_Lazy(int n, VertexArrayHandle* arrays)
            {
                _GenVertexArraysAPPLE_fnptr = (delegate* unmanaged<int, VertexArrayHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenVertexArraysAPPLE");
                _GenVertexArraysAPPLE_fnptr(n, arrays);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, byte> _IsVertexArrayAPPLE_fnptr = &IsVertexArrayAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsVertexArrayAPPLE(VertexArrayHandle array) => _IsVertexArrayAPPLE_fnptr(array);
            [UnmanagedCallersOnly]
            private static byte IsVertexArrayAPPLE_Lazy(VertexArrayHandle array)
            {
                _IsVertexArrayAPPLE_fnptr = (delegate* unmanaged<VertexArrayHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsVertexArrayAPPLE");
                return _IsVertexArrayAPPLE_fnptr(array);
            }
            
            private static delegate* unmanaged<int, void*, void> _VertexArrayRangeAPPLE_fnptr = &VertexArrayRangeAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayRangeAPPLE(int length, void* pointer) => _VertexArrayRangeAPPLE_fnptr(length, pointer);
            [UnmanagedCallersOnly]
            private static void VertexArrayRangeAPPLE_Lazy(int length, void* pointer)
            {
                _VertexArrayRangeAPPLE_fnptr = (delegate* unmanaged<int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayRangeAPPLE");
                _VertexArrayRangeAPPLE_fnptr(length, pointer);
            }
            
            private static delegate* unmanaged<int, void*, void> _FlushVertexArrayRangeAPPLE_fnptr = &FlushVertexArrayRangeAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushVertexArrayRangeAPPLE(int length, void* pointer) => _FlushVertexArrayRangeAPPLE_fnptr(length, pointer);
            [UnmanagedCallersOnly]
            private static void FlushVertexArrayRangeAPPLE_Lazy(int length, void* pointer)
            {
                _FlushVertexArrayRangeAPPLE_fnptr = (delegate* unmanaged<int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glFlushVertexArrayRangeAPPLE");
                _FlushVertexArrayRangeAPPLE_fnptr(length, pointer);
            }
            
            private static delegate* unmanaged<VertexArrayPNameAPPLE, int, void> _VertexArrayParameteriAPPLE_fnptr = &VertexArrayParameteriAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayParameteriAPPLE(VertexArrayPNameAPPLE pname, int param) => _VertexArrayParameteriAPPLE_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void VertexArrayParameteriAPPLE_Lazy(VertexArrayPNameAPPLE pname, int param)
            {
                _VertexArrayParameteriAPPLE_fnptr = (delegate* unmanaged<VertexArrayPNameAPPLE, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayParameteriAPPLE");
                _VertexArrayParameteriAPPLE_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<uint, All, void> _EnableVertexAttribAPPLE_fnptr = &EnableVertexAttribAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVertexAttribAPPLE(uint index, All pname) => _EnableVertexAttribAPPLE_fnptr(index, pname);
            [UnmanagedCallersOnly]
            private static void EnableVertexAttribAPPLE_Lazy(uint index, All pname)
            {
                _EnableVertexAttribAPPLE_fnptr = (delegate* unmanaged<uint, All, void>)GLLoader.BindingsContext.GetProcAddress("glEnableVertexAttribAPPLE");
                _EnableVertexAttribAPPLE_fnptr(index, pname);
            }
            
            private static delegate* unmanaged<uint, All, void> _DisableVertexAttribAPPLE_fnptr = &DisableVertexAttribAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVertexAttribAPPLE(uint index, All pname) => _DisableVertexAttribAPPLE_fnptr(index, pname);
            [UnmanagedCallersOnly]
            private static void DisableVertexAttribAPPLE_Lazy(uint index, All pname)
            {
                _DisableVertexAttribAPPLE_fnptr = (delegate* unmanaged<uint, All, void>)GLLoader.BindingsContext.GetProcAddress("glDisableVertexAttribAPPLE");
                _DisableVertexAttribAPPLE_fnptr(index, pname);
            }
            
            private static delegate* unmanaged<uint, All, byte> _IsVertexAttribEnabledAPPLE_fnptr = &IsVertexAttribEnabledAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsVertexAttribEnabledAPPLE(uint index, All pname) => _IsVertexAttribEnabledAPPLE_fnptr(index, pname);
            [UnmanagedCallersOnly]
            private static byte IsVertexAttribEnabledAPPLE_Lazy(uint index, All pname)
            {
                _IsVertexAttribEnabledAPPLE_fnptr = (delegate* unmanaged<uint, All, byte>)GLLoader.BindingsContext.GetProcAddress("glIsVertexAttribEnabledAPPLE");
                return _IsVertexAttribEnabledAPPLE_fnptr(index, pname);
            }
            
            private static delegate* unmanaged<uint, uint, double, double, int, int, double*, void> _MapVertexAttrib1dAPPLE_fnptr = &MapVertexAttrib1dAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, double* points) => _MapVertexAttrib1dAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            [UnmanagedCallersOnly]
            private static void MapVertexAttrib1dAPPLE_Lazy(uint index, uint size, double u1, double u2, int stride, int order, double* points)
            {
                _MapVertexAttrib1dAPPLE_fnptr = (delegate* unmanaged<uint, uint, double, double, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMapVertexAttrib1dAPPLE");
                _MapVertexAttrib1dAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            }
            
            private static delegate* unmanaged<uint, uint, float, float, int, int, float*, void> _MapVertexAttrib1fAPPLE_fnptr = &MapVertexAttrib1fAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, float* points) => _MapVertexAttrib1fAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            [UnmanagedCallersOnly]
            private static void MapVertexAttrib1fAPPLE_Lazy(uint index, uint size, float u1, float u2, int stride, int order, float* points)
            {
                _MapVertexAttrib1fAPPLE_fnptr = (delegate* unmanaged<uint, uint, float, float, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMapVertexAttrib1fAPPLE");
                _MapVertexAttrib1fAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            }
            
            private static delegate* unmanaged<uint, uint, double, double, int, int, double, double, int, int, double*, void> _MapVertexAttrib2dAPPLE_fnptr = &MapVertexAttrib2dAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) => _MapVertexAttrib2dAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            [UnmanagedCallersOnly]
            private static void MapVertexAttrib2dAPPLE_Lazy(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points)
            {
                _MapVertexAttrib2dAPPLE_fnptr = (delegate* unmanaged<uint, uint, double, double, int, int, double, double, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMapVertexAttrib2dAPPLE");
                _MapVertexAttrib2dAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            
            private static delegate* unmanaged<uint, uint, float, float, int, int, float, float, int, int, float*, void> _MapVertexAttrib2fAPPLE_fnptr = &MapVertexAttrib2fAPPLE_Lazy;
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) => _MapVertexAttrib2fAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            [UnmanagedCallersOnly]
            private static void MapVertexAttrib2fAPPLE_Lazy(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points)
            {
                _MapVertexAttrib2fAPPLE_fnptr = (delegate* unmanaged<uint, uint, float, float, int, int, float, float, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMapVertexAttrib2fAPPLE");
                _MapVertexAttrib2fAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            
        }
        public static unsafe partial class ARB
        {
            private static delegate* unmanaged<void> _ReleaseShaderCompiler_fnptr = &ReleaseShaderCompiler_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Release resources consumed by the implementation's shader compiler. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml" /></remarks>
            public static void ReleaseShaderCompiler() => _ReleaseShaderCompiler_fnptr();
            [UnmanagedCallersOnly]
            private static void ReleaseShaderCompiler_Lazy()
            {
                _ReleaseShaderCompiler_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glReleaseShaderCompiler");
                _ReleaseShaderCompiler_fnptr();
            }
            
            private static delegate* unmanaged<int, ShaderHandle*, ShaderBinaryFormat, void*, int, void> _ShaderBinary_fnptr = &ShaderBinary_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Load pre-compiled shader binaries. </summary>
            /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
            /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
            /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
            /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
            /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml" /></remarks>
            public static void ShaderBinary(int count, ShaderHandle* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => _ShaderBinary_fnptr(count, shaders, binaryFormat, binary, length);
            [UnmanagedCallersOnly]
            private static void ShaderBinary_Lazy(int count, ShaderHandle* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length)
            {
                _ShaderBinary_fnptr = (delegate* unmanaged<int, ShaderHandle*, ShaderBinaryFormat, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glShaderBinary");
                _ShaderBinary_fnptr(count, shaders, binaryFormat, binary, length);
            }
            
            private static delegate* unmanaged<ShaderType, PrecisionType, int*, int*, void> _GetShaderPrecisionFormat_fnptr = &GetShaderPrecisionFormat_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
            /// <param name="shaderType"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="precisionType"> Specifies the numeric format whose precision and range to query. </param>
            /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned. </param>
            /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml" /></remarks>
            public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => _GetShaderPrecisionFormat_fnptr(shadertype, precisiontype, range, precision);
            [UnmanagedCallersOnly]
            private static void GetShaderPrecisionFormat_Lazy(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision)
            {
                _GetShaderPrecisionFormat_fnptr = (delegate* unmanaged<ShaderType, PrecisionType, int*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetShaderPrecisionFormat");
                _GetShaderPrecisionFormat_fnptr(shadertype, precisiontype, range, precision);
            }
            
            private static delegate* unmanaged<float, float, void> _DepthRangef_fnptr = &DepthRangef_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
            /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
            public static void DepthRangef(float n, float f) => _DepthRangef_fnptr(n, f);
            [UnmanagedCallersOnly]
            private static void DepthRangef_Lazy(float n, float f)
            {
                _DepthRangef_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangef");
                _DepthRangef_fnptr(n, f);
            }
            
            private static delegate* unmanaged<float, void> _ClearDepthf_fnptr = &ClearDepthf_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Specify the clear value for the depth buffer. </summary>
            /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
            public static void ClearDepthf(float d) => _ClearDepthf_fnptr(d);
            [UnmanagedCallersOnly]
            private static void ClearDepthf_Lazy(float d)
            {
                _ClearDepthf_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glClearDepthf");
                _ClearDepthf_fnptr(d);
            }
            
            private static delegate* unmanaged<MemoryBarrierMask, void> _MemoryBarrierByRegion_fnptr = &MemoryBarrierByRegion_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility]</b> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
            public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => _MemoryBarrierByRegion_fnptr(barriers);
            [UnmanagedCallersOnly]
            private static void MemoryBarrierByRegion_Lazy(MemoryBarrierMask barriers)
            {
                _MemoryBarrierByRegion_fnptr = (delegate* unmanaged<MemoryBarrierMask, void>)GLLoader.BindingsContext.GetProcAddress("glMemoryBarrierByRegion");
                _MemoryBarrierByRegion_fnptr(barriers);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, float, float, void> _PrimitiveBoundingBoxARB_fnptr = &PrimitiveBoundingBoxARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_ES3_2_compatibility]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrimitiveBoundingBoxARB(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) => _PrimitiveBoundingBoxARB_fnptr(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
            [UnmanagedCallersOnly]
            private static void PrimitiveBoundingBoxARB_Lazy(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW)
            {
                _PrimitiveBoundingBoxARB_fnptr = (delegate* unmanaged<float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glPrimitiveBoundingBoxARB");
                _PrimitiveBoundingBoxARB_fnptr(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, int, int, uint, void> _DrawArraysInstancedBaseInstance_fnptr = &DrawArraysInstancedBaseInstance_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
            /// <param name="count"> Specifies the number of indices to be rendered. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml" /></remarks>
            public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => _DrawArraysInstancedBaseInstance_fnptr(mode, first, count, instancecount, baseinstance);
            [UnmanagedCallersOnly]
            private static void DrawArraysInstancedBaseInstance_Lazy(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
            {
                _DrawArraysInstancedBaseInstance_fnptr = (delegate* unmanaged<PrimitiveType, int, int, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawArraysInstancedBaseInstance");
                _DrawArraysInstancedBaseInstance_fnptr(mode, first, count, instancecount, baseinstance);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, PrimitiveType, void*, int, uint, void> _DrawElementsInstancedBaseInstance_fnptr = &DrawElementsInstancedBaseInstance_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, PrimitiveType type, void* indices, int instancecount, uint baseinstance) => _DrawElementsInstancedBaseInstance_fnptr(mode, count, type, indices, instancecount, baseinstance);
            [UnmanagedCallersOnly]
            private static void DrawElementsInstancedBaseInstance_Lazy(PrimitiveType mode, int count, PrimitiveType type, void* indices, int instancecount, uint baseinstance)
            {
                _DrawElementsInstancedBaseInstance_fnptr = (delegate* unmanaged<PrimitiveType, int, PrimitiveType, void*, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsInstancedBaseInstance");
                _DrawElementsInstancedBaseInstance_fnptr(mode, count, type, indices, instancecount, baseinstance);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, int, uint, void> _DrawElementsInstancedBaseVertexBaseInstance_fnptr = &DrawElementsInstancedBaseVertexBaseInstance_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => _DrawElementsInstancedBaseVertexBaseInstance_fnptr(mode, count, type, indices, instancecount, basevertex, baseinstance);
            [UnmanagedCallersOnly]
            private static void DrawElementsInstancedBaseVertexBaseInstance_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
            {
                _DrawElementsInstancedBaseVertexBaseInstance_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsInstancedBaseVertexBaseInstance");
                _DrawElementsInstancedBaseVertexBaseInstance_fnptr(mode, count, type, indices, instancecount, basevertex, baseinstance);
            }
            
            private static delegate* unmanaged<TextureHandle, ulong> _GetTextureHandleARB_fnptr = &GetTextureHandleARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetTextureHandleARB(TextureHandle texture) => _GetTextureHandleARB_fnptr(texture);
            [UnmanagedCallersOnly]
            private static ulong GetTextureHandleARB_Lazy(TextureHandle texture)
            {
                _GetTextureHandleARB_fnptr = (delegate* unmanaged<TextureHandle, ulong>)GLLoader.BindingsContext.GetProcAddress("glGetTextureHandleARB");
                return _GetTextureHandleARB_fnptr(texture);
            }
            
            private static delegate* unmanaged<TextureHandle, SamplerHandle, ulong> _GetTextureSamplerHandleARB_fnptr = &GetTextureSamplerHandleARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetTextureSamplerHandleARB(TextureHandle texture, SamplerHandle sampler) => _GetTextureSamplerHandleARB_fnptr(texture, sampler);
            [UnmanagedCallersOnly]
            private static ulong GetTextureSamplerHandleARB_Lazy(TextureHandle texture, SamplerHandle sampler)
            {
                _GetTextureSamplerHandleARB_fnptr = (delegate* unmanaged<TextureHandle, SamplerHandle, ulong>)GLLoader.BindingsContext.GetProcAddress("glGetTextureSamplerHandleARB");
                return _GetTextureSamplerHandleARB_fnptr(texture, sampler);
            }
            
            private static delegate* unmanaged<ulong, void> _MakeTextureHandleResidentARB_fnptr = &MakeTextureHandleResidentARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeTextureHandleResidentARB(ulong handle) => _MakeTextureHandleResidentARB_fnptr(handle);
            [UnmanagedCallersOnly]
            private static void MakeTextureHandleResidentARB_Lazy(ulong handle)
            {
                _MakeTextureHandleResidentARB_fnptr = (delegate* unmanaged<ulong, void>)GLLoader.BindingsContext.GetProcAddress("glMakeTextureHandleResidentARB");
                _MakeTextureHandleResidentARB_fnptr(handle);
            }
            
            private static delegate* unmanaged<ulong, void> _MakeTextureHandleNonResidentARB_fnptr = &MakeTextureHandleNonResidentARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeTextureHandleNonResidentARB(ulong handle) => _MakeTextureHandleNonResidentARB_fnptr(handle);
            [UnmanagedCallersOnly]
            private static void MakeTextureHandleNonResidentARB_Lazy(ulong handle)
            {
                _MakeTextureHandleNonResidentARB_fnptr = (delegate* unmanaged<ulong, void>)GLLoader.BindingsContext.GetProcAddress("glMakeTextureHandleNonResidentARB");
                _MakeTextureHandleNonResidentARB_fnptr(handle);
            }
            
            private static delegate* unmanaged<TextureHandle, int, byte, int, PixelFormat, ulong> _GetImageHandleARB_fnptr = &GetImageHandleARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetImageHandleARB(TextureHandle texture, int level, byte layered, int layer, PixelFormat format) => _GetImageHandleARB_fnptr(texture, level, layered, layer, format);
            [UnmanagedCallersOnly]
            private static ulong GetImageHandleARB_Lazy(TextureHandle texture, int level, byte layered, int layer, PixelFormat format)
            {
                _GetImageHandleARB_fnptr = (delegate* unmanaged<TextureHandle, int, byte, int, PixelFormat, ulong>)GLLoader.BindingsContext.GetProcAddress("glGetImageHandleARB");
                return _GetImageHandleARB_fnptr(texture, level, layered, layer, format);
            }
            
            private static delegate* unmanaged<ulong, All, void> _MakeImageHandleResidentARB_fnptr = &MakeImageHandleResidentARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeImageHandleResidentARB(ulong handle, All access) => _MakeImageHandleResidentARB_fnptr(handle, access);
            [UnmanagedCallersOnly]
            private static void MakeImageHandleResidentARB_Lazy(ulong handle, All access)
            {
                _MakeImageHandleResidentARB_fnptr = (delegate* unmanaged<ulong, All, void>)GLLoader.BindingsContext.GetProcAddress("glMakeImageHandleResidentARB");
                _MakeImageHandleResidentARB_fnptr(handle, access);
            }
            
            private static delegate* unmanaged<ulong, void> _MakeImageHandleNonResidentARB_fnptr = &MakeImageHandleNonResidentARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeImageHandleNonResidentARB(ulong handle) => _MakeImageHandleNonResidentARB_fnptr(handle);
            [UnmanagedCallersOnly]
            private static void MakeImageHandleNonResidentARB_Lazy(ulong handle)
            {
                _MakeImageHandleNonResidentARB_fnptr = (delegate* unmanaged<ulong, void>)GLLoader.BindingsContext.GetProcAddress("glMakeImageHandleNonResidentARB");
                _MakeImageHandleNonResidentARB_fnptr(handle);
            }
            
            private static delegate* unmanaged<int, ulong, void> _UniformHandleui64ARB_fnptr = &UniformHandleui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformHandleui64ARB(int location, ulong value) => _UniformHandleui64ARB_fnptr(location, value);
            [UnmanagedCallersOnly]
            private static void UniformHandleui64ARB_Lazy(int location, ulong value)
            {
                _UniformHandleui64ARB_fnptr = (delegate* unmanaged<int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniformHandleui64ARB");
                _UniformHandleui64ARB_fnptr(location, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _UniformHandleui64vARB_fnptr = &UniformHandleui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformHandleui64vARB(int location, int count, ulong* value) => _UniformHandleui64vARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void UniformHandleui64vARB_Lazy(int location, int count, ulong* value)
            {
                _UniformHandleui64vARB_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformHandleui64vARB");
                _UniformHandleui64vARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, void> _ProgramUniformHandleui64ARB_fnptr = &ProgramUniformHandleui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformHandleui64ARB(ProgramHandle program, int location, ulong value) => _ProgramUniformHandleui64ARB_fnptr(program, location, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformHandleui64ARB_Lazy(ProgramHandle program, int location, ulong value)
            {
                _ProgramUniformHandleui64ARB_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformHandleui64ARB");
                _ProgramUniformHandleui64ARB_fnptr(program, location, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniformHandleui64vARB_fnptr = &ProgramUniformHandleui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformHandleui64vARB(ProgramHandle program, int location, int count, ulong* values) => _ProgramUniformHandleui64vARB_fnptr(program, location, count, values);
            [UnmanagedCallersOnly]
            private static void ProgramUniformHandleui64vARB_Lazy(ProgramHandle program, int location, int count, ulong* values)
            {
                _ProgramUniformHandleui64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformHandleui64vARB");
                _ProgramUniformHandleui64vARB_fnptr(program, location, count, values);
            }
            
            private static delegate* unmanaged<ulong, byte> _IsTextureHandleResidentARB_fnptr = &IsTextureHandleResidentARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsTextureHandleResidentARB(ulong handle) => _IsTextureHandleResidentARB_fnptr(handle);
            [UnmanagedCallersOnly]
            private static byte IsTextureHandleResidentARB_Lazy(ulong handle)
            {
                _IsTextureHandleResidentARB_fnptr = (delegate* unmanaged<ulong, byte>)GLLoader.BindingsContext.GetProcAddress("glIsTextureHandleResidentARB");
                return _IsTextureHandleResidentARB_fnptr(handle);
            }
            
            private static delegate* unmanaged<ulong, byte> _IsImageHandleResidentARB_fnptr = &IsImageHandleResidentARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsImageHandleResidentARB(ulong handle) => _IsImageHandleResidentARB_fnptr(handle);
            [UnmanagedCallersOnly]
            private static byte IsImageHandleResidentARB_Lazy(ulong handle)
            {
                _IsImageHandleResidentARB_fnptr = (delegate* unmanaged<ulong, byte>)GLLoader.BindingsContext.GetProcAddress("glIsImageHandleResidentARB");
                return _IsImageHandleResidentARB_fnptr(handle);
            }
            
            private static delegate* unmanaged<uint, ulong, void> _VertexAttribL1ui64ARB_fnptr = &VertexAttribL1ui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1ui64ARB(uint index, ulong x) => _VertexAttribL1ui64ARB_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1ui64ARB_Lazy(uint index, ulong x)
            {
                _VertexAttribL1ui64ARB_fnptr = (delegate* unmanaged<uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1ui64ARB");
                _VertexAttribL1ui64ARB_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, ulong*, void> _VertexAttribL1ui64vARB_fnptr = &VertexAttribL1ui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1ui64vARB(uint index, ulong* v) => _VertexAttribL1ui64vARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1ui64vARB_Lazy(uint index, ulong* v)
            {
                _VertexAttribL1ui64vARB_fnptr = (delegate* unmanaged<uint, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1ui64vARB");
                _VertexAttribL1ui64vARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnum, ulong*, void> _GetVertexAttribLui64vARB_fnptr = &GetVertexAttribLui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribLui64vARB(uint index, VertexAttribEnum pname, ulong* parameters) => _GetVertexAttribLui64vARB_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribLui64vARB_Lazy(uint index, VertexAttribEnum pname, ulong* parameters)
            {
                _GetVertexAttribLui64vARB_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribLui64vARB");
                _GetVertexAttribLui64vARB_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, uint, byte*, void> _BindFragDataLocationIndexed_fnptr = &BindFragDataLocationIndexed_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
            /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
            /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
            /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml" /></remarks>
            public static void BindFragDataLocationIndexed(ProgramHandle program, uint colorNumber, uint index, byte* name) => _BindFragDataLocationIndexed_fnptr(program, colorNumber, index, name);
            [UnmanagedCallersOnly]
            private static void BindFragDataLocationIndexed_Lazy(ProgramHandle program, uint colorNumber, uint index, byte* name)
            {
                _BindFragDataLocationIndexed_fnptr = (delegate* unmanaged<ProgramHandle, uint, uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glBindFragDataLocationIndexed");
                _BindFragDataLocationIndexed_fnptr(program, colorNumber, index, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, byte*, int> _GetFragDataIndex_fnptr = &GetFragDataIndex_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> Query the bindings of color indices to user-defined varying out variables. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
            /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml" /></remarks>
            public static int GetFragDataIndex(ProgramHandle program, byte* name) => _GetFragDataIndex_fnptr(program, name);
            [UnmanagedCallersOnly]
            private static int GetFragDataIndex_Lazy(ProgramHandle program, byte* name)
            {
                _GetFragDataIndex_fnptr = (delegate* unmanaged<ProgramHandle, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetFragDataIndex");
                return _GetFragDataIndex_fnptr(program, name);
            }
            
            private static delegate* unmanaged<BufferStorageTarget, nint, void*, BufferStorageMask, void> _BufferStorage_fnptr = &BufferStorage_Lazy;
            /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage]</b> Creates and initializes a buffer object's immutable data    store. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
            public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => _BufferStorage_fnptr(target, size, data, flags);
            [UnmanagedCallersOnly]
            private static void BufferStorage_Lazy(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags)
            {
                _BufferStorage_fnptr = (delegate* unmanaged<BufferStorageTarget, nint, void*, BufferStorageMask, void>)GLLoader.BindingsContext.GetProcAddress("glBufferStorage");
                _BufferStorage_fnptr(target, size, data, flags);
            }
            
            private static delegate* unmanaged<CLContext*, CLEvent*, All, IntPtr> _CreateSyncFromCLeventARB_fnptr = &CreateSyncFromCLeventARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_cl_event]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLSync CreateSyncFromCLeventARB(CLContext* context, CLEvent* @event, All flags) => (GLSync) _CreateSyncFromCLeventARB_fnptr(context, @event, flags);
            [UnmanagedCallersOnly]
            private static IntPtr CreateSyncFromCLeventARB_Lazy(CLContext* context, CLEvent* @event, All flags)
            {
                _CreateSyncFromCLeventARB_fnptr = (delegate* unmanaged<CLContext*, CLEvent*, All, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glCreateSyncFromCLeventARB");
                return _CreateSyncFromCLeventARB_fnptr(context, @event, flags);
            }
            
            private static delegate* unmanaged<BufferStorageTarget, SizedInternalFormat, PixelFormat, PixelType, void*, void> _ClearBufferData_fnptr = &ClearBufferData_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> Fill a buffer object's data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
            public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => _ClearBufferData_fnptr(target, internalformat, format, type, data);
            [UnmanagedCallersOnly]
            private static void ClearBufferData_Lazy(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data)
            {
                _ClearBufferData_fnptr = (delegate* unmanaged<BufferStorageTarget, SizedInternalFormat, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearBufferData");
                _ClearBufferData_fnptr(target, internalformat, format, type, data);
            }
            
            private static delegate* unmanaged<BufferTargetARB, SizedInternalFormat, IntPtr, nint, PixelFormat, PixelType, void*, void> _ClearBufferSubData_fnptr = &ClearBufferSubData_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> Fill all or part of buffer object's data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object's data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
            public static void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => _ClearBufferSubData_fnptr(target, internalformat, offset, size, format, type, data);
            [UnmanagedCallersOnly]
            private static void ClearBufferSubData_Lazy(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data)
            {
                _ClearBufferSubData_fnptr = (delegate* unmanaged<BufferTargetARB, SizedInternalFormat, IntPtr, nint, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearBufferSubData");
                _ClearBufferSubData_fnptr(target, internalformat, offset, size, format, type, data);
            }
            
            private static delegate* unmanaged<TextureHandle, int, PixelFormat, PixelType, void*, void> _ClearTexImage_fnptr = &ClearTexImage_Lazy;
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> Fills all a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml" /></remarks>
            public static void ClearTexImage(TextureHandle texture, int level, PixelFormat format, PixelType type, void* data) => _ClearTexImage_fnptr(texture, level, format, type, data);
            [UnmanagedCallersOnly]
            private static void ClearTexImage_Lazy(TextureHandle texture, int level, PixelFormat format, PixelType type, void* data)
            {
                _ClearTexImage_fnptr = (delegate* unmanaged<TextureHandle, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearTexImage");
                _ClearTexImage_fnptr(texture, level, format, type, data);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _ClearTexSubImage_fnptr = &ClearTexSubImage_Lazy;
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> Fills all or part of a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
            /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
            /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
            /// <param name="width"> The width of the region to be cleared. </param>
            /// <param name="height"> The height of the region to be cleared. </param>
            /// <param name="depth"> The depth of the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml" /></remarks>
            public static void ClearTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => _ClearTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
            [UnmanagedCallersOnly]
            private static void ClearTexSubImage_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data)
            {
                _ClearTexSubImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearTexSubImage");
                _ClearTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
            }
            
            private static delegate* unmanaged<ClipControlOrigin, ClipControlDepth, void> _ClipControl_fnptr = &ClipControl_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control]</b> Control clip coordinate to window coordinate behavior. </summary>
            /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
            /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml" /></remarks>
            public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => _ClipControl_fnptr(origin, depth);
            [UnmanagedCallersOnly]
            private static void ClipControl_Lazy(ClipControlOrigin origin, ClipControlDepth depth)
            {
                _ClipControl_fnptr = (delegate* unmanaged<ClipControlOrigin, ClipControlDepth, void>)GLLoader.BindingsContext.GetProcAddress("glClipControl");
                _ClipControl_fnptr(origin, depth);
            }
            
            private static delegate* unmanaged<ClampColorTargetARB, ClampColorModeARB, void> _ClampColorARB_fnptr = &ClampColorARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_color_buffer_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClampColorARB(ClampColorTargetARB target, ClampColorModeARB clamp) => _ClampColorARB_fnptr(target, clamp);
            [UnmanagedCallersOnly]
            private static void ClampColorARB_Lazy(ClampColorTargetARB target, ClampColorModeARB clamp)
            {
                _ClampColorARB_fnptr = (delegate* unmanaged<ClampColorTargetARB, ClampColorModeARB, void>)GLLoader.BindingsContext.GetProcAddress("glClampColorARB");
                _ClampColorARB_fnptr(target, clamp);
            }
            
            private static delegate* unmanaged<uint, uint, uint, void> _DispatchCompute_fnptr = &DispatchCompute_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> Launch one or more compute work groups. </summary>
            /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
            /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
            /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml" /></remarks>
            public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => _DispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
            [UnmanagedCallersOnly]
            private static void DispatchCompute_Lazy(uint num_groups_x, uint num_groups_y, uint num_groups_z)
            {
                _DispatchCompute_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDispatchCompute");
                _DispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
            }
            
            private static delegate* unmanaged<IntPtr, void> _DispatchComputeIndirect_fnptr = &DispatchComputeIndirect_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> Launch one or more compute work groups using parameters stored in a buffer. </summary>
            /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml" /></remarks>
            public static void DispatchComputeIndirect(IntPtr indirect) => _DispatchComputeIndirect_fnptr(indirect);
            [UnmanagedCallersOnly]
            private static void DispatchComputeIndirect_Lazy(IntPtr indirect)
            {
                _DispatchComputeIndirect_fnptr = (delegate* unmanaged<IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glDispatchComputeIndirect");
                _DispatchComputeIndirect_fnptr(indirect);
            }
            
            private static delegate* unmanaged<uint, uint, uint, uint, uint, uint, void> _DispatchComputeGroupSizeARB_fnptr = &DispatchComputeGroupSizeARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_compute_variable_group_size]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DispatchComputeGroupSizeARB(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z) => _DispatchComputeGroupSizeARB_fnptr(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
            [UnmanagedCallersOnly]
            private static void DispatchComputeGroupSizeARB_Lazy(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z)
            {
                _DispatchComputeGroupSizeARB_fnptr = (delegate* unmanaged<uint, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDispatchComputeGroupSizeARB");
                _DispatchComputeGroupSizeARB_fnptr(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
            }
            
            private static delegate* unmanaged<CopyBufferSubDataTarget, CopyBufferSubDataTarget, IntPtr, IntPtr, nint, void> _CopyBufferSubData_fnptr = &CopyBufferSubData_Lazy;
            /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
            /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
            public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => _CopyBufferSubData_fnptr(readTarget, writeTarget, readOffset, writeOffset, size);
            [UnmanagedCallersOnly]
            private static void CopyBufferSubData_Lazy(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size)
            {
                _CopyBufferSubData_fnptr = (delegate* unmanaged<CopyBufferSubDataTarget, CopyBufferSubDataTarget, IntPtr, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glCopyBufferSubData");
                _CopyBufferSubData_fnptr(readTarget, writeTarget, readOffset, writeOffset, size);
            }
            
            private static delegate* unmanaged<uint, CopyImageSubDataTarget, int, int, int, int, uint, CopyImageSubDataTarget, int, int, int, int, int, int, int, void> _CopyImageSubData_fnptr = &CopyImageSubData_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image]</b> Perform a raw data copy between two images. </summary>
            /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
            /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
            /// <param name="srcLevel"> The mipmap level to read from the source. </param>
            /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
            /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
            /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
            /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
            /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
            /// <param name="dstLevel">!!missing documentation!!</param>
            /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
            /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
            /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
            /// <param name="srcWidth"> The width of the region to be copied. </param>
            /// <param name="srcHeight"> The height of the region to be copied. </param>
            /// <param name="srcDepth"> The depth of the region to be copied. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml" /></remarks>
            public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => _CopyImageSubData_fnptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            [UnmanagedCallersOnly]
            private static void CopyImageSubData_Lazy(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
            {
                _CopyImageSubData_fnptr = (delegate* unmanaged<uint, CopyImageSubDataTarget, int, int, int, int, uint, CopyImageSubDataTarget, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyImageSubData");
                _CopyImageSubData_fnptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            }
            
            private static delegate* unmanaged<DebugSource, DebugType, DebugSeverity, int, uint*, byte, void> _DebugMessageControlARB_fnptr = &DebugMessageControlARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, byte enabled) => _DebugMessageControlARB_fnptr(source, type, severity, count, ids, enabled);
            [UnmanagedCallersOnly]
            private static void DebugMessageControlARB_Lazy(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, byte enabled)
            {
                _DebugMessageControlARB_fnptr = (delegate* unmanaged<DebugSource, DebugType, DebugSeverity, int, uint*, byte, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageControlARB");
                _DebugMessageControlARB_fnptr(source, type, severity, count, ids, enabled);
            }
            
            private static delegate* unmanaged<DebugSource, DebugType, uint, DebugSeverity, int, byte*, void> _DebugMessageInsertARB_fnptr = &DebugMessageInsertARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageInsertARB(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => _DebugMessageInsertARB_fnptr(source, type, id, severity, length, buf);
            [UnmanagedCallersOnly]
            private static void DebugMessageInsertARB_Lazy(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf)
            {
                _DebugMessageInsertARB_fnptr = (delegate* unmanaged<DebugSource, DebugType, uint, DebugSeverity, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageInsertARB");
                _DebugMessageInsertARB_fnptr(source, type, id, severity, length, buf);
            }
            
            private static delegate* unmanaged<IntPtr, void*, void> _DebugMessageCallbackARB_fnptr = &DebugMessageCallbackARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageCallbackARB(IntPtr callback, void* userParam) => _DebugMessageCallbackARB_fnptr(callback, userParam);
            [UnmanagedCallersOnly]
            private static void DebugMessageCallbackARB_Lazy(IntPtr callback, void* userParam)
            {
                _DebugMessageCallbackARB_fnptr = (delegate* unmanaged<IntPtr, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageCallbackARB");
                _DebugMessageCallbackARB_fnptr(callback, userParam);
            }
            
            private static delegate* unmanaged<uint, int, DebugSource*, DebugType*, uint*, DebugSeverity*, int*, byte*, uint> _GetDebugMessageLogARB_fnptr = &GetDebugMessageLogARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GetDebugMessageLogARB(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => _GetDebugMessageLogARB_fnptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
            [UnmanagedCallersOnly]
            private static uint GetDebugMessageLogARB_Lazy(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog)
            {
                _GetDebugMessageLogARB_fnptr = (delegate* unmanaged<uint, int, DebugSource*, DebugType*, uint*, DebugSeverity*, int*, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetDebugMessageLogARB");
                return _GetDebugMessageLogARB_fnptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
            }
            
            private static delegate* unmanaged<int, TransformFeedbackHandle*, void> _CreateTransformFeedbacks_fnptr = &CreateTransformFeedbacks_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create transform feedback objects. </summary>
            /// <param name="n"> Number of transform feedback objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml" /></remarks>
            public static void CreateTransformFeedbacks(int n, TransformFeedbackHandle* ids) => _CreateTransformFeedbacks_fnptr(n, ids);
            [UnmanagedCallersOnly]
            private static void CreateTransformFeedbacks_Lazy(int n, TransformFeedbackHandle* ids)
            {
                _CreateTransformFeedbacks_fnptr = (delegate* unmanaged<int, TransformFeedbackHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateTransformFeedbacks");
                _CreateTransformFeedbacks_fnptr(n, ids);
            }
            
            private static delegate* unmanaged<TransformFeedbackHandle, uint, BufferHandle, void> _TransformFeedbackBufferBase_fnptr = &TransformFeedbackBufferBase_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml" /></remarks>
            public static void TransformFeedbackBufferBase(TransformFeedbackHandle xfb, uint index, BufferHandle buffer) => _TransformFeedbackBufferBase_fnptr(xfb, index, buffer);
            [UnmanagedCallersOnly]
            private static void TransformFeedbackBufferBase_Lazy(TransformFeedbackHandle xfb, uint index, BufferHandle buffer)
            {
                _TransformFeedbackBufferBase_fnptr = (delegate* unmanaged<TransformFeedbackHandle, uint, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTransformFeedbackBufferBase");
                _TransformFeedbackBufferBase_fnptr(xfb, index, buffer);
            }
            
            private static delegate* unmanaged<TransformFeedbackHandle, uint, BufferHandle, IntPtr, nint, void> _TransformFeedbackBufferRange_fnptr = &TransformFeedbackBufferRange_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a range within a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
            /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml" /></remarks>
            public static void TransformFeedbackBufferRange(TransformFeedbackHandle xfb, uint index, BufferHandle buffer, IntPtr offset, nint size) => _TransformFeedbackBufferRange_fnptr(xfb, index, buffer, offset, size);
            [UnmanagedCallersOnly]
            private static void TransformFeedbackBufferRange_Lazy(TransformFeedbackHandle xfb, uint index, BufferHandle buffer, IntPtr offset, nint size)
            {
                _TransformFeedbackBufferRange_fnptr = (delegate* unmanaged<TransformFeedbackHandle, uint, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glTransformFeedbackBufferRange");
                _TransformFeedbackBufferRange_fnptr(xfb, index, buffer, offset, size);
            }
            
            private static delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, int*, void> _GetTransformFeedbackiv_fnptr = &GetTransformFeedbackiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbackiv(TransformFeedbackHandle xfb, TransformFeedbackPName pname, int* param) => _GetTransformFeedbackiv_fnptr(xfb, pname, param);
            [UnmanagedCallersOnly]
            private static void GetTransformFeedbackiv_Lazy(TransformFeedbackHandle xfb, TransformFeedbackPName pname, int* param)
            {
                _GetTransformFeedbackiv_fnptr = (delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTransformFeedbackiv");
                _GetTransformFeedbackiv_fnptr(xfb, pname, param);
            }
            
            private static delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, uint, int*, void> _GetTransformFeedbacki_v_fnptr = &GetTransformFeedbacki_v_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbacki_v(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, int* param) => _GetTransformFeedbacki_v_fnptr(xfb, pname, index, param);
            [UnmanagedCallersOnly]
            private static void GetTransformFeedbacki_v_Lazy(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, int* param)
            {
                _GetTransformFeedbacki_v_fnptr = (delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTransformFeedbacki_v");
                _GetTransformFeedbacki_v_fnptr(xfb, pname, index, param);
            }
            
            private static delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, uint, long*, void> _GetTransformFeedbacki64_v_fnptr = &GetTransformFeedbacki64_v_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbacki64_v(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, long* param) => _GetTransformFeedbacki64_v_fnptr(xfb, pname, index, param);
            [UnmanagedCallersOnly]
            private static void GetTransformFeedbacki64_v_Lazy(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, long* param)
            {
                _GetTransformFeedbacki64_v_fnptr = (delegate* unmanaged<TransformFeedbackHandle, TransformFeedbackPName, uint, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTransformFeedbacki64_v");
                _GetTransformFeedbacki64_v_fnptr(xfb, pname, index, param);
            }
            
            private static delegate* unmanaged<int, BufferHandle*, void> _CreateBuffers_fnptr = &CreateBuffers_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create buffer objects. </summary>
            /// <param name="n"> Specifies the number of buffer objects to create. </param>
            /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml" /></remarks>
            public static void CreateBuffers(int n, BufferHandle* buffers) => _CreateBuffers_fnptr(n, buffers);
            [UnmanagedCallersOnly]
            private static void CreateBuffers_Lazy(int n, BufferHandle* buffers)
            {
                _CreateBuffers_fnptr = (delegate* unmanaged<int, BufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateBuffers");
                _CreateBuffers_fnptr(n, buffers);
            }
            
            private static delegate* unmanaged<BufferHandle, nint, void*, BufferStorageMask, void> _NamedBufferStorage_fnptr = &NamedBufferStorage_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Creates and initializes a buffer object's immutable data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
            public static void NamedBufferStorage(BufferHandle buffer, nint size, void* data, BufferStorageMask flags) => _NamedBufferStorage_fnptr(buffer, size, data, flags);
            [UnmanagedCallersOnly]
            private static void NamedBufferStorage_Lazy(BufferHandle buffer, nint size, void* data, BufferStorageMask flags)
            {
                _NamedBufferStorage_fnptr = (delegate* unmanaged<BufferHandle, nint, void*, BufferStorageMask, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferStorage");
                _NamedBufferStorage_fnptr(buffer, size, data, flags);
            }
            
            private static delegate* unmanaged<BufferHandle, nint, void*, VertexBufferObjectUsage, void> _NamedBufferData_fnptr = &NamedBufferData_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Creates and initializes a buffer object's data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
            public static void NamedBufferData(BufferHandle buffer, nint size, void* data, VertexBufferObjectUsage usage) => _NamedBufferData_fnptr(buffer, size, data, usage);
            [UnmanagedCallersOnly]
            private static void NamedBufferData_Lazy(BufferHandle buffer, nint size, void* data, VertexBufferObjectUsage usage)
            {
                _NamedBufferData_fnptr = (delegate* unmanaged<BufferHandle, nint, void*, VertexBufferObjectUsage, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferData");
                _NamedBufferData_fnptr(buffer, size, data, usage);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void> _NamedBufferSubData_fnptr = &NamedBufferSubData_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Updates a subset of a buffer object's data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
            /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
            public static void NamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, void* data) => _NamedBufferSubData_fnptr(buffer, offset, size, data);
            [UnmanagedCallersOnly]
            private static void NamedBufferSubData_Lazy(BufferHandle buffer, IntPtr offset, nint size, void* data)
            {
                _NamedBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferSubData");
                _NamedBufferSubData_fnptr(buffer, offset, size, data);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferHandle, IntPtr, IntPtr, nint, void> _CopyNamedBufferSubData_fnptr = &CopyNamedBufferSubData_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
            public static void CopyNamedBufferSubData(BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => _CopyNamedBufferSubData_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
            [UnmanagedCallersOnly]
            private static void CopyNamedBufferSubData_Lazy(BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size)
            {
                _CopyNamedBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, BufferHandle, IntPtr, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glCopyNamedBufferSubData");
                _CopyNamedBufferSubData_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
            }
            
            private static delegate* unmanaged<BufferHandle, SizedInternalFormat, PixelFormat, PixelType, void*, void> _ClearNamedBufferData_fnptr = &ClearNamedBufferData_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Fill a buffer object's data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
            public static void ClearNamedBufferData(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => _ClearNamedBufferData_fnptr(buffer, internalformat, format, type, data);
            [UnmanagedCallersOnly]
            private static void ClearNamedBufferData_Lazy(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data)
            {
                _ClearNamedBufferData_fnptr = (delegate* unmanaged<BufferHandle, SizedInternalFormat, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedBufferData");
                _ClearNamedBufferData_fnptr(buffer, internalformat, format, type, data);
            }
            
            private static delegate* unmanaged<BufferHandle, SizedInternalFormat, IntPtr, nint, PixelFormat, PixelType, void*, void> _ClearNamedBufferSubData_fnptr = &ClearNamedBufferSubData_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Fill all or part of buffer object's data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object's data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
            public static void ClearNamedBufferSubData(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => _ClearNamedBufferSubData_fnptr(buffer, internalformat, offset, size, format, type, data);
            [UnmanagedCallersOnly]
            private static void ClearNamedBufferSubData_Lazy(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data)
            {
                _ClearNamedBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, SizedInternalFormat, IntPtr, nint, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedBufferSubData");
                _ClearNamedBufferSubData_fnptr(buffer, internalformat, offset, size, format, type, data);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferAccessARB, void*> _MapNamedBuffer_fnptr = &MapNamedBuffer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Map all of a buffer object's data store into the client's address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
            /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
            public static void* MapNamedBuffer(BufferHandle buffer, BufferAccessARB access) => _MapNamedBuffer_fnptr(buffer, access);
            [UnmanagedCallersOnly]
            private static void* MapNamedBuffer_Lazy(BufferHandle buffer, BufferAccessARB access)
            {
                _MapNamedBuffer_fnptr = (delegate* unmanaged<BufferHandle, BufferAccessARB, void*>)GLLoader.BindingsContext.GetProcAddress("glMapNamedBuffer");
                return _MapNamedBuffer_fnptr(buffer, access);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, MapBufferAccessMask, void*> _MapNamedBufferRange_fnptr = &MapNamedBufferRange_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Map all or part of a buffer object's data store into the client's address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
            public static void* MapNamedBufferRange(BufferHandle buffer, IntPtr offset, nint length, MapBufferAccessMask access) => _MapNamedBufferRange_fnptr(buffer, offset, length, access);
            [UnmanagedCallersOnly]
            private static void* MapNamedBufferRange_Lazy(BufferHandle buffer, IntPtr offset, nint length, MapBufferAccessMask access)
            {
                _MapNamedBufferRange_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, MapBufferAccessMask, void*>)GLLoader.BindingsContext.GetProcAddress("glMapNamedBufferRange");
                return _MapNamedBufferRange_fnptr(buffer, offset, length, access);
            }
            
            private static delegate* unmanaged<BufferHandle, byte> _UnmapNamedBuffer_fnptr = &UnmapNamedBuffer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Release the mapping of a buffer object's data store into the client's address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
            public static byte UnmapNamedBuffer(BufferHandle buffer) => _UnmapNamedBuffer_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static byte UnmapNamedBuffer_Lazy(BufferHandle buffer)
            {
                _UnmapNamedBuffer_fnptr = (delegate* unmanaged<BufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glUnmapNamedBuffer");
                return _UnmapNamedBuffer_fnptr(buffer);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, void> _FlushMappedNamedBufferRange_fnptr = &FlushMappedNamedBufferRange_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
            public static void FlushMappedNamedBufferRange(BufferHandle buffer, IntPtr offset, nint length) => _FlushMappedNamedBufferRange_fnptr(buffer, offset, length);
            [UnmanagedCallersOnly]
            private static void FlushMappedNamedBufferRange_Lazy(BufferHandle buffer, IntPtr offset, nint length)
            {
                _FlushMappedNamedBufferRange_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glFlushMappedNamedBufferRange");
                _FlushMappedNamedBufferRange_fnptr(buffer, offset, length);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferPNameARB, int*, void> _GetNamedBufferParameteriv_fnptr = &GetNamedBufferParameteriv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
            public static void GetNamedBufferParameteriv(BufferHandle buffer, BufferPNameARB pname, int* parameters) => _GetNamedBufferParameteriv_fnptr(buffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedBufferParameteriv_Lazy(BufferHandle buffer, BufferPNameARB pname, int* parameters)
            {
                _GetNamedBufferParameteriv_fnptr = (delegate* unmanaged<BufferHandle, BufferPNameARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferParameteriv");
                _GetNamedBufferParameteriv_fnptr(buffer, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferPNameARB, long*, void> _GetNamedBufferParameteri64v_fnptr = &GetNamedBufferParameteri64v_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
            public static void GetNamedBufferParameteri64v(BufferHandle buffer, BufferPNameARB pname, long* parameters) => _GetNamedBufferParameteri64v_fnptr(buffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedBufferParameteri64v_Lazy(BufferHandle buffer, BufferPNameARB pname, long* parameters)
            {
                _GetNamedBufferParameteri64v_fnptr = (delegate* unmanaged<BufferHandle, BufferPNameARB, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferParameteri64v");
                _GetNamedBufferParameteri64v_fnptr(buffer, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferPointerNameARB, void**, void> _GetNamedBufferPointerv_fnptr = &GetNamedBufferPointerv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return the pointer to a mapped buffer object's data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
            /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
            /// <param name="parameters"> Returns the pointer value specified by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
            public static void GetNamedBufferPointerv(BufferHandle buffer, BufferPointerNameARB pname, void** parameters) => _GetNamedBufferPointerv_fnptr(buffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedBufferPointerv_Lazy(BufferHandle buffer, BufferPointerNameARB pname, void** parameters)
            {
                _GetNamedBufferPointerv_fnptr = (delegate* unmanaged<BufferHandle, BufferPointerNameARB, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferPointerv");
                _GetNamedBufferPointerv_fnptr(buffer, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void> _GetNamedBufferSubData_fnptr = &GetNamedBufferSubData_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Returns a subset of a buffer object's data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
            /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
            public static void GetNamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, void* data) => _GetNamedBufferSubData_fnptr(buffer, offset, size, data);
            [UnmanagedCallersOnly]
            private static void GetNamedBufferSubData_Lazy(BufferHandle buffer, IntPtr offset, nint size, void* data)
            {
                _GetNamedBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferSubData");
                _GetNamedBufferSubData_fnptr(buffer, offset, size, data);
            }
            
            private static delegate* unmanaged<int, FramebufferHandle*, void> _CreateFramebuffers_fnptr = &CreateFramebuffers_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create framebuffer objects. </summary>
            /// <param name="n"> Number of framebuffer objects to create. </param>
            /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml" /></remarks>
            public static void CreateFramebuffers(int n, FramebufferHandle* framebuffers) => _CreateFramebuffers_fnptr(n, framebuffers);
            [UnmanagedCallersOnly]
            private static void CreateFramebuffers_Lazy(int n, FramebufferHandle* framebuffers)
            {
                _CreateFramebuffers_fnptr = (delegate* unmanaged<int, FramebufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateFramebuffers");
                _CreateFramebuffers_fnptr(n, framebuffers);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void> _NamedFramebufferRenderbuffer_fnptr = &NamedFramebufferRenderbuffer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
            public static void NamedFramebufferRenderbuffer(FramebufferHandle framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => _NamedFramebufferRenderbuffer_fnptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferRenderbuffer_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer)
            {
                _NamedFramebufferRenderbuffer_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferRenderbuffer");
                _NamedFramebufferRenderbuffer_fnptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferParameterName, int, void> _NamedFramebufferParameteri_fnptr = &NamedFramebufferParameteri_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
            public static void NamedFramebufferParameteri(FramebufferHandle framebuffer, FramebufferParameterName pname, int param) => _NamedFramebufferParameteri_fnptr(framebuffer, pname, param);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferParameteri_Lazy(FramebufferHandle framebuffer, FramebufferParameterName pname, int param)
            {
                _NamedFramebufferParameteri_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferParameteri");
                _NamedFramebufferParameteri_fnptr(framebuffer, pname, param);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, void> _NamedFramebufferTexture_fnptr = &NamedFramebufferTexture_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void NamedFramebufferTexture(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level) => _NamedFramebufferTexture_fnptr(framebuffer, attachment, texture, level);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferTexture_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level)
            {
                _NamedFramebufferTexture_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTexture");
                _NamedFramebufferTexture_fnptr(framebuffer, attachment, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, int, void> _NamedFramebufferTextureLayer_fnptr = &NamedFramebufferTextureLayer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
            public static void NamedFramebufferTextureLayer(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => _NamedFramebufferTextureLayer_fnptr(framebuffer, attachment, texture, level, layer);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferTextureLayer_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, int layer)
            {
                _NamedFramebufferTextureLayer_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTextureLayer");
                _NamedFramebufferTextureLayer_fnptr(framebuffer, attachment, texture, level, layer);
            }
            
            private static delegate* unmanaged<FramebufferHandle, ColorBuffer, void> _NamedFramebufferDrawBuffer_fnptr = &NamedFramebufferDrawBuffer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify which color buffers are to be drawn into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
            /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
            public static void NamedFramebufferDrawBuffer(FramebufferHandle framebuffer, ColorBuffer buf) => _NamedFramebufferDrawBuffer_fnptr(framebuffer, buf);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferDrawBuffer_Lazy(FramebufferHandle framebuffer, ColorBuffer buf)
            {
                _NamedFramebufferDrawBuffer_fnptr = (delegate* unmanaged<FramebufferHandle, ColorBuffer, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferDrawBuffer");
                _NamedFramebufferDrawBuffer_fnptr(framebuffer, buf);
            }
            
            private static delegate* unmanaged<FramebufferHandle, int, ColorBuffer*, void> _NamedFramebufferDrawBuffers_fnptr = &NamedFramebufferDrawBuffers_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specifies a list of color buffers to be drawn    into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
            /// <param name="n">Specifies the number of buffers in bufs.</param>
            /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
            public static void NamedFramebufferDrawBuffers(FramebufferHandle framebuffer, int n, ColorBuffer* bufs) => _NamedFramebufferDrawBuffers_fnptr(framebuffer, n, bufs);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferDrawBuffers_Lazy(FramebufferHandle framebuffer, int n, ColorBuffer* bufs)
            {
                _NamedFramebufferDrawBuffers_fnptr = (delegate* unmanaged<FramebufferHandle, int, ColorBuffer*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferDrawBuffers");
                _NamedFramebufferDrawBuffers_fnptr(framebuffer, n, bufs);
            }
            
            private static delegate* unmanaged<FramebufferHandle, ColorBuffer, void> _NamedFramebufferReadBuffer_fnptr = &NamedFramebufferReadBuffer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Select a color buffer source for pixels. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
            /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
            public static void NamedFramebufferReadBuffer(FramebufferHandle framebuffer, ColorBuffer src) => _NamedFramebufferReadBuffer_fnptr(framebuffer, src);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferReadBuffer_Lazy(FramebufferHandle framebuffer, ColorBuffer src)
            {
                _NamedFramebufferReadBuffer_fnptr = (delegate* unmanaged<FramebufferHandle, ColorBuffer, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferReadBuffer");
                _NamedFramebufferReadBuffer_fnptr(framebuffer, src);
            }
            
            private static delegate* unmanaged<FramebufferHandle, int, FramebufferAttachment*, void> _InvalidateNamedFramebufferData_fnptr = &InvalidateNamedFramebufferData_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Invalidate the content of some or all of a framebuffer's attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
            public static void InvalidateNamedFramebufferData(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments) => _InvalidateNamedFramebufferData_fnptr(framebuffer, numAttachments, attachments);
            [UnmanagedCallersOnly]
            private static void InvalidateNamedFramebufferData_Lazy(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments)
            {
                _InvalidateNamedFramebufferData_fnptr = (delegate* unmanaged<FramebufferHandle, int, FramebufferAttachment*, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateNamedFramebufferData");
                _InvalidateNamedFramebufferData_fnptr(framebuffer, numAttachments, attachments);
            }
            
            private static delegate* unmanaged<FramebufferHandle, int, FramebufferAttachment*, int, int, int, int, void> _InvalidateNamedFramebufferSubData_fnptr = &InvalidateNamedFramebufferSubData_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Invalidate the content of a region of some or all of a framebuffer's attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
            public static void InvalidateNamedFramebufferSubData(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => _InvalidateNamedFramebufferSubData_fnptr(framebuffer, numAttachments, attachments, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void InvalidateNamedFramebufferSubData_Lazy(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height)
            {
                _InvalidateNamedFramebufferSubData_fnptr = (delegate* unmanaged<FramebufferHandle, int, FramebufferAttachment*, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateNamedFramebufferSubData");
                _InvalidateNamedFramebufferSubData_fnptr(framebuffer, numAttachments, attachments, x, y, width, height);
            }
            
            private static delegate* unmanaged<FramebufferHandle, Buffer, int, int*, void> _ClearNamedFramebufferiv_fnptr = &ClearNamedFramebufferiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferiv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, int* value) => _ClearNamedFramebufferiv_fnptr(framebuffer, buffer, drawbuffer, value);
            [UnmanagedCallersOnly]
            private static void ClearNamedFramebufferiv_Lazy(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, int* value)
            {
                _ClearNamedFramebufferiv_fnptr = (delegate* unmanaged<FramebufferHandle, Buffer, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedFramebufferiv");
                _ClearNamedFramebufferiv_fnptr(framebuffer, buffer, drawbuffer, value);
            }
            
            private static delegate* unmanaged<FramebufferHandle, Buffer, int, uint*, void> _ClearNamedFramebufferuiv_fnptr = &ClearNamedFramebufferuiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferuiv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, uint* value) => _ClearNamedFramebufferuiv_fnptr(framebuffer, buffer, drawbuffer, value);
            [UnmanagedCallersOnly]
            private static void ClearNamedFramebufferuiv_Lazy(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, uint* value)
            {
                _ClearNamedFramebufferuiv_fnptr = (delegate* unmanaged<FramebufferHandle, Buffer, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedFramebufferuiv");
                _ClearNamedFramebufferuiv_fnptr(framebuffer, buffer, drawbuffer, value);
            }
            
            private static delegate* unmanaged<FramebufferHandle, Buffer, int, float*, void> _ClearNamedFramebufferfv_fnptr = &ClearNamedFramebufferfv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferfv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float* value) => _ClearNamedFramebufferfv_fnptr(framebuffer, buffer, drawbuffer, value);
            [UnmanagedCallersOnly]
            private static void ClearNamedFramebufferfv_Lazy(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float* value)
            {
                _ClearNamedFramebufferfv_fnptr = (delegate* unmanaged<FramebufferHandle, Buffer, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedFramebufferfv");
                _ClearNamedFramebufferfv_fnptr(framebuffer, buffer, drawbuffer, value);
            }
            
            private static delegate* unmanaged<FramebufferHandle, Buffer, int, float, int, void> _ClearNamedFramebufferfi_fnptr = &ClearNamedFramebufferfi_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="depth"> The value to clear the depth buffer to. </param>
            /// <param name="stencil"> The value to clear the stencil buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferfi(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => _ClearNamedFramebufferfi_fnptr(framebuffer, buffer, drawbuffer, depth, stencil);
            [UnmanagedCallersOnly]
            private static void ClearNamedFramebufferfi_Lazy(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil)
            {
                _ClearNamedFramebufferfi_fnptr = (delegate* unmanaged<FramebufferHandle, Buffer, int, float, int, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedFramebufferfi");
                _ClearNamedFramebufferfi_fnptr(framebuffer, buffer, drawbuffer, depth, stencil);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferHandle, int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void> _BlitNamedFramebuffer_fnptr = &BlitNamedFramebuffer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
            public static void BlitNamedFramebuffer(FramebufferHandle readFramebuffer, FramebufferHandle drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => _BlitNamedFramebuffer_fnptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            [UnmanagedCallersOnly]
            private static void BlitNamedFramebuffer_Lazy(FramebufferHandle readFramebuffer, FramebufferHandle drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter)
            {
                _BlitNamedFramebuffer_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferHandle, int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void>)GLLoader.BindingsContext.GetProcAddress("glBlitNamedFramebuffer");
                _BlitNamedFramebuffer_fnptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferTarget, FramebufferStatus> _CheckNamedFramebufferStatus_fnptr = &CheckNamedFramebufferStatus_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Check the completeness status of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
            public static FramebufferStatus CheckNamedFramebufferStatus(FramebufferHandle framebuffer, FramebufferTarget target) => _CheckNamedFramebufferStatus_fnptr(framebuffer, target);
            [UnmanagedCallersOnly]
            private static FramebufferStatus CheckNamedFramebufferStatus_Lazy(FramebufferHandle framebuffer, FramebufferTarget target)
            {
                _CheckNamedFramebufferStatus_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferTarget, FramebufferStatus>)GLLoader.BindingsContext.GetProcAddress("glCheckNamedFramebufferStatus");
                return _CheckNamedFramebufferStatus_fnptr(framebuffer, target);
            }
            
            private static delegate* unmanaged<FramebufferHandle, GetFramebufferParameter, int*, void> _GetNamedFramebufferParameteriv_fnptr = &GetNamedFramebufferParameteriv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="param">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
            public static void GetNamedFramebufferParameteriv(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* param) => _GetNamedFramebufferParameteriv_fnptr(framebuffer, pname, param);
            [UnmanagedCallersOnly]
            private static void GetNamedFramebufferParameteriv_Lazy(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* param)
            {
                _GetNamedFramebufferParameteriv_fnptr = (delegate* unmanaged<FramebufferHandle, GetFramebufferParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedFramebufferParameteriv");
                _GetNamedFramebufferParameteriv_fnptr(framebuffer, pname, param);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void> _GetNamedFramebufferAttachmentParameteriv_fnptr = &GetNamedFramebufferAttachmentParameteriv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
            public static void GetNamedFramebufferAttachmentParameteriv(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => _GetNamedFramebufferAttachmentParameteriv_fnptr(framebuffer, attachment, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedFramebufferAttachmentParameteriv_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters)
            {
                _GetNamedFramebufferAttachmentParameteriv_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedFramebufferAttachmentParameteriv");
                _GetNamedFramebufferAttachmentParameteriv_fnptr(framebuffer, attachment, pname, parameters);
            }
            
            private static delegate* unmanaged<int, RenderbufferHandle*, void> _CreateRenderbuffers_fnptr = &CreateRenderbuffers_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create renderbuffer objects. </summary>
            /// <param name="n"> Number of renderbuffer objects to create. </param>
            /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml" /></remarks>
            public static void CreateRenderbuffers(int n, RenderbufferHandle* renderbuffers) => _CreateRenderbuffers_fnptr(n, renderbuffers);
            [UnmanagedCallersOnly]
            private static void CreateRenderbuffers_Lazy(int n, RenderbufferHandle* renderbuffers)
            {
                _CreateRenderbuffers_fnptr = (delegate* unmanaged<int, RenderbufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateRenderbuffers");
                _CreateRenderbuffers_fnptr(n, renderbuffers);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, InternalFormat, int, int, void> _NamedRenderbufferStorage_fnptr = &NamedRenderbufferStorage_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Establish data storage, format and dimensions of a    renderbuffer object's image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
            public static void NamedRenderbufferStorage(RenderbufferHandle renderbuffer, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorage_fnptr(renderbuffer, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void NamedRenderbufferStorage_Lazy(RenderbufferHandle renderbuffer, InternalFormat internalformat, int width, int height)
            {
                _NamedRenderbufferStorage_fnptr = (delegate* unmanaged<RenderbufferHandle, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedRenderbufferStorage");
                _NamedRenderbufferStorage_fnptr(renderbuffer, internalformat, width, height);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, int, InternalFormat, int, int, void> _NamedRenderbufferStorageMultisample_fnptr = &NamedRenderbufferStorageMultisample_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object's image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
            public static void NamedRenderbufferStorageMultisample(RenderbufferHandle renderbuffer, int samples, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageMultisample_fnptr(renderbuffer, samples, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void NamedRenderbufferStorageMultisample_Lazy(RenderbufferHandle renderbuffer, int samples, InternalFormat internalformat, int width, int height)
            {
                _NamedRenderbufferStorageMultisample_fnptr = (delegate* unmanaged<RenderbufferHandle, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedRenderbufferStorageMultisample");
                _NamedRenderbufferStorageMultisample_fnptr(renderbuffer, samples, internalformat, width, height);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, RenderbufferParameterName, int*, void> _GetNamedRenderbufferParameteriv_fnptr = &GetNamedRenderbufferParameteriv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
            public static void GetNamedRenderbufferParameteriv(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int* parameters) => _GetNamedRenderbufferParameteriv_fnptr(renderbuffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedRenderbufferParameteriv_Lazy(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int* parameters)
            {
                _GetNamedRenderbufferParameteriv_fnptr = (delegate* unmanaged<RenderbufferHandle, RenderbufferParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedRenderbufferParameteriv");
                _GetNamedRenderbufferParameteriv_fnptr(renderbuffer, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, int, TextureHandle*, void> _CreateTextures_fnptr = &CreateTextures_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create texture objects. </summary>
            /// <param name="target"> Specifies the effective texture target of each created texture. </param>
            /// <param name="n"> Number of texture objects to create. </param>
            /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml" /></remarks>
            public static void CreateTextures(TextureTarget target, int n, TextureHandle* textures) => _CreateTextures_fnptr(target, n, textures);
            [UnmanagedCallersOnly]
            private static void CreateTextures_Lazy(TextureTarget target, int n, TextureHandle* textures)
            {
                _CreateTextures_fnptr = (delegate* unmanaged<TextureTarget, int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateTextures");
                _CreateTextures_fnptr(target, n, textures);
            }
            
            private static delegate* unmanaged<TextureHandle, SizedInternalFormat, BufferHandle, void> _TextureBuffer_fnptr = &TextureBuffer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a buffer object's data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
            public static void TextureBuffer(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer) => _TextureBuffer_fnptr(texture, internalformat, buffer);
            [UnmanagedCallersOnly]
            private static void TextureBuffer_Lazy(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer)
            {
                _TextureBuffer_fnptr = (delegate* unmanaged<TextureHandle, SizedInternalFormat, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTextureBuffer");
                _TextureBuffer_fnptr(texture, internalformat, buffer);
            }
            
            private static delegate* unmanaged<TextureHandle, SizedInternalFormat, BufferHandle, IntPtr, nint, void> _TextureBufferRange_fnptr = &TextureBufferRange_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a range of a buffer object's data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer's data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer's data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
            public static void TextureBufferRange(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => _TextureBufferRange_fnptr(texture, internalformat, buffer, offset, size);
            [UnmanagedCallersOnly]
            private static void TextureBufferRange_Lazy(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size)
            {
                _TextureBufferRange_fnptr = (delegate* unmanaged<TextureHandle, SizedInternalFormat, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glTextureBufferRange");
                _TextureBufferRange_fnptr(texture, internalformat, buffer, offset, size);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, void> _TextureStorage1D_fnptr = &TextureStorage1D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
            public static void TextureStorage1D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width) => _TextureStorage1D_fnptr(texture, levels, internalformat, width);
            [UnmanagedCallersOnly]
            private static void TextureStorage1D_Lazy(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width)
            {
                _TextureStorage1D_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage1D");
                _TextureStorage1D_fnptr(texture, levels, internalformat, width);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, void> _TextureStorage2D_fnptr = &TextureStorage2D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
            public static void TextureStorage2D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height) => _TextureStorage2D_fnptr(texture, levels, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void TextureStorage2D_Lazy(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height)
            {
                _TextureStorage2D_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage2D");
                _TextureStorage2D_fnptr(texture, levels, internalformat, width, height);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, void> _TextureStorage3D_fnptr = &TextureStorage3D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
            public static void TextureStorage3D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => _TextureStorage3D_fnptr(texture, levels, internalformat, width, height, depth);
            [UnmanagedCallersOnly]
            private static void TextureStorage3D_Lazy(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth)
            {
                _TextureStorage3D_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage3D");
                _TextureStorage3D_fnptr(texture, levels, internalformat, width, height, depth);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, byte, void> _TextureStorage2DMultisample_fnptr = &TextureStorage2DMultisample_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
            public static void TextureStorage2DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations) => _TextureStorage2DMultisample_fnptr(texture, samples, internalformat, width, height, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void TextureStorage2DMultisample_Lazy(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations)
            {
                _TextureStorage2DMultisample_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage2DMultisample");
                _TextureStorage2DMultisample_fnptr(texture, samples, internalformat, width, height, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, byte, void> _TextureStorage3DMultisample_fnptr = &TextureStorage3DMultisample_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
            public static void TextureStorage3DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations) => _TextureStorage3DMultisample_fnptr(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void TextureStorage3DMultisample_Lazy(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations)
            {
                _TextureStorage3DMultisample_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage3DMultisample");
                _TextureStorage3DMultisample_fnptr(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, PixelFormat, PixelType, void*, void> _TextureSubImage1D_fnptr = &TextureSubImage1D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a one-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
            public static void TextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => _TextureSubImage1D_fnptr(texture, level, xoffset, width, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TextureSubImage1D_Lazy(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels)
            {
                _TextureSubImage1D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureSubImage1D");
                _TextureSubImage1D_fnptr(texture, level, xoffset, width, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TextureSubImage2D_fnptr = &TextureSubImage2D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a two-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
            public static void TextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => _TextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TextureSubImage2D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels)
            {
                _TextureSubImage2D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureSubImage2D");
                _TextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TextureSubImage3D_fnptr = &TextureSubImage3D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a three-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="depth"> Specifies the depth of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
            public static void TextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => _TextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TextureSubImage3D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels)
            {
                _TextureSubImage3D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureSubImage3D");
                _TextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, InternalFormat, int, void*, void> _CompressedTextureSubImage1D_fnptr = &CompressedTextureSubImage1D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a one-dimensional texture subimage in a compressed    format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
            public static void CompressedTextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => _CompressedTextureSubImage1D_fnptr(texture, level, xoffset, width, format, imageSize, data);
            [UnmanagedCallersOnly]
            private static void CompressedTextureSubImage1D_Lazy(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data)
            {
                _CompressedTextureSubImage1D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureSubImage1D");
                _CompressedTextureSubImage1D_fnptr(texture, level, xoffset, width, format, imageSize, data);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTextureSubImage2D_fnptr = &CompressedTextureSubImage2D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a two-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
            public static void CompressedTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => _CompressedTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
            [UnmanagedCallersOnly]
            private static void CompressedTextureSubImage2D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data)
            {
                _CompressedTextureSubImage2D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureSubImage2D");
                _CompressedTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTextureSubImage3D_fnptr = &CompressedTextureSubImage3D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a three-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">!!missing documentation!!</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
            public static void CompressedTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => _CompressedTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            [UnmanagedCallersOnly]
            private static void CompressedTextureSubImage3D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data)
            {
                _CompressedTextureSubImage3D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureSubImage3D");
                _CompressedTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, void> _CopyTextureSubImage1D_fnptr = &CopyTextureSubImage1D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a one-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
            public static void CopyTextureSubImage1D(TextureHandle texture, int level, int xoffset, int x, int y, int width) => _CopyTextureSubImage1D_fnptr(texture, level, xoffset, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyTextureSubImage1D_Lazy(TextureHandle texture, int level, int xoffset, int x, int y, int width)
            {
                _CopyTextureSubImage1D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureSubImage1D");
                _CopyTextureSubImage1D_fnptr(texture, level, xoffset, x, y, width);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, void> _CopyTextureSubImage2D_fnptr = &CopyTextureSubImage2D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a two-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
            public static void CopyTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyTextureSubImage2D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
            {
                _CopyTextureSubImage2D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureSubImage2D");
                _CopyTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, x, y, width, height);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, void> _CopyTextureSubImage3D_fnptr = &CopyTextureSubImage3D_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a three-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
            public static void CopyTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyTextureSubImage3D_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
            {
                _CopyTextureSubImage3D_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureSubImage3D");
                _CopyTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureParameterName, float, void> _TextureParameterf_fnptr = &TextureParameterf_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterf(TextureHandle texture, TextureParameterName pname, float param) => _TextureParameterf_fnptr(texture, pname, param);
            [UnmanagedCallersOnly]
            private static void TextureParameterf_Lazy(TextureHandle texture, TextureParameterName pname, float param)
            {
                _TextureParameterf_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, float, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterf");
                _TextureParameterf_fnptr(texture, pname, param);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureParameterName, float*, void> _TextureParameterfv_fnptr = &TextureParameterfv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterfv(TextureHandle texture, TextureParameterName pname, float* param) => _TextureParameterfv_fnptr(texture, pname, param);
            [UnmanagedCallersOnly]
            private static void TextureParameterfv_Lazy(TextureHandle texture, TextureParameterName pname, float* param)
            {
                _TextureParameterfv_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterfv");
                _TextureParameterfv_fnptr(texture, pname, param);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureParameterName, int, void> _TextureParameteri_fnptr = &TextureParameteri_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameteri(TextureHandle texture, TextureParameterName pname, int param) => _TextureParameteri_fnptr(texture, pname, param);
            [UnmanagedCallersOnly]
            private static void TextureParameteri_Lazy(TextureHandle texture, TextureParameterName pname, int param)
            {
                _TextureParameteri_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameteri");
                _TextureParameteri_fnptr(texture, pname, param);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureParameterName, int*, void> _TextureParameterIiv_fnptr = &TextureParameterIiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterIiv(TextureHandle texture, TextureParameterName pname, int* parameters) => _TextureParameterIiv_fnptr(texture, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TextureParameterIiv_Lazy(TextureHandle texture, TextureParameterName pname, int* parameters)
            {
                _TextureParameterIiv_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterIiv");
                _TextureParameterIiv_fnptr(texture, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureParameterName, uint*, void> _TextureParameterIuiv_fnptr = &TextureParameterIuiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterIuiv(TextureHandle texture, TextureParameterName pname, uint* parameters) => _TextureParameterIuiv_fnptr(texture, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TextureParameterIuiv_Lazy(TextureHandle texture, TextureParameterName pname, uint* parameters)
            {
                _TextureParameterIuiv_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterIuiv");
                _TextureParameterIuiv_fnptr(texture, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureParameterName, int*, void> _TextureParameteriv_fnptr = &TextureParameteriv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameteriv(TextureHandle texture, TextureParameterName pname, int* param) => _TextureParameteriv_fnptr(texture, pname, param);
            [UnmanagedCallersOnly]
            private static void TextureParameteriv_Lazy(TextureHandle texture, TextureParameterName pname, int* param)
            {
                _TextureParameteriv_fnptr = (delegate* unmanaged<TextureHandle, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameteriv");
                _TextureParameteriv_fnptr(texture, pname, param);
            }
            
            private static delegate* unmanaged<TextureHandle, void> _GenerateTextureMipmap_fnptr = &GenerateTextureMipmap_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Generate mipmaps for a specified texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
            public static void GenerateTextureMipmap(TextureHandle texture) => _GenerateTextureMipmap_fnptr(texture);
            [UnmanagedCallersOnly]
            private static void GenerateTextureMipmap_Lazy(TextureHandle texture)
            {
                _GenerateTextureMipmap_fnptr = (delegate* unmanaged<TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glGenerateTextureMipmap");
                _GenerateTextureMipmap_fnptr(texture);
            }
            
            private static delegate* unmanaged<uint, TextureHandle, void> _BindTextureUnit_fnptr = &BindTextureUnit_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind an existing texture object to the specified texture unit . </summary>
            /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
            /// <param name="texture">Specifies the name of a texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml" /></remarks>
            public static void BindTextureUnit(uint unit, TextureHandle texture) => _BindTextureUnit_fnptr(unit, texture);
            [UnmanagedCallersOnly]
            private static void BindTextureUnit_Lazy(uint unit, TextureHandle texture)
            {
                _BindTextureUnit_fnptr = (delegate* unmanaged<uint, TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindTextureUnit");
                _BindTextureUnit_fnptr(unit, texture);
            }
            
            private static delegate* unmanaged<TextureHandle, int, PixelFormat, PixelType, int, void*, void> _GetTextureImage_fnptr = &GetTextureImage_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return a texture image. </summary>
            /// <param name="texture"> Specifies the texture object name. </param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
            /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
            /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
            public static void GetTextureImage(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => _GetTextureImage_fnptr(texture, level, format, type, bufSize, pixels);
            [UnmanagedCallersOnly]
            private static void GetTextureImage_Lazy(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels)
            {
                _GetTextureImage_fnptr = (delegate* unmanaged<TextureHandle, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureImage");
                _GetTextureImage_fnptr(texture, level, format, type, bufSize, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, void*, void> _GetCompressedTextureImage_fnptr = &GetCompressedTextureImage_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return a compressed texture image. </summary>
            /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
            /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
            /// <param name="pixels">Returns the compressed texture image.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
            public static void GetCompressedTextureImage(TextureHandle texture, int level, int bufSize, void* pixels) => _GetCompressedTextureImage_fnptr(texture, level, bufSize, pixels);
            [UnmanagedCallersOnly]
            private static void GetCompressedTextureImage_Lazy(TextureHandle texture, int level, int bufSize, void* pixels)
            {
                _GetCompressedTextureImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCompressedTextureImage");
                _GetCompressedTextureImage_fnptr(texture, level, bufSize, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, int, GetTextureParameter, float*, void> _GetTextureLevelParameterfv_fnptr = &GetTextureLevelParameterfv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
            public static void GetTextureLevelParameterfv(TextureHandle texture, int level, GetTextureParameter pname, float* parameters) => _GetTextureLevelParameterfv_fnptr(texture, level, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureLevelParameterfv_Lazy(TextureHandle texture, int level, GetTextureParameter pname, float* parameters)
            {
                _GetTextureLevelParameterfv_fnptr = (delegate* unmanaged<TextureHandle, int, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureLevelParameterfv");
                _GetTextureLevelParameterfv_fnptr(texture, level, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, int, GetTextureParameter, int*, void> _GetTextureLevelParameteriv_fnptr = &GetTextureLevelParameteriv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
            public static void GetTextureLevelParameteriv(TextureHandle texture, int level, GetTextureParameter pname, int* parameters) => _GetTextureLevelParameteriv_fnptr(texture, level, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureLevelParameteriv_Lazy(TextureHandle texture, int level, GetTextureParameter pname, int* parameters)
            {
                _GetTextureLevelParameteriv_fnptr = (delegate* unmanaged<TextureHandle, int, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureLevelParameteriv");
                _GetTextureLevelParameteriv_fnptr(texture, level, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, GetTextureParameter, float*, void> _GetTextureParameterfv_fnptr = &GetTextureParameterfv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterfv(TextureHandle texture, GetTextureParameter pname, float* parameters) => _GetTextureParameterfv_fnptr(texture, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureParameterfv_Lazy(TextureHandle texture, GetTextureParameter pname, float* parameters)
            {
                _GetTextureParameterfv_fnptr = (delegate* unmanaged<TextureHandle, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterfv");
                _GetTextureParameterfv_fnptr(texture, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, GetTextureParameter, int*, void> _GetTextureParameterIiv_fnptr = &GetTextureParameterIiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterIiv(TextureHandle texture, GetTextureParameter pname, int* parameters) => _GetTextureParameterIiv_fnptr(texture, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureParameterIiv_Lazy(TextureHandle texture, GetTextureParameter pname, int* parameters)
            {
                _GetTextureParameterIiv_fnptr = (delegate* unmanaged<TextureHandle, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterIiv");
                _GetTextureParameterIiv_fnptr(texture, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, GetTextureParameter, uint*, void> _GetTextureParameterIuiv_fnptr = &GetTextureParameterIuiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterIuiv(TextureHandle texture, GetTextureParameter pname, uint* parameters) => _GetTextureParameterIuiv_fnptr(texture, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureParameterIuiv_Lazy(TextureHandle texture, GetTextureParameter pname, uint* parameters)
            {
                _GetTextureParameterIuiv_fnptr = (delegate* unmanaged<TextureHandle, GetTextureParameter, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterIuiv");
                _GetTextureParameterIuiv_fnptr(texture, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, GetTextureParameter, int*, void> _GetTextureParameteriv_fnptr = &GetTextureParameteriv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameteriv(TextureHandle texture, GetTextureParameter pname, int* parameters) => _GetTextureParameteriv_fnptr(texture, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureParameteriv_Lazy(TextureHandle texture, GetTextureParameter pname, int* parameters)
            {
                _GetTextureParameteriv_fnptr = (delegate* unmanaged<TextureHandle, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameteriv");
                _GetTextureParameteriv_fnptr(texture, pname, parameters);
            }
            
            private static delegate* unmanaged<int, VertexArrayHandle*, void> _CreateVertexArrays_fnptr = &CreateVertexArrays_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create vertex array objects. </summary>
            /// <param name="n"> Number of vertex array objects to create. </param>
            /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml" /></remarks>
            public static void CreateVertexArrays(int n, VertexArrayHandle* arrays) => _CreateVertexArrays_fnptr(n, arrays);
            [UnmanagedCallersOnly]
            private static void CreateVertexArrays_Lazy(int n, VertexArrayHandle* arrays)
            {
                _CreateVertexArrays_fnptr = (delegate* unmanaged<int, VertexArrayHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateVertexArrays");
                _CreateVertexArrays_fnptr(n, arrays);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, void> _DisableVertexArrayAttrib_fnptr = &DisableVertexArrayAttrib_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
            public static void DisableVertexArrayAttrib(VertexArrayHandle vaobj, uint index) => _DisableVertexArrayAttrib_fnptr(vaobj, index);
            [UnmanagedCallersOnly]
            private static void DisableVertexArrayAttrib_Lazy(VertexArrayHandle vaobj, uint index)
            {
                _DisableVertexArrayAttrib_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisableVertexArrayAttrib");
                _DisableVertexArrayAttrib_fnptr(vaobj, index);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, void> _EnableVertexArrayAttrib_fnptr = &EnableVertexArrayAttrib_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
            public static void EnableVertexArrayAttrib(VertexArrayHandle vaobj, uint index) => _EnableVertexArrayAttrib_fnptr(vaobj, index);
            [UnmanagedCallersOnly]
            private static void EnableVertexArrayAttrib_Lazy(VertexArrayHandle vaobj, uint index)
            {
                _EnableVertexArrayAttrib_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnableVertexArrayAttrib");
                _EnableVertexArrayAttrib_fnptr(vaobj, index);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, void> _VertexArrayElementBuffer_fnptr = &VertexArrayElementBuffer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Configures element array buffer binding of a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
            /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml" /></remarks>
            public static void VertexArrayElementBuffer(VertexArrayHandle vaobj, BufferHandle buffer) => _VertexArrayElementBuffer_fnptr(vaobj, buffer);
            [UnmanagedCallersOnly]
            private static void VertexArrayElementBuffer_Lazy(VertexArrayHandle vaobj, BufferHandle buffer)
            {
                _VertexArrayElementBuffer_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayElementBuffer");
                _VertexArrayElementBuffer_fnptr(vaobj, buffer);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, BufferHandle, IntPtr, int, void> _VertexArrayVertexBuffer_fnptr = &VertexArrayVertexBuffer_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
            public static void VertexArrayVertexBuffer(VertexArrayHandle vaobj, uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => _VertexArrayVertexBuffer_fnptr(vaobj, bindingindex, buffer, offset, stride);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexBuffer_Lazy(VertexArrayHandle vaobj, uint bindingindex, BufferHandle buffer, IntPtr offset, int stride)
            {
                _VertexArrayVertexBuffer_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, BufferHandle, IntPtr, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexBuffer");
                _VertexArrayVertexBuffer_fnptr(vaobj, bindingindex, buffer, offset, stride);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, int, BufferHandle*, IntPtr*, int*, void> _VertexArrayVertexBuffers_fnptr = &VertexArrayVertexBuffers_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
            public static void VertexArrayVertexBuffers(VertexArrayHandle vaobj, uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides) => _VertexArrayVertexBuffers_fnptr(vaobj, first, count, buffers, offsets, strides);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexBuffers_Lazy(VertexArrayHandle vaobj, uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides)
            {
                _VertexArrayVertexBuffers_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, BufferHandle*, IntPtr*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexBuffers");
                _VertexArrayVertexBuffers_fnptr(vaobj, first, count, buffers, offsets, strides);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, uint, void> _VertexArrayAttribBinding_fnptr = &VertexArrayAttribBinding_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
            public static void VertexArrayAttribBinding(VertexArrayHandle vaobj, uint attribindex, uint bindingindex) => _VertexArrayAttribBinding_fnptr(vaobj, attribindex, bindingindex);
            [UnmanagedCallersOnly]
            private static void VertexArrayAttribBinding_Lazy(VertexArrayHandle vaobj, uint attribindex, uint bindingindex)
            {
                _VertexArrayAttribBinding_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayAttribBinding");
                _VertexArrayAttribBinding_fnptr(vaobj, attribindex, bindingindex);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribType, byte, uint, void> _VertexArrayAttribFormat_fnptr = &VertexArrayAttribFormat_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset) => _VertexArrayAttribFormat_fnptr(vaobj, attribindex, size, type, normalized, relativeoffset);
            [UnmanagedCallersOnly]
            private static void VertexArrayAttribFormat_Lazy(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset)
            {
                _VertexArrayAttribFormat_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayAttribFormat");
                _VertexArrayAttribFormat_fnptr(vaobj, attribindex, size, type, normalized, relativeoffset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribIType, uint, void> _VertexArrayAttribIFormat_fnptr = &VertexArrayAttribIFormat_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribIFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => _VertexArrayAttribIFormat_fnptr(vaobj, attribindex, size, type, relativeoffset);
            [UnmanagedCallersOnly]
            private static void VertexArrayAttribIFormat_Lazy(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset)
            {
                _VertexArrayAttribIFormat_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribIType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayAttribIFormat");
                _VertexArrayAttribIFormat_fnptr(vaobj, attribindex, size, type, relativeoffset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribLType, uint, void> _VertexArrayAttribLFormat_fnptr = &VertexArrayAttribLFormat_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribLFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => _VertexArrayAttribLFormat_fnptr(vaobj, attribindex, size, type, relativeoffset);
            [UnmanagedCallersOnly]
            private static void VertexArrayAttribLFormat_Lazy(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset)
            {
                _VertexArrayAttribLFormat_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribLType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayAttribLFormat");
                _VertexArrayAttribLFormat_fnptr(vaobj, attribindex, size, type, relativeoffset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, uint, void> _VertexArrayBindingDivisor_fnptr = &VertexArrayBindingDivisor_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
            public static void VertexArrayBindingDivisor(VertexArrayHandle vaobj, uint bindingindex, uint divisor) => _VertexArrayBindingDivisor_fnptr(vaobj, bindingindex, divisor);
            [UnmanagedCallersOnly]
            private static void VertexArrayBindingDivisor_Lazy(VertexArrayHandle vaobj, uint bindingindex, uint divisor)
            {
                _VertexArrayBindingDivisor_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayBindingDivisor");
                _VertexArrayBindingDivisor_fnptr(vaobj, bindingindex, divisor);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, VertexArrayPName, int*, void> _GetVertexArrayiv_fnptr = &GetVertexArrayiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of a vertex array object. </summary>
            /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
            /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml" /></remarks>
            public static void GetVertexArrayiv(VertexArrayHandle vaobj, VertexArrayPName pname, int* param) => _GetVertexArrayiv_fnptr(vaobj, pname, param);
            [UnmanagedCallersOnly]
            private static void GetVertexArrayiv_Lazy(VertexArrayHandle vaobj, VertexArrayPName pname, int* param)
            {
                _GetVertexArrayiv_fnptr = (delegate* unmanaged<VertexArrayHandle, VertexArrayPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayiv");
                _GetVertexArrayiv_fnptr(vaobj, pname, param);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, int*, void> _GetVertexArrayIndexediv_fnptr = &GetVertexArrayIndexediv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
            public static void GetVertexArrayIndexediv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, int* param) => _GetVertexArrayIndexediv_fnptr(vaobj, index, pname, param);
            [UnmanagedCallersOnly]
            private static void GetVertexArrayIndexediv_Lazy(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, int* param)
            {
                _GetVertexArrayIndexediv_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayIndexediv");
                _GetVertexArrayIndexediv_fnptr(vaobj, index, pname, param);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, long*, void> _GetVertexArrayIndexed64iv_fnptr = &GetVertexArrayIndexed64iv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
            public static void GetVertexArrayIndexed64iv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, long* param) => _GetVertexArrayIndexed64iv_fnptr(vaobj, index, pname, param);
            [UnmanagedCallersOnly]
            private static void GetVertexArrayIndexed64iv_Lazy(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, long* param)
            {
                _GetVertexArrayIndexed64iv_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayIndexed64iv");
                _GetVertexArrayIndexed64iv_fnptr(vaobj, index, pname, param);
            }
            
            private static delegate* unmanaged<int, SamplerHandle*, void> _CreateSamplers_fnptr = &CreateSamplers_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create sampler objects. </summary>
            /// <param name="n"> Number of sampler objects to create. </param>
            /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml" /></remarks>
            public static void CreateSamplers(int n, SamplerHandle* samplers) => _CreateSamplers_fnptr(n, samplers);
            [UnmanagedCallersOnly]
            private static void CreateSamplers_Lazy(int n, SamplerHandle* samplers)
            {
                _CreateSamplers_fnptr = (delegate* unmanaged<int, SamplerHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateSamplers");
                _CreateSamplers_fnptr(n, samplers);
            }
            
            private static delegate* unmanaged<int, ProgramPipelineHandle*, void> _CreateProgramPipelines_fnptr = &CreateProgramPipelines_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create program pipeline objects. </summary>
            /// <param name="n"> Number of program pipeline objects to create. </param>
            /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml" /></remarks>
            public static void CreateProgramPipelines(int n, ProgramPipelineHandle* pipelines) => _CreateProgramPipelines_fnptr(n, pipelines);
            [UnmanagedCallersOnly]
            private static void CreateProgramPipelines_Lazy(int n, ProgramPipelineHandle* pipelines)
            {
                _CreateProgramPipelines_fnptr = (delegate* unmanaged<int, ProgramPipelineHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateProgramPipelines");
                _CreateProgramPipelines_fnptr(n, pipelines);
            }
            
            private static delegate* unmanaged<QueryTarget, int, QueryHandle*, void> _CreateQueries_fnptr = &CreateQueries_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create query objects. </summary>
            /// <param name="target"> Specifies the target of each created query object. </param>
            /// <param name="n"> Number of query objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml" /></remarks>
            public static void CreateQueries(QueryTarget target, int n, QueryHandle* ids) => _CreateQueries_fnptr(target, n, ids);
            [UnmanagedCallersOnly]
            private static void CreateQueries_Lazy(QueryTarget target, int n, QueryHandle* ids)
            {
                _CreateQueries_fnptr = (delegate* unmanaged<QueryTarget, int, QueryHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateQueries");
                _CreateQueries_fnptr(target, n, ids);
            }
            
            private static delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void> _GetQueryBufferObjecti64v_fnptr = &GetQueryBufferObjecti64v_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjecti64v(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjecti64v_fnptr(id, buffer, pname, offset);
            [UnmanagedCallersOnly]
            private static void GetQueryBufferObjecti64v_Lazy(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
            {
                _GetQueryBufferObjecti64v_fnptr = (delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryBufferObjecti64v");
                _GetQueryBufferObjecti64v_fnptr(id, buffer, pname, offset);
            }
            
            private static delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void> _GetQueryBufferObjectiv_fnptr = &GetQueryBufferObjectiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectiv(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjectiv_fnptr(id, buffer, pname, offset);
            [UnmanagedCallersOnly]
            private static void GetQueryBufferObjectiv_Lazy(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
            {
                _GetQueryBufferObjectiv_fnptr = (delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryBufferObjectiv");
                _GetQueryBufferObjectiv_fnptr(id, buffer, pname, offset);
            }
            
            private static delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void> _GetQueryBufferObjectui64v_fnptr = &GetQueryBufferObjectui64v_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectui64v(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjectui64v_fnptr(id, buffer, pname, offset);
            [UnmanagedCallersOnly]
            private static void GetQueryBufferObjectui64v_Lazy(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
            {
                _GetQueryBufferObjectui64v_fnptr = (delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryBufferObjectui64v");
                _GetQueryBufferObjectui64v_fnptr(id, buffer, pname, offset);
            }
            
            private static delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void> _GetQueryBufferObjectuiv_fnptr = &GetQueryBufferObjectuiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectuiv(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjectuiv_fnptr(id, buffer, pname, offset);
            [UnmanagedCallersOnly]
            private static void GetQueryBufferObjectuiv_Lazy(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
            {
                _GetQueryBufferObjectuiv_fnptr = (delegate* unmanaged<QueryHandle, BufferHandle, QueryObjectParameterName, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryBufferObjectuiv");
                _GetQueryBufferObjectuiv_fnptr(id, buffer, pname, offset);
            }
            
            private static delegate* unmanaged<int, DrawBufferMode*, void> _DrawBuffersARB_fnptr = &DrawBuffersARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_draw_buffers]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawBuffersARB(int n, DrawBufferMode* bufs) => _DrawBuffersARB_fnptr(n, bufs);
            [UnmanagedCallersOnly]
            private static void DrawBuffersARB_Lazy(int n, DrawBufferMode* bufs)
            {
                _DrawBuffersARB_fnptr = (delegate* unmanaged<int, DrawBufferMode*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawBuffersARB");
                _DrawBuffersARB_fnptr(n, bufs);
            }
            
            private static delegate* unmanaged<uint, BlendEquationModeEXT, void> _BlendEquationiARB_fnptr = &BlendEquationiARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationiARB(uint buf, BlendEquationModeEXT mode) => _BlendEquationiARB_fnptr(buf, mode);
            [UnmanagedCallersOnly]
            private static void BlendEquationiARB_Lazy(uint buf, BlendEquationModeEXT mode)
            {
                _BlendEquationiARB_fnptr = (delegate* unmanaged<uint, BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquationiARB");
                _BlendEquationiARB_fnptr(buf, mode);
            }
            
            private static delegate* unmanaged<uint, BlendEquationModeEXT, BlendEquationModeEXT, void> _BlendEquationSeparateiARB_fnptr = &BlendEquationSeparateiARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationSeparateiARB(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparateiARB_fnptr(buf, modeRGB, modeAlpha);
            [UnmanagedCallersOnly]
            private static void BlendEquationSeparateiARB_Lazy(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha)
            {
                _BlendEquationSeparateiARB_fnptr = (delegate* unmanaged<uint, BlendEquationModeEXT, BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquationSeparateiARB");
                _BlendEquationSeparateiARB_fnptr(buf, modeRGB, modeAlpha);
            }
            
            private static delegate* unmanaged<uint, BlendingFactor, BlendingFactor, void> _BlendFunciARB_fnptr = &BlendFunciARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFunciARB(uint buf, BlendingFactor src, BlendingFactor dst) => _BlendFunciARB_fnptr(buf, src, dst);
            [UnmanagedCallersOnly]
            private static void BlendFunciARB_Lazy(uint buf, BlendingFactor src, BlendingFactor dst)
            {
                _BlendFunciARB_fnptr = (delegate* unmanaged<uint, BlendingFactor, BlendingFactor, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFunciARB");
                _BlendFunciARB_fnptr(buf, src, dst);
            }
            
            private static delegate* unmanaged<uint, BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void> _BlendFuncSeparateiARB_fnptr = &BlendFuncSeparateiARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncSeparateiARB(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => _BlendFuncSeparateiARB_fnptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
            [UnmanagedCallersOnly]
            private static void BlendFuncSeparateiARB_Lazy(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha)
            {
                _BlendFuncSeparateiARB_fnptr = (delegate* unmanaged<uint, BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFuncSeparateiARB");
                _BlendFuncSeparateiARB_fnptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void> _DrawElementsBaseVertex_fnptr = &DrawElementsBaseVertex_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml" /></remarks>
            public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => _DrawElementsBaseVertex_fnptr(mode, count, type, indices, basevertex);
            [UnmanagedCallersOnly]
            private static void DrawElementsBaseVertex_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex)
            {
                _DrawElementsBaseVertex_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsBaseVertex");
                _DrawElementsBaseVertex_fnptr(mode, count, type, indices, basevertex);
            }
            
            private static delegate* unmanaged<PrimitiveType, uint, uint, int, DrawElementsType, void*, int, void> _DrawRangeElementsBaseVertex_fnptr = &DrawRangeElementsBaseVertex_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="start"> Specifies the minimum array index contained in indices. </param>
            /// <param name="end"> Specifies the maximum array index contained in indices. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml" /></remarks>
            public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => _DrawRangeElementsBaseVertex_fnptr(mode, start, end, count, type, indices, basevertex);
            [UnmanagedCallersOnly]
            private static void DrawRangeElementsBaseVertex_Lazy(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex)
            {
                _DrawRangeElementsBaseVertex_fnptr = (delegate* unmanaged<PrimitiveType, uint, uint, int, DrawElementsType, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawRangeElementsBaseVertex");
                _DrawRangeElementsBaseVertex_fnptr(mode, start, end, count, type, indices, basevertex);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, int, void> _DrawElementsInstancedBaseVertex_fnptr = &DrawElementsInstancedBaseVertex_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => _DrawElementsInstancedBaseVertex_fnptr(mode, count, type, indices, instancecount, basevertex);
            [UnmanagedCallersOnly]
            private static void DrawElementsInstancedBaseVertex_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex)
            {
                _DrawElementsInstancedBaseVertex_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsInstancedBaseVertex");
                _DrawElementsInstancedBaseVertex_fnptr(mode, count, type, indices, instancecount, basevertex);
            }
            
            private static delegate* unmanaged<PrimitiveType, int*, DrawElementsType, void**, int, int*, void> _MultiDrawElementsBaseVertex_fnptr = &MultiDrawElementsBaseVertex_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Points to an array of the elements counts. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
            /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml" /></remarks>
            public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => _MultiDrawElementsBaseVertex_fnptr(mode, count, type, indices, drawcount, basevertex);
            [UnmanagedCallersOnly]
            private static void MultiDrawElementsBaseVertex_Lazy(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex)
            {
                _MultiDrawElementsBaseVertex_fnptr = (delegate* unmanaged<PrimitiveType, int*, DrawElementsType, void**, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsBaseVertex");
                _MultiDrawElementsBaseVertex_fnptr(mode, count, type, indices, drawcount, basevertex);
            }
            
            private static delegate* unmanaged<PrimitiveType, void*, void> _DrawArraysIndirect_fnptr = &DrawArraysIndirect_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> Render primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml" /></remarks>
            public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => _DrawArraysIndirect_fnptr(mode, indirect);
            [UnmanagedCallersOnly]
            private static void DrawArraysIndirect_Lazy(PrimitiveType mode, void* indirect)
            {
                _DrawArraysIndirect_fnptr = (delegate* unmanaged<PrimitiveType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawArraysIndirect");
                _DrawArraysIndirect_fnptr(mode, indirect);
            }
            
            private static delegate* unmanaged<PrimitiveType, DrawElementsType, void*, void> _DrawElementsIndirect_fnptr = &DrawElementsIndirect_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml" /></remarks>
            public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => _DrawElementsIndirect_fnptr(mode, type, indirect);
            [UnmanagedCallersOnly]
            private static void DrawElementsIndirect_Lazy(PrimitiveType mode, DrawElementsType type, void* indirect)
            {
                _DrawElementsIndirect_fnptr = (delegate* unmanaged<PrimitiveType, DrawElementsType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsIndirect");
                _DrawElementsIndirect_fnptr(mode, type, indirect);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, int, int, void> _DrawArraysInstancedARB_fnptr = &DrawArraysInstancedARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_draw_instanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawArraysInstancedARB(PrimitiveType mode, int first, int count, int primcount) => _DrawArraysInstancedARB_fnptr(mode, first, count, primcount);
            [UnmanagedCallersOnly]
            private static void DrawArraysInstancedARB_Lazy(PrimitiveType mode, int first, int count, int primcount)
            {
                _DrawArraysInstancedARB_fnptr = (delegate* unmanaged<PrimitiveType, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawArraysInstancedARB");
                _DrawArraysInstancedARB_fnptr(mode, first, count, primcount);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void> _DrawElementsInstancedARB_fnptr = &DrawElementsInstancedARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_draw_instanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawElementsInstancedARB(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => _DrawElementsInstancedARB_fnptr(mode, count, type, indices, primcount);
            [UnmanagedCallersOnly]
            private static void DrawElementsInstancedARB_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount)
            {
                _DrawElementsInstancedARB_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsInstancedARB");
                _DrawElementsInstancedARB_fnptr(mode, count, type, indices, primcount);
            }
            
            private static delegate* unmanaged<ProgramTarget, ProgramFormat, int, void*, void> _ProgramStringARB_fnptr = &ProgramStringARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramStringARB(ProgramTarget target, ProgramFormat format, int len, void* str) => _ProgramStringARB_fnptr(target, format, len, str);
            [UnmanagedCallersOnly]
            private static void ProgramStringARB_Lazy(ProgramTarget target, ProgramFormat format, int len, void* str)
            {
                _ProgramStringARB_fnptr = (delegate* unmanaged<ProgramTarget, ProgramFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramStringARB");
                _ProgramStringARB_fnptr(target, format, len, str);
            }
            
            private static delegate* unmanaged<ProgramTarget, ProgramHandle, void> _BindProgramARB_fnptr = &BindProgramARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindProgramARB(ProgramTarget target, ProgramHandle program) => _BindProgramARB_fnptr(target, program);
            [UnmanagedCallersOnly]
            private static void BindProgramARB_Lazy(ProgramTarget target, ProgramHandle program)
            {
                _BindProgramARB_fnptr = (delegate* unmanaged<ProgramTarget, ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindProgramARB");
                _BindProgramARB_fnptr(target, program);
            }
            
            private static delegate* unmanaged<int, ProgramHandle*, void> _DeleteProgramsARB_fnptr = &DeleteProgramsARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteProgramsARB(int n, ProgramHandle* programs) => _DeleteProgramsARB_fnptr(n, programs);
            [UnmanagedCallersOnly]
            private static void DeleteProgramsARB_Lazy(int n, ProgramHandle* programs)
            {
                _DeleteProgramsARB_fnptr = (delegate* unmanaged<int, ProgramHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteProgramsARB");
                _DeleteProgramsARB_fnptr(n, programs);
            }
            
            private static delegate* unmanaged<int, ProgramHandle*, void> _GenProgramsARB_fnptr = &GenProgramsARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenProgramsARB(int n, ProgramHandle* programs) => _GenProgramsARB_fnptr(n, programs);
            [UnmanagedCallersOnly]
            private static void GenProgramsARB_Lazy(int n, ProgramHandle* programs)
            {
                _GenProgramsARB_fnptr = (delegate* unmanaged<int, ProgramHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenProgramsARB");
                _GenProgramsARB_fnptr(n, programs);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, double, double, double, double, void> _ProgramEnvParameter4dARB_fnptr = &ProgramEnvParameter4dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => _ProgramEnvParameter4dARB_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParameter4dARB_Lazy(ProgramTarget target, uint index, double x, double y, double z, double w)
            {
                _ProgramEnvParameter4dARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParameter4dARB");
                _ProgramEnvParameter4dARB_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, double*, void> _ProgramEnvParameter4dvARB_fnptr = &ProgramEnvParameter4dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, double* parameters) => _ProgramEnvParameter4dvARB_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParameter4dvARB_Lazy(ProgramTarget target, uint index, double* parameters)
            {
                _ProgramEnvParameter4dvARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParameter4dvARB");
                _ProgramEnvParameter4dvARB_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, float, float, float, float, void> _ProgramEnvParameter4fARB_fnptr = &ProgramEnvParameter4fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => _ProgramEnvParameter4fARB_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParameter4fARB_Lazy(ProgramTarget target, uint index, float x, float y, float z, float w)
            {
                _ProgramEnvParameter4fARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParameter4fARB");
                _ProgramEnvParameter4fARB_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, float*, void> _ProgramEnvParameter4fvARB_fnptr = &ProgramEnvParameter4fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, float* parameters) => _ProgramEnvParameter4fvARB_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParameter4fvARB_Lazy(ProgramTarget target, uint index, float* parameters)
            {
                _ProgramEnvParameter4fvARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParameter4fvARB");
                _ProgramEnvParameter4fvARB_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, double, double, double, double, void> _ProgramLocalParameter4dARB_fnptr = &ProgramLocalParameter4dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => _ProgramLocalParameter4dARB_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParameter4dARB_Lazy(ProgramTarget target, uint index, double x, double y, double z, double w)
            {
                _ProgramLocalParameter4dARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParameter4dARB");
                _ProgramLocalParameter4dARB_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, double*, void> _ProgramLocalParameter4dvARB_fnptr = &ProgramLocalParameter4dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, double* parameters) => _ProgramLocalParameter4dvARB_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParameter4dvARB_Lazy(ProgramTarget target, uint index, double* parameters)
            {
                _ProgramLocalParameter4dvARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParameter4dvARB");
                _ProgramLocalParameter4dvARB_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, float, float, float, float, void> _ProgramLocalParameter4fARB_fnptr = &ProgramLocalParameter4fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => _ProgramLocalParameter4fARB_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParameter4fARB_Lazy(ProgramTarget target, uint index, float x, float y, float z, float w)
            {
                _ProgramLocalParameter4fARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParameter4fARB");
                _ProgramLocalParameter4fARB_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, float*, void> _ProgramLocalParameter4fvARB_fnptr = &ProgramLocalParameter4fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, float* parameters) => _ProgramLocalParameter4fvARB_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParameter4fvARB_Lazy(ProgramTarget target, uint index, float* parameters)
            {
                _ProgramLocalParameter4fvARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParameter4fvARB");
                _ProgramLocalParameter4fvARB_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, double*, void> _GetProgramEnvParameterdvARB_fnptr = &GetProgramEnvParameterdvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, double* parameters) => _GetProgramEnvParameterdvARB_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramEnvParameterdvARB_Lazy(ProgramTarget target, uint index, double* parameters)
            {
                _GetProgramEnvParameterdvARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramEnvParameterdvARB");
                _GetProgramEnvParameterdvARB_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, float*, void> _GetProgramEnvParameterfvARB_fnptr = &GetProgramEnvParameterfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, float* parameters) => _GetProgramEnvParameterfvARB_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramEnvParameterfvARB_Lazy(ProgramTarget target, uint index, float* parameters)
            {
                _GetProgramEnvParameterfvARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramEnvParameterfvARB");
                _GetProgramEnvParameterfvARB_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, double*, void> _GetProgramLocalParameterdvARB_fnptr = &GetProgramLocalParameterdvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, double* parameters) => _GetProgramLocalParameterdvARB_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramLocalParameterdvARB_Lazy(ProgramTarget target, uint index, double* parameters)
            {
                _GetProgramLocalParameterdvARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramLocalParameterdvARB");
                _GetProgramLocalParameterdvARB_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, float*, void> _GetProgramLocalParameterfvARB_fnptr = &GetProgramLocalParameterfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, float* parameters) => _GetProgramLocalParameterfvARB_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramLocalParameterfvARB_Lazy(ProgramTarget target, uint index, float* parameters)
            {
                _GetProgramLocalParameterfvARB_fnptr = (delegate* unmanaged<ProgramTarget, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramLocalParameterfvARB");
                _GetProgramLocalParameterfvARB_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, ProgramPropertyARB, int*, void> _GetProgramivARB_fnptr = &GetProgramivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramivARB(ProgramTarget target, ProgramPropertyARB pname, int* parameters) => _GetProgramivARB_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramivARB_Lazy(ProgramTarget target, ProgramPropertyARB pname, int* parameters)
            {
                _GetProgramivARB_fnptr = (delegate* unmanaged<ProgramTarget, ProgramPropertyARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramivARB");
                _GetProgramivARB_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, ProgramStringProperty, void*, void> _GetProgramStringARB_fnptr = &GetProgramStringARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramStringARB(ProgramTarget target, ProgramStringProperty pname, void* str) => _GetProgramStringARB_fnptr(target, pname, str);
            [UnmanagedCallersOnly]
            private static void GetProgramStringARB_Lazy(ProgramTarget target, ProgramStringProperty pname, void* str)
            {
                _GetProgramStringARB_fnptr = (delegate* unmanaged<ProgramTarget, ProgramStringProperty, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramStringARB");
                _GetProgramStringARB_fnptr(target, pname, str);
            }
            
            private static delegate* unmanaged<ProgramHandle, byte> _IsProgramARB_fnptr = &IsProgramARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsProgramARB(ProgramHandle program) => _IsProgramARB_fnptr(program);
            [UnmanagedCallersOnly]
            private static byte IsProgramARB_Lazy(ProgramHandle program)
            {
                _IsProgramARB_fnptr = (delegate* unmanaged<ProgramHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsProgramARB");
                return _IsProgramARB_fnptr(program);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferParameterName, int, void> _FramebufferParameteri_fnptr = &FramebufferParameteri_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> Set a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
            public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => _FramebufferParameteri_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void FramebufferParameteri_Lazy(FramebufferTarget target, FramebufferParameterName pname, int param)
            {
                _FramebufferParameteri_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferParameteri");
                _FramebufferParameteri_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachmentParameterName, int*, void> _GetFramebufferParameteriv_fnptr = &GetFramebufferParameteriv_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> Query a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
            public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => _GetFramebufferParameteriv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFramebufferParameteriv_Lazy(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters)
            {
                _GetFramebufferParameteriv_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachmentParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFramebufferParameteriv");
                _GetFramebufferParameteriv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, byte> _IsRenderbuffer_fnptr = &IsRenderbuffer_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Determine if a name corresponds to a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml" /></remarks>
            public static byte IsRenderbuffer(RenderbufferHandle renderbuffer) => _IsRenderbuffer_fnptr(renderbuffer);
            [UnmanagedCallersOnly]
            private static byte IsRenderbuffer_Lazy(RenderbufferHandle renderbuffer)
            {
                _IsRenderbuffer_fnptr = (delegate* unmanaged<RenderbufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsRenderbuffer");
                return _IsRenderbuffer_fnptr(renderbuffer);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, RenderbufferHandle, void> _BindRenderbuffer_fnptr = &BindRenderbuffer_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Bind a renderbuffer to a renderbuffer target. </summary>
            /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml" /></remarks>
            public static void BindRenderbuffer(RenderbufferTarget target, RenderbufferHandle renderbuffer) => _BindRenderbuffer_fnptr(target, renderbuffer);
            [UnmanagedCallersOnly]
            private static void BindRenderbuffer_Lazy(RenderbufferTarget target, RenderbufferHandle renderbuffer)
            {
                _BindRenderbuffer_fnptr = (delegate* unmanaged<RenderbufferTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindRenderbuffer");
                _BindRenderbuffer_fnptr(target, renderbuffer);
            }
            
            private static delegate* unmanaged<int, RenderbufferHandle*, void> _DeleteRenderbuffers_fnptr = &DeleteRenderbuffers_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Delete renderbuffer objects. </summary>
            /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
            /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml" /></remarks>
            public static void DeleteRenderbuffers(int n, RenderbufferHandle* renderbuffers) => _DeleteRenderbuffers_fnptr(n, renderbuffers);
            [UnmanagedCallersOnly]
            private static void DeleteRenderbuffers_Lazy(int n, RenderbufferHandle* renderbuffers)
            {
                _DeleteRenderbuffers_fnptr = (delegate* unmanaged<int, RenderbufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteRenderbuffers");
                _DeleteRenderbuffers_fnptr(n, renderbuffers);
            }
            
            private static delegate* unmanaged<int, RenderbufferHandle*, void> _GenRenderbuffers_fnptr = &GenRenderbuffers_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate renderbuffer object names. </summary>
            /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
            /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml" /></remarks>
            public static void GenRenderbuffers(int n, RenderbufferHandle* renderbuffers) => _GenRenderbuffers_fnptr(n, renderbuffers);
            [UnmanagedCallersOnly]
            private static void GenRenderbuffers_Lazy(int n, RenderbufferHandle* renderbuffers)
            {
                _GenRenderbuffers_fnptr = (delegate* unmanaged<int, RenderbufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenRenderbuffers");
                _GenRenderbuffers_fnptr(n, renderbuffers);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, InternalFormat, int, int, void> _RenderbufferStorage_fnptr = &RenderbufferStorage_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Establish data storage, format and dimensions of a    renderbuffer object's image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
            public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => _RenderbufferStorage_fnptr(target, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void RenderbufferStorage_Lazy(RenderbufferTarget target, InternalFormat internalformat, int width, int height)
            {
                _RenderbufferStorage_fnptr = (delegate* unmanaged<RenderbufferTarget, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRenderbufferStorage");
                _RenderbufferStorage_fnptr(target, internalformat, width, height);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, RenderbufferParameterName, int*, void> _GetRenderbufferParameteriv_fnptr = &GetRenderbufferParameteriv_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
            public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => _GetRenderbufferParameteriv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetRenderbufferParameteriv_Lazy(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters)
            {
                _GetRenderbufferParameteriv_fnptr = (delegate* unmanaged<RenderbufferTarget, RenderbufferParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetRenderbufferParameteriv");
                _GetRenderbufferParameteriv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<FramebufferHandle, byte> _IsFramebuffer_fnptr = &IsFramebuffer_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Determine if a name corresponds to a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml" /></remarks>
            public static byte IsFramebuffer(FramebufferHandle framebuffer) => _IsFramebuffer_fnptr(framebuffer);
            [UnmanagedCallersOnly]
            private static byte IsFramebuffer_Lazy(FramebufferHandle framebuffer)
            {
                _IsFramebuffer_fnptr = (delegate* unmanaged<FramebufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsFramebuffer");
                return _IsFramebuffer_fnptr(framebuffer);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferHandle, void> _BindFramebuffer_fnptr = &BindFramebuffer_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Bind a framebuffer to a framebuffer target. </summary>
            /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml" /></remarks>
            public static void BindFramebuffer(FramebufferTarget target, FramebufferHandle framebuffer) => _BindFramebuffer_fnptr(target, framebuffer);
            [UnmanagedCallersOnly]
            private static void BindFramebuffer_Lazy(FramebufferTarget target, FramebufferHandle framebuffer)
            {
                _BindFramebuffer_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindFramebuffer");
                _BindFramebuffer_fnptr(target, framebuffer);
            }
            
            private static delegate* unmanaged<int, FramebufferHandle*, void> _DeleteFramebuffers_fnptr = &DeleteFramebuffers_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Delete framebuffer objects. </summary>
            /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
            /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml" /></remarks>
            public static void DeleteFramebuffers(int n, FramebufferHandle* framebuffers) => _DeleteFramebuffers_fnptr(n, framebuffers);
            [UnmanagedCallersOnly]
            private static void DeleteFramebuffers_Lazy(int n, FramebufferHandle* framebuffers)
            {
                _DeleteFramebuffers_fnptr = (delegate* unmanaged<int, FramebufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteFramebuffers");
                _DeleteFramebuffers_fnptr(n, framebuffers);
            }
            
            private static delegate* unmanaged<int, FramebufferHandle*, void> _GenFramebuffers_fnptr = &GenFramebuffers_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate framebuffer object names. </summary>
            /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
            /// <param name="ids"> Specifies an array in which the generated framebuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml" /></remarks>
            public static void GenFramebuffers(int n, FramebufferHandle* framebuffers) => _GenFramebuffers_fnptr(n, framebuffers);
            [UnmanagedCallersOnly]
            private static void GenFramebuffers_Lazy(int n, FramebufferHandle* framebuffers)
            {
                _GenFramebuffers_fnptr = (delegate* unmanaged<int, FramebufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenFramebuffers");
                _GenFramebuffers_fnptr(n, framebuffers);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferStatus> _CheckFramebufferStatus_fnptr = &CheckFramebufferStatus_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Check the completeness status of a framebuffer. </summary>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
            public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => _CheckFramebufferStatus_fnptr(target);
            [UnmanagedCallersOnly]
            private static FramebufferStatus CheckFramebufferStatus_Lazy(FramebufferTarget target)
            {
                _CheckFramebufferStatus_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferStatus>)GLLoader.BindingsContext.GetProcAddress("glCheckFramebufferStatus");
                return _CheckFramebufferStatus_fnptr(target);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void> _FramebufferTexture1D_fnptr = &FramebufferTexture1D_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => _FramebufferTexture1D_fnptr(target, attachment, textarget, texture, level);
            [UnmanagedCallersOnly]
            private static void FramebufferTexture1D_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level)
            {
                _FramebufferTexture1D_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture1D");
                _FramebufferTexture1D_fnptr(target, attachment, textarget, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void> _FramebufferTexture2D_fnptr = &FramebufferTexture2D_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => _FramebufferTexture2D_fnptr(target, attachment, textarget, texture, level);
            [UnmanagedCallersOnly]
            private static void FramebufferTexture2D_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level)
            {
                _FramebufferTexture2D_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture2D");
                _FramebufferTexture2D_fnptr(target, attachment, textarget, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, int, void> _FramebufferTexture3D_fnptr = &FramebufferTexture3D_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset) => _FramebufferTexture3D_fnptr(target, attachment, textarget, texture, level, zoffset);
            [UnmanagedCallersOnly]
            private static void FramebufferTexture3D_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset)
            {
                _FramebufferTexture3D_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture3D");
                _FramebufferTexture3D_fnptr(target, attachment, textarget, texture, level, zoffset);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void> _FramebufferRenderbuffer_fnptr = &FramebufferRenderbuffer_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
            public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => _FramebufferRenderbuffer_fnptr(target, attachment, renderbuffertarget, renderbuffer);
            [UnmanagedCallersOnly]
            private static void FramebufferRenderbuffer_Lazy(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer)
            {
                _FramebufferRenderbuffer_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferRenderbuffer");
                _FramebufferRenderbuffer_fnptr(target, attachment, renderbuffertarget, renderbuffer);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void> _GetFramebufferAttachmentParameteriv_fnptr = &GetFramebufferAttachmentParameteriv_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
            public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => _GetFramebufferAttachmentParameteriv_fnptr(target, attachment, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFramebufferAttachmentParameteriv_Lazy(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters)
            {
                _GetFramebufferAttachmentParameteriv_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFramebufferAttachmentParameteriv");
                _GetFramebufferAttachmentParameteriv_fnptr(target, attachment, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, void> _GenerateMipmap_fnptr = &GenerateMipmap_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate mipmaps for a specified texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
            public static void GenerateMipmap(TextureTarget target) => _GenerateMipmap_fnptr(target);
            [UnmanagedCallersOnly]
            private static void GenerateMipmap_Lazy(TextureTarget target)
            {
                _GenerateMipmap_fnptr = (delegate* unmanaged<TextureTarget, void>)GLLoader.BindingsContext.GetProcAddress("glGenerateMipmap");
                _GenerateMipmap_fnptr(target);
            }
            
            private static delegate* unmanaged<int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void> _BlitFramebuffer_fnptr = &BlitFramebuffer_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
            public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => _BlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            [UnmanagedCallersOnly]
            private static void BlitFramebuffer_Lazy(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter)
            {
                _BlitFramebuffer_fnptr = (delegate* unmanaged<int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void>)GLLoader.BindingsContext.GetProcAddress("glBlitFramebuffer");
                _BlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, int, InternalFormat, int, int, void> _RenderbufferStorageMultisample_fnptr = &RenderbufferStorageMultisample_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object's image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
            public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisample_fnptr(target, samples, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void RenderbufferStorageMultisample_Lazy(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height)
            {
                _RenderbufferStorageMultisample_fnptr = (delegate* unmanaged<RenderbufferTarget, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRenderbufferStorageMultisample");
                _RenderbufferStorageMultisample_fnptr(target, samples, internalformat, width, height);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void> _FramebufferTextureLayer_fnptr = &FramebufferTextureLayer_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
            public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => _FramebufferTextureLayer_fnptr(target, attachment, texture, level, layer);
            [UnmanagedCallersOnly]
            private static void FramebufferTextureLayer_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer)
            {
                _FramebufferTextureLayer_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureLayer");
                _FramebufferTextureLayer_fnptr(target, attachment, texture, level, layer);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramParameterPName, int, void> _ProgramParameteriARB_fnptr = &ProgramParameteriARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameteriARB(ProgramHandle program, ProgramParameterPName pname, int value) => _ProgramParameteriARB_fnptr(program, pname, value);
            [UnmanagedCallersOnly]
            private static void ProgramParameteriARB_Lazy(ProgramHandle program, ProgramParameterPName pname, int value)
            {
                _ProgramParameteriARB_fnptr = (delegate* unmanaged<ProgramHandle, ProgramParameterPName, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameteriARB");
                _ProgramParameteriARB_fnptr(program, pname, value);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, void> _FramebufferTextureARB_fnptr = &FramebufferTextureARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureARB(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level) => _FramebufferTextureARB_fnptr(target, attachment, texture, level);
            [UnmanagedCallersOnly]
            private static void FramebufferTextureARB_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level)
            {
                _FramebufferTextureARB_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureARB");
                _FramebufferTextureARB_fnptr(target, attachment, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void> _FramebufferTextureLayerARB_fnptr = &FramebufferTextureLayerARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureLayerARB(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => _FramebufferTextureLayerARB_fnptr(target, attachment, texture, level, layer);
            [UnmanagedCallersOnly]
            private static void FramebufferTextureLayerARB_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer)
            {
                _FramebufferTextureLayerARB_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureLayerARB");
                _FramebufferTextureLayerARB_fnptr(target, attachment, texture, level, layer);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, TextureTarget, void> _FramebufferTextureFaceARB_fnptr = &FramebufferTextureFaceARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureFaceARB(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, TextureTarget face) => _FramebufferTextureFaceARB_fnptr(target, attachment, texture, level, face);
            [UnmanagedCallersOnly]
            private static void FramebufferTextureFaceARB_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, TextureTarget face)
            {
                _FramebufferTextureFaceARB_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, TextureTarget, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureFaceARB");
                _FramebufferTextureFaceARB_fnptr(target, attachment, texture, level, face);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int*, All*, void*, void> _GetProgramBinary_fnptr = &GetProgramBinary_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> Return a binary representation of a program object's compiled and linked executable source. </summary>
            /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
            /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
            /// <param name="binary"> Specifies the address an array into which the GL will return program's binary representation. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml" /></remarks>
            public static void GetProgramBinary(ProgramHandle program, int bufSize, int* length, All* binaryFormat, void* binary) => _GetProgramBinary_fnptr(program, bufSize, length, binaryFormat, binary);
            [UnmanagedCallersOnly]
            private static void GetProgramBinary_Lazy(ProgramHandle program, int bufSize, int* length, All* binaryFormat, void* binary)
            {
                _GetProgramBinary_fnptr = (delegate* unmanaged<ProgramHandle, int, int*, All*, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramBinary");
                _GetProgramBinary_fnptr(program, bufSize, length, binaryFormat, binary);
            }
            
            private static delegate* unmanaged<ProgramHandle, All, void*, int, void> _ProgramBinary_fnptr = &ProgramBinary_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> Load a program object with a program binary. </summary>
            /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
            /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
            /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
            /// <param name="length"> Specifies the number of bytes contained in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml" /></remarks>
            public static void ProgramBinary(ProgramHandle program, All binaryFormat, void* binary, int length) => _ProgramBinary_fnptr(program, binaryFormat, binary, length);
            [UnmanagedCallersOnly]
            private static void ProgramBinary_Lazy(ProgramHandle program, All binaryFormat, void* binary, int length)
            {
                _ProgramBinary_fnptr = (delegate* unmanaged<ProgramHandle, All, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramBinary");
                _ProgramBinary_fnptr(program, binaryFormat, binary, length);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramParameterPName, int, void> _ProgramParameteri_fnptr = &ProgramParameteri_Lazy;
            /// <summary> <b>[requires: v4.1 | v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects]</b> Specify a parameter for a program object. </summary>
            /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the name of the parameter to modify. </param>
            /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml" /></remarks>
            public static void ProgramParameteri(ProgramHandle program, ProgramParameterPName pname, int value) => _ProgramParameteri_fnptr(program, pname, value);
            [UnmanagedCallersOnly]
            private static void ProgramParameteri_Lazy(ProgramHandle program, ProgramParameterPName pname, int value)
            {
                _ProgramParameteri_fnptr = (delegate* unmanaged<ProgramHandle, ProgramParameterPName, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameteri");
                _ProgramParameteri_fnptr(program, pname, value);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, int, void*, void> _GetTextureSubImage_fnptr = &GetTextureSubImage_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> Retrieve a sub-region of a texture image from a texture    object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
            /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml" /></remarks>
            public static void GetTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => _GetTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
            [UnmanagedCallersOnly]
            private static void GetTextureSubImage_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels)
            {
                _GetTextureSubImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureSubImage");
                _GetTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, void*, void> _GetCompressedTextureSubImage_fnptr = &GetCompressedTextureSubImage_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml" /></remarks>
            public static void GetCompressedTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => _GetCompressedTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
            [UnmanagedCallersOnly]
            private static void GetCompressedTextureSubImage_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
            {
                _GetCompressedTextureSubImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCompressedTextureSubImage");
                _GetCompressedTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
            }
            
            private static delegate* unmanaged<ShaderHandle, byte*, uint, uint*, uint*, void> _SpecializeShaderARB_fnptr = &SpecializeShaderARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gl_spirv]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpecializeShaderARB(ShaderHandle shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => _SpecializeShaderARB_fnptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
            [UnmanagedCallersOnly]
            private static void SpecializeShaderARB_Lazy(ShaderHandle shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue)
            {
                _SpecializeShaderARB_fnptr = (delegate* unmanaged<ShaderHandle, byte*, uint, uint*, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSpecializeShaderARB");
                _SpecializeShaderARB_fnptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
            }
            
            private static delegate* unmanaged<int, double, void> _Uniform1d_fnptr = &Uniform1d_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1d(int location, double x) => _Uniform1d_fnptr(location, x);
            [UnmanagedCallersOnly]
            private static void Uniform1d_Lazy(int location, double x)
            {
                _Uniform1d_fnptr = (delegate* unmanaged<int, double, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1d");
                _Uniform1d_fnptr(location, x);
            }
            
            private static delegate* unmanaged<int, double, double, void> _Uniform2d_fnptr = &Uniform2d_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2d(int location, double x, double y) => _Uniform2d_fnptr(location, x, y);
            [UnmanagedCallersOnly]
            private static void Uniform2d_Lazy(int location, double x, double y)
            {
                _Uniform2d_fnptr = (delegate* unmanaged<int, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2d");
                _Uniform2d_fnptr(location, x, y);
            }
            
            private static delegate* unmanaged<int, double, double, double, void> _Uniform3d_fnptr = &Uniform3d_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3d(int location, double x, double y, double z) => _Uniform3d_fnptr(location, x, y, z);
            [UnmanagedCallersOnly]
            private static void Uniform3d_Lazy(int location, double x, double y, double z)
            {
                _Uniform3d_fnptr = (delegate* unmanaged<int, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3d");
                _Uniform3d_fnptr(location, x, y, z);
            }
            
            private static delegate* unmanaged<int, double, double, double, double, void> _Uniform4d_fnptr = &Uniform4d_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4d(int location, double x, double y, double z, double w) => _Uniform4d_fnptr(location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void Uniform4d_Lazy(int location, double x, double y, double z, double w)
            {
                _Uniform4d_fnptr = (delegate* unmanaged<int, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4d");
                _Uniform4d_fnptr(location, x, y, z, w);
            }
            
            private static delegate* unmanaged<int, int, double*, void> _Uniform1dv_fnptr = &Uniform1dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1dv(int location, int count, double* value) => _Uniform1dv_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1dv_Lazy(int location, int count, double* value)
            {
                _Uniform1dv_fnptr = (delegate* unmanaged<int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1dv");
                _Uniform1dv_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, double*, void> _Uniform2dv_fnptr = &Uniform2dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2dv(int location, int count, double* value) => _Uniform2dv_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2dv_Lazy(int location, int count, double* value)
            {
                _Uniform2dv_fnptr = (delegate* unmanaged<int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2dv");
                _Uniform2dv_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, double*, void> _Uniform3dv_fnptr = &Uniform3dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3dv(int location, int count, double* value) => _Uniform3dv_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3dv_Lazy(int location, int count, double* value)
            {
                _Uniform3dv_fnptr = (delegate* unmanaged<int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3dv");
                _Uniform3dv_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, double*, void> _Uniform4dv_fnptr = &Uniform4dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4dv(int location, int count, double* value) => _Uniform4dv_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4dv_Lazy(int location, int count, double* value)
            {
                _Uniform4dv_fnptr = (delegate* unmanaged<int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4dv");
                _Uniform4dv_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix2dv_fnptr = &UniformMatrix2dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix2dv(int location, int count, byte transpose, double* value) => _UniformMatrix2dv_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix2dv_Lazy(int location, int count, byte transpose, double* value)
            {
                _UniformMatrix2dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2dv");
                _UniformMatrix2dv_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix3dv_fnptr = &UniformMatrix3dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix3dv(int location, int count, byte transpose, double* value) => _UniformMatrix3dv_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix3dv_Lazy(int location, int count, byte transpose, double* value)
            {
                _UniformMatrix3dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3dv");
                _UniformMatrix3dv_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix4dv_fnptr = &UniformMatrix4dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix4dv(int location, int count, byte transpose, double* value) => _UniformMatrix4dv_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix4dv_Lazy(int location, int count, byte transpose, double* value)
            {
                _UniformMatrix4dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4dv");
                _UniformMatrix4dv_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix2x3dv_fnptr = &UniformMatrix2x3dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix2x3dv(int location, int count, byte transpose, double* value) => _UniformMatrix2x3dv_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix2x3dv_Lazy(int location, int count, byte transpose, double* value)
            {
                _UniformMatrix2x3dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2x3dv");
                _UniformMatrix2x3dv_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix2x4dv_fnptr = &UniformMatrix2x4dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix2x4dv(int location, int count, byte transpose, double* value) => _UniformMatrix2x4dv_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix2x4dv_Lazy(int location, int count, byte transpose, double* value)
            {
                _UniformMatrix2x4dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2x4dv");
                _UniformMatrix2x4dv_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix3x2dv_fnptr = &UniformMatrix3x2dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix3x2dv(int location, int count, byte transpose, double* value) => _UniformMatrix3x2dv_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix3x2dv_Lazy(int location, int count, byte transpose, double* value)
            {
                _UniformMatrix3x2dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3x2dv");
                _UniformMatrix3x2dv_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix3x4dv_fnptr = &UniformMatrix3x4dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix3x4dv(int location, int count, byte transpose, double* value) => _UniformMatrix3x4dv_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix3x4dv_Lazy(int location, int count, byte transpose, double* value)
            {
                _UniformMatrix3x4dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3x4dv");
                _UniformMatrix3x4dv_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix4x2dv_fnptr = &UniformMatrix4x2dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix4x2dv(int location, int count, byte transpose, double* value) => _UniformMatrix4x2dv_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix4x2dv_Lazy(int location, int count, byte transpose, double* value)
            {
                _UniformMatrix4x2dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4x2dv");
                _UniformMatrix4x2dv_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, double*, void> _UniformMatrix4x3dv_fnptr = &UniformMatrix4x3dv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix4x3dv(int location, int count, byte transpose, double* value) => _UniformMatrix4x3dv_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix4x3dv_Lazy(int location, int count, byte transpose, double* value)
            {
                _UniformMatrix4x3dv_fnptr = (delegate* unmanaged<int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4x3dv");
                _UniformMatrix4x3dv_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, double*, void> _GetUniformdv_fnptr = &GetUniformdv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetUniformdv(ProgramHandle program, int location, double* parameters) => _GetUniformdv_fnptr(program, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformdv_Lazy(ProgramHandle program, int location, double* parameters)
            {
                _GetUniformdv_fnptr = (delegate* unmanaged<ProgramHandle, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformdv");
                _GetUniformdv_fnptr(program, location, parameters);
            }
            
            private static delegate* unmanaged<int, long, void> _Uniform1i64ARB_fnptr = &Uniform1i64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64ARB(int location, long x) => _Uniform1i64ARB_fnptr(location, x);
            [UnmanagedCallersOnly]
            private static void Uniform1i64ARB_Lazy(int location, long x)
            {
                _Uniform1i64ARB_fnptr = (delegate* unmanaged<int, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1i64ARB");
                _Uniform1i64ARB_fnptr(location, x);
            }
            
            private static delegate* unmanaged<int, long, long, void> _Uniform2i64ARB_fnptr = &Uniform2i64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64ARB(int location, long x, long y) => _Uniform2i64ARB_fnptr(location, x, y);
            [UnmanagedCallersOnly]
            private static void Uniform2i64ARB_Lazy(int location, long x, long y)
            {
                _Uniform2i64ARB_fnptr = (delegate* unmanaged<int, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2i64ARB");
                _Uniform2i64ARB_fnptr(location, x, y);
            }
            
            private static delegate* unmanaged<int, long, long, long, void> _Uniform3i64ARB_fnptr = &Uniform3i64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64ARB(int location, long x, long y, long z) => _Uniform3i64ARB_fnptr(location, x, y, z);
            [UnmanagedCallersOnly]
            private static void Uniform3i64ARB_Lazy(int location, long x, long y, long z)
            {
                _Uniform3i64ARB_fnptr = (delegate* unmanaged<int, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3i64ARB");
                _Uniform3i64ARB_fnptr(location, x, y, z);
            }
            
            private static delegate* unmanaged<int, long, long, long, long, void> _Uniform4i64ARB_fnptr = &Uniform4i64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64ARB(int location, long x, long y, long z, long w) => _Uniform4i64ARB_fnptr(location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void Uniform4i64ARB_Lazy(int location, long x, long y, long z, long w)
            {
                _Uniform4i64ARB_fnptr = (delegate* unmanaged<int, long, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4i64ARB");
                _Uniform4i64ARB_fnptr(location, x, y, z, w);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform1i64vARB_fnptr = &Uniform1i64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64vARB(int location, int count, long* value) => _Uniform1i64vARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1i64vARB_Lazy(int location, int count, long* value)
            {
                _Uniform1i64vARB_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1i64vARB");
                _Uniform1i64vARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform2i64vARB_fnptr = &Uniform2i64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64vARB(int location, int count, long* value) => _Uniform2i64vARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2i64vARB_Lazy(int location, int count, long* value)
            {
                _Uniform2i64vARB_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2i64vARB");
                _Uniform2i64vARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform3i64vARB_fnptr = &Uniform3i64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64vARB(int location, int count, long* value) => _Uniform3i64vARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3i64vARB_Lazy(int location, int count, long* value)
            {
                _Uniform3i64vARB_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3i64vARB");
                _Uniform3i64vARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform4i64vARB_fnptr = &Uniform4i64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64vARB(int location, int count, long* value) => _Uniform4i64vARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4i64vARB_Lazy(int location, int count, long* value)
            {
                _Uniform4i64vARB_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4i64vARB");
                _Uniform4i64vARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, ulong, void> _Uniform1ui64ARB_fnptr = &Uniform1ui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64ARB(int location, ulong x) => _Uniform1ui64ARB_fnptr(location, x);
            [UnmanagedCallersOnly]
            private static void Uniform1ui64ARB_Lazy(int location, ulong x)
            {
                _Uniform1ui64ARB_fnptr = (delegate* unmanaged<int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1ui64ARB");
                _Uniform1ui64ARB_fnptr(location, x);
            }
            
            private static delegate* unmanaged<int, ulong, ulong, void> _Uniform2ui64ARB_fnptr = &Uniform2ui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64ARB(int location, ulong x, ulong y) => _Uniform2ui64ARB_fnptr(location, x, y);
            [UnmanagedCallersOnly]
            private static void Uniform2ui64ARB_Lazy(int location, ulong x, ulong y)
            {
                _Uniform2ui64ARB_fnptr = (delegate* unmanaged<int, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2ui64ARB");
                _Uniform2ui64ARB_fnptr(location, x, y);
            }
            
            private static delegate* unmanaged<int, ulong, ulong, ulong, void> _Uniform3ui64ARB_fnptr = &Uniform3ui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64ARB(int location, ulong x, ulong y, ulong z) => _Uniform3ui64ARB_fnptr(location, x, y, z);
            [UnmanagedCallersOnly]
            private static void Uniform3ui64ARB_Lazy(int location, ulong x, ulong y, ulong z)
            {
                _Uniform3ui64ARB_fnptr = (delegate* unmanaged<int, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3ui64ARB");
                _Uniform3ui64ARB_fnptr(location, x, y, z);
            }
            
            private static delegate* unmanaged<int, ulong, ulong, ulong, ulong, void> _Uniform4ui64ARB_fnptr = &Uniform4ui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64ARB(int location, ulong x, ulong y, ulong z, ulong w) => _Uniform4ui64ARB_fnptr(location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void Uniform4ui64ARB_Lazy(int location, ulong x, ulong y, ulong z, ulong w)
            {
                _Uniform4ui64ARB_fnptr = (delegate* unmanaged<int, ulong, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4ui64ARB");
                _Uniform4ui64ARB_fnptr(location, x, y, z, w);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform1ui64vARB_fnptr = &Uniform1ui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64vARB(int location, int count, ulong* value) => _Uniform1ui64vARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1ui64vARB_Lazy(int location, int count, ulong* value)
            {
                _Uniform1ui64vARB_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1ui64vARB");
                _Uniform1ui64vARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform2ui64vARB_fnptr = &Uniform2ui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64vARB(int location, int count, ulong* value) => _Uniform2ui64vARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2ui64vARB_Lazy(int location, int count, ulong* value)
            {
                _Uniform2ui64vARB_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2ui64vARB");
                _Uniform2ui64vARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform3ui64vARB_fnptr = &Uniform3ui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64vARB(int location, int count, ulong* value) => _Uniform3ui64vARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3ui64vARB_Lazy(int location, int count, ulong* value)
            {
                _Uniform3ui64vARB_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3ui64vARB");
                _Uniform3ui64vARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform4ui64vARB_fnptr = &Uniform4ui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64vARB(int location, int count, ulong* value) => _Uniform4ui64vARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4ui64vARB_Lazy(int location, int count, ulong* value)
            {
                _Uniform4ui64vARB_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4ui64vARB");
                _Uniform4ui64vARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long*, void> _GetUniformi64vARB_fnptr = &GetUniformi64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformi64vARB(ProgramHandle program, int location, long* parameters) => _GetUniformi64vARB_fnptr(program, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformi64vARB_Lazy(ProgramHandle program, int location, long* parameters)
            {
                _GetUniformi64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformi64vARB");
                _GetUniformi64vARB_fnptr(program, location, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong*, void> _GetUniformui64vARB_fnptr = &GetUniformui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformui64vARB(ProgramHandle program, int location, ulong* parameters) => _GetUniformui64vARB_fnptr(program, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformui64vARB_Lazy(ProgramHandle program, int location, ulong* parameters)
            {
                _GetUniformui64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformui64vARB");
                _GetUniformui64vARB_fnptr(program, location, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _GetnUniformi64vARB_fnptr = &GetnUniformi64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformi64vARB(ProgramHandle program, int location, int bufSize, long* parameters) => _GetnUniformi64vARB_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformi64vARB_Lazy(ProgramHandle program, int location, int bufSize, long* parameters)
            {
                _GetnUniformi64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformi64vARB");
                _GetnUniformi64vARB_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _GetnUniformui64vARB_fnptr = &GetnUniformui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformui64vARB(ProgramHandle program, int location, int bufSize, ulong* parameters) => _GetnUniformui64vARB_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformui64vARB_Lazy(ProgramHandle program, int location, int bufSize, ulong* parameters)
            {
                _GetnUniformui64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformui64vARB");
                _GetnUniformui64vARB_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, void> _ProgramUniform1i64ARB_fnptr = &ProgramUniform1i64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64ARB(ProgramHandle program, int location, long x) => _ProgramUniform1i64ARB_fnptr(program, location, x);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1i64ARB_Lazy(ProgramHandle program, int location, long x)
            {
                _ProgramUniform1i64ARB_fnptr = (delegate* unmanaged<ProgramHandle, int, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1i64ARB");
                _ProgramUniform1i64ARB_fnptr(program, location, x);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, long, void> _ProgramUniform2i64ARB_fnptr = &ProgramUniform2i64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64ARB(ProgramHandle program, int location, long x, long y) => _ProgramUniform2i64ARB_fnptr(program, location, x, y);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2i64ARB_Lazy(ProgramHandle program, int location, long x, long y)
            {
                _ProgramUniform2i64ARB_fnptr = (delegate* unmanaged<ProgramHandle, int, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2i64ARB");
                _ProgramUniform2i64ARB_fnptr(program, location, x, y);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, long, long, void> _ProgramUniform3i64ARB_fnptr = &ProgramUniform3i64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64ARB(ProgramHandle program, int location, long x, long y, long z) => _ProgramUniform3i64ARB_fnptr(program, location, x, y, z);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3i64ARB_Lazy(ProgramHandle program, int location, long x, long y, long z)
            {
                _ProgramUniform3i64ARB_fnptr = (delegate* unmanaged<ProgramHandle, int, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3i64ARB");
                _ProgramUniform3i64ARB_fnptr(program, location, x, y, z);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, long, long, long, void> _ProgramUniform4i64ARB_fnptr = &ProgramUniform4i64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64ARB(ProgramHandle program, int location, long x, long y, long z, long w) => _ProgramUniform4i64ARB_fnptr(program, location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4i64ARB_Lazy(ProgramHandle program, int location, long x, long y, long z, long w)
            {
                _ProgramUniform4i64ARB_fnptr = (delegate* unmanaged<ProgramHandle, int, long, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4i64ARB");
                _ProgramUniform4i64ARB_fnptr(program, location, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform1i64vARB_fnptr = &ProgramUniform1i64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64vARB(ProgramHandle program, int location, int count, long* value) => _ProgramUniform1i64vARB_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1i64vARB_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform1i64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1i64vARB");
                _ProgramUniform1i64vARB_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform2i64vARB_fnptr = &ProgramUniform2i64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64vARB(ProgramHandle program, int location, int count, long* value) => _ProgramUniform2i64vARB_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2i64vARB_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform2i64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2i64vARB");
                _ProgramUniform2i64vARB_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform3i64vARB_fnptr = &ProgramUniform3i64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64vARB(ProgramHandle program, int location, int count, long* value) => _ProgramUniform3i64vARB_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3i64vARB_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform3i64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3i64vARB");
                _ProgramUniform3i64vARB_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform4i64vARB_fnptr = &ProgramUniform4i64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64vARB(ProgramHandle program, int location, int count, long* value) => _ProgramUniform4i64vARB_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4i64vARB_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform4i64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4i64vARB");
                _ProgramUniform4i64vARB_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, void> _ProgramUniform1ui64ARB_fnptr = &ProgramUniform1ui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64ARB(ProgramHandle program, int location, ulong x) => _ProgramUniform1ui64ARB_fnptr(program, location, x);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1ui64ARB_Lazy(ProgramHandle program, int location, ulong x)
            {
                _ProgramUniform1ui64ARB_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1ui64ARB");
                _ProgramUniform1ui64ARB_fnptr(program, location, x);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, ulong, void> _ProgramUniform2ui64ARB_fnptr = &ProgramUniform2ui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64ARB(ProgramHandle program, int location, ulong x, ulong y) => _ProgramUniform2ui64ARB_fnptr(program, location, x, y);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2ui64ARB_Lazy(ProgramHandle program, int location, ulong x, ulong y)
            {
                _ProgramUniform2ui64ARB_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2ui64ARB");
                _ProgramUniform2ui64ARB_fnptr(program, location, x, y);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, void> _ProgramUniform3ui64ARB_fnptr = &ProgramUniform3ui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64ARB(ProgramHandle program, int location, ulong x, ulong y, ulong z) => _ProgramUniform3ui64ARB_fnptr(program, location, x, y, z);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3ui64ARB_Lazy(ProgramHandle program, int location, ulong x, ulong y, ulong z)
            {
                _ProgramUniform3ui64ARB_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3ui64ARB");
                _ProgramUniform3ui64ARB_fnptr(program, location, x, y, z);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, ulong, void> _ProgramUniform4ui64ARB_fnptr = &ProgramUniform4ui64ARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64ARB(ProgramHandle program, int location, ulong x, ulong y, ulong z, ulong w) => _ProgramUniform4ui64ARB_fnptr(program, location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4ui64ARB_Lazy(ProgramHandle program, int location, ulong x, ulong y, ulong z, ulong w)
            {
                _ProgramUniform4ui64ARB_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4ui64ARB");
                _ProgramUniform4ui64ARB_fnptr(program, location, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform1ui64vARB_fnptr = &ProgramUniform1ui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64vARB(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform1ui64vARB_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1ui64vARB_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform1ui64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1ui64vARB");
                _ProgramUniform1ui64vARB_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform2ui64vARB_fnptr = &ProgramUniform2ui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64vARB(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform2ui64vARB_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2ui64vARB_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform2ui64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2ui64vARB");
                _ProgramUniform2ui64vARB_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform3ui64vARB_fnptr = &ProgramUniform3ui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64vARB(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform3ui64vARB_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3ui64vARB_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform3ui64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3ui64vARB");
                _ProgramUniform3ui64vARB_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform4ui64vARB_fnptr = &ProgramUniform4ui64vARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64vARB(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform4ui64vARB_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4ui64vARB_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform4ui64vARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4ui64vARB");
                _ProgramUniform4ui64vARB_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<float, float, float, float, void> _BlendColor_fnptr = &BlendColor_Lazy;
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> Set the blend color. </summary>
            /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml" /></remarks>
            public static void BlendColor(float red, float green, float blue, float alpha) => _BlendColor_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void BlendColor_Lazy(float red, float green, float blue, float alpha)
            {
                _BlendColor_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glBlendColor");
                _BlendColor_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<BlendEquationModeEXT, void> _BlendEquation_fnptr = &BlendEquation_Lazy;
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
            /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
            public static void BlendEquation(BlendEquationModeEXT mode) => _BlendEquation_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void BlendEquation_Lazy(BlendEquationModeEXT mode)
            {
                _BlendEquation_fnptr = (delegate* unmanaged<BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquation");
                _BlendEquation_fnptr(mode);
            }
            
            private static delegate* unmanaged<ColorTableTarget, InternalFormat, int, PixelFormat, PixelType, void*, void> _ColorTable_fnptr = &ColorTable_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Define a color lookup table. </summary>
            /// <param name="target"> Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="internalformat"> The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16. </param>
            /// <param name="width"> The number of entries in the color lookup table specified by data. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA. </param>
            /// <param name="type"> The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="data"> Pointer to a one-dimensional array of pixel data that is processed to build the color table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorTable.xml" /></remarks>
            public static void ColorTable(ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table) => _ColorTable_fnptr(target, internalformat, width, format, type, table);
            [UnmanagedCallersOnly]
            private static void ColorTable_Lazy(ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table)
            {
                _ColorTable_fnptr = (delegate* unmanaged<ColorTableTarget, InternalFormat, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glColorTable");
                _ColorTable_fnptr(target, internalformat, width, format, type, table);
            }
            
            private static delegate* unmanaged<ColorTableTarget, ColorTableParameterPNameSGI, float*, void> _ColorTableParameterfv_fnptr = &ColorTableParameterfv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Set color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorTableParameter.xml" /></remarks>
            public static void ColorTableParameterfv(ColorTableTarget target, ColorTableParameterPNameSGI pname, float* parameters) => _ColorTableParameterfv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ColorTableParameterfv_Lazy(ColorTableTarget target, ColorTableParameterPNameSGI pname, float* parameters)
            {
                _ColorTableParameterfv_fnptr = (delegate* unmanaged<ColorTableTarget, ColorTableParameterPNameSGI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glColorTableParameterfv");
                _ColorTableParameterfv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ColorTableTarget, ColorTableParameterPNameSGI, int*, void> _ColorTableParameteriv_fnptr = &ColorTableParameteriv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Set color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorTableParameter.xml" /></remarks>
            public static void ColorTableParameteriv(ColorTableTarget target, ColorTableParameterPNameSGI pname, int* parameters) => _ColorTableParameteriv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ColorTableParameteriv_Lazy(ColorTableTarget target, ColorTableParameterPNameSGI pname, int* parameters)
            {
                _ColorTableParameteriv_fnptr = (delegate* unmanaged<ColorTableTarget, ColorTableParameterPNameSGI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glColorTableParameteriv");
                _ColorTableParameteriv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ColorTableTarget, InternalFormat, int, int, int, void> _CopyColorTable_fnptr = &CopyColorTable_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Copy pixels into a color table. </summary>
            /// <param name="target"> The color table target. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="internalformat"> The internal storage format of the texture image. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="x"> The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table. </param>
            /// <param name="y"> The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table. </param>
            /// <param name="width"> The width of the pixel rectangle. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyColorTable.xml" /></remarks>
            public static void CopyColorTable(ColorTableTarget target, InternalFormat internalformat, int x, int y, int width) => _CopyColorTable_fnptr(target, internalformat, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyColorTable_Lazy(ColorTableTarget target, InternalFormat internalformat, int x, int y, int width)
            {
                _CopyColorTable_fnptr = (delegate* unmanaged<ColorTableTarget, InternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyColorTable");
                _CopyColorTable_fnptr(target, internalformat, x, y, width);
            }
            
            private static delegate* unmanaged<ColorTableTarget, PixelFormat, PixelType, void*, void> _GetColorTable_fnptr = &GetColorTable_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Retrieve contents of a color lookup table. </summary>
            /// <param name="target"> Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="format"> The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA. </param>
            /// <param name="type"> The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="table"> Pointer to a one-dimensional array of pixel data containing the contents of the color table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetColorTable.xml" /></remarks>
            public static void GetColorTable(ColorTableTarget target, PixelFormat format, PixelType type, void* table) => _GetColorTable_fnptr(target, format, type, table);
            [UnmanagedCallersOnly]
            private static void GetColorTable_Lazy(ColorTableTarget target, PixelFormat format, PixelType type, void* table)
            {
                _GetColorTable_fnptr = (delegate* unmanaged<ColorTableTarget, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetColorTable");
                _GetColorTable_fnptr(target, format, type, table);
            }
            
            private static delegate* unmanaged<ColorTableTarget, GetColorTableParameterPNameSGI, float*, void> _GetColorTableParameterfv_fnptr = &GetColorTableParameterfv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameter will be stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetColorTableParameter.xml" /></remarks>
            public static void GetColorTableParameterfv(ColorTableTarget target, GetColorTableParameterPNameSGI pname, float* parameters) => _GetColorTableParameterfv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetColorTableParameterfv_Lazy(ColorTableTarget target, GetColorTableParameterPNameSGI pname, float* parameters)
            {
                _GetColorTableParameterfv_fnptr = (delegate* unmanaged<ColorTableTarget, GetColorTableParameterPNameSGI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetColorTableParameterfv");
                _GetColorTableParameterfv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ColorTableTarget, GetColorTableParameterPNameSGI, int*, void> _GetColorTableParameteriv_fnptr = &GetColorTableParameteriv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameter will be stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetColorTableParameter.xml" /></remarks>
            public static void GetColorTableParameteriv(ColorTableTarget target, GetColorTableParameterPNameSGI pname, int* parameters) => _GetColorTableParameteriv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetColorTableParameteriv_Lazy(ColorTableTarget target, GetColorTableParameterPNameSGI pname, int* parameters)
            {
                _GetColorTableParameteriv_fnptr = (delegate* unmanaged<ColorTableTarget, GetColorTableParameterPNameSGI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetColorTableParameteriv");
                _GetColorTableParameteriv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ColorTableTarget, int, int, PixelFormat, PixelType, void*, void> _ColorSubTable_fnptr = &ColorSubTable_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Respecify a portion of a color table. </summary>
            /// <param name="target"> Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="start"> The starting index of the portion of the color table to be replaced. </param>
            /// <param name="count"> The number of table entries to replace. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA. </param>
            /// <param name="type"> The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="data"> Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorSubTable.xml" /></remarks>
            public static void ColorSubTable(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data) => _ColorSubTable_fnptr(target, start, count, format, type, data);
            [UnmanagedCallersOnly]
            private static void ColorSubTable_Lazy(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data)
            {
                _ColorSubTable_fnptr = (delegate* unmanaged<ColorTableTarget, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glColorSubTable");
                _ColorSubTable_fnptr(target, start, count, format, type, data);
            }
            
            private static delegate* unmanaged<ColorTableTarget, int, int, int, int, void> _CopyColorSubTable_fnptr = &CopyColorSubTable_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Respecify a portion of a color table. </summary>
            /// <param name="target"> Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="start"> The starting index of the portion of the color table to be replaced. </param>
            /// <param name="x"> The window coordinates of the left corner of the row of pixels to be copied. </param>
            /// <param name="y"> The window coordinates of the left corner of the row of pixels to be copied. </param>
            /// <param name="width"> The number of table entries to replace. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyColorSubTable.xml" /></remarks>
            public static void CopyColorSubTable(ColorTableTarget target, int start, int x, int y, int width) => _CopyColorSubTable_fnptr(target, start, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyColorSubTable_Lazy(ColorTableTarget target, int start, int x, int y, int width)
            {
                _CopyColorSubTable_fnptr = (delegate* unmanaged<ColorTableTarget, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyColorSubTable");
                _CopyColorSubTable_fnptr(target, start, x, y, width);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, InternalFormat, int, PixelFormat, PixelType, void*, void> _ConvolutionFilter1D_fnptr = &ConvolutionFilter1D_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Define a one-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_1D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="width"> The width of the pixel array referenced by data. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA. </param>
            /// <param name="type"> The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="data"> Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionFilter1D.xml" /></remarks>
            public static void ConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image) => _ConvolutionFilter1D_fnptr(target, internalformat, width, format, type, image);
            [UnmanagedCallersOnly]
            private static void ConvolutionFilter1D_Lazy(ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image)
            {
                _ConvolutionFilter1D_fnptr = (delegate* unmanaged<ConvolutionTarget, InternalFormat, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionFilter1D");
                _ConvolutionFilter1D_fnptr(target, internalformat, width, format, type, image);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, InternalFormat, int, int, PixelFormat, PixelType, void*, void> _ConvolutionFilter2D_fnptr = &ConvolutionFilter2D_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Define a two-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_2D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="width"> The width of the pixel array referenced by data. </param>
            /// <param name="height"> The height of the pixel array referenced by data. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="data"> Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionFilter2D.xml" /></remarks>
            public static void ConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image) => _ConvolutionFilter2D_fnptr(target, internalformat, width, height, format, type, image);
            [UnmanagedCallersOnly]
            private static void ConvolutionFilter2D_Lazy(ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image)
            {
                _ConvolutionFilter2D_fnptr = (delegate* unmanaged<ConvolutionTarget, InternalFormat, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionFilter2D");
                _ConvolutionFilter2D_fnptr(target, internalformat, width, height, format, type, image);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, float, void> _ConvolutionParameterf_fnptr = &ConvolutionParameterf_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Set convolution parameters. </summary>
            /// <param name="target"> The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE. </param>
            /// <param name="parameters"> The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionParameter.xml" /></remarks>
            public static void ConvolutionParameterf(ConvolutionTarget target, ConvolutionParameterEXT pname, float parameters) => _ConvolutionParameterf_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameterf_Lazy(ConvolutionTarget target, ConvolutionParameterEXT pname, float parameters)
            {
                _ConvolutionParameterf_fnptr = (delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, float, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameterf");
                _ConvolutionParameterf_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, float*, void> _ConvolutionParameterfv_fnptr = &ConvolutionParameterfv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameterEXT pname, float* parameters) => _ConvolutionParameterfv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameterfv_Lazy(ConvolutionTarget target, ConvolutionParameterEXT pname, float* parameters)
            {
                _ConvolutionParameterfv_fnptr = (delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameterfv");
                _ConvolutionParameterfv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, int, void> _ConvolutionParameteri_fnptr = &ConvolutionParameteri_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Set convolution parameters. </summary>
            /// <param name="target"> The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE. </param>
            /// <param name="parameters"> The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionParameter.xml" /></remarks>
            public static void ConvolutionParameteri(ConvolutionTarget target, ConvolutionParameterEXT pname, int parameters) => _ConvolutionParameteri_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameteri_Lazy(ConvolutionTarget target, ConvolutionParameterEXT pname, int parameters)
            {
                _ConvolutionParameteri_fnptr = (delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, int, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameteri");
                _ConvolutionParameteri_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, int*, void> _ConvolutionParameteriv_fnptr = &ConvolutionParameteriv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameterEXT pname, int* parameters) => _ConvolutionParameteriv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameteriv_Lazy(ConvolutionTarget target, ConvolutionParameterEXT pname, int* parameters)
            {
                _ConvolutionParameteriv_fnptr = (delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameteriv");
                _ConvolutionParameteriv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, InternalFormat, int, int, int, void> _CopyConvolutionFilter1D_fnptr = &CopyConvolutionFilter1D_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Copy pixels into a one-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_1D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="x"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="y"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="width"> The width of the pixel array to copy. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyConvolutionFilter1D.xml" /></remarks>
            public static void CopyConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width) => _CopyConvolutionFilter1D_fnptr(target, internalformat, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyConvolutionFilter1D_Lazy(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width)
            {
                _CopyConvolutionFilter1D_fnptr = (delegate* unmanaged<ConvolutionTarget, InternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyConvolutionFilter1D");
                _CopyConvolutionFilter1D_fnptr(target, internalformat, x, y, width);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, InternalFormat, int, int, int, int, void> _CopyConvolutionFilter2D_fnptr = &CopyConvolutionFilter2D_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Copy pixels into a two-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_2D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="x"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="y"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="width"> The width of the pixel array to copy. </param>
            /// <param name="height"> The height of the pixel array to copy. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyConvolutionFilter2D.xml" /></remarks>
            public static void CopyConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width, int height) => _CopyConvolutionFilter2D_fnptr(target, internalformat, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyConvolutionFilter2D_Lazy(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width, int height)
            {
                _CopyConvolutionFilter2D_fnptr = (delegate* unmanaged<ConvolutionTarget, InternalFormat, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyConvolutionFilter2D");
                _CopyConvolutionFilter2D_fnptr(target, internalformat, x, y, width, height);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, PixelFormat, PixelType, void*, void> _GetConvolutionFilter_fnptr = &GetConvolutionFilter_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get current 1D or 2D convolution filter kernel. </summary>
            /// <param name="target"> The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D. </param>
            /// <param name="format"> Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="image"> Pointer to storage for the output image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetConvolutionFilter.xml" /></remarks>
            public static void GetConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, void* image) => _GetConvolutionFilter_fnptr(target, format, type, image);
            [UnmanagedCallersOnly]
            private static void GetConvolutionFilter_Lazy(ConvolutionTarget target, PixelFormat format, PixelType type, void* image)
            {
                _GetConvolutionFilter_fnptr = (delegate* unmanaged<ConvolutionTarget, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetConvolutionFilter");
                _GetConvolutionFilter_fnptr(target, format, type, image);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, float*, void> _GetConvolutionParameterfv_fnptr = &GetConvolutionParameterfv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get convolution parameters. </summary>
            /// <param name="target"> The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT. </param>
            /// <param name="parameters"> Pointer to storage for the parameters to be retrieved. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetConvolutionParameter.xml" /></remarks>
            public static void GetConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameterEXT pname, float* parameters) => _GetConvolutionParameterfv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetConvolutionParameterfv_Lazy(ConvolutionTarget target, ConvolutionParameterEXT pname, float* parameters)
            {
                _GetConvolutionParameterfv_fnptr = (delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetConvolutionParameterfv");
                _GetConvolutionParameterfv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, int*, void> _GetConvolutionParameteriv_fnptr = &GetConvolutionParameteriv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get convolution parameters. </summary>
            /// <param name="target"> The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT. </param>
            /// <param name="parameters"> Pointer to storage for the parameters to be retrieved. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetConvolutionParameter.xml" /></remarks>
            public static void GetConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameterEXT pname, int* parameters) => _GetConvolutionParameteriv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetConvolutionParameteriv_Lazy(ConvolutionTarget target, ConvolutionParameterEXT pname, int* parameters)
            {
                _GetConvolutionParameteriv_fnptr = (delegate* unmanaged<ConvolutionTarget, ConvolutionParameterEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetConvolutionParameteriv");
                _GetConvolutionParameteriv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<SeparableTargetEXT, PixelFormat, PixelType, void*, void*, void*, void> _GetSeparableFilter_fnptr = &GetSeparableFilter_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get separable convolution filter kernel images. </summary>
            /// <param name="target"> The separable filter to be retrieved. Must be GL_SEPARABLE_2D. </param>
            /// <param name="format"> Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="row"> Pointer to storage for the row filter image. </param>
            /// <param name="column"> Pointer to storage for the column filter image. </param>
            /// <param name="span"> Pointer to storage for the span filter image (currently unused). </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetSeparableFilter.xml" /></remarks>
            public static void GetSeparableFilter(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span) => _GetSeparableFilter_fnptr(target, format, type, row, column, span);
            [UnmanagedCallersOnly]
            private static void GetSeparableFilter_Lazy(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span)
            {
                _GetSeparableFilter_fnptr = (delegate* unmanaged<SeparableTargetEXT, PixelFormat, PixelType, void*, void*, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSeparableFilter");
                _GetSeparableFilter_fnptr(target, format, type, row, column, span);
            }
            
            private static delegate* unmanaged<SeparableTargetEXT, InternalFormat, int, int, PixelFormat, PixelType, void*, void*, void> _SeparableFilter2D_fnptr = &SeparableFilter2D_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Define a separable two-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_SEPARABLE_2D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="width"> The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.) </param>
            /// <param name="height"> The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.) </param>
            /// <param name="format"> The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="row"> Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel. </param>
            /// <param name="column"> Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSeparableFilter2D.xml" /></remarks>
            public static void SeparableFilter2D(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column) => _SeparableFilter2D_fnptr(target, internalformat, width, height, format, type, row, column);
            [UnmanagedCallersOnly]
            private static void SeparableFilter2D_Lazy(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column)
            {
                _SeparableFilter2D_fnptr = (delegate* unmanaged<SeparableTargetEXT, InternalFormat, int, int, PixelFormat, PixelType, void*, void*, void>)GLLoader.BindingsContext.GetProcAddress("glSeparableFilter2D");
                _SeparableFilter2D_fnptr(target, internalformat, width, height, format, type, row, column);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, byte, PixelFormat, PixelType, void*, void> _GetHistogram_fnptr = &GetHistogram_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get histogram table. </summary>
            /// <param name="target"> Must be GL_HISTOGRAM. </param>
            /// <param name="reset"> If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified. </param>
            /// <param name="format"> The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="values"> A pointer to storage for the returned histogram table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetHistogram.xml" /></remarks>
            public static void GetHistogram(HistogramTargetEXT target, byte reset, PixelFormat format, PixelType type, void* values) => _GetHistogram_fnptr(target, reset, format, type, values);
            [UnmanagedCallersOnly]
            private static void GetHistogram_Lazy(HistogramTargetEXT target, byte reset, PixelFormat format, PixelType type, void* values)
            {
                _GetHistogram_fnptr = (delegate* unmanaged<HistogramTargetEXT, byte, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetHistogram");
                _GetHistogram_fnptr(target, reset, format, type, values);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, float*, void> _GetHistogramParameterfv_fnptr = &GetHistogramParameterfv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get histogram parameters. </summary>
            /// <param name="target"> Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM. </param>
            /// <param name="pname"> The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK. </param>
            /// <param name="parameters"> Pointer to storage for the returned values. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetHistogramParameter.xml" /></remarks>
            public static void GetHistogramParameterfv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters) => _GetHistogramParameterfv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetHistogramParameterfv_Lazy(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters)
            {
                _GetHistogramParameterfv_fnptr = (delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetHistogramParameterfv");
                _GetHistogramParameterfv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, int*, void> _GetHistogramParameteriv_fnptr = &GetHistogramParameteriv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get histogram parameters. </summary>
            /// <param name="target"> Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM. </param>
            /// <param name="pname"> The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK. </param>
            /// <param name="parameters"> Pointer to storage for the returned values. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetHistogramParameter.xml" /></remarks>
            public static void GetHistogramParameteriv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => _GetHistogramParameteriv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetHistogramParameteriv_Lazy(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters)
            {
                _GetHistogramParameteriv_fnptr = (delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetHistogramParameteriv");
                _GetHistogramParameteriv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, byte, PixelFormat, PixelType, void*, void> _GetMinmax_fnptr = &GetMinmax_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get minimum and maximum pixel values. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <param name="reset"> If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered. </param>
            /// <param name="format"> The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="types"> The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="values"> A pointer to storage for the returned values. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMinmax.xml" /></remarks>
            public static void GetMinmax(MinmaxTargetEXT target, byte reset, PixelFormat format, PixelType type, void* values) => _GetMinmax_fnptr(target, reset, format, type, values);
            [UnmanagedCallersOnly]
            private static void GetMinmax_Lazy(MinmaxTargetEXT target, byte reset, PixelFormat format, PixelType type, void* values)
            {
                _GetMinmax_fnptr = (delegate* unmanaged<MinmaxTargetEXT, byte, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMinmax");
                _GetMinmax_fnptr(target, reset, format, type, values);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, GetMinmaxParameterPNameEXT, float*, void> _GetMinmaxParameterfv_fnptr = &GetMinmaxParameterfv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get minmax parameters. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK. </param>
            /// <param name="parameters"> A pointer to storage for the retrieved parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMinmaxParameter.xml" /></remarks>
            public static void GetMinmaxParameterfv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters) => _GetMinmaxParameterfv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMinmaxParameterfv_Lazy(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters)
            {
                _GetMinmaxParameterfv_fnptr = (delegate* unmanaged<MinmaxTargetEXT, GetMinmaxParameterPNameEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMinmaxParameterfv");
                _GetMinmaxParameterfv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, GetMinmaxParameterPNameEXT, int*, void> _GetMinmaxParameteriv_fnptr = &GetMinmaxParameteriv_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Get minmax parameters. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK. </param>
            /// <param name="parameters"> A pointer to storage for the retrieved parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMinmaxParameter.xml" /></remarks>
            public static void GetMinmaxParameteriv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters) => _GetMinmaxParameteriv_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMinmaxParameteriv_Lazy(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters)
            {
                _GetMinmaxParameteriv_fnptr = (delegate* unmanaged<MinmaxTargetEXT, GetMinmaxParameterPNameEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMinmaxParameteriv");
                _GetMinmaxParameteriv_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, int, InternalFormat, byte, void> _Histogram_fnptr = &Histogram_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Define histogram table. </summary>
            /// <param name="target"> The histogram whose parameters are to be set. Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM. </param>
            /// <param name="width"> The number of entries in the histogram table. Must be a power of 2. </param>
            /// <param name="internalformat"> The format of entries in the histogram table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="sink"> If GL_TRUE, pixels will be consumed by the histogramming process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the minmax process after histogramming. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glHistogram.xml" /></remarks>
            public static void Histogram(HistogramTargetEXT target, int width, InternalFormat internalformat, byte sink) => _Histogram_fnptr(target, width, internalformat, sink);
            [UnmanagedCallersOnly]
            private static void Histogram_Lazy(HistogramTargetEXT target, int width, InternalFormat internalformat, byte sink)
            {
                _Histogram_fnptr = (delegate* unmanaged<HistogramTargetEXT, int, InternalFormat, byte, void>)GLLoader.BindingsContext.GetProcAddress("glHistogram");
                _Histogram_fnptr(target, width, internalformat, sink);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, InternalFormat, byte, void> _Minmax_fnptr = &Minmax_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Define minmax table. </summary>
            /// <param name="target"> The minmax table whose parameters are to be set. Must be GL_MINMAX. </param>
            /// <param name="internalformat"> The format of entries in the minmax table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="sink"> If GL_TRUE, pixels will be consumed by the minmax process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the final conversion process after minmax. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMinmax.xml" /></remarks>
            public static void Minmax(MinmaxTargetEXT target, InternalFormat internalformat, byte sink) => _Minmax_fnptr(target, internalformat, sink);
            [UnmanagedCallersOnly]
            private static void Minmax_Lazy(MinmaxTargetEXT target, InternalFormat internalformat, byte sink)
            {
                _Minmax_fnptr = (delegate* unmanaged<MinmaxTargetEXT, InternalFormat, byte, void>)GLLoader.BindingsContext.GetProcAddress("glMinmax");
                _Minmax_fnptr(target, internalformat, sink);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, void> _ResetHistogram_fnptr = &ResetHistogram_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Reset histogram table entries to zero. </summary>
            /// <param name="target"> Must be GL_HISTOGRAM. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glResetHistogram.xml" /></remarks>
            public static void ResetHistogram(HistogramTargetEXT target) => _ResetHistogram_fnptr(target);
            [UnmanagedCallersOnly]
            private static void ResetHistogram_Lazy(HistogramTargetEXT target)
            {
                _ResetHistogram_fnptr = (delegate* unmanaged<HistogramTargetEXT, void>)GLLoader.BindingsContext.GetProcAddress("glResetHistogram");
                _ResetHistogram_fnptr(target);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, void> _ResetMinmax_fnptr = &ResetMinmax_Lazy;
            /// <summary> <b>[requires: GL_ARB_imaging]</b> Reset minmax table entries to initial values. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glResetMinmax.xml" /></remarks>
            public static void ResetMinmax(MinmaxTargetEXT target) => _ResetMinmax_fnptr(target);
            [UnmanagedCallersOnly]
            private static void ResetMinmax_Lazy(MinmaxTargetEXT target)
            {
                _ResetMinmax_fnptr = (delegate* unmanaged<MinmaxTargetEXT, void>)GLLoader.BindingsContext.GetProcAddress("glResetMinmax");
                _ResetMinmax_fnptr(target);
            }
            
            private static delegate* unmanaged<PrimitiveType, void*, IntPtr, int, int, void> _MultiDrawArraysIndirectCountARB_fnptr = &MultiDrawArraysIndirectCountARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_indirect_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysIndirectCountARB(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawArraysIndirectCountARB_fnptr(mode, indirect, drawcount, maxdrawcount, stride);
            [UnmanagedCallersOnly]
            private static void MultiDrawArraysIndirectCountARB_Lazy(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride)
            {
                _MultiDrawArraysIndirectCountARB_fnptr = (delegate* unmanaged<PrimitiveType, void*, IntPtr, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawArraysIndirectCountARB");
                _MultiDrawArraysIndirectCountARB_fnptr(mode, indirect, drawcount, maxdrawcount, stride);
            }
            
            private static delegate* unmanaged<PrimitiveType, DrawElementsType, void*, IntPtr, int, int, void> _MultiDrawElementsIndirectCountARB_fnptr = &MultiDrawElementsIndirectCountARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_indirect_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsIndirectCountARB(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawElementsIndirectCountARB_fnptr(mode, type, indirect, drawcount, maxdrawcount, stride);
            [UnmanagedCallersOnly]
            private static void MultiDrawElementsIndirectCountARB_Lazy(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride)
            {
                _MultiDrawElementsIndirectCountARB_fnptr = (delegate* unmanaged<PrimitiveType, DrawElementsType, void*, IntPtr, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsIndirectCountARB");
                _MultiDrawElementsIndirectCountARB_fnptr(mode, type, indirect, drawcount, maxdrawcount, stride);
            }
            
            private static delegate* unmanaged<uint, uint, void> _VertexAttribDivisorARB_fnptr = &VertexAttribDivisorARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_instanced_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribDivisorARB(uint index, uint divisor) => _VertexAttribDivisorARB_fnptr(index, divisor);
            [UnmanagedCallersOnly]
            private static void VertexAttribDivisorARB_Lazy(uint index, uint divisor)
            {
                _VertexAttribDivisorARB_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribDivisorARB");
                _VertexAttribDivisorARB_fnptr(index, divisor);
            }
            
            private static delegate* unmanaged<TextureTarget, InternalFormat, InternalFormatPName, int, int*, void> _GetInternalformativ_fnptr = &GetInternalformativ_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
            public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => _GetInternalformativ_fnptr(target, internalformat, pname, count, parameters);
            [UnmanagedCallersOnly]
            private static void GetInternalformativ_Lazy(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters)
            {
                _GetInternalformativ_fnptr = (delegate* unmanaged<TextureTarget, InternalFormat, InternalFormatPName, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInternalformativ");
                _GetInternalformativ_fnptr(target, internalformat, pname, count, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, InternalFormat, InternalFormatPName, int, long*, void> _GetInternalformati64v_fnptr = &GetInternalformati64v_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
            public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => _GetInternalformati64v_fnptr(target, internalformat, pname, count, parameters);
            [UnmanagedCallersOnly]
            private static void GetInternalformati64v_Lazy(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters)
            {
                _GetInternalformati64v_fnptr = (delegate* unmanaged<TextureTarget, InternalFormat, InternalFormatPName, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInternalformati64v");
                _GetInternalformati64v_fnptr(target, internalformat, pname, count, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, void> _InvalidateTexSubImage_fnptr = &InvalidateTexSubImage_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate a region of a texture image. </summary>
            /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
            /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
            /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
            /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
            /// <param name="width"> The width of the region to be invalidated. </param>
            /// <param name="height"> The height of the region to be invalidated. </param>
            /// <param name="depth"> The depth of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml" /></remarks>
            public static void InvalidateTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => _InvalidateTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
            [UnmanagedCallersOnly]
            private static void InvalidateTexSubImage_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth)
            {
                _InvalidateTexSubImage_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateTexSubImage");
                _InvalidateTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
            }
            
            private static delegate* unmanaged<TextureHandle, int, void> _InvalidateTexImage_fnptr = &InvalidateTexImage_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the entirety a texture image. </summary>
            /// <param name="texture"> The name of a texture object to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml" /></remarks>
            public static void InvalidateTexImage(TextureHandle texture, int level) => _InvalidateTexImage_fnptr(texture, level);
            [UnmanagedCallersOnly]
            private static void InvalidateTexImage_Lazy(TextureHandle texture, int level)
            {
                _InvalidateTexImage_fnptr = (delegate* unmanaged<TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateTexImage");
                _InvalidateTexImage_fnptr(texture, level);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, void> _InvalidateBufferSubData_fnptr = &InvalidateBufferSubData_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate a region of a buffer object's data store. </summary>
            /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
            /// <param name="offset"> The offset within the buffer's data store of the start of the range to be invalidated. </param>
            /// <param name="length"> The length of the range within the buffer's data store to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml" /></remarks>
            public static void InvalidateBufferSubData(BufferHandle buffer, IntPtr offset, nint length) => _InvalidateBufferSubData_fnptr(buffer, offset, length);
            [UnmanagedCallersOnly]
            private static void InvalidateBufferSubData_Lazy(BufferHandle buffer, IntPtr offset, nint length)
            {
                _InvalidateBufferSubData_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateBufferSubData");
                _InvalidateBufferSubData_fnptr(buffer, offset, length);
            }
            
            private static delegate* unmanaged<BufferHandle, void> _InvalidateBufferData_fnptr = &InvalidateBufferData_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of a buffer object's data store. </summary>
            /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml" /></remarks>
            public static void InvalidateBufferData(BufferHandle buffer) => _InvalidateBufferData_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static void InvalidateBufferData_Lazy(BufferHandle buffer)
            {
                _InvalidateBufferData_fnptr = (delegate* unmanaged<BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateBufferData");
                _InvalidateBufferData_fnptr(buffer);
            }
            
            private static delegate* unmanaged<FramebufferTarget, int, InvalidateFramebufferAttachment*, void> _InvalidateFramebuffer_fnptr = &InvalidateFramebuffer_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of some or all of a framebuffer's attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
            public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => _InvalidateFramebuffer_fnptr(target, numAttachments, attachments);
            [UnmanagedCallersOnly]
            private static void InvalidateFramebuffer_Lazy(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments)
            {
                _InvalidateFramebuffer_fnptr = (delegate* unmanaged<FramebufferTarget, int, InvalidateFramebufferAttachment*, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateFramebuffer");
                _InvalidateFramebuffer_fnptr(target, numAttachments, attachments);
            }
            
            private static delegate* unmanaged<FramebufferTarget, int, InvalidateFramebufferAttachment*, int, int, int, int, void> _InvalidateSubFramebuffer_fnptr = &InvalidateSubFramebuffer_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of a region of some or all of a framebuffer's attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
            public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => _InvalidateSubFramebuffer_fnptr(target, numAttachments, attachments, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void InvalidateSubFramebuffer_Lazy(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height)
            {
                _InvalidateSubFramebuffer_fnptr = (delegate* unmanaged<FramebufferTarget, int, InvalidateFramebufferAttachment*, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glInvalidateSubFramebuffer");
                _InvalidateSubFramebuffer_fnptr(target, numAttachments, attachments, x, y, width, height);
            }
            
            private static delegate* unmanaged<BufferTargetARB, IntPtr, nint, MapBufferAccessMask, void*> _MapBufferRange_fnptr = &MapBufferRange_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> Map all or part of a buffer object's data store into the client's address space. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
            public static void* MapBufferRange(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access) => _MapBufferRange_fnptr(target, offset, length, access);
            [UnmanagedCallersOnly]
            private static void* MapBufferRange_Lazy(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access)
            {
                _MapBufferRange_fnptr = (delegate* unmanaged<BufferTargetARB, IntPtr, nint, MapBufferAccessMask, void*>)GLLoader.BindingsContext.GetProcAddress("glMapBufferRange");
                return _MapBufferRange_fnptr(target, offset, length, access);
            }
            
            private static delegate* unmanaged<BufferTargetARB, IntPtr, nint, void> _FlushMappedBufferRange_fnptr = &FlushMappedBufferRange_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
            public static void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, nint length) => _FlushMappedBufferRange_fnptr(target, offset, length);
            [UnmanagedCallersOnly]
            private static void FlushMappedBufferRange_Lazy(BufferTargetARB target, IntPtr offset, nint length)
            {
                _FlushMappedBufferRange_fnptr = (delegate* unmanaged<BufferTargetARB, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glFlushMappedBufferRange");
                _FlushMappedBufferRange_fnptr(target, offset, length);
            }
            
            private static delegate* unmanaged<int, void> _CurrentPaletteMatrixARB_fnptr = &CurrentPaletteMatrixARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CurrentPaletteMatrixARB(int index) => _CurrentPaletteMatrixARB_fnptr(index);
            [UnmanagedCallersOnly]
            private static void CurrentPaletteMatrixARB_Lazy(int index)
            {
                _CurrentPaletteMatrixARB_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glCurrentPaletteMatrixARB");
                _CurrentPaletteMatrixARB_fnptr(index);
            }
            
            private static delegate* unmanaged<int, byte*, void> _MatrixIndexubvARB_fnptr = &MatrixIndexubvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixIndexubvARB(int size, byte* indices) => _MatrixIndexubvARB_fnptr(size, indices);
            [UnmanagedCallersOnly]
            private static void MatrixIndexubvARB_Lazy(int size, byte* indices)
            {
                _MatrixIndexubvARB_fnptr = (delegate* unmanaged<int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixIndexubvARB");
                _MatrixIndexubvARB_fnptr(size, indices);
            }
            
            private static delegate* unmanaged<int, ushort*, void> _MatrixIndexusvARB_fnptr = &MatrixIndexusvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixIndexusvARB(int size, ushort* indices) => _MatrixIndexusvARB_fnptr(size, indices);
            [UnmanagedCallersOnly]
            private static void MatrixIndexusvARB_Lazy(int size, ushort* indices)
            {
                _MatrixIndexusvARB_fnptr = (delegate* unmanaged<int, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixIndexusvARB");
                _MatrixIndexusvARB_fnptr(size, indices);
            }
            
            private static delegate* unmanaged<int, uint*, void> _MatrixIndexuivARB_fnptr = &MatrixIndexuivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixIndexuivARB(int size, uint* indices) => _MatrixIndexuivARB_fnptr(size, indices);
            [UnmanagedCallersOnly]
            private static void MatrixIndexuivARB_Lazy(int size, uint* indices)
            {
                _MatrixIndexuivARB_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixIndexuivARB");
                _MatrixIndexuivARB_fnptr(size, indices);
            }
            
            private static delegate* unmanaged<int, MatrixIndexPointerTypeARB, int, void*, void> _MatrixIndexPointerARB_fnptr = &MatrixIndexPointerARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixIndexPointerARB(int size, MatrixIndexPointerTypeARB type, int stride, void* pointer) => _MatrixIndexPointerARB_fnptr(size, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void MatrixIndexPointerARB_Lazy(int size, MatrixIndexPointerTypeARB type, int stride, void* pointer)
            {
                _MatrixIndexPointerARB_fnptr = (delegate* unmanaged<int, MatrixIndexPointerTypeARB, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixIndexPointerARB");
                _MatrixIndexPointerARB_fnptr(size, type, stride, pointer);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, int, BufferHandle*, void> _BindBuffersBase_fnptr = &BindBuffersBase_Lazy;
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml" /></remarks>
            public static void BindBuffersBase(BufferTargetARB target, uint first, int count, BufferHandle* buffers) => _BindBuffersBase_fnptr(target, first, count, buffers);
            [UnmanagedCallersOnly]
            private static void BindBuffersBase_Lazy(BufferTargetARB target, uint first, int count, BufferHandle* buffers)
            {
                _BindBuffersBase_fnptr = (delegate* unmanaged<BufferTargetARB, uint, int, BufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glBindBuffersBase");
                _BindBuffersBase_fnptr(target, first, count, buffers);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, int, BufferHandle*, IntPtr*, nint*, void> _BindBuffersRange_fnptr = &BindBuffersRange_Lazy;
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml" /></remarks>
            public static void BindBuffersRange(BufferTargetARB target, uint first, int count, BufferHandle* buffers, IntPtr* offsets, nint* sizes) => _BindBuffersRange_fnptr(target, first, count, buffers, offsets, sizes);
            [UnmanagedCallersOnly]
            private static void BindBuffersRange_Lazy(BufferTargetARB target, uint first, int count, BufferHandle* buffers, IntPtr* offsets, nint* sizes)
            {
                _BindBuffersRange_fnptr = (delegate* unmanaged<BufferTargetARB, uint, int, BufferHandle*, IntPtr*, nint*, void>)GLLoader.BindingsContext.GetProcAddress("glBindBuffersRange");
                _BindBuffersRange_fnptr(target, first, count, buffers, offsets, sizes);
            }
            
            private static delegate* unmanaged<uint, int, TextureHandle*, void> _BindTextures_fnptr = &BindTextures_Lazy;
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named textures to a sequence of consecutive texture units. </summary>
            /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml" /></remarks>
            public static void BindTextures(uint first, int count, TextureHandle* textures) => _BindTextures_fnptr(first, count, textures);
            [UnmanagedCallersOnly]
            private static void BindTextures_Lazy(uint first, int count, TextureHandle* textures)
            {
                _BindTextures_fnptr = (delegate* unmanaged<uint, int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glBindTextures");
                _BindTextures_fnptr(first, count, textures);
            }
            
            private static delegate* unmanaged<uint, int, SamplerHandle*, void> _BindSamplers_fnptr = &BindSamplers_Lazy;
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
            /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
            /// <param name="count"> Specifies the number of samplers to bind. </param>
            /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml" /></remarks>
            public static void BindSamplers(uint first, int count, SamplerHandle* samplers) => _BindSamplers_fnptr(first, count, samplers);
            [UnmanagedCallersOnly]
            private static void BindSamplers_Lazy(uint first, int count, SamplerHandle* samplers)
            {
                _BindSamplers_fnptr = (delegate* unmanaged<uint, int, SamplerHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glBindSamplers");
                _BindSamplers_fnptr(first, count, samplers);
            }
            
            private static delegate* unmanaged<uint, int, TextureHandle*, void> _BindImageTextures_fnptr = &BindImageTextures_Lazy;
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named texture images to a sequence of consecutive image units. </summary>
            /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml" /></remarks>
            public static void BindImageTextures(uint first, int count, TextureHandle* textures) => _BindImageTextures_fnptr(first, count, textures);
            [UnmanagedCallersOnly]
            private static void BindImageTextures_Lazy(uint first, int count, TextureHandle* textures)
            {
                _BindImageTextures_fnptr = (delegate* unmanaged<uint, int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glBindImageTextures");
                _BindImageTextures_fnptr(first, count, textures);
            }
            
            private static delegate* unmanaged<uint, int, BufferHandle*, IntPtr*, int*, void> _BindVertexBuffers_fnptr = &BindVertexBuffers_Lazy;
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
            public static void BindVertexBuffers(uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides) => _BindVertexBuffers_fnptr(first, count, buffers, offsets, strides);
            [UnmanagedCallersOnly]
            private static void BindVertexBuffers_Lazy(uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides)
            {
                _BindVertexBuffers_fnptr = (delegate* unmanaged<uint, int, BufferHandle*, IntPtr*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glBindVertexBuffers");
                _BindVertexBuffers_fnptr(first, count, buffers, offsets, strides);
            }
            
            private static delegate* unmanaged<PrimitiveType, void*, int, int, void> _MultiDrawArraysIndirect_fnptr = &MultiDrawArraysIndirect_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml" /></remarks>
            public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => _MultiDrawArraysIndirect_fnptr(mode, indirect, drawcount, stride);
            [UnmanagedCallersOnly]
            private static void MultiDrawArraysIndirect_Lazy(PrimitiveType mode, void* indirect, int drawcount, int stride)
            {
                _MultiDrawArraysIndirect_fnptr = (delegate* unmanaged<PrimitiveType, void*, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawArraysIndirect");
                _MultiDrawArraysIndirect_fnptr(mode, indirect, drawcount, stride);
            }
            
            private static delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, void> _MultiDrawElementsIndirect_fnptr = &MultiDrawElementsIndirect_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml" /></remarks>
            public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => _MultiDrawElementsIndirect_fnptr(mode, type, indirect, drawcount, stride);
            [UnmanagedCallersOnly]
            private static void MultiDrawElementsIndirect_Lazy(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride)
            {
                _MultiDrawElementsIndirect_fnptr = (delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsIndirect");
                _MultiDrawElementsIndirect_fnptr(mode, type, indirect, drawcount, stride);
            }
            
            private static delegate* unmanaged<float, byte, void> _SampleCoverageARB_fnptr = &SampleCoverageARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleCoverageARB(float value, byte invert) => _SampleCoverageARB_fnptr(value, invert);
            [UnmanagedCallersOnly]
            private static void SampleCoverageARB_Lazy(float value, byte invert)
            {
                _SampleCoverageARB_fnptr = (delegate* unmanaged<float, byte, void>)GLLoader.BindingsContext.GetProcAddress("glSampleCoverageARB");
                _SampleCoverageARB_fnptr(value, invert);
            }
            
            private static delegate* unmanaged<TextureUnit, void> _ActiveTextureARB_fnptr = &ActiveTextureARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveTextureARB(TextureUnit texture) => _ActiveTextureARB_fnptr(texture);
            [UnmanagedCallersOnly]
            private static void ActiveTextureARB_Lazy(TextureUnit texture)
            {
                _ActiveTextureARB_fnptr = (delegate* unmanaged<TextureUnit, void>)GLLoader.BindingsContext.GetProcAddress("glActiveTextureARB");
                _ActiveTextureARB_fnptr(texture);
            }
            
            private static delegate* unmanaged<TextureUnit, void> _ClientActiveTextureARB_fnptr = &ClientActiveTextureARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClientActiveTextureARB(TextureUnit texture) => _ClientActiveTextureARB_fnptr(texture);
            [UnmanagedCallersOnly]
            private static void ClientActiveTextureARB_Lazy(TextureUnit texture)
            {
                _ClientActiveTextureARB_fnptr = (delegate* unmanaged<TextureUnit, void>)GLLoader.BindingsContext.GetProcAddress("glClientActiveTextureARB");
                _ClientActiveTextureARB_fnptr(texture);
            }
            
            private static delegate* unmanaged<TextureUnit, double, void> _MultiTexCoord1dARB_fnptr = &MultiTexCoord1dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1dARB(TextureUnit target, double s) => _MultiTexCoord1dARB_fnptr(target, s);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1dARB_Lazy(TextureUnit target, double s)
            {
                _MultiTexCoord1dARB_fnptr = (delegate* unmanaged<TextureUnit, double, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1dARB");
                _MultiTexCoord1dARB_fnptr(target, s);
            }
            
            private static delegate* unmanaged<TextureUnit, double*, void> _MultiTexCoord1dvARB_fnptr = &MultiTexCoord1dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1dvARB(TextureUnit target, double* v) => _MultiTexCoord1dvARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1dvARB_Lazy(TextureUnit target, double* v)
            {
                _MultiTexCoord1dvARB_fnptr = (delegate* unmanaged<TextureUnit, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1dvARB");
                _MultiTexCoord1dvARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, float, void> _MultiTexCoord1fARB_fnptr = &MultiTexCoord1fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1fARB(TextureUnit target, float s) => _MultiTexCoord1fARB_fnptr(target, s);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1fARB_Lazy(TextureUnit target, float s)
            {
                _MultiTexCoord1fARB_fnptr = (delegate* unmanaged<TextureUnit, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1fARB");
                _MultiTexCoord1fARB_fnptr(target, s);
            }
            
            private static delegate* unmanaged<TextureUnit, float*, void> _MultiTexCoord1fvARB_fnptr = &MultiTexCoord1fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1fvARB(TextureUnit target, float* v) => _MultiTexCoord1fvARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1fvARB_Lazy(TextureUnit target, float* v)
            {
                _MultiTexCoord1fvARB_fnptr = (delegate* unmanaged<TextureUnit, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1fvARB");
                _MultiTexCoord1fvARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, int, void> _MultiTexCoord1iARB_fnptr = &MultiTexCoord1iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1iARB(TextureUnit target, int s) => _MultiTexCoord1iARB_fnptr(target, s);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1iARB_Lazy(TextureUnit target, int s)
            {
                _MultiTexCoord1iARB_fnptr = (delegate* unmanaged<TextureUnit, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1iARB");
                _MultiTexCoord1iARB_fnptr(target, s);
            }
            
            private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord1ivARB_fnptr = &MultiTexCoord1ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1ivARB(TextureUnit target, int* v) => _MultiTexCoord1ivARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1ivARB_Lazy(TextureUnit target, int* v)
            {
                _MultiTexCoord1ivARB_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1ivARB");
                _MultiTexCoord1ivARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, short, void> _MultiTexCoord1sARB_fnptr = &MultiTexCoord1sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1sARB(TextureUnit target, short s) => _MultiTexCoord1sARB_fnptr(target, s);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1sARB_Lazy(TextureUnit target, short s)
            {
                _MultiTexCoord1sARB_fnptr = (delegate* unmanaged<TextureUnit, short, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1sARB");
                _MultiTexCoord1sARB_fnptr(target, s);
            }
            
            private static delegate* unmanaged<TextureUnit, short*, void> _MultiTexCoord1svARB_fnptr = &MultiTexCoord1svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1svARB(TextureUnit target, short* v) => _MultiTexCoord1svARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1svARB_Lazy(TextureUnit target, short* v)
            {
                _MultiTexCoord1svARB_fnptr = (delegate* unmanaged<TextureUnit, short*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1svARB");
                _MultiTexCoord1svARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, double, double, void> _MultiTexCoord2dARB_fnptr = &MultiTexCoord2dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2dARB(TextureUnit target, double s, double t) => _MultiTexCoord2dARB_fnptr(target, s, t);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2dARB_Lazy(TextureUnit target, double s, double t)
            {
                _MultiTexCoord2dARB_fnptr = (delegate* unmanaged<TextureUnit, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2dARB");
                _MultiTexCoord2dARB_fnptr(target, s, t);
            }
            
            private static delegate* unmanaged<TextureUnit, double*, void> _MultiTexCoord2dvARB_fnptr = &MultiTexCoord2dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2dvARB(TextureUnit target, double* v) => _MultiTexCoord2dvARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2dvARB_Lazy(TextureUnit target, double* v)
            {
                _MultiTexCoord2dvARB_fnptr = (delegate* unmanaged<TextureUnit, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2dvARB");
                _MultiTexCoord2dvARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, float, float, void> _MultiTexCoord2fARB_fnptr = &MultiTexCoord2fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2fARB(TextureUnit target, float s, float t) => _MultiTexCoord2fARB_fnptr(target, s, t);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2fARB_Lazy(TextureUnit target, float s, float t)
            {
                _MultiTexCoord2fARB_fnptr = (delegate* unmanaged<TextureUnit, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2fARB");
                _MultiTexCoord2fARB_fnptr(target, s, t);
            }
            
            private static delegate* unmanaged<TextureUnit, float*, void> _MultiTexCoord2fvARB_fnptr = &MultiTexCoord2fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2fvARB(TextureUnit target, float* v) => _MultiTexCoord2fvARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2fvARB_Lazy(TextureUnit target, float* v)
            {
                _MultiTexCoord2fvARB_fnptr = (delegate* unmanaged<TextureUnit, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2fvARB");
                _MultiTexCoord2fvARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, int, int, void> _MultiTexCoord2iARB_fnptr = &MultiTexCoord2iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2iARB(TextureUnit target, int s, int t) => _MultiTexCoord2iARB_fnptr(target, s, t);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2iARB_Lazy(TextureUnit target, int s, int t)
            {
                _MultiTexCoord2iARB_fnptr = (delegate* unmanaged<TextureUnit, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2iARB");
                _MultiTexCoord2iARB_fnptr(target, s, t);
            }
            
            private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord2ivARB_fnptr = &MultiTexCoord2ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2ivARB(TextureUnit target, int* v) => _MultiTexCoord2ivARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2ivARB_Lazy(TextureUnit target, int* v)
            {
                _MultiTexCoord2ivARB_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2ivARB");
                _MultiTexCoord2ivARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, short, short, void> _MultiTexCoord2sARB_fnptr = &MultiTexCoord2sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2sARB(TextureUnit target, short s, short t) => _MultiTexCoord2sARB_fnptr(target, s, t);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2sARB_Lazy(TextureUnit target, short s, short t)
            {
                _MultiTexCoord2sARB_fnptr = (delegate* unmanaged<TextureUnit, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2sARB");
                _MultiTexCoord2sARB_fnptr(target, s, t);
            }
            
            private static delegate* unmanaged<TextureUnit, short*, void> _MultiTexCoord2svARB_fnptr = &MultiTexCoord2svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2svARB(TextureUnit target, short* v) => _MultiTexCoord2svARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2svARB_Lazy(TextureUnit target, short* v)
            {
                _MultiTexCoord2svARB_fnptr = (delegate* unmanaged<TextureUnit, short*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2svARB");
                _MultiTexCoord2svARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, double, double, double, void> _MultiTexCoord3dARB_fnptr = &MultiTexCoord3dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3dARB(TextureUnit target, double s, double t, double r) => _MultiTexCoord3dARB_fnptr(target, s, t, r);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3dARB_Lazy(TextureUnit target, double s, double t, double r)
            {
                _MultiTexCoord3dARB_fnptr = (delegate* unmanaged<TextureUnit, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3dARB");
                _MultiTexCoord3dARB_fnptr(target, s, t, r);
            }
            
            private static delegate* unmanaged<TextureUnit, double*, void> _MultiTexCoord3dvARB_fnptr = &MultiTexCoord3dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3dvARB(TextureUnit target, double* v) => _MultiTexCoord3dvARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3dvARB_Lazy(TextureUnit target, double* v)
            {
                _MultiTexCoord3dvARB_fnptr = (delegate* unmanaged<TextureUnit, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3dvARB");
                _MultiTexCoord3dvARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, float, float, float, void> _MultiTexCoord3fARB_fnptr = &MultiTexCoord3fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3fARB(TextureUnit target, float s, float t, float r) => _MultiTexCoord3fARB_fnptr(target, s, t, r);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3fARB_Lazy(TextureUnit target, float s, float t, float r)
            {
                _MultiTexCoord3fARB_fnptr = (delegate* unmanaged<TextureUnit, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3fARB");
                _MultiTexCoord3fARB_fnptr(target, s, t, r);
            }
            
            private static delegate* unmanaged<TextureUnit, float*, void> _MultiTexCoord3fvARB_fnptr = &MultiTexCoord3fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3fvARB(TextureUnit target, float* v) => _MultiTexCoord3fvARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3fvARB_Lazy(TextureUnit target, float* v)
            {
                _MultiTexCoord3fvARB_fnptr = (delegate* unmanaged<TextureUnit, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3fvARB");
                _MultiTexCoord3fvARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, int, int, int, void> _MultiTexCoord3iARB_fnptr = &MultiTexCoord3iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3iARB(TextureUnit target, int s, int t, int r) => _MultiTexCoord3iARB_fnptr(target, s, t, r);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3iARB_Lazy(TextureUnit target, int s, int t, int r)
            {
                _MultiTexCoord3iARB_fnptr = (delegate* unmanaged<TextureUnit, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3iARB");
                _MultiTexCoord3iARB_fnptr(target, s, t, r);
            }
            
            private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord3ivARB_fnptr = &MultiTexCoord3ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3ivARB(TextureUnit target, int* v) => _MultiTexCoord3ivARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3ivARB_Lazy(TextureUnit target, int* v)
            {
                _MultiTexCoord3ivARB_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3ivARB");
                _MultiTexCoord3ivARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, short, short, short, void> _MultiTexCoord3sARB_fnptr = &MultiTexCoord3sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3sARB(TextureUnit target, short s, short t, short r) => _MultiTexCoord3sARB_fnptr(target, s, t, r);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3sARB_Lazy(TextureUnit target, short s, short t, short r)
            {
                _MultiTexCoord3sARB_fnptr = (delegate* unmanaged<TextureUnit, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3sARB");
                _MultiTexCoord3sARB_fnptr(target, s, t, r);
            }
            
            private static delegate* unmanaged<TextureUnit, short*, void> _MultiTexCoord3svARB_fnptr = &MultiTexCoord3svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3svARB(TextureUnit target, short* v) => _MultiTexCoord3svARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3svARB_Lazy(TextureUnit target, short* v)
            {
                _MultiTexCoord3svARB_fnptr = (delegate* unmanaged<TextureUnit, short*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3svARB");
                _MultiTexCoord3svARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, double, double, double, double, void> _MultiTexCoord4dARB_fnptr = &MultiTexCoord4dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4dARB(TextureUnit target, double s, double t, double r, double q) => _MultiTexCoord4dARB_fnptr(target, s, t, r, q);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4dARB_Lazy(TextureUnit target, double s, double t, double r, double q)
            {
                _MultiTexCoord4dARB_fnptr = (delegate* unmanaged<TextureUnit, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4dARB");
                _MultiTexCoord4dARB_fnptr(target, s, t, r, q);
            }
            
            private static delegate* unmanaged<TextureUnit, double*, void> _MultiTexCoord4dvARB_fnptr = &MultiTexCoord4dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4dvARB(TextureUnit target, double* v) => _MultiTexCoord4dvARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4dvARB_Lazy(TextureUnit target, double* v)
            {
                _MultiTexCoord4dvARB_fnptr = (delegate* unmanaged<TextureUnit, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4dvARB");
                _MultiTexCoord4dvARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, float, float, float, float, void> _MultiTexCoord4fARB_fnptr = &MultiTexCoord4fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4fARB(TextureUnit target, float s, float t, float r, float q) => _MultiTexCoord4fARB_fnptr(target, s, t, r, q);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4fARB_Lazy(TextureUnit target, float s, float t, float r, float q)
            {
                _MultiTexCoord4fARB_fnptr = (delegate* unmanaged<TextureUnit, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4fARB");
                _MultiTexCoord4fARB_fnptr(target, s, t, r, q);
            }
            
            private static delegate* unmanaged<TextureUnit, float*, void> _MultiTexCoord4fvARB_fnptr = &MultiTexCoord4fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4fvARB(TextureUnit target, float* v) => _MultiTexCoord4fvARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4fvARB_Lazy(TextureUnit target, float* v)
            {
                _MultiTexCoord4fvARB_fnptr = (delegate* unmanaged<TextureUnit, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4fvARB");
                _MultiTexCoord4fvARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, int, int, int, int, void> _MultiTexCoord4iARB_fnptr = &MultiTexCoord4iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4iARB(TextureUnit target, int s, int t, int r, int q) => _MultiTexCoord4iARB_fnptr(target, s, t, r, q);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4iARB_Lazy(TextureUnit target, int s, int t, int r, int q)
            {
                _MultiTexCoord4iARB_fnptr = (delegate* unmanaged<TextureUnit, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4iARB");
                _MultiTexCoord4iARB_fnptr(target, s, t, r, q);
            }
            
            private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord4ivARB_fnptr = &MultiTexCoord4ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4ivARB(TextureUnit target, int* v) => _MultiTexCoord4ivARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4ivARB_Lazy(TextureUnit target, int* v)
            {
                _MultiTexCoord4ivARB_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4ivARB");
                _MultiTexCoord4ivARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, short, short, short, short, void> _MultiTexCoord4sARB_fnptr = &MultiTexCoord4sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4sARB(TextureUnit target, short s, short t, short r, short q) => _MultiTexCoord4sARB_fnptr(target, s, t, r, q);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4sARB_Lazy(TextureUnit target, short s, short t, short r, short q)
            {
                _MultiTexCoord4sARB_fnptr = (delegate* unmanaged<TextureUnit, short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4sARB");
                _MultiTexCoord4sARB_fnptr(target, s, t, r, q);
            }
            
            private static delegate* unmanaged<TextureUnit, short*, void> _MultiTexCoord4svARB_fnptr = &MultiTexCoord4svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4svARB(TextureUnit target, short* v) => _MultiTexCoord4svARB_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4svARB_Lazy(TextureUnit target, short* v)
            {
                _MultiTexCoord4svARB_fnptr = (delegate* unmanaged<TextureUnit, short*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4svARB");
                _MultiTexCoord4svARB_fnptr(target, v);
            }
            
            private static delegate* unmanaged<int, QueryHandle*, void> _GenQueriesARB_fnptr = &GenQueriesARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenQueriesARB(int n, QueryHandle* ids) => _GenQueriesARB_fnptr(n, ids);
            [UnmanagedCallersOnly]
            private static void GenQueriesARB_Lazy(int n, QueryHandle* ids)
            {
                _GenQueriesARB_fnptr = (delegate* unmanaged<int, QueryHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenQueriesARB");
                _GenQueriesARB_fnptr(n, ids);
            }
            
            private static delegate* unmanaged<int, QueryHandle*, void> _DeleteQueriesARB_fnptr = &DeleteQueriesARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteQueriesARB(int n, QueryHandle* ids) => _DeleteQueriesARB_fnptr(n, ids);
            [UnmanagedCallersOnly]
            private static void DeleteQueriesARB_Lazy(int n, QueryHandle* ids)
            {
                _DeleteQueriesARB_fnptr = (delegate* unmanaged<int, QueryHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteQueriesARB");
                _DeleteQueriesARB_fnptr(n, ids);
            }
            
            private static delegate* unmanaged<QueryHandle, byte> _IsQueryARB_fnptr = &IsQueryARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsQueryARB(QueryHandle id) => _IsQueryARB_fnptr(id);
            [UnmanagedCallersOnly]
            private static byte IsQueryARB_Lazy(QueryHandle id)
            {
                _IsQueryARB_fnptr = (delegate* unmanaged<QueryHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsQueryARB");
                return _IsQueryARB_fnptr(id);
            }
            
            private static delegate* unmanaged<QueryTarget, QueryHandle, void> _BeginQueryARB_fnptr = &BeginQueryARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginQueryARB(QueryTarget target, QueryHandle id) => _BeginQueryARB_fnptr(target, id);
            [UnmanagedCallersOnly]
            private static void BeginQueryARB_Lazy(QueryTarget target, QueryHandle id)
            {
                _BeginQueryARB_fnptr = (delegate* unmanaged<QueryTarget, QueryHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBeginQueryARB");
                _BeginQueryARB_fnptr(target, id);
            }
            
            private static delegate* unmanaged<QueryTarget, void> _EndQueryARB_fnptr = &EndQueryARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndQueryARB(QueryTarget target) => _EndQueryARB_fnptr(target);
            [UnmanagedCallersOnly]
            private static void EndQueryARB_Lazy(QueryTarget target)
            {
                _EndQueryARB_fnptr = (delegate* unmanaged<QueryTarget, void>)GLLoader.BindingsContext.GetProcAddress("glEndQueryARB");
                _EndQueryARB_fnptr(target);
            }
            
            private static delegate* unmanaged<QueryTarget, QueryParameterName, int*, void> _GetQueryivARB_fnptr = &GetQueryivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryivARB(QueryTarget target, QueryParameterName pname, int* parameters) => _GetQueryivARB_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetQueryivARB_Lazy(QueryTarget target, QueryParameterName pname, int* parameters)
            {
                _GetQueryivARB_fnptr = (delegate* unmanaged<QueryTarget, QueryParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryivARB");
                _GetQueryivARB_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, int*, void> _GetQueryObjectivARB_fnptr = &GetQueryObjectivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryObjectivARB(QueryHandle id, QueryObjectParameterName pname, int* parameters) => _GetQueryObjectivARB_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetQueryObjectivARB_Lazy(QueryHandle id, QueryObjectParameterName pname, int* parameters)
            {
                _GetQueryObjectivARB_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjectivARB");
                _GetQueryObjectivARB_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, uint*, void> _GetQueryObjectuivARB_fnptr = &GetQueryObjectuivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryObjectuivARB(QueryHandle id, QueryObjectParameterName pname, uint* parameters) => _GetQueryObjectuivARB_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetQueryObjectuivARB_Lazy(QueryHandle id, QueryObjectParameterName pname, uint* parameters)
            {
                _GetQueryObjectuivARB_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjectuivARB");
                _GetQueryObjectuivARB_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, void> _MaxShaderCompilerThreadsARB_fnptr = &MaxShaderCompilerThreadsARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_parallel_shader_compile]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MaxShaderCompilerThreadsARB(uint count) => _MaxShaderCompilerThreadsARB_fnptr(count);
            [UnmanagedCallersOnly]
            private static void MaxShaderCompilerThreadsARB_Lazy(uint count)
            {
                _MaxShaderCompilerThreadsARB_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glMaxShaderCompilerThreadsARB");
                _MaxShaderCompilerThreadsARB_fnptr(count);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, float, void> _PointParameterfARB_fnptr = &PointParameterfARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfARB(PointParameterNameARB pname, float param) => _PointParameterfARB_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PointParameterfARB_Lazy(PointParameterNameARB pname, float param)
            {
                _PointParameterfARB_fnptr = (delegate* unmanaged<PointParameterNameARB, float, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterfARB");
                _PointParameterfARB_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, float*, void> _PointParameterfvARB_fnptr = &PointParameterfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfvARB(PointParameterNameARB pname, float* parameters) => _PointParameterfvARB_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void PointParameterfvARB_Lazy(PointParameterNameARB pname, float* parameters)
            {
                _PointParameterfvARB_fnptr = (delegate* unmanaged<PointParameterNameARB, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterfvARB");
                _PointParameterfvARB_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<float, float, float, void> _PolygonOffsetClamp_fnptr = &PolygonOffsetClamp_Lazy;
            /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PolygonOffsetClamp(float factor, float units, float clamp) => _PolygonOffsetClamp_fnptr(factor, units, clamp);
            [UnmanagedCallersOnly]
            private static void PolygonOffsetClamp_Lazy(float factor, float units, float clamp)
            {
                _PolygonOffsetClamp_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glPolygonOffsetClamp");
                _PolygonOffsetClamp_fnptr(factor, units, clamp);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramInterface, ProgramInterfacePName, int*, void> _GetProgramInterfaceiv_fnptr = &GetProgramInterfaceiv_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query a property of an interface in a program. </summary>
            /// <param name="program"> The name of a program object whose interface to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program to query. </param>
            /// <param name="pname"> The name of the parameter within programInterface to query. </param>
            /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml" /></remarks>
            public static void GetProgramInterfaceiv(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => _GetProgramInterfaceiv_fnptr(program, programInterface, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramInterfaceiv_Lazy(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters)
            {
                _GetProgramInterfaceiv_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, ProgramInterfacePName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramInterfaceiv");
                _GetProgramInterfaceiv_fnptr(program, programInterface, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, uint> _GetProgramResourceIndex_fnptr = &GetProgramResourceIndex_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the index of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the index of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml" /></remarks>
            public static uint GetProgramResourceIndex(ProgramHandle program, ProgramInterface programInterface, byte* name) => _GetProgramResourceIndex_fnptr(program, programInterface, name);
            [UnmanagedCallersOnly]
            private static uint GetProgramResourceIndex_Lazy(ProgramHandle program, ProgramInterface programInterface, byte* name)
            {
                _GetProgramResourceIndex_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceIndex");
                return _GetProgramResourceIndex_fnptr(program, programInterface, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, int*, byte*, void> _GetProgramResourceName_fnptr = &GetProgramResourceName_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the name of an indexed resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
            /// <param name="index"> The index of the resource within programInterface of program. </param>
            /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
            /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
            /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml" /></remarks>
            public static void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => _GetProgramResourceName_fnptr(program, programInterface, index, bufSize, length, name);
            [UnmanagedCallersOnly]
            private static void GetProgramResourceName_Lazy(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
            {
                _GetProgramResourceName_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceName");
                _GetProgramResourceName_fnptr(program, programInterface, index, bufSize, length, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, ProgramResourceProperty*, int, int*, int*, void> _GetProgramResourceiv_fnptr = &GetProgramResourceiv_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Retrieve values for multiple properties of a single active resource within a program object. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="index">!!missing documentation!!</param>
            /// <param name="propCount">!!missing documentation!!</param>
            /// <param name="props">!!missing documentation!!</param>
            /// <param name="bufSize">!!missing documentation!!</param>
            /// <param name="length">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml" /></remarks>
            public static void GetProgramResourceiv(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => _GetProgramResourceiv_fnptr(program, programInterface, index, propCount, props, count, length, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramResourceiv_Lazy(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters)
            {
                _GetProgramResourceiv_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, ProgramResourceProperty*, int, int*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceiv");
                _GetProgramResourceiv_fnptr(program, programInterface, index, propCount, props, count, length, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, int> _GetProgramResourceLocation_fnptr = &GetProgramResourceLocation_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the location of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml" /></remarks>
            public static int GetProgramResourceLocation(ProgramHandle program, ProgramInterface programInterface, byte* name) => _GetProgramResourceLocation_fnptr(program, programInterface, name);
            [UnmanagedCallersOnly]
            private static int GetProgramResourceLocation_Lazy(ProgramHandle program, ProgramInterface programInterface, byte* name)
            {
                _GetProgramResourceLocation_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceLocation");
                return _GetProgramResourceLocation_fnptr(program, programInterface, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, int> _GetProgramResourceLocationIndex_fnptr = &GetProgramResourceLocationIndex_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the fragment color index of a named variable within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml" /></remarks>
            public static int GetProgramResourceLocationIndex(ProgramHandle program, ProgramInterface programInterface, byte* name) => _GetProgramResourceLocationIndex_fnptr(program, programInterface, name);
            [UnmanagedCallersOnly]
            private static int GetProgramResourceLocationIndex_Lazy(ProgramHandle program, ProgramInterface programInterface, byte* name)
            {
                _GetProgramResourceLocationIndex_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourceLocationIndex");
                return _GetProgramResourceLocationIndex_fnptr(program, programInterface, name);
            }
            
            private static delegate* unmanaged<VertexProvokingMode, void> _ProvokingVertex_fnptr = &ProvokingVertex_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex]</b> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
            /// <param name="provokeMode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml" /></remarks>
            public static void ProvokingVertex(VertexProvokingMode mode) => _ProvokingVertex_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void ProvokingVertex_Lazy(VertexProvokingMode mode)
            {
                _ProvokingVertex_fnptr = (delegate* unmanaged<VertexProvokingMode, void>)GLLoader.BindingsContext.GetProcAddress("glProvokingVertex");
                _ProvokingVertex_fnptr(mode);
            }
            
            private static delegate* unmanaged<GraphicsResetStatus> _GetGraphicsResetStatusARB_fnptr = &GetGraphicsResetStatusARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatusARB() => _GetGraphicsResetStatusARB_fnptr();
            [UnmanagedCallersOnly]
            private static GraphicsResetStatus GetGraphicsResetStatusARB_Lazy()
            {
                _GetGraphicsResetStatusARB_fnptr = (delegate* unmanaged<GraphicsResetStatus>)GLLoader.BindingsContext.GetProcAddress("glGetGraphicsResetStatusARB");
                return _GetGraphicsResetStatusARB_fnptr();
            }
            
            private static delegate* unmanaged<TextureTarget, int, PixelFormat, PixelType, int, void*, void> _GetnTexImageARB_fnptr = &GetnTexImageARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnTexImageARB(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* img) => _GetnTexImageARB_fnptr(target, level, format, type, bufSize, img);
            [UnmanagedCallersOnly]
            private static void GetnTexImageARB_Lazy(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* img)
            {
                _GetnTexImageARB_fnptr = (delegate* unmanaged<TextureTarget, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnTexImageARB");
                _GetnTexImageARB_fnptr(target, level, format, type, bufSize, img);
            }
            
            private static delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, int, void*, void> _ReadnPixelsARB_fnptr = &ReadnPixelsARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReadnPixelsARB(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => _ReadnPixelsARB_fnptr(x, y, width, height, format, type, bufSize, data);
            [UnmanagedCallersOnly]
            private static void ReadnPixelsARB_Lazy(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data)
            {
                _ReadnPixelsARB_fnptr = (delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glReadnPixelsARB");
                _ReadnPixelsARB_fnptr(x, y, width, height, format, type, bufSize, data);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, void*, void> _GetnCompressedTexImageARB_fnptr = &GetnCompressedTexImageARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnCompressedTexImageARB(TextureTarget target, int lod, int bufSize, void* img) => _GetnCompressedTexImageARB_fnptr(target, lod, bufSize, img);
            [UnmanagedCallersOnly]
            private static void GetnCompressedTexImageARB_Lazy(TextureTarget target, int lod, int bufSize, void* img)
            {
                _GetnCompressedTexImageARB_fnptr = (delegate* unmanaged<TextureTarget, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnCompressedTexImageARB");
                _GetnCompressedTexImageARB_fnptr(target, lod, bufSize, img);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _GetnUniformfvARB_fnptr = &GetnUniformfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformfvARB(ProgramHandle program, int location, int bufSize, float* parameters) => _GetnUniformfvARB_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformfvARB_Lazy(ProgramHandle program, int location, int bufSize, float* parameters)
            {
                _GetnUniformfvARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformfvARB");
                _GetnUniformfvARB_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _GetnUniformivARB_fnptr = &GetnUniformivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformivARB(ProgramHandle program, int location, int bufSize, int* parameters) => _GetnUniformivARB_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformivARB_Lazy(ProgramHandle program, int location, int bufSize, int* parameters)
            {
                _GetnUniformivARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformivARB");
                _GetnUniformivARB_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _GetnUniformuivARB_fnptr = &GetnUniformuivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformuivARB(ProgramHandle program, int location, int bufSize, uint* parameters) => _GetnUniformuivARB_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformuivARB_Lazy(ProgramHandle program, int location, int bufSize, uint* parameters)
            {
                _GetnUniformuivARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformuivARB");
                _GetnUniformuivARB_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _GetnUniformdvARB_fnptr = &GetnUniformdvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformdvARB(ProgramHandle program, int location, int bufSize, double* parameters) => _GetnUniformdvARB_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformdvARB_Lazy(ProgramHandle program, int location, int bufSize, double* parameters)
            {
                _GetnUniformdvARB_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformdvARB");
                _GetnUniformdvARB_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<MapTarget, MapQuery, int, double*, void> _GetnMapdvARB_fnptr = &GetnMapdvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnMapdvARB(MapTarget target, MapQuery query, int bufSize, double* v) => _GetnMapdvARB_fnptr(target, query, bufSize, v);
            [UnmanagedCallersOnly]
            private static void GetnMapdvARB_Lazy(MapTarget target, MapQuery query, int bufSize, double* v)
            {
                _GetnMapdvARB_fnptr = (delegate* unmanaged<MapTarget, MapQuery, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnMapdvARB");
                _GetnMapdvARB_fnptr(target, query, bufSize, v);
            }
            
            private static delegate* unmanaged<MapTarget, MapQuery, int, float*, void> _GetnMapfvARB_fnptr = &GetnMapfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnMapfvARB(MapTarget target, MapQuery query, int bufSize, float* v) => _GetnMapfvARB_fnptr(target, query, bufSize, v);
            [UnmanagedCallersOnly]
            private static void GetnMapfvARB_Lazy(MapTarget target, MapQuery query, int bufSize, float* v)
            {
                _GetnMapfvARB_fnptr = (delegate* unmanaged<MapTarget, MapQuery, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnMapfvARB");
                _GetnMapfvARB_fnptr(target, query, bufSize, v);
            }
            
            private static delegate* unmanaged<MapTarget, MapQuery, int, int*, void> _GetnMapivARB_fnptr = &GetnMapivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnMapivARB(MapTarget target, MapQuery query, int bufSize, int* v) => _GetnMapivARB_fnptr(target, query, bufSize, v);
            [UnmanagedCallersOnly]
            private static void GetnMapivARB_Lazy(MapTarget target, MapQuery query, int bufSize, int* v)
            {
                _GetnMapivARB_fnptr = (delegate* unmanaged<MapTarget, MapQuery, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnMapivARB");
                _GetnMapivARB_fnptr(target, query, bufSize, v);
            }
            
            private static delegate* unmanaged<PixelMap, int, float*, void> _GetnPixelMapfvARB_fnptr = &GetnPixelMapfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnPixelMapfvARB(PixelMap map, int bufSize, float* values) => _GetnPixelMapfvARB_fnptr(map, bufSize, values);
            [UnmanagedCallersOnly]
            private static void GetnPixelMapfvARB_Lazy(PixelMap map, int bufSize, float* values)
            {
                _GetnPixelMapfvARB_fnptr = (delegate* unmanaged<PixelMap, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnPixelMapfvARB");
                _GetnPixelMapfvARB_fnptr(map, bufSize, values);
            }
            
            private static delegate* unmanaged<PixelMap, int, uint*, void> _GetnPixelMapuivARB_fnptr = &GetnPixelMapuivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnPixelMapuivARB(PixelMap map, int bufSize, uint* values) => _GetnPixelMapuivARB_fnptr(map, bufSize, values);
            [UnmanagedCallersOnly]
            private static void GetnPixelMapuivARB_Lazy(PixelMap map, int bufSize, uint* values)
            {
                _GetnPixelMapuivARB_fnptr = (delegate* unmanaged<PixelMap, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnPixelMapuivARB");
                _GetnPixelMapuivARB_fnptr(map, bufSize, values);
            }
            
            private static delegate* unmanaged<PixelMap, int, ushort*, void> _GetnPixelMapusvARB_fnptr = &GetnPixelMapusvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnPixelMapusvARB(PixelMap map, int bufSize, ushort* values) => _GetnPixelMapusvARB_fnptr(map, bufSize, values);
            [UnmanagedCallersOnly]
            private static void GetnPixelMapusvARB_Lazy(PixelMap map, int bufSize, ushort* values)
            {
                _GetnPixelMapusvARB_fnptr = (delegate* unmanaged<PixelMap, int, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnPixelMapusvARB");
                _GetnPixelMapusvARB_fnptr(map, bufSize, values);
            }
            
            private static delegate* unmanaged<int, byte*, void> _GetnPolygonStippleARB_fnptr = &GetnPolygonStippleARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnPolygonStippleARB(int bufSize, byte* pattern) => _GetnPolygonStippleARB_fnptr(bufSize, pattern);
            [UnmanagedCallersOnly]
            private static void GetnPolygonStippleARB_Lazy(int bufSize, byte* pattern)
            {
                _GetnPolygonStippleARB_fnptr = (delegate* unmanaged<int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnPolygonStippleARB");
                _GetnPolygonStippleARB_fnptr(bufSize, pattern);
            }
            
            private static delegate* unmanaged<ColorTableTarget, PixelFormat, PixelType, int, void*, void> _GetnColorTableARB_fnptr = &GetnColorTableARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnColorTableARB(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, void* table) => _GetnColorTableARB_fnptr(target, format, type, bufSize, table);
            [UnmanagedCallersOnly]
            private static void GetnColorTableARB_Lazy(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, void* table)
            {
                _GetnColorTableARB_fnptr = (delegate* unmanaged<ColorTableTarget, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnColorTableARB");
                _GetnColorTableARB_fnptr(target, format, type, bufSize, table);
            }
            
            private static delegate* unmanaged<ConvolutionTarget, PixelFormat, PixelType, int, void*, void> _GetnConvolutionFilterARB_fnptr = &GetnConvolutionFilterARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnConvolutionFilterARB(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, void* image) => _GetnConvolutionFilterARB_fnptr(target, format, type, bufSize, image);
            [UnmanagedCallersOnly]
            private static void GetnConvolutionFilterARB_Lazy(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, void* image)
            {
                _GetnConvolutionFilterARB_fnptr = (delegate* unmanaged<ConvolutionTarget, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnConvolutionFilterARB");
                _GetnConvolutionFilterARB_fnptr(target, format, type, bufSize, image);
            }
            
            private static delegate* unmanaged<SeparableTargetEXT, PixelFormat, PixelType, int, void*, int, void*, void*, void> _GetnSeparableFilterARB_fnptr = &GetnSeparableFilterARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnSeparableFilterARB(SeparableTargetEXT target, PixelFormat format, PixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span) => _GetnSeparableFilterARB_fnptr(target, format, type, rowBufSize, row, columnBufSize, column, span);
            [UnmanagedCallersOnly]
            private static void GetnSeparableFilterARB_Lazy(SeparableTargetEXT target, PixelFormat format, PixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span)
            {
                _GetnSeparableFilterARB_fnptr = (delegate* unmanaged<SeparableTargetEXT, PixelFormat, PixelType, int, void*, int, void*, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnSeparableFilterARB");
                _GetnSeparableFilterARB_fnptr(target, format, type, rowBufSize, row, columnBufSize, column, span);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, byte, PixelFormat, PixelType, int, void*, void> _GetnHistogramARB_fnptr = &GetnHistogramARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnHistogramARB(HistogramTargetEXT target, byte reset, PixelFormat format, PixelType type, int bufSize, void* values) => _GetnHistogramARB_fnptr(target, reset, format, type, bufSize, values);
            [UnmanagedCallersOnly]
            private static void GetnHistogramARB_Lazy(HistogramTargetEXT target, byte reset, PixelFormat format, PixelType type, int bufSize, void* values)
            {
                _GetnHistogramARB_fnptr = (delegate* unmanaged<HistogramTargetEXT, byte, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnHistogramARB");
                _GetnHistogramARB_fnptr(target, reset, format, type, bufSize, values);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, byte, PixelFormat, PixelType, int, void*, void> _GetnMinmaxARB_fnptr = &GetnMinmaxARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnMinmaxARB(MinmaxTargetEXT target, byte reset, PixelFormat format, PixelType type, int bufSize, void* values) => _GetnMinmaxARB_fnptr(target, reset, format, type, bufSize, values);
            [UnmanagedCallersOnly]
            private static void GetnMinmaxARB_Lazy(MinmaxTargetEXT target, byte reset, PixelFormat format, PixelType type, int bufSize, void* values)
            {
                _GetnMinmaxARB_fnptr = (delegate* unmanaged<MinmaxTargetEXT, byte, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnMinmaxARB");
                _GetnMinmaxARB_fnptr(target, reset, format, type, bufSize, values);
            }
            
            private static delegate* unmanaged<FramebufferTarget, uint, int, float*, void> _FramebufferSampleLocationsfvARB_fnptr = &FramebufferSampleLocationsfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferSampleLocationsfvARB(FramebufferTarget target, uint start, int count, float* v) => _FramebufferSampleLocationsfvARB_fnptr(target, start, count, v);
            [UnmanagedCallersOnly]
            private static void FramebufferSampleLocationsfvARB_Lazy(FramebufferTarget target, uint start, int count, float* v)
            {
                _FramebufferSampleLocationsfvARB_fnptr = (delegate* unmanaged<FramebufferTarget, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferSampleLocationsfvARB");
                _FramebufferSampleLocationsfvARB_fnptr(target, start, count, v);
            }
            
            private static delegate* unmanaged<FramebufferHandle, uint, int, float*, void> _NamedFramebufferSampleLocationsfvARB_fnptr = &NamedFramebufferSampleLocationsfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferSampleLocationsfvARB(FramebufferHandle framebuffer, uint start, int count, float* v) => _NamedFramebufferSampleLocationsfvARB_fnptr(framebuffer, start, count, v);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferSampleLocationsfvARB_Lazy(FramebufferHandle framebuffer, uint start, int count, float* v)
            {
                _NamedFramebufferSampleLocationsfvARB_fnptr = (delegate* unmanaged<FramebufferHandle, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferSampleLocationsfvARB");
                _NamedFramebufferSampleLocationsfvARB_fnptr(framebuffer, start, count, v);
            }
            
            private static delegate* unmanaged<void> _EvaluateDepthValuesARB_fnptr = &EvaluateDepthValuesARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvaluateDepthValuesARB() => _EvaluateDepthValuesARB_fnptr();
            [UnmanagedCallersOnly]
            private static void EvaluateDepthValuesARB_Lazy()
            {
                _EvaluateDepthValuesARB_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEvaluateDepthValuesARB");
                _EvaluateDepthValuesARB_fnptr();
            }
            
            private static delegate* unmanaged<float, void> _MinSampleShadingARB_fnptr = &MinSampleShadingARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_sample_shading]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MinSampleShadingARB(float value) => _MinSampleShadingARB_fnptr(value);
            [UnmanagedCallersOnly]
            private static void MinSampleShadingARB_Lazy(float value)
            {
                _MinSampleShadingARB_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glMinSampleShadingARB");
                _MinSampleShadingARB_fnptr(value);
            }
            
            private static delegate* unmanaged<int, SamplerHandle*, void> _GenSamplers_fnptr = &GenSamplers_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Generate sampler object names. </summary>
            /// <param name="n"> Specifies the number of sampler object names to generate. </param>
            /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml" /></remarks>
            public static void GenSamplers(int count, SamplerHandle* samplers) => _GenSamplers_fnptr(count, samplers);
            [UnmanagedCallersOnly]
            private static void GenSamplers_Lazy(int count, SamplerHandle* samplers)
            {
                _GenSamplers_fnptr = (delegate* unmanaged<int, SamplerHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenSamplers");
                _GenSamplers_fnptr(count, samplers);
            }
            
            private static delegate* unmanaged<int, SamplerHandle*, void> _DeleteSamplers_fnptr = &DeleteSamplers_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Delete named sampler objects. </summary>
            /// <param name="n"> Specifies the number of sampler objects to be deleted. </param>
            /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml" /></remarks>
            public static void DeleteSamplers(int count, SamplerHandle* samplers) => _DeleteSamplers_fnptr(count, samplers);
            [UnmanagedCallersOnly]
            private static void DeleteSamplers_Lazy(int count, SamplerHandle* samplers)
            {
                _DeleteSamplers_fnptr = (delegate* unmanaged<int, SamplerHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteSamplers");
                _DeleteSamplers_fnptr(count, samplers);
            }
            
            private static delegate* unmanaged<SamplerHandle, byte> _IsSampler_fnptr = &IsSampler_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Determine if a name corresponds to a sampler object. </summary>
            /// <param name="id"> Specifies a value that may be the name of a sampler object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml" /></remarks>
            public static byte IsSampler(SamplerHandle sampler) => _IsSampler_fnptr(sampler);
            [UnmanagedCallersOnly]
            private static byte IsSampler_Lazy(SamplerHandle sampler)
            {
                _IsSampler_fnptr = (delegate* unmanaged<SamplerHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsSampler");
                return _IsSampler_fnptr(sampler);
            }
            
            private static delegate* unmanaged<uint, SamplerHandle, void> _BindSampler_fnptr = &BindSampler_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Bind a named sampler to a texturing target. </summary>
            /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
            /// <param name="sampler"> Specifies the name of a sampler. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml" /></remarks>
            public static void BindSampler(uint unit, SamplerHandle sampler) => _BindSampler_fnptr(unit, sampler);
            [UnmanagedCallersOnly]
            private static void BindSampler_Lazy(uint unit, SamplerHandle sampler)
            {
                _BindSampler_fnptr = (delegate* unmanaged<uint, SamplerHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindSampler");
                _BindSampler_fnptr(unit, sampler);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int, void> _SamplerParameteri_fnptr = &SamplerParameteri_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, int param) => _SamplerParameteri_fnptr(sampler, pname, param);
            [UnmanagedCallersOnly]
            private static void SamplerParameteri_Lazy(SamplerHandle sampler, SamplerParameterI pname, int param)
            {
                _SamplerParameteri_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameteri");
                _SamplerParameteri_fnptr(sampler, pname, param);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void> _SamplerParameteriv_fnptr = &SamplerParameteriv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameteriv(SamplerHandle sampler, SamplerParameterI pname, int* param) => _SamplerParameteriv_fnptr(sampler, pname, param);
            [UnmanagedCallersOnly]
            private static void SamplerParameteriv_Lazy(SamplerHandle sampler, SamplerParameterI pname, int* param)
            {
                _SamplerParameteriv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameteriv");
                _SamplerParameteriv_fnptr(sampler, pname, param);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterF, float, void> _SamplerParameterf_fnptr = &SamplerParameterf_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, float param) => _SamplerParameterf_fnptr(sampler, pname, param);
            [UnmanagedCallersOnly]
            private static void SamplerParameterf_Lazy(SamplerHandle sampler, SamplerParameterF pname, float param)
            {
                _SamplerParameterf_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterF, float, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameterf");
                _SamplerParameterf_fnptr(sampler, pname, param);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterF, float*, void> _SamplerParameterfv_fnptr = &SamplerParameterfv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterfv(SamplerHandle sampler, SamplerParameterF pname, float* param) => _SamplerParameterfv_fnptr(sampler, pname, param);
            [UnmanagedCallersOnly]
            private static void SamplerParameterfv_Lazy(SamplerHandle sampler, SamplerParameterF pname, float* param)
            {
                _SamplerParameterfv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterF, float*, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameterfv");
                _SamplerParameterfv_fnptr(sampler, pname, param);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void> _SamplerParameterIiv_fnptr = &SamplerParameterIiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterIiv(SamplerHandle sampler, SamplerParameterI pname, int* param) => _SamplerParameterIiv_fnptr(sampler, pname, param);
            [UnmanagedCallersOnly]
            private static void SamplerParameterIiv_Lazy(SamplerHandle sampler, SamplerParameterI pname, int* param)
            {
                _SamplerParameterIiv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameterIiv");
                _SamplerParameterIiv_fnptr(sampler, pname, param);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterI, uint*, void> _SamplerParameterIuiv_fnptr = &SamplerParameterIuiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterIuiv(SamplerHandle sampler, SamplerParameterI pname, uint* param) => _SamplerParameterIuiv_fnptr(sampler, pname, param);
            [UnmanagedCallersOnly]
            private static void SamplerParameterIuiv_Lazy(SamplerHandle sampler, SamplerParameterI pname, uint* param)
            {
                _SamplerParameterIuiv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSamplerParameterIuiv");
                _SamplerParameterIuiv_fnptr(sampler, pname, param);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void> _GetSamplerParameteriv_fnptr = &GetSamplerParameteriv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameteriv(SamplerHandle sampler, SamplerParameterI pname, int* parameters) => _GetSamplerParameteriv_fnptr(sampler, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetSamplerParameteriv_Lazy(SamplerHandle sampler, SamplerParameterI pname, int* parameters)
            {
                _GetSamplerParameteriv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSamplerParameteriv");
                _GetSamplerParameteriv_fnptr(sampler, pname, parameters);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void> _GetSamplerParameterIiv_fnptr = &GetSamplerParameterIiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterIiv(SamplerHandle sampler, SamplerParameterI pname, int* parameters) => _GetSamplerParameterIiv_fnptr(sampler, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetSamplerParameterIiv_Lazy(SamplerHandle sampler, SamplerParameterI pname, int* parameters)
            {
                _GetSamplerParameterIiv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSamplerParameterIiv");
                _GetSamplerParameterIiv_fnptr(sampler, pname, parameters);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterF, float*, void> _GetSamplerParameterfv_fnptr = &GetSamplerParameterfv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterfv(SamplerHandle sampler, SamplerParameterF pname, float* parameters) => _GetSamplerParameterfv_fnptr(sampler, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetSamplerParameterfv_Lazy(SamplerHandle sampler, SamplerParameterF pname, float* parameters)
            {
                _GetSamplerParameterfv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterF, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSamplerParameterfv");
                _GetSamplerParameterfv_fnptr(sampler, pname, parameters);
            }
            
            private static delegate* unmanaged<SamplerHandle, SamplerParameterI, uint*, void> _GetSamplerParameterIuiv_fnptr = &GetSamplerParameterIuiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterIuiv(SamplerHandle sampler, SamplerParameterI pname, uint* parameters) => _GetSamplerParameterIuiv_fnptr(sampler, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetSamplerParameterIuiv_Lazy(SamplerHandle sampler, SamplerParameterI pname, uint* parameters)
            {
                _GetSamplerParameterIuiv_fnptr = (delegate* unmanaged<SamplerHandle, SamplerParameterI, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSamplerParameterIuiv");
                _GetSamplerParameterIuiv_fnptr(sampler, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, UseProgramStageMask, ProgramHandle, void> _UseProgramStages_fnptr = &UseProgramStages_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Bind stages of a program object to a program pipeline. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
            /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
            /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml" /></remarks>
            public static void UseProgramStages(ProgramPipelineHandle pipeline, UseProgramStageMask stages, ProgramHandle program) => _UseProgramStages_fnptr(pipeline, stages, program);
            [UnmanagedCallersOnly]
            private static void UseProgramStages_Lazy(ProgramPipelineHandle pipeline, UseProgramStageMask stages, ProgramHandle program)
            {
                _UseProgramStages_fnptr = (delegate* unmanaged<ProgramPipelineHandle, UseProgramStageMask, ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glUseProgramStages");
                _UseProgramStages_fnptr(pipeline, stages, program);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, ProgramHandle, void> _ActiveShaderProgram_fnptr = &ActiveShaderProgram_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Set the active program object for a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
            /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml" /></remarks>
            public static void ActiveShaderProgram(ProgramPipelineHandle pipeline, ProgramHandle program) => _ActiveShaderProgram_fnptr(pipeline, program);
            [UnmanagedCallersOnly]
            private static void ActiveShaderProgram_Lazy(ProgramPipelineHandle pipeline, ProgramHandle program)
            {
                _ActiveShaderProgram_fnptr = (delegate* unmanaged<ProgramPipelineHandle, ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glActiveShaderProgram");
                _ActiveShaderProgram_fnptr(pipeline, program);
            }
            
            private static delegate* unmanaged<ShaderType, int, byte**, int> _CreateShaderProgramv_fnptr = &CreateShaderProgramv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Create a stand-alone program from an array of null-terminated source code strings. </summary>
            /// <param name="type"> Specifies the type of shader to create. </param>
            /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
            /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml" /></remarks>
            public static ProgramHandle CreateShaderProgramv(ShaderType type, int count, byte** strings) => (ProgramHandle) _CreateShaderProgramv_fnptr(type, count, strings);
            [UnmanagedCallersOnly]
            private static int CreateShaderProgramv_Lazy(ShaderType type, int count, byte** strings)
            {
                _CreateShaderProgramv_fnptr = (delegate* unmanaged<ShaderType, int, byte**, int>)GLLoader.BindingsContext.GetProcAddress("glCreateShaderProgramv");
                return _CreateShaderProgramv_fnptr(type, count, strings);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, void> _BindProgramPipeline_fnptr = &BindProgramPipeline_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Bind a program pipeline to the current context. </summary>
            /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml" /></remarks>
            public static void BindProgramPipeline(ProgramPipelineHandle pipeline) => _BindProgramPipeline_fnptr(pipeline);
            [UnmanagedCallersOnly]
            private static void BindProgramPipeline_Lazy(ProgramPipelineHandle pipeline)
            {
                _BindProgramPipeline_fnptr = (delegate* unmanaged<ProgramPipelineHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindProgramPipeline");
                _BindProgramPipeline_fnptr(pipeline);
            }
            
            private static delegate* unmanaged<int, ProgramPipelineHandle*, void> _DeleteProgramPipelines_fnptr = &DeleteProgramPipelines_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Delete program pipeline objects. </summary>
            /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
            /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml" /></remarks>
            public static void DeleteProgramPipelines(int n, ProgramPipelineHandle* pipelines) => _DeleteProgramPipelines_fnptr(n, pipelines);
            [UnmanagedCallersOnly]
            private static void DeleteProgramPipelines_Lazy(int n, ProgramPipelineHandle* pipelines)
            {
                _DeleteProgramPipelines_fnptr = (delegate* unmanaged<int, ProgramPipelineHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteProgramPipelines");
                _DeleteProgramPipelines_fnptr(n, pipelines);
            }
            
            private static delegate* unmanaged<int, ProgramPipelineHandle*, void> _GenProgramPipelines_fnptr = &GenProgramPipelines_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Reserve program pipeline object names. </summary>
            /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
            /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml" /></remarks>
            public static void GenProgramPipelines(int n, ProgramPipelineHandle* pipelines) => _GenProgramPipelines_fnptr(n, pipelines);
            [UnmanagedCallersOnly]
            private static void GenProgramPipelines_Lazy(int n, ProgramPipelineHandle* pipelines)
            {
                _GenProgramPipelines_fnptr = (delegate* unmanaged<int, ProgramPipelineHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenProgramPipelines");
                _GenProgramPipelines_fnptr(n, pipelines);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, byte> _IsProgramPipeline_fnptr = &IsProgramPipeline_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Determine if a name corresponds to a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml" /></remarks>
            public static byte IsProgramPipeline(ProgramPipelineHandle pipeline) => _IsProgramPipeline_fnptr(pipeline);
            [UnmanagedCallersOnly]
            private static byte IsProgramPipeline_Lazy(ProgramPipelineHandle pipeline)
            {
                _IsProgramPipeline_fnptr = (delegate* unmanaged<ProgramPipelineHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsProgramPipeline");
                return _IsProgramPipeline_fnptr(pipeline);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, PipelineParameterName, int*, void> _GetProgramPipelineiv_fnptr = &GetProgramPipelineiv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Retrieve properties of a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
            /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml" /></remarks>
            public static void GetProgramPipelineiv(ProgramPipelineHandle pipeline, PipelineParameterName pname, int* parameters) => _GetProgramPipelineiv_fnptr(pipeline, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramPipelineiv_Lazy(ProgramPipelineHandle pipeline, PipelineParameterName pname, int* parameters)
            {
                _GetProgramPipelineiv_fnptr = (delegate* unmanaged<ProgramPipelineHandle, PipelineParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramPipelineiv");
                _GetProgramPipelineiv_fnptr(pipeline, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, void> _ProgramUniform1i_fnptr = &ProgramUniform1i_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1i(ProgramHandle program, int location, int v0) => _ProgramUniform1i_fnptr(program, location, v0);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1i_Lazy(ProgramHandle program, int location, int v0)
            {
                _ProgramUniform1i_fnptr = (delegate* unmanaged<ProgramHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1i");
                _ProgramUniform1i_fnptr(program, location, v0);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform1iv_fnptr = &ProgramUniform1iv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1iv(ProgramHandle program, int location, int count, int* value) => _ProgramUniform1iv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1iv_Lazy(ProgramHandle program, int location, int count, int* value)
            {
                _ProgramUniform1iv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1iv");
                _ProgramUniform1iv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, float, void> _ProgramUniform1f_fnptr = &ProgramUniform1f_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1f(ProgramHandle program, int location, float v0) => _ProgramUniform1f_fnptr(program, location, v0);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1f_Lazy(ProgramHandle program, int location, float v0)
            {
                _ProgramUniform1f_fnptr = (delegate* unmanaged<ProgramHandle, int, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1f");
                _ProgramUniform1f_fnptr(program, location, v0);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform1fv_fnptr = &ProgramUniform1fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1fv(ProgramHandle program, int location, int count, float* value) => _ProgramUniform1fv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1fv_Lazy(ProgramHandle program, int location, int count, float* value)
            {
                _ProgramUniform1fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1fv");
                _ProgramUniform1fv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, double, void> _ProgramUniform1d_fnptr = &ProgramUniform1d_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1d(ProgramHandle program, int location, double v0) => _ProgramUniform1d_fnptr(program, location, v0);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1d_Lazy(ProgramHandle program, int location, double v0)
            {
                _ProgramUniform1d_fnptr = (delegate* unmanaged<ProgramHandle, int, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1d");
                _ProgramUniform1d_fnptr(program, location, v0);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform1dv_fnptr = &ProgramUniform1dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1dv(ProgramHandle program, int location, int count, double* value) => _ProgramUniform1dv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1dv_Lazy(ProgramHandle program, int location, int count, double* value)
            {
                _ProgramUniform1dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1dv");
                _ProgramUniform1dv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint, void> _ProgramUniform1ui_fnptr = &ProgramUniform1ui_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1ui(ProgramHandle program, int location, uint v0) => _ProgramUniform1ui_fnptr(program, location, v0);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1ui_Lazy(ProgramHandle program, int location, uint v0)
            {
                _ProgramUniform1ui_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1ui");
                _ProgramUniform1ui_fnptr(program, location, v0);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform1uiv_fnptr = &ProgramUniform1uiv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1uiv(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform1uiv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1uiv_Lazy(ProgramHandle program, int location, int count, uint* value)
            {
                _ProgramUniform1uiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1uiv");
                _ProgramUniform1uiv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int, void> _ProgramUniform2i_fnptr = &ProgramUniform2i_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2i(ProgramHandle program, int location, int v0, int v1) => _ProgramUniform2i_fnptr(program, location, v0, v1);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2i_Lazy(ProgramHandle program, int location, int v0, int v1)
            {
                _ProgramUniform2i_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2i");
                _ProgramUniform2i_fnptr(program, location, v0, v1);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform2iv_fnptr = &ProgramUniform2iv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2iv(ProgramHandle program, int location, int count, int* value) => _ProgramUniform2iv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2iv_Lazy(ProgramHandle program, int location, int count, int* value)
            {
                _ProgramUniform2iv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2iv");
                _ProgramUniform2iv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, float, float, void> _ProgramUniform2f_fnptr = &ProgramUniform2f_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2f(ProgramHandle program, int location, float v0, float v1) => _ProgramUniform2f_fnptr(program, location, v0, v1);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2f_Lazy(ProgramHandle program, int location, float v0, float v1)
            {
                _ProgramUniform2f_fnptr = (delegate* unmanaged<ProgramHandle, int, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2f");
                _ProgramUniform2f_fnptr(program, location, v0, v1);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform2fv_fnptr = &ProgramUniform2fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2fv(ProgramHandle program, int location, int count, float* value) => _ProgramUniform2fv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2fv_Lazy(ProgramHandle program, int location, int count, float* value)
            {
                _ProgramUniform2fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2fv");
                _ProgramUniform2fv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, double, double, void> _ProgramUniform2d_fnptr = &ProgramUniform2d_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2d(ProgramHandle program, int location, double v0, double v1) => _ProgramUniform2d_fnptr(program, location, v0, v1);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2d_Lazy(ProgramHandle program, int location, double v0, double v1)
            {
                _ProgramUniform2d_fnptr = (delegate* unmanaged<ProgramHandle, int, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2d");
                _ProgramUniform2d_fnptr(program, location, v0, v1);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform2dv_fnptr = &ProgramUniform2dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2dv(ProgramHandle program, int location, int count, double* value) => _ProgramUniform2dv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2dv_Lazy(ProgramHandle program, int location, int count, double* value)
            {
                _ProgramUniform2dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2dv");
                _ProgramUniform2dv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint, uint, void> _ProgramUniform2ui_fnptr = &ProgramUniform2ui_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2ui(ProgramHandle program, int location, uint v0, uint v1) => _ProgramUniform2ui_fnptr(program, location, v0, v1);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2ui_Lazy(ProgramHandle program, int location, uint v0, uint v1)
            {
                _ProgramUniform2ui_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2ui");
                _ProgramUniform2ui_fnptr(program, location, v0, v1);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform2uiv_fnptr = &ProgramUniform2uiv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2uiv(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform2uiv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2uiv_Lazy(ProgramHandle program, int location, int count, uint* value)
            {
                _ProgramUniform2uiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2uiv");
                _ProgramUniform2uiv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int, int, void> _ProgramUniform3i_fnptr = &ProgramUniform3i_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3i(ProgramHandle program, int location, int v0, int v1, int v2) => _ProgramUniform3i_fnptr(program, location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3i_Lazy(ProgramHandle program, int location, int v0, int v1, int v2)
            {
                _ProgramUniform3i_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3i");
                _ProgramUniform3i_fnptr(program, location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform3iv_fnptr = &ProgramUniform3iv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3iv(ProgramHandle program, int location, int count, int* value) => _ProgramUniform3iv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3iv_Lazy(ProgramHandle program, int location, int count, int* value)
            {
                _ProgramUniform3iv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3iv");
                _ProgramUniform3iv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, float, float, float, void> _ProgramUniform3f_fnptr = &ProgramUniform3f_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3f(ProgramHandle program, int location, float v0, float v1, float v2) => _ProgramUniform3f_fnptr(program, location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3f_Lazy(ProgramHandle program, int location, float v0, float v1, float v2)
            {
                _ProgramUniform3f_fnptr = (delegate* unmanaged<ProgramHandle, int, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3f");
                _ProgramUniform3f_fnptr(program, location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform3fv_fnptr = &ProgramUniform3fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3fv(ProgramHandle program, int location, int count, float* value) => _ProgramUniform3fv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3fv_Lazy(ProgramHandle program, int location, int count, float* value)
            {
                _ProgramUniform3fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3fv");
                _ProgramUniform3fv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, double, double, double, void> _ProgramUniform3d_fnptr = &ProgramUniform3d_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3d(ProgramHandle program, int location, double v0, double v1, double v2) => _ProgramUniform3d_fnptr(program, location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3d_Lazy(ProgramHandle program, int location, double v0, double v1, double v2)
            {
                _ProgramUniform3d_fnptr = (delegate* unmanaged<ProgramHandle, int, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3d");
                _ProgramUniform3d_fnptr(program, location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform3dv_fnptr = &ProgramUniform3dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3dv(ProgramHandle program, int location, int count, double* value) => _ProgramUniform3dv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3dv_Lazy(ProgramHandle program, int location, int count, double* value)
            {
                _ProgramUniform3dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3dv");
                _ProgramUniform3dv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint, uint, uint, void> _ProgramUniform3ui_fnptr = &ProgramUniform3ui_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3ui(ProgramHandle program, int location, uint v0, uint v1, uint v2) => _ProgramUniform3ui_fnptr(program, location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3ui_Lazy(ProgramHandle program, int location, uint v0, uint v1, uint v2)
            {
                _ProgramUniform3ui_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3ui");
                _ProgramUniform3ui_fnptr(program, location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform3uiv_fnptr = &ProgramUniform3uiv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3uiv(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform3uiv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3uiv_Lazy(ProgramHandle program, int location, int count, uint* value)
            {
                _ProgramUniform3uiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3uiv");
                _ProgramUniform3uiv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int, int, int, void> _ProgramUniform4i_fnptr = &ProgramUniform4i_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4i(ProgramHandle program, int location, int v0, int v1, int v2, int v3) => _ProgramUniform4i_fnptr(program, location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4i_Lazy(ProgramHandle program, int location, int v0, int v1, int v2, int v3)
            {
                _ProgramUniform4i_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4i");
                _ProgramUniform4i_fnptr(program, location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform4iv_fnptr = &ProgramUniform4iv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4iv(ProgramHandle program, int location, int count, int* value) => _ProgramUniform4iv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4iv_Lazy(ProgramHandle program, int location, int count, int* value)
            {
                _ProgramUniform4iv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4iv");
                _ProgramUniform4iv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, float, float, float, float, void> _ProgramUniform4f_fnptr = &ProgramUniform4f_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4f(ProgramHandle program, int location, float v0, float v1, float v2, float v3) => _ProgramUniform4f_fnptr(program, location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4f_Lazy(ProgramHandle program, int location, float v0, float v1, float v2, float v3)
            {
                _ProgramUniform4f_fnptr = (delegate* unmanaged<ProgramHandle, int, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4f");
                _ProgramUniform4f_fnptr(program, location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform4fv_fnptr = &ProgramUniform4fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4fv(ProgramHandle program, int location, int count, float* value) => _ProgramUniform4fv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4fv_Lazy(ProgramHandle program, int location, int count, float* value)
            {
                _ProgramUniform4fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4fv");
                _ProgramUniform4fv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, double, double, double, double, void> _ProgramUniform4d_fnptr = &ProgramUniform4d_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4d(ProgramHandle program, int location, double v0, double v1, double v2, double v3) => _ProgramUniform4d_fnptr(program, location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4d_Lazy(ProgramHandle program, int location, double v0, double v1, double v2, double v3)
            {
                _ProgramUniform4d_fnptr = (delegate* unmanaged<ProgramHandle, int, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4d");
                _ProgramUniform4d_fnptr(program, location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform4dv_fnptr = &ProgramUniform4dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4dv(ProgramHandle program, int location, int count, double* value) => _ProgramUniform4dv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4dv_Lazy(ProgramHandle program, int location, int count, double* value)
            {
                _ProgramUniform4dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4dv");
                _ProgramUniform4dv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint, uint, uint, uint, void> _ProgramUniform4ui_fnptr = &ProgramUniform4ui_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4ui(ProgramHandle program, int location, uint v0, uint v1, uint v2, uint v3) => _ProgramUniform4ui_fnptr(program, location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4ui_Lazy(ProgramHandle program, int location, uint v0, uint v1, uint v2, uint v3)
            {
                _ProgramUniform4ui_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4ui");
                _ProgramUniform4ui_fnptr(program, location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform4uiv_fnptr = &ProgramUniform4uiv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4uiv(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform4uiv_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4uiv_Lazy(ProgramHandle program, int location, int count, uint* value)
            {
                _ProgramUniform4uiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4uiv");
                _ProgramUniform4uiv_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix2fv_fnptr = &ProgramUniformMatrix2fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix2fv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix2fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2fv");
                _ProgramUniformMatrix2fv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix3fv_fnptr = &ProgramUniformMatrix3fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix3fv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix3fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3fv");
                _ProgramUniformMatrix3fv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix4fv_fnptr = &ProgramUniformMatrix4fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix4fv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix4fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4fv");
                _ProgramUniformMatrix4fv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix2dv_fnptr = &ProgramUniformMatrix2dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix2dv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix2dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2dv");
                _ProgramUniformMatrix2dv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix3dv_fnptr = &ProgramUniformMatrix3dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix3dv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix3dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3dv");
                _ProgramUniformMatrix3dv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix4dv_fnptr = &ProgramUniformMatrix4dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix4dv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix4dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4dv");
                _ProgramUniformMatrix4dv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix2x3fv_fnptr = &ProgramUniformMatrix2x3fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2x3fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix2x3fv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2x3fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix2x3fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x3fv");
                _ProgramUniformMatrix2x3fv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix3x2fv_fnptr = &ProgramUniformMatrix3x2fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3x2fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix3x2fv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3x2fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix3x2fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x2fv");
                _ProgramUniformMatrix3x2fv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix2x4fv_fnptr = &ProgramUniformMatrix2x4fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2x4fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix2x4fv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2x4fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix2x4fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x4fv");
                _ProgramUniformMatrix2x4fv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix4x2fv_fnptr = &ProgramUniformMatrix4x2fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4x2fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix4x2fv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4x2fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix4x2fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x2fv");
                _ProgramUniformMatrix4x2fv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix3x4fv_fnptr = &ProgramUniformMatrix3x4fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3x4fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix3x4fv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3x4fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix3x4fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x4fv");
                _ProgramUniformMatrix3x4fv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix4x3fv_fnptr = &ProgramUniformMatrix4x3fv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4x3fv(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix4x3fv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4x3fv_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix4x3fv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x3fv");
                _ProgramUniformMatrix4x3fv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix2x3dv_fnptr = &ProgramUniformMatrix2x3dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x3dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix2x3dv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2x3dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix2x3dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x3dv");
                _ProgramUniformMatrix2x3dv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix3x2dv_fnptr = &ProgramUniformMatrix3x2dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x2dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix3x2dv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3x2dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix3x2dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x2dv");
                _ProgramUniformMatrix3x2dv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix2x4dv_fnptr = &ProgramUniformMatrix2x4dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x4dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix2x4dv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2x4dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix2x4dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x4dv");
                _ProgramUniformMatrix2x4dv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix4x2dv_fnptr = &ProgramUniformMatrix4x2dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x2dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix4x2dv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4x2dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix4x2dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x2dv");
                _ProgramUniformMatrix4x2dv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix3x4dv_fnptr = &ProgramUniformMatrix3x4dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x4dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix3x4dv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3x4dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix3x4dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x4dv");
                _ProgramUniformMatrix3x4dv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix4x3dv_fnptr = &ProgramUniformMatrix4x3dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x3dv(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix4x3dv_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4x3dv_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix4x3dv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x3dv");
                _ProgramUniformMatrix4x3dv_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, void> _ValidateProgramPipeline_fnptr = &ValidateProgramPipeline_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Validate a program pipeline object against current GL state. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml" /></remarks>
            public static void ValidateProgramPipeline(ProgramPipelineHandle pipeline) => _ValidateProgramPipeline_fnptr(pipeline);
            [UnmanagedCallersOnly]
            private static void ValidateProgramPipeline_Lazy(ProgramPipelineHandle pipeline)
            {
                _ValidateProgramPipeline_fnptr = (delegate* unmanaged<ProgramPipelineHandle, void>)GLLoader.BindingsContext.GetProcAddress("glValidateProgramPipeline");
                _ValidateProgramPipeline_fnptr(pipeline);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, int, int*, byte*, void> _GetProgramPipelineInfoLog_fnptr = &GetProgramPipelineInfoLog_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Retrieve the info log string from a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
            /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
            /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
            /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml" /></remarks>
            public static void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, int* length, byte* infoLog) => _GetProgramPipelineInfoLog_fnptr(pipeline, bufSize, length, infoLog);
            [UnmanagedCallersOnly]
            private static void GetProgramPipelineInfoLog_Lazy(ProgramPipelineHandle pipeline, int bufSize, int* length, byte* infoLog)
            {
                _GetProgramPipelineInfoLog_fnptr = (delegate* unmanaged<ProgramPipelineHandle, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramPipelineInfoLog");
                _GetProgramPipelineInfoLog_fnptr(pipeline, bufSize, length, infoLog);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, AtomicCounterBufferPName, int*, void> _GetActiveAtomicCounterBufferiv_fnptr = &GetActiveAtomicCounterBufferiv_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters]</b> Retrieve information about the set of active atomic counter buffers for a program. </summary>
            /// <param name="program"> The name of a program object from which to retrieve information. </param>
            /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
            /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml" /></remarks>
            public static void GetActiveAtomicCounterBufferiv(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => _GetActiveAtomicCounterBufferiv_fnptr(program, bufferIndex, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetActiveAtomicCounterBufferiv_Lazy(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters)
            {
                _GetActiveAtomicCounterBufferiv_fnptr = (delegate* unmanaged<ProgramHandle, uint, AtomicCounterBufferPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveAtomicCounterBufferiv");
                _GetActiveAtomicCounterBufferiv_fnptr(program, bufferIndex, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, TextureHandle, int, byte, int, BufferAccessARB, InternalFormat, void> _BindImageTexture_fnptr = &BindImageTexture_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> Bind a level of a texture to an image unit. </summary>
            /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
            /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
            /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
            /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
            /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
            /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
            /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml" /></remarks>
            public static void BindImageTexture(uint unit, TextureHandle texture, int level, byte layered, int layer, BufferAccessARB access, InternalFormat format) => _BindImageTexture_fnptr(unit, texture, level, layered, layer, access, format);
            [UnmanagedCallersOnly]
            private static void BindImageTexture_Lazy(uint unit, TextureHandle texture, int level, byte layered, int layer, BufferAccessARB access, InternalFormat format)
            {
                _BindImageTexture_fnptr = (delegate* unmanaged<uint, TextureHandle, int, byte, int, BufferAccessARB, InternalFormat, void>)GLLoader.BindingsContext.GetProcAddress("glBindImageTexture");
                _BindImageTexture_fnptr(unit, texture, level, layered, layer, access, format);
            }
            
            private static delegate* unmanaged<MemoryBarrierMask, void> _MemoryBarrier_fnptr = &MemoryBarrier_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
            public static void MemoryBarrier(MemoryBarrierMask barriers) => _MemoryBarrier_fnptr(barriers);
            [UnmanagedCallersOnly]
            private static void MemoryBarrier_Lazy(MemoryBarrierMask barriers)
            {
                _MemoryBarrier_fnptr = (delegate* unmanaged<MemoryBarrierMask, void>)GLLoader.BindingsContext.GetProcAddress("glMemoryBarrier");
                _MemoryBarrier_fnptr(barriers);
            }
            
            private static delegate* unmanaged<GLHandleARB, void> _DeleteObjectARB_fnptr = &DeleteObjectARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteObjectARB(GLHandleARB obj) => _DeleteObjectARB_fnptr(obj);
            [UnmanagedCallersOnly]
            private static void DeleteObjectARB_Lazy(GLHandleARB obj)
            {
                _DeleteObjectARB_fnptr = (delegate* unmanaged<GLHandleARB, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteObjectARB");
                _DeleteObjectARB_fnptr(obj);
            }
            
            private static delegate* unmanaged<All, IntPtr> _GetHandleARB_fnptr = &GetHandleARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLHandleARB GetHandleARB(All pname) => (GLHandleARB) _GetHandleARB_fnptr(pname);
            [UnmanagedCallersOnly]
            private static IntPtr GetHandleARB_Lazy(All pname)
            {
                _GetHandleARB_fnptr = (delegate* unmanaged<All, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glGetHandleARB");
                return _GetHandleARB_fnptr(pname);
            }
            
            private static delegate* unmanaged<GLHandleARB, GLHandleARB, void> _DetachObjectARB_fnptr = &DetachObjectARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DetachObjectARB(GLHandleARB containerObj, GLHandleARB attachedObj) => _DetachObjectARB_fnptr(containerObj, attachedObj);
            [UnmanagedCallersOnly]
            private static void DetachObjectARB_Lazy(GLHandleARB containerObj, GLHandleARB attachedObj)
            {
                _DetachObjectARB_fnptr = (delegate* unmanaged<GLHandleARB, GLHandleARB, void>)GLLoader.BindingsContext.GetProcAddress("glDetachObjectARB");
                _DetachObjectARB_fnptr(containerObj, attachedObj);
            }
            
            private static delegate* unmanaged<ShaderType, IntPtr> _CreateShaderObjectARB_fnptr = &CreateShaderObjectARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLHandleARB CreateShaderObjectARB(ShaderType shaderType) => (GLHandleARB) _CreateShaderObjectARB_fnptr(shaderType);
            [UnmanagedCallersOnly]
            private static IntPtr CreateShaderObjectARB_Lazy(ShaderType shaderType)
            {
                _CreateShaderObjectARB_fnptr = (delegate* unmanaged<ShaderType, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glCreateShaderObjectARB");
                return _CreateShaderObjectARB_fnptr(shaderType);
            }
            
            private static delegate* unmanaged<GLHandleARB, int, byte**, int*, void> _ShaderSourceARB_fnptr = &ShaderSourceARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShaderSourceARB(GLHandleARB shaderObj, int count, byte** str, int* length) => _ShaderSourceARB_fnptr(shaderObj, count, str, length);
            [UnmanagedCallersOnly]
            private static void ShaderSourceARB_Lazy(GLHandleARB shaderObj, int count, byte** str, int* length)
            {
                _ShaderSourceARB_fnptr = (delegate* unmanaged<GLHandleARB, int, byte**, int*, void>)GLLoader.BindingsContext.GetProcAddress("glShaderSourceARB");
                _ShaderSourceARB_fnptr(shaderObj, count, str, length);
            }
            
            private static delegate* unmanaged<GLHandleARB, void> _CompileShaderARB_fnptr = &CompileShaderARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompileShaderARB(GLHandleARB shaderObj) => _CompileShaderARB_fnptr(shaderObj);
            [UnmanagedCallersOnly]
            private static void CompileShaderARB_Lazy(GLHandleARB shaderObj)
            {
                _CompileShaderARB_fnptr = (delegate* unmanaged<GLHandleARB, void>)GLLoader.BindingsContext.GetProcAddress("glCompileShaderARB");
                _CompileShaderARB_fnptr(shaderObj);
            }
            
            private static delegate* unmanaged<IntPtr> _CreateProgramObjectARB_fnptr = &CreateProgramObjectARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLHandleARB CreateProgramObjectARB() => (GLHandleARB) _CreateProgramObjectARB_fnptr();
            [UnmanagedCallersOnly]
            private static IntPtr CreateProgramObjectARB_Lazy()
            {
                _CreateProgramObjectARB_fnptr = (delegate* unmanaged<IntPtr>)GLLoader.BindingsContext.GetProcAddress("glCreateProgramObjectARB");
                return _CreateProgramObjectARB_fnptr();
            }
            
            private static delegate* unmanaged<GLHandleARB, GLHandleARB, void> _AttachObjectARB_fnptr = &AttachObjectARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AttachObjectARB(GLHandleARB containerObj, GLHandleARB obj) => _AttachObjectARB_fnptr(containerObj, obj);
            [UnmanagedCallersOnly]
            private static void AttachObjectARB_Lazy(GLHandleARB containerObj, GLHandleARB obj)
            {
                _AttachObjectARB_fnptr = (delegate* unmanaged<GLHandleARB, GLHandleARB, void>)GLLoader.BindingsContext.GetProcAddress("glAttachObjectARB");
                _AttachObjectARB_fnptr(containerObj, obj);
            }
            
            private static delegate* unmanaged<GLHandleARB, void> _LinkProgramARB_fnptr = &LinkProgramARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LinkProgramARB(GLHandleARB programObj) => _LinkProgramARB_fnptr(programObj);
            [UnmanagedCallersOnly]
            private static void LinkProgramARB_Lazy(GLHandleARB programObj)
            {
                _LinkProgramARB_fnptr = (delegate* unmanaged<GLHandleARB, void>)GLLoader.BindingsContext.GetProcAddress("glLinkProgramARB");
                _LinkProgramARB_fnptr(programObj);
            }
            
            private static delegate* unmanaged<GLHandleARB, void> _UseProgramObjectARB_fnptr = &UseProgramObjectARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UseProgramObjectARB(GLHandleARB programObj) => _UseProgramObjectARB_fnptr(programObj);
            [UnmanagedCallersOnly]
            private static void UseProgramObjectARB_Lazy(GLHandleARB programObj)
            {
                _UseProgramObjectARB_fnptr = (delegate* unmanaged<GLHandleARB, void>)GLLoader.BindingsContext.GetProcAddress("glUseProgramObjectARB");
                _UseProgramObjectARB_fnptr(programObj);
            }
            
            private static delegate* unmanaged<GLHandleARB, void> _ValidateProgramARB_fnptr = &ValidateProgramARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ValidateProgramARB(GLHandleARB programObj) => _ValidateProgramARB_fnptr(programObj);
            [UnmanagedCallersOnly]
            private static void ValidateProgramARB_Lazy(GLHandleARB programObj)
            {
                _ValidateProgramARB_fnptr = (delegate* unmanaged<GLHandleARB, void>)GLLoader.BindingsContext.GetProcAddress("glValidateProgramARB");
                _ValidateProgramARB_fnptr(programObj);
            }
            
            private static delegate* unmanaged<int, float, void> _Uniform1fARB_fnptr = &Uniform1fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1fARB(int location, float v0) => _Uniform1fARB_fnptr(location, v0);
            [UnmanagedCallersOnly]
            private static void Uniform1fARB_Lazy(int location, float v0)
            {
                _Uniform1fARB_fnptr = (delegate* unmanaged<int, float, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1fARB");
                _Uniform1fARB_fnptr(location, v0);
            }
            
            private static delegate* unmanaged<int, float, float, void> _Uniform2fARB_fnptr = &Uniform2fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2fARB(int location, float v0, float v1) => _Uniform2fARB_fnptr(location, v0, v1);
            [UnmanagedCallersOnly]
            private static void Uniform2fARB_Lazy(int location, float v0, float v1)
            {
                _Uniform2fARB_fnptr = (delegate* unmanaged<int, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2fARB");
                _Uniform2fARB_fnptr(location, v0, v1);
            }
            
            private static delegate* unmanaged<int, float, float, float, void> _Uniform3fARB_fnptr = &Uniform3fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3fARB(int location, float v0, float v1, float v2) => _Uniform3fARB_fnptr(location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void Uniform3fARB_Lazy(int location, float v0, float v1, float v2)
            {
                _Uniform3fARB_fnptr = (delegate* unmanaged<int, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3fARB");
                _Uniform3fARB_fnptr(location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<int, float, float, float, float, void> _Uniform4fARB_fnptr = &Uniform4fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4fARB(int location, float v0, float v1, float v2, float v3) => _Uniform4fARB_fnptr(location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void Uniform4fARB_Lazy(int location, float v0, float v1, float v2, float v3)
            {
                _Uniform4fARB_fnptr = (delegate* unmanaged<int, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4fARB");
                _Uniform4fARB_fnptr(location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<int, int, void> _Uniform1iARB_fnptr = &Uniform1iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1iARB(int location, int v0) => _Uniform1iARB_fnptr(location, v0);
            [UnmanagedCallersOnly]
            private static void Uniform1iARB_Lazy(int location, int v0)
            {
                _Uniform1iARB_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1iARB");
                _Uniform1iARB_fnptr(location, v0);
            }
            
            private static delegate* unmanaged<int, int, int, void> _Uniform2iARB_fnptr = &Uniform2iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2iARB(int location, int v0, int v1) => _Uniform2iARB_fnptr(location, v0, v1);
            [UnmanagedCallersOnly]
            private static void Uniform2iARB_Lazy(int location, int v0, int v1)
            {
                _Uniform2iARB_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2iARB");
                _Uniform2iARB_fnptr(location, v0, v1);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _Uniform3iARB_fnptr = &Uniform3iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3iARB(int location, int v0, int v1, int v2) => _Uniform3iARB_fnptr(location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void Uniform3iARB_Lazy(int location, int v0, int v1, int v2)
            {
                _Uniform3iARB_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3iARB");
                _Uniform3iARB_fnptr(location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<int, int, int, int, int, void> _Uniform4iARB_fnptr = &Uniform4iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4iARB(int location, int v0, int v1, int v2, int v3) => _Uniform4iARB_fnptr(location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void Uniform4iARB_Lazy(int location, int v0, int v1, int v2, int v3)
            {
                _Uniform4iARB_fnptr = (delegate* unmanaged<int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4iARB");
                _Uniform4iARB_fnptr(location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<int, int, float*, void> _Uniform1fvARB_fnptr = &Uniform1fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1fvARB(int location, int count, float* value) => _Uniform1fvARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1fvARB_Lazy(int location, int count, float* value)
            {
                _Uniform1fvARB_fnptr = (delegate* unmanaged<int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1fvARB");
                _Uniform1fvARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, float*, void> _Uniform2fvARB_fnptr = &Uniform2fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2fvARB(int location, int count, float* value) => _Uniform2fvARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2fvARB_Lazy(int location, int count, float* value)
            {
                _Uniform2fvARB_fnptr = (delegate* unmanaged<int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2fvARB");
                _Uniform2fvARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, float*, void> _Uniform3fvARB_fnptr = &Uniform3fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3fvARB(int location, int count, float* value) => _Uniform3fvARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3fvARB_Lazy(int location, int count, float* value)
            {
                _Uniform3fvARB_fnptr = (delegate* unmanaged<int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3fvARB");
                _Uniform3fvARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, float*, void> _Uniform4fvARB_fnptr = &Uniform4fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4fvARB(int location, int count, float* value) => _Uniform4fvARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4fvARB_Lazy(int location, int count, float* value)
            {
                _Uniform4fvARB_fnptr = (delegate* unmanaged<int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4fvARB");
                _Uniform4fvARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, int*, void> _Uniform1ivARB_fnptr = &Uniform1ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ivARB(int location, int count, int* value) => _Uniform1ivARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1ivARB_Lazy(int location, int count, int* value)
            {
                _Uniform1ivARB_fnptr = (delegate* unmanaged<int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1ivARB");
                _Uniform1ivARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, int*, void> _Uniform2ivARB_fnptr = &Uniform2ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ivARB(int location, int count, int* value) => _Uniform2ivARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2ivARB_Lazy(int location, int count, int* value)
            {
                _Uniform2ivARB_fnptr = (delegate* unmanaged<int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2ivARB");
                _Uniform2ivARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, int*, void> _Uniform3ivARB_fnptr = &Uniform3ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ivARB(int location, int count, int* value) => _Uniform3ivARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3ivARB_Lazy(int location, int count, int* value)
            {
                _Uniform3ivARB_fnptr = (delegate* unmanaged<int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3ivARB");
                _Uniform3ivARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, int*, void> _Uniform4ivARB_fnptr = &Uniform4ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ivARB(int location, int count, int* value) => _Uniform4ivARB_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4ivARB_Lazy(int location, int count, int* value)
            {
                _Uniform4ivARB_fnptr = (delegate* unmanaged<int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4ivARB");
                _Uniform4ivARB_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix2fvARB_fnptr = &UniformMatrix2fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix2fvARB(int location, int count, byte transpose, float* value) => _UniformMatrix2fvARB_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix2fvARB_Lazy(int location, int count, byte transpose, float* value)
            {
                _UniformMatrix2fvARB_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix2fvARB");
                _UniformMatrix2fvARB_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix3fvARB_fnptr = &UniformMatrix3fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix3fvARB(int location, int count, byte transpose, float* value) => _UniformMatrix3fvARB_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix3fvARB_Lazy(int location, int count, byte transpose, float* value)
            {
                _UniformMatrix3fvARB_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix3fvARB");
                _UniformMatrix3fvARB_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<int, int, byte, float*, void> _UniformMatrix4fvARB_fnptr = &UniformMatrix4fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix4fvARB(int location, int count, byte transpose, float* value) => _UniformMatrix4fvARB_fnptr(location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void UniformMatrix4fvARB_Lazy(int location, int count, byte transpose, float* value)
            {
                _UniformMatrix4fvARB_fnptr = (delegate* unmanaged<int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformMatrix4fvARB");
                _UniformMatrix4fvARB_fnptr(location, count, transpose, value);
            }
            
            private static delegate* unmanaged<GLHandleARB, All, float*, void> _GetObjectParameterfvARB_fnptr = &GetObjectParameterfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectParameterfvARB(GLHandleARB obj, All pname, float* parameters) => _GetObjectParameterfvARB_fnptr(obj, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetObjectParameterfvARB_Lazy(GLHandleARB obj, All pname, float* parameters)
            {
                _GetObjectParameterfvARB_fnptr = (delegate* unmanaged<GLHandleARB, All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectParameterfvARB");
                _GetObjectParameterfvARB_fnptr(obj, pname, parameters);
            }
            
            private static delegate* unmanaged<GLHandleARB, All, int*, void> _GetObjectParameterivARB_fnptr = &GetObjectParameterivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectParameterivARB(GLHandleARB obj, All pname, int* parameters) => _GetObjectParameterivARB_fnptr(obj, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetObjectParameterivARB_Lazy(GLHandleARB obj, All pname, int* parameters)
            {
                _GetObjectParameterivARB_fnptr = (delegate* unmanaged<GLHandleARB, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectParameterivARB");
                _GetObjectParameterivARB_fnptr(obj, pname, parameters);
            }
            
            private static delegate* unmanaged<GLHandleARB, int, int*, byte*, void> _GetInfoLogARB_fnptr = &GetInfoLogARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInfoLogARB(GLHandleARB obj, int maxLength, int* length, byte* infoLog) => _GetInfoLogARB_fnptr(obj, maxLength, length, infoLog);
            [UnmanagedCallersOnly]
            private static void GetInfoLogARB_Lazy(GLHandleARB obj, int maxLength, int* length, byte* infoLog)
            {
                _GetInfoLogARB_fnptr = (delegate* unmanaged<GLHandleARB, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInfoLogARB");
                _GetInfoLogARB_fnptr(obj, maxLength, length, infoLog);
            }
            
            private static delegate* unmanaged<GLHandleARB, int, int*, GLHandleARB*, void> _GetAttachedObjectsARB_fnptr = &GetAttachedObjectsARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetAttachedObjectsARB(GLHandleARB containerObj, int maxCount, int* count, GLHandleARB* obj) => _GetAttachedObjectsARB_fnptr(containerObj, maxCount, count, obj);
            [UnmanagedCallersOnly]
            private static void GetAttachedObjectsARB_Lazy(GLHandleARB containerObj, int maxCount, int* count, GLHandleARB* obj)
            {
                _GetAttachedObjectsARB_fnptr = (delegate* unmanaged<GLHandleARB, int, int*, GLHandleARB*, void>)GLLoader.BindingsContext.GetProcAddress("glGetAttachedObjectsARB");
                _GetAttachedObjectsARB_fnptr(containerObj, maxCount, count, obj);
            }
            
            private static delegate* unmanaged<GLHandleARB, byte*, int> _GetUniformLocationARB_fnptr = &GetUniformLocationARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetUniformLocationARB(GLHandleARB programObj, byte* name) => _GetUniformLocationARB_fnptr(programObj, name);
            [UnmanagedCallersOnly]
            private static int GetUniformLocationARB_Lazy(GLHandleARB programObj, byte* name)
            {
                _GetUniformLocationARB_fnptr = (delegate* unmanaged<GLHandleARB, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetUniformLocationARB");
                return _GetUniformLocationARB_fnptr(programObj, name);
            }
            
            private static delegate* unmanaged<GLHandleARB, uint, int, int*, int*, UniformType*, byte*, void> _GetActiveUniformARB_fnptr = &GetActiveUniformARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, UniformType* type, byte* name) => _GetActiveUniformARB_fnptr(programObj, index, maxLength, length, size, type, name);
            [UnmanagedCallersOnly]
            private static void GetActiveUniformARB_Lazy(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, UniformType* type, byte* name)
            {
                _GetActiveUniformARB_fnptr = (delegate* unmanaged<GLHandleARB, uint, int, int*, int*, UniformType*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniformARB");
                _GetActiveUniformARB_fnptr(programObj, index, maxLength, length, size, type, name);
            }
            
            private static delegate* unmanaged<GLHandleARB, int, float*, void> _GetUniformfvARB_fnptr = &GetUniformfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformfvARB(GLHandleARB programObj, int location, float* parameters) => _GetUniformfvARB_fnptr(programObj, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformfvARB_Lazy(GLHandleARB programObj, int location, float* parameters)
            {
                _GetUniformfvARB_fnptr = (delegate* unmanaged<GLHandleARB, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformfvARB");
                _GetUniformfvARB_fnptr(programObj, location, parameters);
            }
            
            private static delegate* unmanaged<GLHandleARB, int, int*, void> _GetUniformivARB_fnptr = &GetUniformivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformivARB(GLHandleARB programObj, int location, int* parameters) => _GetUniformivARB_fnptr(programObj, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformivARB_Lazy(GLHandleARB programObj, int location, int* parameters)
            {
                _GetUniformivARB_fnptr = (delegate* unmanaged<GLHandleARB, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformivARB");
                _GetUniformivARB_fnptr(programObj, location, parameters);
            }
            
            private static delegate* unmanaged<GLHandleARB, int, int*, byte*, void> _GetShaderSourceARB_fnptr = &GetShaderSourceARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetShaderSourceARB(GLHandleARB obj, int maxLength, int* length, byte* source) => _GetShaderSourceARB_fnptr(obj, maxLength, length, source);
            [UnmanagedCallersOnly]
            private static void GetShaderSourceARB_Lazy(GLHandleARB obj, int maxLength, int* length, byte* source)
            {
                _GetShaderSourceARB_fnptr = (delegate* unmanaged<GLHandleARB, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetShaderSourceARB");
                _GetShaderSourceARB_fnptr(obj, maxLength, length, source);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, uint, void> _ShaderStorageBlockBinding_fnptr = &ShaderStorageBlockBinding_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object]</b> Change an active shader storage block binding. </summary>
            /// <param name="program"> The name of the program containing the block whose binding to change. </param>
            /// <param name="storageBlockIndex"> The index storage block within the program. </param>
            /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml" /></remarks>
            public static void ShaderStorageBlockBinding(ProgramHandle program, uint storageBlockIndex, uint storageBlockBinding) => _ShaderStorageBlockBinding_fnptr(program, storageBlockIndex, storageBlockBinding);
            [UnmanagedCallersOnly]
            private static void ShaderStorageBlockBinding_Lazy(ProgramHandle program, uint storageBlockIndex, uint storageBlockBinding)
            {
                _ShaderStorageBlockBinding_fnptr = (delegate* unmanaged<ProgramHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glShaderStorageBlockBinding");
                _ShaderStorageBlockBinding_fnptr(program, storageBlockIndex, storageBlockBinding);
            }
            
            private static delegate* unmanaged<ProgramHandle, ShaderType, byte*, int> _GetSubroutineUniformLocation_fnptr = &GetSubroutineUniformLocation_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml" /></remarks>
            public static int GetSubroutineUniformLocation(ProgramHandle program, ShaderType shadertype, byte* name) => _GetSubroutineUniformLocation_fnptr(program, shadertype, name);
            [UnmanagedCallersOnly]
            private static int GetSubroutineUniformLocation_Lazy(ProgramHandle program, ShaderType shadertype, byte* name)
            {
                _GetSubroutineUniformLocation_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetSubroutineUniformLocation");
                return _GetSubroutineUniformLocation_fnptr(program, shadertype, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, ShaderType, byte*, uint> _GetSubroutineIndex_fnptr = &GetSubroutineIndex_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml" /></remarks>
            public static uint GetSubroutineIndex(ProgramHandle program, ShaderType shadertype, byte* name) => _GetSubroutineIndex_fnptr(program, shadertype, name);
            [UnmanagedCallersOnly]
            private static uint GetSubroutineIndex_Lazy(ProgramHandle program, ShaderType shadertype, byte* name)
            {
                _GetSubroutineIndex_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetSubroutineIndex");
                return _GetSubroutineIndex_fnptr(program, shadertype, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, ShaderType, uint, SubroutineParameterName, int*, void> _GetActiveSubroutineUniformiv_fnptr = &GetActiveSubroutineUniformiv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query a property of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
            /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml" /></remarks>
            public static void GetActiveSubroutineUniformiv(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => _GetActiveSubroutineUniformiv_fnptr(program, shadertype, index, pname, values);
            [UnmanagedCallersOnly]
            private static void GetActiveSubroutineUniformiv_Lazy(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values)
            {
                _GetActiveSubroutineUniformiv_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, uint, SubroutineParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveSubroutineUniformiv");
                _GetActiveSubroutineUniformiv_fnptr(program, shadertype, index, pname, values);
            }
            
            private static delegate* unmanaged<ProgramHandle, ShaderType, uint, int, int*, byte*, void> _GetActiveSubroutineUniformName_fnptr = &GetActiveSubroutineUniformName_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query the name of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
            /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml" /></remarks>
            public static void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => _GetActiveSubroutineUniformName_fnptr(program, shadertype, index, bufSize, length, name);
            [UnmanagedCallersOnly]
            private static void GetActiveSubroutineUniformName_Lazy(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name)
            {
                _GetActiveSubroutineUniformName_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveSubroutineUniformName");
                _GetActiveSubroutineUniformName_fnptr(program, shadertype, index, bufSize, length, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, ShaderType, uint, int, int*, byte*, void> _GetActiveSubroutineName_fnptr = &GetActiveSubroutineName_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query the name of an active shader subroutine. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
            /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml" /></remarks>
            public static void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => _GetActiveSubroutineName_fnptr(program, shadertype, index, bufSize, length, name);
            [UnmanagedCallersOnly]
            private static void GetActiveSubroutineName_Lazy(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name)
            {
                _GetActiveSubroutineName_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveSubroutineName");
                _GetActiveSubroutineName_fnptr(program, shadertype, index, bufSize, length, name);
            }
            
            private static delegate* unmanaged<ShaderType, int, uint*, void> _UniformSubroutinesuiv_fnptr = &UniformSubroutinesuiv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Load active subroutine uniforms. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
            /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml" /></remarks>
            public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => _UniformSubroutinesuiv_fnptr(shadertype, count, indices);
            [UnmanagedCallersOnly]
            private static void UniformSubroutinesuiv_Lazy(ShaderType shadertype, int count, uint* indices)
            {
                _UniformSubroutinesuiv_fnptr = (delegate* unmanaged<ShaderType, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformSubroutinesuiv");
                _UniformSubroutinesuiv_fnptr(shadertype, count, indices);
            }
            
            private static delegate* unmanaged<ShaderType, int, uint*, void> _GetUniformSubroutineuiv_fnptr = &GetUniformSubroutineuiv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="location"> Specifies the location of the subroutine uniform. </param>
            /// <param name="values"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml" /></remarks>
            public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => _GetUniformSubroutineuiv_fnptr(shadertype, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformSubroutineuiv_Lazy(ShaderType shadertype, int location, uint* parameters)
            {
                _GetUniformSubroutineuiv_fnptr = (delegate* unmanaged<ShaderType, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformSubroutineuiv");
                _GetUniformSubroutineuiv_fnptr(shadertype, location, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ShaderType, ProgramStagePName, int*, void> _GetProgramStageiv_fnptr = &GetProgramStageiv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
            /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml" /></remarks>
            public static void GetProgramStageiv(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int* values) => _GetProgramStageiv_fnptr(program, shadertype, pname, values);
            [UnmanagedCallersOnly]
            private static void GetProgramStageiv_Lazy(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int* values)
            {
                _GetProgramStageiv_fnptr = (delegate* unmanaged<ProgramHandle, ShaderType, ProgramStagePName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramStageiv");
                _GetProgramStageiv_fnptr(program, shadertype, pname, values);
            }
            
            private static delegate* unmanaged<All, int, byte*, int, byte*, void> _NamedStringARB_fnptr = &NamedStringARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedStringARB(All type, int namelen, byte* name, int stringlen, byte* str) => _NamedStringARB_fnptr(type, namelen, name, stringlen, str);
            [UnmanagedCallersOnly]
            private static void NamedStringARB_Lazy(All type, int namelen, byte* name, int stringlen, byte* str)
            {
                _NamedStringARB_fnptr = (delegate* unmanaged<All, int, byte*, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedStringARB");
                _NamedStringARB_fnptr(type, namelen, name, stringlen, str);
            }
            
            private static delegate* unmanaged<int, byte*, void> _DeleteNamedStringARB_fnptr = &DeleteNamedStringARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteNamedStringARB(int namelen, byte* name) => _DeleteNamedStringARB_fnptr(namelen, name);
            [UnmanagedCallersOnly]
            private static void DeleteNamedStringARB_Lazy(int namelen, byte* name)
            {
                _DeleteNamedStringARB_fnptr = (delegate* unmanaged<int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteNamedStringARB");
                _DeleteNamedStringARB_fnptr(namelen, name);
            }
            
            private static delegate* unmanaged<ShaderHandle, int, byte**, int*, void> _CompileShaderIncludeARB_fnptr = &CompileShaderIncludeARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompileShaderIncludeARB(ShaderHandle shader, int count, byte** path, int* length) => _CompileShaderIncludeARB_fnptr(shader, count, path, length);
            [UnmanagedCallersOnly]
            private static void CompileShaderIncludeARB_Lazy(ShaderHandle shader, int count, byte** path, int* length)
            {
                _CompileShaderIncludeARB_fnptr = (delegate* unmanaged<ShaderHandle, int, byte**, int*, void>)GLLoader.BindingsContext.GetProcAddress("glCompileShaderIncludeARB");
                _CompileShaderIncludeARB_fnptr(shader, count, path, length);
            }
            
            private static delegate* unmanaged<int, byte*, byte> _IsNamedStringARB_fnptr = &IsNamedStringARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsNamedStringARB(int namelen, byte* name) => _IsNamedStringARB_fnptr(namelen, name);
            [UnmanagedCallersOnly]
            private static byte IsNamedStringARB_Lazy(int namelen, byte* name)
            {
                _IsNamedStringARB_fnptr = (delegate* unmanaged<int, byte*, byte>)GLLoader.BindingsContext.GetProcAddress("glIsNamedStringARB");
                return _IsNamedStringARB_fnptr(namelen, name);
            }
            
            private static delegate* unmanaged<int, byte*, int, int*, byte*, void> _GetNamedStringARB_fnptr = &GetNamedStringARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedStringARB(int namelen, byte* name, int bufSize, int* stringlen, byte* str) => _GetNamedStringARB_fnptr(namelen, name, bufSize, stringlen, str);
            [UnmanagedCallersOnly]
            private static void GetNamedStringARB_Lazy(int namelen, byte* name, int bufSize, int* stringlen, byte* str)
            {
                _GetNamedStringARB_fnptr = (delegate* unmanaged<int, byte*, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedStringARB");
                _GetNamedStringARB_fnptr(namelen, name, bufSize, stringlen, str);
            }
            
            private static delegate* unmanaged<int, byte*, All, int*, void> _GetNamedStringivARB_fnptr = &GetNamedStringivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedStringivARB(int namelen, byte* name, All pname, int* parameters) => _GetNamedStringivARB_fnptr(namelen, name, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedStringivARB_Lazy(int namelen, byte* name, All pname, int* parameters)
            {
                _GetNamedStringivARB_fnptr = (delegate* unmanaged<int, byte*, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedStringivARB");
                _GetNamedStringivARB_fnptr(namelen, name, pname, parameters);
            }
            
            private static delegate* unmanaged<All, IntPtr, nint, byte, void> _BufferPageCommitmentARB_fnptr = &BufferPageCommitmentARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferPageCommitmentARB(All target, IntPtr offset, nint size, byte commit) => _BufferPageCommitmentARB_fnptr(target, offset, size, commit);
            [UnmanagedCallersOnly]
            private static void BufferPageCommitmentARB_Lazy(All target, IntPtr offset, nint size, byte commit)
            {
                _BufferPageCommitmentARB_fnptr = (delegate* unmanaged<All, IntPtr, nint, byte, void>)GLLoader.BindingsContext.GetProcAddress("glBufferPageCommitmentARB");
                _BufferPageCommitmentARB_fnptr(target, offset, size, commit);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, byte, void> _NamedBufferPageCommitmentEXT_fnptr = &NamedBufferPageCommitmentEXT_Lazy;
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferPageCommitmentEXT(BufferHandle buffer, IntPtr offset, nint size, byte commit) => _NamedBufferPageCommitmentEXT_fnptr(buffer, offset, size, commit);
            [UnmanagedCallersOnly]
            private static void NamedBufferPageCommitmentEXT_Lazy(BufferHandle buffer, IntPtr offset, nint size, byte commit)
            {
                _NamedBufferPageCommitmentEXT_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, byte, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferPageCommitmentEXT");
                _NamedBufferPageCommitmentEXT_fnptr(buffer, offset, size, commit);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, byte, void> _NamedBufferPageCommitmentARB_fnptr = &NamedBufferPageCommitmentARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferPageCommitmentARB(BufferHandle buffer, IntPtr offset, nint size, byte commit) => _NamedBufferPageCommitmentARB_fnptr(buffer, offset, size, commit);
            [UnmanagedCallersOnly]
            private static void NamedBufferPageCommitmentARB_Lazy(BufferHandle buffer, IntPtr offset, nint size, byte commit)
            {
                _NamedBufferPageCommitmentARB_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, byte, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferPageCommitmentARB");
                _NamedBufferPageCommitmentARB_fnptr(buffer, offset, size, commit);
            }
            
            private static delegate* unmanaged<All, int, int, int, int, int, int, int, byte, void> _TexPageCommitmentARB_fnptr = &TexPageCommitmentARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_sparse_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexPageCommitmentARB(All target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, byte commit) => _TexPageCommitmentARB_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
            [UnmanagedCallersOnly]
            private static void TexPageCommitmentARB_Lazy(All target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, byte commit)
            {
                _TexPageCommitmentARB_fnptr = (delegate* unmanaged<All, int, int, int, int, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexPageCommitmentARB");
                _TexPageCommitmentARB_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
            }
            
            private static delegate* unmanaged<SyncCondition, SyncBehaviorFlags, IntPtr> _FenceSync_fnptr = &FenceSync_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Create a new sync object and insert it into the GL command stream. </summary>
            /// <param name="condition"> Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
            /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml" /></remarks>
            public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) _FenceSync_fnptr(condition, flags);
            [UnmanagedCallersOnly]
            private static IntPtr FenceSync_Lazy(SyncCondition condition, SyncBehaviorFlags flags)
            {
                _FenceSync_fnptr = (delegate* unmanaged<SyncCondition, SyncBehaviorFlags, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glFenceSync");
                return _FenceSync_fnptr(condition, flags);
            }
            
            private static delegate* unmanaged<GLSync, byte> _IsSync_fnptr = &IsSync_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Determine if a name corresponds to a sync object. </summary>
            /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml" /></remarks>
            public static byte IsSync(GLSync sync) => _IsSync_fnptr(sync);
            [UnmanagedCallersOnly]
            private static byte IsSync_Lazy(GLSync sync)
            {
                _IsSync_fnptr = (delegate* unmanaged<GLSync, byte>)GLLoader.BindingsContext.GetProcAddress("glIsSync");
                return _IsSync_fnptr(sync);
            }
            
            private static delegate* unmanaged<GLSync, void> _DeleteSync_fnptr = &DeleteSync_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Delete a sync object. </summary>
            /// <param name="sync"> The sync object to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml" /></remarks>
            public static void DeleteSync(GLSync sync) => _DeleteSync_fnptr(sync);
            [UnmanagedCallersOnly]
            private static void DeleteSync_Lazy(GLSync sync)
            {
                _DeleteSync_fnptr = (delegate* unmanaged<GLSync, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteSync");
                _DeleteSync_fnptr(sync);
            }
            
            private static delegate* unmanaged<GLSync, SyncObjectMask, ulong, SyncStatus> _ClientWaitSync_fnptr = &ClientWaitSync_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Block and wait for a sync object to become signaled. </summary>
            /// <param name="sync"> The sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
            /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml" /></remarks>
            public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => _ClientWaitSync_fnptr(sync, flags, timeout);
            [UnmanagedCallersOnly]
            private static SyncStatus ClientWaitSync_Lazy(GLSync sync, SyncObjectMask flags, ulong timeout)
            {
                _ClientWaitSync_fnptr = (delegate* unmanaged<GLSync, SyncObjectMask, ulong, SyncStatus>)GLLoader.BindingsContext.GetProcAddress("glClientWaitSync");
                return _ClientWaitSync_fnptr(sync, flags, timeout);
            }
            
            private static delegate* unmanaged<GLSync, SyncBehaviorFlags, ulong, void> _WaitSync_fnptr = &WaitSync_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
            /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
            /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml" /></remarks>
            public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => _WaitSync_fnptr(sync, flags, timeout);
            [UnmanagedCallersOnly]
            private static void WaitSync_Lazy(GLSync sync, SyncBehaviorFlags flags, ulong timeout)
            {
                _WaitSync_fnptr = (delegate* unmanaged<GLSync, SyncBehaviorFlags, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glWaitSync");
                _WaitSync_fnptr(sync, flags, timeout);
            }
            
            private static delegate* unmanaged<GetPName, long*, void> _GetInteger64v_fnptr = &GetInteger64v_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetInteger64v(GetPName pname, long* data) => _GetInteger64v_fnptr(pname, data);
            [UnmanagedCallersOnly]
            private static void GetInteger64v_Lazy(GetPName pname, long* data)
            {
                _GetInteger64v_fnptr = (delegate* unmanaged<GetPName, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInteger64v");
                _GetInteger64v_fnptr(pname, data);
            }
            
            private static delegate* unmanaged<GLSync, SyncParameterName, int, int*, int*, void> _GetSynciv_fnptr = &GetSynciv_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Query the properties of a sync object. </summary>
            /// <param name="sync"> Specifies the sync object whose properties to query. </param>
            /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in values. </param>
            /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
            /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml" /></remarks>
            public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => _GetSynciv_fnptr(sync, pname, count, length, values);
            [UnmanagedCallersOnly]
            private static void GetSynciv_Lazy(GLSync sync, SyncParameterName pname, int count, int* length, int* values)
            {
                _GetSynciv_fnptr = (delegate* unmanaged<GLSync, SyncParameterName, int, int*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSynciv");
                _GetSynciv_fnptr(sync, pname, count, length, values);
            }
            
            private static delegate* unmanaged<PatchParameterName, int, void> _PatchParameteri_fnptr = &PatchParameteri_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
            public static void PatchParameteri(PatchParameterName pname, int value) => _PatchParameteri_fnptr(pname, value);
            [UnmanagedCallersOnly]
            private static void PatchParameteri_Lazy(PatchParameterName pname, int value)
            {
                _PatchParameteri_fnptr = (delegate* unmanaged<PatchParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glPatchParameteri");
                _PatchParameteri_fnptr(pname, value);
            }
            
            private static delegate* unmanaged<PatchParameterName, float*, void> _PatchParameterfv_fnptr = &PatchParameterfv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
            public static void PatchParameterfv(PatchParameterName pname, float* values) => _PatchParameterfv_fnptr(pname, values);
            [UnmanagedCallersOnly]
            private static void PatchParameterfv_Lazy(PatchParameterName pname, float* values)
            {
                _PatchParameterfv_fnptr = (delegate* unmanaged<PatchParameterName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPatchParameterfv");
                _PatchParameterfv_fnptr(pname, values);
            }
            
            private static delegate* unmanaged<void> _TextureBarrier_fnptr = &TextureBarrier_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier]</b> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml" /></remarks>
            public static void TextureBarrier() => _TextureBarrier_fnptr();
            [UnmanagedCallersOnly]
            private static void TextureBarrier_Lazy()
            {
                _TextureBarrier_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glTextureBarrier");
                _TextureBarrier_fnptr();
            }
            
            private static delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, void> _TexBufferARB_fnptr = &TexBufferARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_texture_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexBufferARB(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer) => _TexBufferARB_fnptr(target, internalformat, buffer);
            [UnmanagedCallersOnly]
            private static void TexBufferARB_Lazy(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer)
            {
                _TexBufferARB_fnptr = (delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTexBufferARB");
                _TexBufferARB_fnptr(target, internalformat, buffer);
            }
            
            private static delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, IntPtr, nint, void> _TexBufferRange_fnptr = &TexBufferRange_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range]</b> Attach a range of a buffer object's data store to a buffer texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer's data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer's data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
            public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => _TexBufferRange_fnptr(target, internalformat, buffer, offset, size);
            [UnmanagedCallersOnly]
            private static void TexBufferRange_Lazy(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size)
            {
                _TexBufferRange_fnptr = (delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glTexBufferRange");
                _TexBufferRange_fnptr(target, internalformat, buffer, offset, size);
            }
            
            private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, void*, void> _CompressedTexImage3DARB_fnptr = &CompressedTexImage3DARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexImage3DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => _CompressedTexImage3DARB_fnptr(target, level, internalformat, width, height, depth, border, imageSize, data);
            [UnmanagedCallersOnly]
            private static void CompressedTexImage3DARB_Lazy(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
            {
                _CompressedTexImage3DARB_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexImage3DARB");
                _CompressedTexImage3DARB_fnptr(target, level, internalformat, width, height, depth, border, imageSize, data);
            }
            
            private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, void*, void> _CompressedTexImage2DARB_fnptr = &CompressedTexImage2DARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexImage2DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => _CompressedTexImage2DARB_fnptr(target, level, internalformat, width, height, border, imageSize, data);
            [UnmanagedCallersOnly]
            private static void CompressedTexImage2DARB_Lazy(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
            {
                _CompressedTexImage2DARB_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexImage2DARB");
                _CompressedTexImage2DARB_fnptr(target, level, internalformat, width, height, border, imageSize, data);
            }
            
            private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, void*, void> _CompressedTexImage1DARB_fnptr = &CompressedTexImage1DARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexImage1DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => _CompressedTexImage1DARB_fnptr(target, level, internalformat, width, border, imageSize, data);
            [UnmanagedCallersOnly]
            private static void CompressedTexImage1DARB_Lazy(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data)
            {
                _CompressedTexImage1DARB_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexImage1DARB");
                _CompressedTexImage1DARB_fnptr(target, level, internalformat, width, border, imageSize, data);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTexSubImage3DARB_fnptr = &CompressedTexSubImage3DARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexSubImage3DARB(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => _CompressedTexSubImage3DARB_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            [UnmanagedCallersOnly]
            private static void CompressedTexSubImage3DARB_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data)
            {
                _CompressedTexSubImage3DARB_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexSubImage3DARB");
                _CompressedTexSubImage3DARB_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTexSubImage2DARB_fnptr = &CompressedTexSubImage2DARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexSubImage2DARB(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => _CompressedTexSubImage2DARB_fnptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
            [UnmanagedCallersOnly]
            private static void CompressedTexSubImage2DARB_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data)
            {
                _CompressedTexSubImage2DARB_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexSubImage2DARB");
                _CompressedTexSubImage2DARB_fnptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, InternalFormat, int, void*, void> _CompressedTexSubImage1DARB_fnptr = &CompressedTexSubImage1DARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexSubImage1DARB(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => _CompressedTexSubImage1DARB_fnptr(target, level, xoffset, width, format, imageSize, data);
            [UnmanagedCallersOnly]
            private static void CompressedTexSubImage1DARB_Lazy(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data)
            {
                _CompressedTexSubImage1DARB_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTexSubImage1DARB");
                _CompressedTexSubImage1DARB_fnptr(target, level, xoffset, width, format, imageSize, data);
            }
            
            private static delegate* unmanaged<TextureTarget, int, void*, void> _GetCompressedTexImageARB_fnptr = &GetCompressedTexImageARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCompressedTexImageARB(TextureTarget target, int level, void* img) => _GetCompressedTexImageARB_fnptr(target, level, img);
            [UnmanagedCallersOnly]
            private static void GetCompressedTexImageARB_Lazy(TextureTarget target, int level, void* img)
            {
                _GetCompressedTexImageARB_fnptr = (delegate* unmanaged<TextureTarget, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCompressedTexImageARB");
                _GetCompressedTexImageARB_fnptr(target, level, img);
            }
            
            private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, byte, void> _TexImage2DMultisample_fnptr = &TexImage2DMultisample_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture's image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> The number of samples in the multisample texture's image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture's image, in texels. </param>
            /// <param name="height"> The height of the multisample texture's image, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml" /></remarks>
            public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, byte fixedsamplelocations) => _TexImage2DMultisample_fnptr(target, samples, internalformat, width, height, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void TexImage2DMultisample_Lazy(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, byte fixedsamplelocations)
            {
                _TexImage2DMultisample_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage2DMultisample");
                _TexImage2DMultisample_fnptr(target, samples, internalformat, width, height, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, byte, void> _TexImage3DMultisample_fnptr = &TexImage3DMultisample_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture's image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> The number of samples in the multisample texture's image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture's image, in texels. </param>
            /// <param name="height"> The height of the multisample texture's image, in texels. </param>
            /// <param name="depth">!!missing documentation!!</param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml" /></remarks>
            public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations) => _TexImage3DMultisample_fnptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void TexImage3DMultisample_Lazy(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations)
            {
                _TexImage3DMultisample_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage3DMultisample");
                _TexImage3DMultisample_fnptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<GetMultisamplePNameNV, uint, float*, void> _GetMultisamplefv_fnptr = &GetMultisamplefv_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Retrieve the location of a sample. </summary>
            /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
            /// <param name="index"> Specifies the index of the sample whose position to query. </param>
            /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml" /></remarks>
            public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => _GetMultisamplefv_fnptr(pname, index, val);
            [UnmanagedCallersOnly]
            private static void GetMultisamplefv_Lazy(GetMultisamplePNameNV pname, uint index, float* val)
            {
                _GetMultisamplefv_fnptr = (delegate* unmanaged<GetMultisamplePNameNV, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultisamplefv");
                _GetMultisamplefv_fnptr(pname, index, val);
            }
            
            private static delegate* unmanaged<uint, All, void> _SampleMaski_fnptr = &SampleMaski_Lazy;
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Set the value of a sub-word of the sample mask. </summary>
            /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
            /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml" /></remarks>
            public static void SampleMaski(uint maskNumber, All mask) => _SampleMaski_fnptr(maskNumber, mask);
            [UnmanagedCallersOnly]
            private static void SampleMaski_Lazy(uint maskNumber, All mask)
            {
                _SampleMaski_fnptr = (delegate* unmanaged<uint, All, void>)GLLoader.BindingsContext.GetProcAddress("glSampleMaski");
                _SampleMaski_fnptr(maskNumber, mask);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, void> _TexStorage1D_fnptr = &TexStorage1D_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
            public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => _TexStorage1D_fnptr(target, levels, internalformat, width);
            [UnmanagedCallersOnly]
            private static void TexStorage1D_Lazy(TextureTarget target, int levels, SizedInternalFormat internalformat, int width)
            {
                _TexStorage1D_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage1D");
                _TexStorage1D_fnptr(target, levels, internalformat, width);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, void> _TexStorage2D_fnptr = &TexStorage2D_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
            public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => _TexStorage2D_fnptr(target, levels, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void TexStorage2D_Lazy(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height)
            {
                _TexStorage2D_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage2D");
                _TexStorage2D_fnptr(target, levels, internalformat, width, height);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, void> _TexStorage3D_fnptr = &TexStorage3D_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
            public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => _TexStorage3D_fnptr(target, levels, internalformat, width, height, depth);
            [UnmanagedCallersOnly]
            private static void TexStorage3D_Lazy(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth)
            {
                _TexStorage3D_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage3D");
                _TexStorage3D_fnptr(target, levels, internalformat, width, height, depth);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, byte, void> _TexStorage2DMultisample_fnptr = &TexStorage2DMultisample_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
            public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations) => _TexStorage2DMultisample_fnptr(target, samples, internalformat, width, height, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void TexStorage2DMultisample_Lazy(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations)
            {
                _TexStorage2DMultisample_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage2DMultisample");
                _TexStorage2DMultisample_fnptr(target, samples, internalformat, width, height, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, byte, void> _TexStorage3DMultisample_fnptr = &TexStorage3DMultisample_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
            public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations) => _TexStorage3DMultisample_fnptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void TexStorage3DMultisample_Lazy(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations)
            {
                _TexStorage3DMultisample_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage3DMultisample");
                _TexStorage3DMultisample_fnptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, TextureHandle, SizedInternalFormat, uint, uint, uint, uint, void> _TextureView_fnptr = &TextureView_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view]</b> Initialize a texture as a data alias of another texture's data store. </summary>
            /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
            /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
            /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
            /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
            /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
            /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
            /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
            /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml" /></remarks>
            public static void TextureView(TextureHandle texture, TextureTarget target, TextureHandle origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => _TextureView_fnptr(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
            [UnmanagedCallersOnly]
            private static void TextureView_Lazy(TextureHandle texture, TextureTarget target, TextureHandle origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers)
            {
                _TextureView_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, TextureHandle, SizedInternalFormat, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTextureView");
                _TextureView_fnptr(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
            }
            
            private static delegate* unmanaged<QueryHandle, QueryCounterTarget, void> _QueryCounter_fnptr = &QueryCounter_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
            /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
            /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml" /></remarks>
            public static void QueryCounter(QueryHandle id, QueryCounterTarget target) => _QueryCounter_fnptr(id, target);
            [UnmanagedCallersOnly]
            private static void QueryCounter_Lazy(QueryHandle id, QueryCounterTarget target)
            {
                _QueryCounter_fnptr = (delegate* unmanaged<QueryHandle, QueryCounterTarget, void>)GLLoader.BindingsContext.GetProcAddress("glQueryCounter");
                _QueryCounter_fnptr(id, target);
            }
            
            private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, long*, void> _GetQueryObjecti64v_fnptr = &GetQueryObjecti64v_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryObjecti64v(QueryHandle id, QueryObjectParameterName pname, long* parameters) => _GetQueryObjecti64v_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetQueryObjecti64v_Lazy(QueryHandle id, QueryObjectParameterName pname, long* parameters)
            {
                _GetQueryObjecti64v_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjecti64v");
                _GetQueryObjecti64v_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, ulong*, void> _GetQueryObjectui64v_fnptr = &GetQueryObjectui64v_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryObjectui64v(QueryHandle id, QueryObjectParameterName pname, ulong* parameters) => _GetQueryObjectui64v_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetQueryObjectui64v_Lazy(QueryHandle id, QueryObjectParameterName pname, ulong* parameters)
            {
                _GetQueryObjectui64v_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjectui64v");
                _GetQueryObjectui64v_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<BindTransformFeedbackTarget, TransformFeedbackHandle, void> _BindTransformFeedback_fnptr = &BindTransformFeedback_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Bind a transform feedback object. </summary>
            /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
            /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml" /></remarks>
            public static void BindTransformFeedback(BindTransformFeedbackTarget target, TransformFeedbackHandle id) => _BindTransformFeedback_fnptr(target, id);
            [UnmanagedCallersOnly]
            private static void BindTransformFeedback_Lazy(BindTransformFeedbackTarget target, TransformFeedbackHandle id)
            {
                _BindTransformFeedback_fnptr = (delegate* unmanaged<BindTransformFeedbackTarget, TransformFeedbackHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindTransformFeedback");
                _BindTransformFeedback_fnptr(target, id);
            }
            
            private static delegate* unmanaged<int, TransformFeedbackHandle*, void> _DeleteTransformFeedbacks_fnptr = &DeleteTransformFeedbacks_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Delete transform feedback objects. </summary>
            /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
            /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml" /></remarks>
            public static void DeleteTransformFeedbacks(int n, TransformFeedbackHandle* ids) => _DeleteTransformFeedbacks_fnptr(n, ids);
            [UnmanagedCallersOnly]
            private static void DeleteTransformFeedbacks_Lazy(int n, TransformFeedbackHandle* ids)
            {
                _DeleteTransformFeedbacks_fnptr = (delegate* unmanaged<int, TransformFeedbackHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteTransformFeedbacks");
                _DeleteTransformFeedbacks_fnptr(n, ids);
            }
            
            private static delegate* unmanaged<int, TransformFeedbackHandle*, void> _GenTransformFeedbacks_fnptr = &GenTransformFeedbacks_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Reserve transform feedback object names. </summary>
            /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
            /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml" /></remarks>
            public static void GenTransformFeedbacks(int n, TransformFeedbackHandle* ids) => _GenTransformFeedbacks_fnptr(n, ids);
            [UnmanagedCallersOnly]
            private static void GenTransformFeedbacks_Lazy(int n, TransformFeedbackHandle* ids)
            {
                _GenTransformFeedbacks_fnptr = (delegate* unmanaged<int, TransformFeedbackHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenTransformFeedbacks");
                _GenTransformFeedbacks_fnptr(n, ids);
            }
            
            private static delegate* unmanaged<TransformFeedbackHandle, byte> _IsTransformFeedback_fnptr = &IsTransformFeedback_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Determine if a name corresponds to a transform feedback object. </summary>
            /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml" /></remarks>
            public static byte IsTransformFeedback(TransformFeedbackHandle id) => _IsTransformFeedback_fnptr(id);
            [UnmanagedCallersOnly]
            private static byte IsTransformFeedback_Lazy(TransformFeedbackHandle id)
            {
                _IsTransformFeedback_fnptr = (delegate* unmanaged<TransformFeedbackHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsTransformFeedback");
                return _IsTransformFeedback_fnptr(id);
            }
            
            private static delegate* unmanaged<void> _PauseTransformFeedback_fnptr = &PauseTransformFeedback_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Pause transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml" /></remarks>
            public static void PauseTransformFeedback() => _PauseTransformFeedback_fnptr();
            [UnmanagedCallersOnly]
            private static void PauseTransformFeedback_Lazy()
            {
                _PauseTransformFeedback_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPauseTransformFeedback");
                _PauseTransformFeedback_fnptr();
            }
            
            private static delegate* unmanaged<void> _ResumeTransformFeedback_fnptr = &ResumeTransformFeedback_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Resume transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml" /></remarks>
            public static void ResumeTransformFeedback() => _ResumeTransformFeedback_fnptr();
            [UnmanagedCallersOnly]
            private static void ResumeTransformFeedback_Lazy()
            {
                _ResumeTransformFeedback_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glResumeTransformFeedback");
                _ResumeTransformFeedback_fnptr();
            }
            
            private static delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, void> _DrawTransformFeedback_fnptr = &DrawTransformFeedback_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Render primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml" /></remarks>
            public static void DrawTransformFeedback(PrimitiveType mode, TransformFeedbackHandle id) => _DrawTransformFeedback_fnptr(mode, id);
            [UnmanagedCallersOnly]
            private static void DrawTransformFeedback_Lazy(PrimitiveType mode, TransformFeedbackHandle id)
            {
                _DrawTransformFeedback_fnptr = (delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTransformFeedback");
                _DrawTransformFeedback_fnptr(mode, id);
            }
            
            private static delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, uint, void> _DrawTransformFeedbackStream_fnptr = &DrawTransformFeedbackStream_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml" /></remarks>
            public static void DrawTransformFeedbackStream(PrimitiveType mode, TransformFeedbackHandle id, uint stream) => _DrawTransformFeedbackStream_fnptr(mode, id, stream);
            [UnmanagedCallersOnly]
            private static void DrawTransformFeedbackStream_Lazy(PrimitiveType mode, TransformFeedbackHandle id, uint stream)
            {
                _DrawTransformFeedbackStream_fnptr = (delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTransformFeedbackStream");
                _DrawTransformFeedbackStream_fnptr(mode, id, stream);
            }
            
            private static delegate* unmanaged<QueryTarget, uint, QueryHandle, void> _BeginQueryIndexed_fnptr = &BeginQueryIndexed_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
            public static void BeginQueryIndexed(QueryTarget target, uint index, QueryHandle id) => _BeginQueryIndexed_fnptr(target, index, id);
            [UnmanagedCallersOnly]
            private static void BeginQueryIndexed_Lazy(QueryTarget target, uint index, QueryHandle id)
            {
                _BeginQueryIndexed_fnptr = (delegate* unmanaged<QueryTarget, uint, QueryHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBeginQueryIndexed");
                _BeginQueryIndexed_fnptr(target, index, id);
            }
            
            private static delegate* unmanaged<QueryTarget, uint, void> _EndQueryIndexed_fnptr = &EndQueryIndexed_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
            public static void EndQueryIndexed(QueryTarget target, uint index) => _EndQueryIndexed_fnptr(target, index);
            [UnmanagedCallersOnly]
            private static void EndQueryIndexed_Lazy(QueryTarget target, uint index)
            {
                _EndQueryIndexed_fnptr = (delegate* unmanaged<QueryTarget, uint, void>)GLLoader.BindingsContext.GetProcAddress("glEndQueryIndexed");
                _EndQueryIndexed_fnptr(target, index);
            }
            
            private static delegate* unmanaged<QueryTarget, uint, QueryParameterName, int*, void> _GetQueryIndexediv_fnptr = &GetQueryIndexediv_Lazy;
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Return parameters of an indexed query object target. </summary>
            /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
            /// <param name="index"> Specifies the index of the query object target. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
            /// <param name="parameters"> Returns the requested data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml" /></remarks>
            public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => _GetQueryIndexediv_fnptr(target, index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetQueryIndexediv_Lazy(QueryTarget target, uint index, QueryParameterName pname, int* parameters)
            {
                _GetQueryIndexediv_fnptr = (delegate* unmanaged<QueryTarget, uint, QueryParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryIndexediv");
                _GetQueryIndexediv_fnptr(target, index, pname, parameters);
            }
            
            private static delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, int, void> _DrawTransformFeedbackInstanced_fnptr = &DrawTransformFeedbackInstanced_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml" /></remarks>
            public static void DrawTransformFeedbackInstanced(PrimitiveType mode, TransformFeedbackHandle id, int instancecount) => _DrawTransformFeedbackInstanced_fnptr(mode, id, instancecount);
            [UnmanagedCallersOnly]
            private static void DrawTransformFeedbackInstanced_Lazy(PrimitiveType mode, TransformFeedbackHandle id, int instancecount)
            {
                _DrawTransformFeedbackInstanced_fnptr = (delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTransformFeedbackInstanced");
                _DrawTransformFeedbackInstanced_fnptr(mode, id, instancecount);
            }
            
            private static delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, uint, int, void> _DrawTransformFeedbackStreamInstanced_fnptr = &DrawTransformFeedbackStreamInstanced_Lazy;
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml" /></remarks>
            public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, TransformFeedbackHandle id, uint stream, int instancecount) => _DrawTransformFeedbackStreamInstanced_fnptr(mode, id, stream, instancecount);
            [UnmanagedCallersOnly]
            private static void DrawTransformFeedbackStreamInstanced_Lazy(PrimitiveType mode, TransformFeedbackHandle id, uint stream, int instancecount)
            {
                _DrawTransformFeedbackStreamInstanced_fnptr = (delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, uint, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTransformFeedbackStreamInstanced");
                _DrawTransformFeedbackStreamInstanced_fnptr(mode, id, stream, instancecount);
            }
            
            private static delegate* unmanaged<float*, void> _LoadTransposeMatrixfARB_fnptr = &LoadTransposeMatrixfARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadTransposeMatrixfARB(float* m) => _LoadTransposeMatrixfARB_fnptr(m);
            [UnmanagedCallersOnly]
            private static void LoadTransposeMatrixfARB_Lazy(float* m)
            {
                _LoadTransposeMatrixfARB_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glLoadTransposeMatrixfARB");
                _LoadTransposeMatrixfARB_fnptr(m);
            }
            
            private static delegate* unmanaged<double*, void> _LoadTransposeMatrixdARB_fnptr = &LoadTransposeMatrixdARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadTransposeMatrixdARB(double* m) => _LoadTransposeMatrixdARB_fnptr(m);
            [UnmanagedCallersOnly]
            private static void LoadTransposeMatrixdARB_Lazy(double* m)
            {
                _LoadTransposeMatrixdARB_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glLoadTransposeMatrixdARB");
                _LoadTransposeMatrixdARB_fnptr(m);
            }
            
            private static delegate* unmanaged<float*, void> _MultTransposeMatrixfARB_fnptr = &MultTransposeMatrixfARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultTransposeMatrixfARB(float* m) => _MultTransposeMatrixfARB_fnptr(m);
            [UnmanagedCallersOnly]
            private static void MultTransposeMatrixfARB_Lazy(float* m)
            {
                _MultTransposeMatrixfARB_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultTransposeMatrixfARB");
                _MultTransposeMatrixfARB_fnptr(m);
            }
            
            private static delegate* unmanaged<double*, void> _MultTransposeMatrixdARB_fnptr = &MultTransposeMatrixdARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultTransposeMatrixdARB(double* m) => _MultTransposeMatrixdARB_fnptr(m);
            [UnmanagedCallersOnly]
            private static void MultTransposeMatrixdARB_Lazy(double* m)
            {
                _MultTransposeMatrixdARB_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultTransposeMatrixdARB");
                _MultTransposeMatrixdARB_fnptr(m);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, byte**, uint*, void> _GetUniformIndices_fnptr = &GetUniformIndices_Lazy;
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
            /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
            /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
            /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml" /></remarks>
            public static void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, uint* uniformIndices) => _GetUniformIndices_fnptr(program, uniformCount, uniformNames, uniformIndices);
            [UnmanagedCallersOnly]
            private static void GetUniformIndices_Lazy(ProgramHandle program, int uniformCount, byte** uniformNames, uint* uniformIndices)
            {
                _GetUniformIndices_fnptr = (delegate* unmanaged<ProgramHandle, int, byte**, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformIndices");
                _GetUniformIndices_fnptr(program, uniformCount, uniformNames, uniformIndices);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint*, UniformPName, int*, void> _GetActiveUniformsiv_fnptr = &GetActiveUniformsiv_Lazy;
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Returns information about several active uniform variables for the specified program object. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
            /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
            /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
            /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml" /></remarks>
            public static void GetActiveUniformsiv(ProgramHandle program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => _GetActiveUniformsiv_fnptr(program, uniformCount, uniformIndices, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetActiveUniformsiv_Lazy(ProgramHandle program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters)
            {
                _GetActiveUniformsiv_fnptr = (delegate* unmanaged<ProgramHandle, int, uint*, UniformPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniformsiv");
                _GetActiveUniformsiv_fnptr(program, uniformCount, uniformIndices, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, int, int*, byte*, void> _GetActiveUniformName_fnptr = &GetActiveUniformName_Lazy;
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Query the name of an active uniform. </summary>
            /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
            /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
            /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
            /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
            /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml" /></remarks>
            public static void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => _GetActiveUniformName_fnptr(program, uniformIndex, bufSize, length, uniformName);
            [UnmanagedCallersOnly]
            private static void GetActiveUniformName_Lazy(ProgramHandle program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
            {
                _GetActiveUniformName_fnptr = (delegate* unmanaged<ProgramHandle, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniformName");
                _GetActiveUniformName_fnptr(program, uniformIndex, bufSize, length, uniformName);
            }
            
            private static delegate* unmanaged<ProgramHandle, byte*, uint> _GetUniformBlockIndex_fnptr = &GetUniformBlockIndex_Lazy;
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml" /></remarks>
            public static uint GetUniformBlockIndex(ProgramHandle program, byte* uniformBlockName) => _GetUniformBlockIndex_fnptr(program, uniformBlockName);
            [UnmanagedCallersOnly]
            private static uint GetUniformBlockIndex_Lazy(ProgramHandle program, byte* uniformBlockName)
            {
                _GetUniformBlockIndex_fnptr = (delegate* unmanaged<ProgramHandle, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetUniformBlockIndex");
                return _GetUniformBlockIndex_fnptr(program, uniformBlockName);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, UniformBlockPName, int*, void> _GetActiveUniformBlockiv_fnptr = &GetActiveUniformBlockiv_Lazy;
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Query information about an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="pname"> Specifies the name of the parameter to query. </param>
            /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml" /></remarks>
            public static void GetActiveUniformBlockiv(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => _GetActiveUniformBlockiv_fnptr(program, uniformBlockIndex, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetActiveUniformBlockiv_Lazy(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters)
            {
                _GetActiveUniformBlockiv_fnptr = (delegate* unmanaged<ProgramHandle, uint, UniformBlockPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniformBlockiv");
                _GetActiveUniformBlockiv_fnptr(program, uniformBlockIndex, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, int, int*, byte*, void> _GetActiveUniformBlockName_fnptr = &GetActiveUniformBlockName_Lazy;
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the name of an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml" /></remarks>
            public static void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => _GetActiveUniformBlockName_fnptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
            [UnmanagedCallersOnly]
            private static void GetActiveUniformBlockName_Lazy(ProgramHandle program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
            {
                _GetActiveUniformBlockName_fnptr = (delegate* unmanaged<ProgramHandle, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveUniformBlockName");
                _GetActiveUniformBlockName_fnptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, uint, void> _UniformBlockBinding_fnptr = &UniformBlockBinding_Lazy;
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Assign a binding point to an active uniform block. </summary>
            /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
            /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
            /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml" /></remarks>
            public static void UniformBlockBinding(ProgramHandle program, uint uniformBlockIndex, uint uniformBlockBinding) => _UniformBlockBinding_fnptr(program, uniformBlockIndex, uniformBlockBinding);
            [UnmanagedCallersOnly]
            private static void UniformBlockBinding_Lazy(ProgramHandle program, uint uniformBlockIndex, uint uniformBlockBinding)
            {
                _UniformBlockBinding_fnptr = (delegate* unmanaged<ProgramHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniformBlockBinding");
                _UniformBlockBinding_fnptr(program, uniformBlockIndex, uniformBlockBinding);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, nint, void> _BindBufferRange_fnptr = &BindBufferRange_Lazy;
            /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Bind a range within a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
            /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml" /></remarks>
            public static void BindBufferRange(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size) => _BindBufferRange_fnptr(target, index, buffer, offset, size);
            [UnmanagedCallersOnly]
            private static void BindBufferRange_Lazy(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size)
            {
                _BindBufferRange_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferRange");
                _BindBufferRange_fnptr(target, index, buffer, offset, size);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, void> _BindBufferBase_fnptr = &BindBufferBase_Lazy;
            /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Bind a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml" /></remarks>
            public static void BindBufferBase(BufferTargetARB target, uint index, BufferHandle buffer) => _BindBufferBase_fnptr(target, index, buffer);
            [UnmanagedCallersOnly]
            private static void BindBufferBase_Lazy(BufferTargetARB target, uint index, BufferHandle buffer)
            {
                _BindBufferBase_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferBase");
                _BindBufferBase_fnptr(target, index, buffer);
            }
            
            private static delegate* unmanaged<GetPName, uint, int*, void> _GetIntegeri_v_fnptr = &GetIntegeri_v_Lazy;
            /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetIntegeri_v(GetPName target, uint index, int* data) => _GetIntegeri_v_fnptr(target, index, data);
            [UnmanagedCallersOnly]
            private static void GetIntegeri_v_Lazy(GetPName target, uint index, int* data)
            {
                _GetIntegeri_v_fnptr = (delegate* unmanaged<GetPName, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetIntegeri_v");
                _GetIntegeri_v_fnptr(target, index, data);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, void> _BindVertexArray_fnptr = &BindVertexArray_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Bind a vertex array object. </summary>
            /// <param name="array"> Specifies the name of the vertex array to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" /></remarks>
            public static void BindVertexArray(VertexArrayHandle array) => _BindVertexArray_fnptr(array);
            [UnmanagedCallersOnly]
            private static void BindVertexArray_Lazy(VertexArrayHandle array)
            {
                _BindVertexArray_fnptr = (delegate* unmanaged<VertexArrayHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindVertexArray");
                _BindVertexArray_fnptr(array);
            }
            
            private static delegate* unmanaged<int, VertexArrayHandle*, void> _DeleteVertexArrays_fnptr = &DeleteVertexArrays_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Delete vertex array objects. </summary>
            /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
            /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml" /></remarks>
            public static void DeleteVertexArrays(int n, VertexArrayHandle* arrays) => _DeleteVertexArrays_fnptr(n, arrays);
            [UnmanagedCallersOnly]
            private static void DeleteVertexArrays_Lazy(int n, VertexArrayHandle* arrays)
            {
                _DeleteVertexArrays_fnptr = (delegate* unmanaged<int, VertexArrayHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteVertexArrays");
                _DeleteVertexArrays_fnptr(n, arrays);
            }
            
            private static delegate* unmanaged<int, VertexArrayHandle*, void> _GenVertexArrays_fnptr = &GenVertexArrays_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Generate vertex array object names. </summary>
            /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
            /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" /></remarks>
            public static void GenVertexArrays(int n, VertexArrayHandle* arrays) => _GenVertexArrays_fnptr(n, arrays);
            [UnmanagedCallersOnly]
            private static void GenVertexArrays_Lazy(int n, VertexArrayHandle* arrays)
            {
                _GenVertexArrays_fnptr = (delegate* unmanaged<int, VertexArrayHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenVertexArrays");
                _GenVertexArrays_fnptr(n, arrays);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, byte> _IsVertexArray_fnptr = &IsVertexArray_Lazy;
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Determine if a name corresponds to a vertex array object. </summary>
            /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml" /></remarks>
            public static byte IsVertexArray(VertexArrayHandle array) => _IsVertexArray_fnptr(array);
            [UnmanagedCallersOnly]
            private static byte IsVertexArray_Lazy(VertexArrayHandle array)
            {
                _IsVertexArray_fnptr = (delegate* unmanaged<VertexArrayHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsVertexArray");
                return _IsVertexArray_fnptr(array);
            }
            
            private static delegate* unmanaged<uint, double, void> _VertexAttribL1d_fnptr = &VertexAttribL1d_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL1d(uint index, double x) => _VertexAttribL1d_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1d_Lazy(uint index, double x)
            {
                _VertexAttribL1d_fnptr = (delegate* unmanaged<uint, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1d");
                _VertexAttribL1d_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, double, double, void> _VertexAttribL2d_fnptr = &VertexAttribL2d_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL2d(uint index, double x, double y) => _VertexAttribL2d_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttribL2d_Lazy(uint index, double x, double y)
            {
                _VertexAttribL2d_fnptr = (delegate* unmanaged<uint, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2d");
                _VertexAttribL2d_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, double, double, double, void> _VertexAttribL3d_fnptr = &VertexAttribL3d_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL3d(uint index, double x, double y, double z) => _VertexAttribL3d_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttribL3d_Lazy(uint index, double x, double y, double z)
            {
                _VertexAttribL3d_fnptr = (delegate* unmanaged<uint, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3d");
                _VertexAttribL3d_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, double, double, double, double, void> _VertexAttribL4d_fnptr = &VertexAttribL4d_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => _VertexAttribL4d_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttribL4d_Lazy(uint index, double x, double y, double z, double w)
            {
                _VertexAttribL4d_fnptr = (delegate* unmanaged<uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4d");
                _VertexAttribL4d_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttribL1dv_fnptr = &VertexAttribL1dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL1dv(uint index, double* v) => _VertexAttribL1dv_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1dv_Lazy(uint index, double* v)
            {
                _VertexAttribL1dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1dv");
                _VertexAttribL1dv_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttribL2dv_fnptr = &VertexAttribL2dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL2dv(uint index, double* v) => _VertexAttribL2dv_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL2dv_Lazy(uint index, double* v)
            {
                _VertexAttribL2dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2dv");
                _VertexAttribL2dv_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttribL3dv_fnptr = &VertexAttribL3dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL3dv(uint index, double* v) => _VertexAttribL3dv_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL3dv_Lazy(uint index, double* v)
            {
                _VertexAttribL3dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3dv");
                _VertexAttribL3dv_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttribL4dv_fnptr = &VertexAttribL4dv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL4dv(uint index, double* v) => _VertexAttribL4dv_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL4dv_Lazy(uint index, double* v)
            {
                _VertexAttribL4dv_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4dv");
                _VertexAttribL4dv_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribLType, int, void*, void> _VertexAttribLPointer_fnptr = &VertexAttribLPointer_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Define an array of generic vertex attribute data. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
            /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
            /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
            /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
            public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => _VertexAttribLPointer_fnptr(index, size, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void VertexAttribLPointer_Lazy(uint index, int size, VertexAttribLType type, int stride, void* pointer)
            {
                _VertexAttribLPointer_fnptr = (delegate* unmanaged<uint, int, VertexAttribLType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribLPointer");
                _VertexAttribLPointer_fnptr(index, size, type, stride, pointer);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnum, double*, void> _GetVertexAttribLdv_fnptr = &GetVertexAttribLdv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Return a generic vertex attribute parameter. </summary>
            /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
            /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
            public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => _GetVertexAttribLdv_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribLdv_Lazy(uint index, VertexAttribEnum pname, double* parameters)
            {
                _GetVertexAttribLdv_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribLdv");
                _GetVertexAttribLdv_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, BufferHandle, IntPtr, int, void> _BindVertexBuffer_fnptr = &BindVertexBuffer_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
            public static void BindVertexBuffer(uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => _BindVertexBuffer_fnptr(bindingindex, buffer, offset, stride);
            [UnmanagedCallersOnly]
            private static void BindVertexBuffer_Lazy(uint bindingindex, BufferHandle buffer, IntPtr offset, int stride)
            {
                _BindVertexBuffer_fnptr = (delegate* unmanaged<uint, BufferHandle, IntPtr, int, void>)GLLoader.BindingsContext.GetProcAddress("glBindVertexBuffer");
                _BindVertexBuffer_fnptr(bindingindex, buffer, offset, stride);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribType, byte, uint, void> _VertexAttribFormat_fnptr = &VertexAttribFormat_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset) => _VertexAttribFormat_fnptr(attribindex, size, type, normalized, relativeoffset);
            [UnmanagedCallersOnly]
            private static void VertexAttribFormat_Lazy(uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset)
            {
                _VertexAttribFormat_fnptr = (delegate* unmanaged<uint, int, VertexAttribType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribFormat");
                _VertexAttribFormat_fnptr(attribindex, size, type, normalized, relativeoffset);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribIType, uint, void> _VertexAttribIFormat_fnptr = &VertexAttribIFormat_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => _VertexAttribIFormat_fnptr(attribindex, size, type, relativeoffset);
            [UnmanagedCallersOnly]
            private static void VertexAttribIFormat_Lazy(uint attribindex, int size, VertexAttribIType type, uint relativeoffset)
            {
                _VertexAttribIFormat_fnptr = (delegate* unmanaged<uint, int, VertexAttribIType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribIFormat");
                _VertexAttribIFormat_fnptr(attribindex, size, type, relativeoffset);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribLType, uint, void> _VertexAttribLFormat_fnptr = &VertexAttribLFormat_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => _VertexAttribLFormat_fnptr(attribindex, size, type, relativeoffset);
            [UnmanagedCallersOnly]
            private static void VertexAttribLFormat_Lazy(uint attribindex, int size, VertexAttribLType type, uint relativeoffset)
            {
                _VertexAttribLFormat_fnptr = (delegate* unmanaged<uint, int, VertexAttribLType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribLFormat");
                _VertexAttribLFormat_fnptr(attribindex, size, type, relativeoffset);
            }
            
            private static delegate* unmanaged<uint, uint, void> _VertexAttribBinding_fnptr = &VertexAttribBinding_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
            public static void VertexAttribBinding(uint attribindex, uint bindingindex) => _VertexAttribBinding_fnptr(attribindex, bindingindex);
            [UnmanagedCallersOnly]
            private static void VertexAttribBinding_Lazy(uint attribindex, uint bindingindex)
            {
                _VertexAttribBinding_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribBinding");
                _VertexAttribBinding_fnptr(attribindex, bindingindex);
            }
            
            private static delegate* unmanaged<uint, uint, void> _VertexBindingDivisor_fnptr = &VertexBindingDivisor_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
            public static void VertexBindingDivisor(uint bindingindex, uint divisor) => _VertexBindingDivisor_fnptr(bindingindex, divisor);
            [UnmanagedCallersOnly]
            private static void VertexBindingDivisor_Lazy(uint bindingindex, uint divisor)
            {
                _VertexBindingDivisor_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexBindingDivisor");
                _VertexBindingDivisor_fnptr(bindingindex, divisor);
            }
            
            private static delegate* unmanaged<int, sbyte*, void> _WeightbvARB_fnptr = &WeightbvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightbvARB(int size, sbyte* weights) => _WeightbvARB_fnptr(size, weights);
            [UnmanagedCallersOnly]
            private static void WeightbvARB_Lazy(int size, sbyte* weights)
            {
                _WeightbvARB_fnptr = (delegate* unmanaged<int, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightbvARB");
                _WeightbvARB_fnptr(size, weights);
            }
            
            private static delegate* unmanaged<int, short*, void> _WeightsvARB_fnptr = &WeightsvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightsvARB(int size, short* weights) => _WeightsvARB_fnptr(size, weights);
            [UnmanagedCallersOnly]
            private static void WeightsvARB_Lazy(int size, short* weights)
            {
                _WeightsvARB_fnptr = (delegate* unmanaged<int, short*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightsvARB");
                _WeightsvARB_fnptr(size, weights);
            }
            
            private static delegate* unmanaged<int, int*, void> _WeightivARB_fnptr = &WeightivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightivARB(int size, int* weights) => _WeightivARB_fnptr(size, weights);
            [UnmanagedCallersOnly]
            private static void WeightivARB_Lazy(int size, int* weights)
            {
                _WeightivARB_fnptr = (delegate* unmanaged<int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightivARB");
                _WeightivARB_fnptr(size, weights);
            }
            
            private static delegate* unmanaged<int, float*, void> _WeightfvARB_fnptr = &WeightfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightfvARB(int size, float* weights) => _WeightfvARB_fnptr(size, weights);
            [UnmanagedCallersOnly]
            private static void WeightfvARB_Lazy(int size, float* weights)
            {
                _WeightfvARB_fnptr = (delegate* unmanaged<int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightfvARB");
                _WeightfvARB_fnptr(size, weights);
            }
            
            private static delegate* unmanaged<int, double*, void> _WeightdvARB_fnptr = &WeightdvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightdvARB(int size, double* weights) => _WeightdvARB_fnptr(size, weights);
            [UnmanagedCallersOnly]
            private static void WeightdvARB_Lazy(int size, double* weights)
            {
                _WeightdvARB_fnptr = (delegate* unmanaged<int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightdvARB");
                _WeightdvARB_fnptr(size, weights);
            }
            
            private static delegate* unmanaged<int, byte*, void> _WeightubvARB_fnptr = &WeightubvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightubvARB(int size, byte* weights) => _WeightubvARB_fnptr(size, weights);
            [UnmanagedCallersOnly]
            private static void WeightubvARB_Lazy(int size, byte* weights)
            {
                _WeightubvARB_fnptr = (delegate* unmanaged<int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightubvARB");
                _WeightubvARB_fnptr(size, weights);
            }
            
            private static delegate* unmanaged<int, ushort*, void> _WeightusvARB_fnptr = &WeightusvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightusvARB(int size, ushort* weights) => _WeightusvARB_fnptr(size, weights);
            [UnmanagedCallersOnly]
            private static void WeightusvARB_Lazy(int size, ushort* weights)
            {
                _WeightusvARB_fnptr = (delegate* unmanaged<int, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightusvARB");
                _WeightusvARB_fnptr(size, weights);
            }
            
            private static delegate* unmanaged<int, uint*, void> _WeightuivARB_fnptr = &WeightuivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightuivARB(int size, uint* weights) => _WeightuivARB_fnptr(size, weights);
            [UnmanagedCallersOnly]
            private static void WeightuivARB_Lazy(int size, uint* weights)
            {
                _WeightuivARB_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightuivARB");
                _WeightuivARB_fnptr(size, weights);
            }
            
            private static delegate* unmanaged<int, WeightPointerTypeARB, int, void*, void> _WeightPointerARB_fnptr = &WeightPointerARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightPointerARB(int size, WeightPointerTypeARB type, int stride, void* pointer) => _WeightPointerARB_fnptr(size, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void WeightPointerARB_Lazy(int size, WeightPointerTypeARB type, int stride, void* pointer)
            {
                _WeightPointerARB_fnptr = (delegate* unmanaged<int, WeightPointerTypeARB, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightPointerARB");
                _WeightPointerARB_fnptr(size, type, stride, pointer);
            }
            
            private static delegate* unmanaged<int, void> _VertexBlendARB_fnptr = &VertexBlendARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexBlendARB(int count) => _VertexBlendARB_fnptr(count);
            [UnmanagedCallersOnly]
            private static void VertexBlendARB_Lazy(int count)
            {
                _VertexBlendARB_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexBlendARB");
                _VertexBlendARB_fnptr(count);
            }
            
            private static delegate* unmanaged<BufferTargetARB, BufferHandle, void> _BindBufferARB_fnptr = &BindBufferARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferARB(BufferTargetARB target, BufferHandle buffer) => _BindBufferARB_fnptr(target, buffer);
            [UnmanagedCallersOnly]
            private static void BindBufferARB_Lazy(BufferTargetARB target, BufferHandle buffer)
            {
                _BindBufferARB_fnptr = (delegate* unmanaged<BufferTargetARB, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferARB");
                _BindBufferARB_fnptr(target, buffer);
            }
            
            private static delegate* unmanaged<int, BufferHandle*, void> _DeleteBuffersARB_fnptr = &DeleteBuffersARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteBuffersARB(int n, BufferHandle* buffers) => _DeleteBuffersARB_fnptr(n, buffers);
            [UnmanagedCallersOnly]
            private static void DeleteBuffersARB_Lazy(int n, BufferHandle* buffers)
            {
                _DeleteBuffersARB_fnptr = (delegate* unmanaged<int, BufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteBuffersARB");
                _DeleteBuffersARB_fnptr(n, buffers);
            }
            
            private static delegate* unmanaged<int, BufferHandle*, void> _GenBuffersARB_fnptr = &GenBuffersARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenBuffersARB(int n, BufferHandle* buffers) => _GenBuffersARB_fnptr(n, buffers);
            [UnmanagedCallersOnly]
            private static void GenBuffersARB_Lazy(int n, BufferHandle* buffers)
            {
                _GenBuffersARB_fnptr = (delegate* unmanaged<int, BufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenBuffersARB");
                _GenBuffersARB_fnptr(n, buffers);
            }
            
            private static delegate* unmanaged<BufferHandle, byte> _IsBufferARB_fnptr = &IsBufferARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsBufferARB(BufferHandle buffer) => _IsBufferARB_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static byte IsBufferARB_Lazy(BufferHandle buffer)
            {
                _IsBufferARB_fnptr = (delegate* unmanaged<BufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsBufferARB");
                return _IsBufferARB_fnptr(buffer);
            }
            
            private static delegate* unmanaged<BufferTargetARB, nint, void*, BufferUsageARB, void> _BufferDataARB_fnptr = &BufferDataARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferDataARB(BufferTargetARB target, nint size, void* data, BufferUsageARB usage) => _BufferDataARB_fnptr(target, size, data, usage);
            [UnmanagedCallersOnly]
            private static void BufferDataARB_Lazy(BufferTargetARB target, nint size, void* data, BufferUsageARB usage)
            {
                _BufferDataARB_fnptr = (delegate* unmanaged<BufferTargetARB, nint, void*, BufferUsageARB, void>)GLLoader.BindingsContext.GetProcAddress("glBufferDataARB");
                _BufferDataARB_fnptr(target, size, data, usage);
            }
            
            private static delegate* unmanaged<BufferTargetARB, IntPtr, nint, void*, void> _BufferSubDataARB_fnptr = &BufferSubDataARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferSubDataARB(BufferTargetARB target, IntPtr offset, nint size, void* data) => _BufferSubDataARB_fnptr(target, offset, size, data);
            [UnmanagedCallersOnly]
            private static void BufferSubDataARB_Lazy(BufferTargetARB target, IntPtr offset, nint size, void* data)
            {
                _BufferSubDataARB_fnptr = (delegate* unmanaged<BufferTargetARB, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glBufferSubDataARB");
                _BufferSubDataARB_fnptr(target, offset, size, data);
            }
            
            private static delegate* unmanaged<BufferTargetARB, IntPtr, nint, void*, void> _GetBufferSubDataARB_fnptr = &GetBufferSubDataARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBufferSubDataARB(BufferTargetARB target, IntPtr offset, nint size, void* data) => _GetBufferSubDataARB_fnptr(target, offset, size, data);
            [UnmanagedCallersOnly]
            private static void GetBufferSubDataARB_Lazy(BufferTargetARB target, IntPtr offset, nint size, void* data)
            {
                _GetBufferSubDataARB_fnptr = (delegate* unmanaged<BufferTargetARB, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetBufferSubDataARB");
                _GetBufferSubDataARB_fnptr(target, offset, size, data);
            }
            
            private static delegate* unmanaged<BufferTargetARB, BufferAccessARB, void*> _MapBufferARB_fnptr = &MapBufferARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapBufferARB(BufferTargetARB target, BufferAccessARB access) => _MapBufferARB_fnptr(target, access);
            [UnmanagedCallersOnly]
            private static void* MapBufferARB_Lazy(BufferTargetARB target, BufferAccessARB access)
            {
                _MapBufferARB_fnptr = (delegate* unmanaged<BufferTargetARB, BufferAccessARB, void*>)GLLoader.BindingsContext.GetProcAddress("glMapBufferARB");
                return _MapBufferARB_fnptr(target, access);
            }
            
            private static delegate* unmanaged<BufferTargetARB, byte> _UnmapBufferARB_fnptr = &UnmapBufferARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte UnmapBufferARB(BufferTargetARB target) => _UnmapBufferARB_fnptr(target);
            [UnmanagedCallersOnly]
            private static byte UnmapBufferARB_Lazy(BufferTargetARB target)
            {
                _UnmapBufferARB_fnptr = (delegate* unmanaged<BufferTargetARB, byte>)GLLoader.BindingsContext.GetProcAddress("glUnmapBufferARB");
                return _UnmapBufferARB_fnptr(target);
            }
            
            private static delegate* unmanaged<BufferTargetARB, BufferPNameARB, int*, void> _GetBufferParameterivARB_fnptr = &GetBufferParameterivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBufferParameterivARB(BufferTargetARB target, BufferPNameARB pname, int* parameters) => _GetBufferParameterivARB_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetBufferParameterivARB_Lazy(BufferTargetARB target, BufferPNameARB pname, int* parameters)
            {
                _GetBufferParameterivARB_fnptr = (delegate* unmanaged<BufferTargetARB, BufferPNameARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetBufferParameterivARB");
                _GetBufferParameterivARB_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferTargetARB, BufferPointerNameARB, void**, void> _GetBufferPointervARB_fnptr = &GetBufferPointervARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBufferPointervARB(BufferTargetARB target, BufferPointerNameARB pname, void** parameters) => _GetBufferPointervARB_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetBufferPointervARB_Lazy(BufferTargetARB target, BufferPointerNameARB pname, void** parameters)
            {
                _GetBufferPointervARB_fnptr = (delegate* unmanaged<BufferTargetARB, BufferPointerNameARB, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetBufferPointervARB");
                _GetBufferPointervARB_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, double, void> _VertexAttrib1dARB_fnptr = &VertexAttrib1dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1dARB(uint index, double x) => _VertexAttrib1dARB_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1dARB_Lazy(uint index, double x)
            {
                _VertexAttrib1dARB_fnptr = (delegate* unmanaged<uint, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1dARB");
                _VertexAttrib1dARB_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttrib1dvARB_fnptr = &VertexAttrib1dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1dvARB(uint index, double* v) => _VertexAttrib1dvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1dvARB_Lazy(uint index, double* v)
            {
                _VertexAttrib1dvARB_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1dvARB");
                _VertexAttrib1dvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, float, void> _VertexAttrib1fARB_fnptr = &VertexAttrib1fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1fARB(uint index, float x) => _VertexAttrib1fARB_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1fARB_Lazy(uint index, float x)
            {
                _VertexAttrib1fARB_fnptr = (delegate* unmanaged<uint, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1fARB");
                _VertexAttrib1fARB_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, float*, void> _VertexAttrib1fvARB_fnptr = &VertexAttrib1fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1fvARB(uint index, float* v) => _VertexAttrib1fvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1fvARB_Lazy(uint index, float* v)
            {
                _VertexAttrib1fvARB_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1fvARB");
                _VertexAttrib1fvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short, void> _VertexAttrib1sARB_fnptr = &VertexAttrib1sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1sARB(uint index, short x) => _VertexAttrib1sARB_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1sARB_Lazy(uint index, short x)
            {
                _VertexAttrib1sARB_fnptr = (delegate* unmanaged<uint, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1sARB");
                _VertexAttrib1sARB_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttrib1svARB_fnptr = &VertexAttrib1svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1svARB(uint index, short* v) => _VertexAttrib1svARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1svARB_Lazy(uint index, short* v)
            {
                _VertexAttrib1svARB_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1svARB");
                _VertexAttrib1svARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double, double, void> _VertexAttrib2dARB_fnptr = &VertexAttrib2dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2dARB(uint index, double x, double y) => _VertexAttrib2dARB_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2dARB_Lazy(uint index, double x, double y)
            {
                _VertexAttrib2dARB_fnptr = (delegate* unmanaged<uint, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2dARB");
                _VertexAttrib2dARB_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttrib2dvARB_fnptr = &VertexAttrib2dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2dvARB(uint index, double* v) => _VertexAttrib2dvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2dvARB_Lazy(uint index, double* v)
            {
                _VertexAttrib2dvARB_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2dvARB");
                _VertexAttrib2dvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, float, float, void> _VertexAttrib2fARB_fnptr = &VertexAttrib2fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2fARB(uint index, float x, float y) => _VertexAttrib2fARB_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2fARB_Lazy(uint index, float x, float y)
            {
                _VertexAttrib2fARB_fnptr = (delegate* unmanaged<uint, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2fARB");
                _VertexAttrib2fARB_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, float*, void> _VertexAttrib2fvARB_fnptr = &VertexAttrib2fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2fvARB(uint index, float* v) => _VertexAttrib2fvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2fvARB_Lazy(uint index, float* v)
            {
                _VertexAttrib2fvARB_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2fvARB");
                _VertexAttrib2fvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short, short, void> _VertexAttrib2sARB_fnptr = &VertexAttrib2sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2sARB(uint index, short x, short y) => _VertexAttrib2sARB_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2sARB_Lazy(uint index, short x, short y)
            {
                _VertexAttrib2sARB_fnptr = (delegate* unmanaged<uint, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2sARB");
                _VertexAttrib2sARB_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttrib2svARB_fnptr = &VertexAttrib2svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2svARB(uint index, short* v) => _VertexAttrib2svARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2svARB_Lazy(uint index, short* v)
            {
                _VertexAttrib2svARB_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2svARB");
                _VertexAttrib2svARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double, double, double, void> _VertexAttrib3dARB_fnptr = &VertexAttrib3dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3dARB(uint index, double x, double y, double z) => _VertexAttrib3dARB_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3dARB_Lazy(uint index, double x, double y, double z)
            {
                _VertexAttrib3dARB_fnptr = (delegate* unmanaged<uint, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3dARB");
                _VertexAttrib3dARB_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttrib3dvARB_fnptr = &VertexAttrib3dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3dvARB(uint index, double* v) => _VertexAttrib3dvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3dvARB_Lazy(uint index, double* v)
            {
                _VertexAttrib3dvARB_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3dvARB");
                _VertexAttrib3dvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, void> _VertexAttrib3fARB_fnptr = &VertexAttrib3fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3fARB(uint index, float x, float y, float z) => _VertexAttrib3fARB_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3fARB_Lazy(uint index, float x, float y, float z)
            {
                _VertexAttrib3fARB_fnptr = (delegate* unmanaged<uint, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3fARB");
                _VertexAttrib3fARB_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, float*, void> _VertexAttrib3fvARB_fnptr = &VertexAttrib3fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3fvARB(uint index, float* v) => _VertexAttrib3fvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3fvARB_Lazy(uint index, float* v)
            {
                _VertexAttrib3fvARB_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3fvARB");
                _VertexAttrib3fvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short, short, short, void> _VertexAttrib3sARB_fnptr = &VertexAttrib3sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3sARB(uint index, short x, short y, short z) => _VertexAttrib3sARB_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3sARB_Lazy(uint index, short x, short y, short z)
            {
                _VertexAttrib3sARB_fnptr = (delegate* unmanaged<uint, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3sARB");
                _VertexAttrib3sARB_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttrib3svARB_fnptr = &VertexAttrib3svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3svARB(uint index, short* v) => _VertexAttrib3svARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3svARB_Lazy(uint index, short* v)
            {
                _VertexAttrib3svARB_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3svARB");
                _VertexAttrib3svARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, sbyte*, void> _VertexAttrib4NbvARB_fnptr = &VertexAttrib4NbvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NbvARB(uint index, sbyte* v) => _VertexAttrib4NbvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4NbvARB_Lazy(uint index, sbyte* v)
            {
                _VertexAttrib4NbvARB_fnptr = (delegate* unmanaged<uint, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4NbvARB");
                _VertexAttrib4NbvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttrib4NivARB_fnptr = &VertexAttrib4NivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NivARB(uint index, int* v) => _VertexAttrib4NivARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4NivARB_Lazy(uint index, int* v)
            {
                _VertexAttrib4NivARB_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4NivARB");
                _VertexAttrib4NivARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttrib4NsvARB_fnptr = &VertexAttrib4NsvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NsvARB(uint index, short* v) => _VertexAttrib4NsvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4NsvARB_Lazy(uint index, short* v)
            {
                _VertexAttrib4NsvARB_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4NsvARB");
                _VertexAttrib4NsvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, byte, byte, byte, byte, void> _VertexAttrib4NubARB_fnptr = &VertexAttrib4NubARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NubARB(uint index, byte x, byte y, byte z, byte w) => _VertexAttrib4NubARB_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4NubARB_Lazy(uint index, byte x, byte y, byte z, byte w)
            {
                _VertexAttrib4NubARB_fnptr = (delegate* unmanaged<uint, byte, byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4NubARB");
                _VertexAttrib4NubARB_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, byte*, void> _VertexAttrib4NubvARB_fnptr = &VertexAttrib4NubvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NubvARB(uint index, byte* v) => _VertexAttrib4NubvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4NubvARB_Lazy(uint index, byte* v)
            {
                _VertexAttrib4NubvARB_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4NubvARB");
                _VertexAttrib4NubvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttrib4NuivARB_fnptr = &VertexAttrib4NuivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NuivARB(uint index, uint* v) => _VertexAttrib4NuivARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4NuivARB_Lazy(uint index, uint* v)
            {
                _VertexAttrib4NuivARB_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4NuivARB");
                _VertexAttrib4NuivARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, ushort*, void> _VertexAttrib4NusvARB_fnptr = &VertexAttrib4NusvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NusvARB(uint index, ushort* v) => _VertexAttrib4NusvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4NusvARB_Lazy(uint index, ushort* v)
            {
                _VertexAttrib4NusvARB_fnptr = (delegate* unmanaged<uint, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4NusvARB");
                _VertexAttrib4NusvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, sbyte*, void> _VertexAttrib4bvARB_fnptr = &VertexAttrib4bvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4bvARB(uint index, sbyte* v) => _VertexAttrib4bvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4bvARB_Lazy(uint index, sbyte* v)
            {
                _VertexAttrib4bvARB_fnptr = (delegate* unmanaged<uint, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4bvARB");
                _VertexAttrib4bvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double, double, double, double, void> _VertexAttrib4dARB_fnptr = &VertexAttrib4dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4dARB(uint index, double x, double y, double z, double w) => _VertexAttrib4dARB_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4dARB_Lazy(uint index, double x, double y, double z, double w)
            {
                _VertexAttrib4dARB_fnptr = (delegate* unmanaged<uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4dARB");
                _VertexAttrib4dARB_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttrib4dvARB_fnptr = &VertexAttrib4dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4dvARB(uint index, double* v) => _VertexAttrib4dvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4dvARB_Lazy(uint index, double* v)
            {
                _VertexAttrib4dvARB_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4dvARB");
                _VertexAttrib4dvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, float, void> _VertexAttrib4fARB_fnptr = &VertexAttrib4fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4fARB(uint index, float x, float y, float z, float w) => _VertexAttrib4fARB_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4fARB_Lazy(uint index, float x, float y, float z, float w)
            {
                _VertexAttrib4fARB_fnptr = (delegate* unmanaged<uint, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4fARB");
                _VertexAttrib4fARB_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, float*, void> _VertexAttrib4fvARB_fnptr = &VertexAttrib4fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4fvARB(uint index, float* v) => _VertexAttrib4fvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4fvARB_Lazy(uint index, float* v)
            {
                _VertexAttrib4fvARB_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4fvARB");
                _VertexAttrib4fvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttrib4ivARB_fnptr = &VertexAttrib4ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4ivARB(uint index, int* v) => _VertexAttrib4ivARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4ivARB_Lazy(uint index, int* v)
            {
                _VertexAttrib4ivARB_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4ivARB");
                _VertexAttrib4ivARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short, short, short, short, void> _VertexAttrib4sARB_fnptr = &VertexAttrib4sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4sARB(uint index, short x, short y, short z, short w) => _VertexAttrib4sARB_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4sARB_Lazy(uint index, short x, short y, short z, short w)
            {
                _VertexAttrib4sARB_fnptr = (delegate* unmanaged<uint, short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4sARB");
                _VertexAttrib4sARB_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttrib4svARB_fnptr = &VertexAttrib4svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4svARB(uint index, short* v) => _VertexAttrib4svARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4svARB_Lazy(uint index, short* v)
            {
                _VertexAttrib4svARB_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4svARB");
                _VertexAttrib4svARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, byte*, void> _VertexAttrib4ubvARB_fnptr = &VertexAttrib4ubvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4ubvARB(uint index, byte* v) => _VertexAttrib4ubvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4ubvARB_Lazy(uint index, byte* v)
            {
                _VertexAttrib4ubvARB_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4ubvARB");
                _VertexAttrib4ubvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttrib4uivARB_fnptr = &VertexAttrib4uivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4uivARB(uint index, uint* v) => _VertexAttrib4uivARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4uivARB_Lazy(uint index, uint* v)
            {
                _VertexAttrib4uivARB_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4uivARB");
                _VertexAttrib4uivARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, ushort*, void> _VertexAttrib4usvARB_fnptr = &VertexAttrib4usvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4usvARB(uint index, ushort* v) => _VertexAttrib4usvARB_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4usvARB_Lazy(uint index, ushort* v)
            {
                _VertexAttrib4usvARB_fnptr = (delegate* unmanaged<uint, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4usvARB");
                _VertexAttrib4usvARB_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribPointerType, byte, int, void*, void> _VertexAttribPointerARB_fnptr = &VertexAttribPointerARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribPointerARB(uint index, int size, VertexAttribPointerType type, byte normalized, int stride, void* pointer) => _VertexAttribPointerARB_fnptr(index, size, type, normalized, stride, pointer);
            [UnmanagedCallersOnly]
            private static void VertexAttribPointerARB_Lazy(uint index, int size, VertexAttribPointerType type, byte normalized, int stride, void* pointer)
            {
                _VertexAttribPointerARB_fnptr = (delegate* unmanaged<uint, int, VertexAttribPointerType, byte, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribPointerARB");
                _VertexAttribPointerARB_fnptr(index, size, type, normalized, stride, pointer);
            }
            
            private static delegate* unmanaged<uint, void> _EnableVertexAttribArrayARB_fnptr = &EnableVertexAttribArrayARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVertexAttribArrayARB(uint index) => _EnableVertexAttribArrayARB_fnptr(index);
            [UnmanagedCallersOnly]
            private static void EnableVertexAttribArrayARB_Lazy(uint index)
            {
                _EnableVertexAttribArrayARB_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnableVertexAttribArrayARB");
                _EnableVertexAttribArrayARB_fnptr(index);
            }
            
            private static delegate* unmanaged<uint, void> _DisableVertexAttribArrayARB_fnptr = &DisableVertexAttribArrayARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVertexAttribArrayARB(uint index) => _DisableVertexAttribArrayARB_fnptr(index);
            [UnmanagedCallersOnly]
            private static void DisableVertexAttribArrayARB_Lazy(uint index)
            {
                _DisableVertexAttribArrayARB_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisableVertexAttribArrayARB");
                _DisableVertexAttribArrayARB_fnptr(index);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPropertyARB, double*, void> _GetVertexAttribdvARB_fnptr = &GetVertexAttribdvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, double* parameters) => _GetVertexAttribdvARB_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribdvARB_Lazy(uint index, VertexAttribPropertyARB pname, double* parameters)
            {
                _GetVertexAttribdvARB_fnptr = (delegate* unmanaged<uint, VertexAttribPropertyARB, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribdvARB");
                _GetVertexAttribdvARB_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPropertyARB, float*, void> _GetVertexAttribfvARB_fnptr = &GetVertexAttribfvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, float* parameters) => _GetVertexAttribfvARB_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribfvARB_Lazy(uint index, VertexAttribPropertyARB pname, float* parameters)
            {
                _GetVertexAttribfvARB_fnptr = (delegate* unmanaged<uint, VertexAttribPropertyARB, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribfvARB");
                _GetVertexAttribfvARB_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPropertyARB, int*, void> _GetVertexAttribivARB_fnptr = &GetVertexAttribivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, int* parameters) => _GetVertexAttribivARB_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribivARB_Lazy(uint index, VertexAttribPropertyARB pname, int* parameters)
            {
                _GetVertexAttribivARB_fnptr = (delegate* unmanaged<uint, VertexAttribPropertyARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribivARB");
                _GetVertexAttribivARB_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPointerPropertyARB, void**, void> _GetVertexAttribPointervARB_fnptr = &GetVertexAttribPointervARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribPointervARB(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => _GetVertexAttribPointervARB_fnptr(index, pname, pointer);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribPointervARB_Lazy(uint index, VertexAttribPointerPropertyARB pname, void** pointer)
            {
                _GetVertexAttribPointervARB_fnptr = (delegate* unmanaged<uint, VertexAttribPointerPropertyARB, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribPointervARB");
                _GetVertexAttribPointervARB_fnptr(index, pname, pointer);
            }
            
            private static delegate* unmanaged<GLHandleARB, uint, byte*, void> _BindAttribLocationARB_fnptr = &BindAttribLocationARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindAttribLocationARB(GLHandleARB programObj, uint index, byte* name) => _BindAttribLocationARB_fnptr(programObj, index, name);
            [UnmanagedCallersOnly]
            private static void BindAttribLocationARB_Lazy(GLHandleARB programObj, uint index, byte* name)
            {
                _BindAttribLocationARB_fnptr = (delegate* unmanaged<GLHandleARB, uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glBindAttribLocationARB");
                _BindAttribLocationARB_fnptr(programObj, index, name);
            }
            
            private static delegate* unmanaged<GLHandleARB, uint, int, int*, int*, AttributeType*, byte*, void> _GetActiveAttribARB_fnptr = &GetActiveAttribARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, AttributeType* type, byte* name) => _GetActiveAttribARB_fnptr(programObj, index, maxLength, length, size, type, name);
            [UnmanagedCallersOnly]
            private static void GetActiveAttribARB_Lazy(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, AttributeType* type, byte* name)
            {
                _GetActiveAttribARB_fnptr = (delegate* unmanaged<GLHandleARB, uint, int, int*, int*, AttributeType*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveAttribARB");
                _GetActiveAttribARB_fnptr(programObj, index, maxLength, length, size, type, name);
            }
            
            private static delegate* unmanaged<GLHandleARB, byte*, int> _GetAttribLocationARB_fnptr = &GetAttribLocationARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetAttribLocationARB(GLHandleARB programObj, byte* name) => _GetAttribLocationARB_fnptr(programObj, name);
            [UnmanagedCallersOnly]
            private static int GetAttribLocationARB_Lazy(GLHandleARB programObj, byte* name)
            {
                _GetAttribLocationARB_fnptr = (delegate* unmanaged<GLHandleARB, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetAttribLocationARB");
                return _GetAttribLocationARB_fnptr(programObj, name);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void> _VertexAttribP1ui_fnptr = &VertexAttribP1ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, byte normalized, uint value) => _VertexAttribP1ui_fnptr(index, type, normalized, value);
            [UnmanagedCallersOnly]
            private static void VertexAttribP1ui_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint value)
            {
                _VertexAttribP1ui_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP1ui");
                _VertexAttribP1ui_fnptr(index, type, normalized, value);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void> _VertexAttribP1uiv_fnptr = &VertexAttribP1uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, byte normalized, uint* value) => _VertexAttribP1uiv_fnptr(index, type, normalized, value);
            [UnmanagedCallersOnly]
            private static void VertexAttribP1uiv_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint* value)
            {
                _VertexAttribP1uiv_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP1uiv");
                _VertexAttribP1uiv_fnptr(index, type, normalized, value);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void> _VertexAttribP2ui_fnptr = &VertexAttribP2ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, byte normalized, uint value) => _VertexAttribP2ui_fnptr(index, type, normalized, value);
            [UnmanagedCallersOnly]
            private static void VertexAttribP2ui_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint value)
            {
                _VertexAttribP2ui_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP2ui");
                _VertexAttribP2ui_fnptr(index, type, normalized, value);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void> _VertexAttribP2uiv_fnptr = &VertexAttribP2uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, byte normalized, uint* value) => _VertexAttribP2uiv_fnptr(index, type, normalized, value);
            [UnmanagedCallersOnly]
            private static void VertexAttribP2uiv_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint* value)
            {
                _VertexAttribP2uiv_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP2uiv");
                _VertexAttribP2uiv_fnptr(index, type, normalized, value);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void> _VertexAttribP3ui_fnptr = &VertexAttribP3ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, byte normalized, uint value) => _VertexAttribP3ui_fnptr(index, type, normalized, value);
            [UnmanagedCallersOnly]
            private static void VertexAttribP3ui_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint value)
            {
                _VertexAttribP3ui_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP3ui");
                _VertexAttribP3ui_fnptr(index, type, normalized, value);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void> _VertexAttribP3uiv_fnptr = &VertexAttribP3uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, byte normalized, uint* value) => _VertexAttribP3uiv_fnptr(index, type, normalized, value);
            [UnmanagedCallersOnly]
            private static void VertexAttribP3uiv_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint* value)
            {
                _VertexAttribP3uiv_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP3uiv");
                _VertexAttribP3uiv_fnptr(index, type, normalized, value);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void> _VertexAttribP4ui_fnptr = &VertexAttribP4ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, byte normalized, uint value) => _VertexAttribP4ui_fnptr(index, type, normalized, value);
            [UnmanagedCallersOnly]
            private static void VertexAttribP4ui_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint value)
            {
                _VertexAttribP4ui_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP4ui");
                _VertexAttribP4ui_fnptr(index, type, normalized, value);
            }
            
            private static delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void> _VertexAttribP4uiv_fnptr = &VertexAttribP4uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, byte normalized, uint* value) => _VertexAttribP4uiv_fnptr(index, type, normalized, value);
            [UnmanagedCallersOnly]
            private static void VertexAttribP4uiv_Lazy(uint index, VertexAttribPointerType type, byte normalized, uint* value)
            {
                _VertexAttribP4uiv_fnptr = (delegate* unmanaged<uint, VertexAttribPointerType, byte, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribP4uiv");
                _VertexAttribP4uiv_fnptr(index, type, normalized, value);
            }
            
            private static delegate* unmanaged<VertexPointerType, uint, void> _VertexP2ui_fnptr = &VertexP2ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexP2ui(VertexPointerType type, uint value) => _VertexP2ui_fnptr(type, value);
            [UnmanagedCallersOnly]
            private static void VertexP2ui_Lazy(VertexPointerType type, uint value)
            {
                _VertexP2ui_fnptr = (delegate* unmanaged<VertexPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP2ui");
                _VertexP2ui_fnptr(type, value);
            }
            
            private static delegate* unmanaged<VertexPointerType, uint*, void> _VertexP2uiv_fnptr = &VertexP2uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexP2uiv(VertexPointerType type, uint* value) => _VertexP2uiv_fnptr(type, value);
            [UnmanagedCallersOnly]
            private static void VertexP2uiv_Lazy(VertexPointerType type, uint* value)
            {
                _VertexP2uiv_fnptr = (delegate* unmanaged<VertexPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP2uiv");
                _VertexP2uiv_fnptr(type, value);
            }
            
            private static delegate* unmanaged<VertexPointerType, uint, void> _VertexP3ui_fnptr = &VertexP3ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexP3ui(VertexPointerType type, uint value) => _VertexP3ui_fnptr(type, value);
            [UnmanagedCallersOnly]
            private static void VertexP3ui_Lazy(VertexPointerType type, uint value)
            {
                _VertexP3ui_fnptr = (delegate* unmanaged<VertexPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP3ui");
                _VertexP3ui_fnptr(type, value);
            }
            
            private static delegate* unmanaged<VertexPointerType, uint*, void> _VertexP3uiv_fnptr = &VertexP3uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexP3uiv(VertexPointerType type, uint* value) => _VertexP3uiv_fnptr(type, value);
            [UnmanagedCallersOnly]
            private static void VertexP3uiv_Lazy(VertexPointerType type, uint* value)
            {
                _VertexP3uiv_fnptr = (delegate* unmanaged<VertexPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP3uiv");
                _VertexP3uiv_fnptr(type, value);
            }
            
            private static delegate* unmanaged<VertexPointerType, uint, void> _VertexP4ui_fnptr = &VertexP4ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexP4ui(VertexPointerType type, uint value) => _VertexP4ui_fnptr(type, value);
            [UnmanagedCallersOnly]
            private static void VertexP4ui_Lazy(VertexPointerType type, uint value)
            {
                _VertexP4ui_fnptr = (delegate* unmanaged<VertexPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP4ui");
                _VertexP4ui_fnptr(type, value);
            }
            
            private static delegate* unmanaged<VertexPointerType, uint*, void> _VertexP4uiv_fnptr = &VertexP4uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexP4uiv(VertexPointerType type, uint* value) => _VertexP4uiv_fnptr(type, value);
            [UnmanagedCallersOnly]
            private static void VertexP4uiv_Lazy(VertexPointerType type, uint* value)
            {
                _VertexP4uiv_fnptr = (delegate* unmanaged<VertexPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexP4uiv");
                _VertexP4uiv_fnptr(type, value);
            }
            
            private static delegate* unmanaged<TexCoordPointerType, uint, void> _TexCoordP1ui_fnptr = &TexCoordP1ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordP1ui(TexCoordPointerType type, uint coords) => _TexCoordP1ui_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void TexCoordP1ui_Lazy(TexCoordPointerType type, uint coords)
            {
                _TexCoordP1ui_fnptr = (delegate* unmanaged<TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP1ui");
                _TexCoordP1ui_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<TexCoordPointerType, uint*, void> _TexCoordP1uiv_fnptr = &TexCoordP1uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordP1uiv(TexCoordPointerType type, uint* coords) => _TexCoordP1uiv_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void TexCoordP1uiv_Lazy(TexCoordPointerType type, uint* coords)
            {
                _TexCoordP1uiv_fnptr = (delegate* unmanaged<TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP1uiv");
                _TexCoordP1uiv_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<TexCoordPointerType, uint, void> _TexCoordP2ui_fnptr = &TexCoordP2ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordP2ui(TexCoordPointerType type, uint coords) => _TexCoordP2ui_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void TexCoordP2ui_Lazy(TexCoordPointerType type, uint coords)
            {
                _TexCoordP2ui_fnptr = (delegate* unmanaged<TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP2ui");
                _TexCoordP2ui_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<TexCoordPointerType, uint*, void> _TexCoordP2uiv_fnptr = &TexCoordP2uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordP2uiv(TexCoordPointerType type, uint* coords) => _TexCoordP2uiv_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void TexCoordP2uiv_Lazy(TexCoordPointerType type, uint* coords)
            {
                _TexCoordP2uiv_fnptr = (delegate* unmanaged<TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP2uiv");
                _TexCoordP2uiv_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<TexCoordPointerType, uint, void> _TexCoordP3ui_fnptr = &TexCoordP3ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordP3ui(TexCoordPointerType type, uint coords) => _TexCoordP3ui_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void TexCoordP3ui_Lazy(TexCoordPointerType type, uint coords)
            {
                _TexCoordP3ui_fnptr = (delegate* unmanaged<TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP3ui");
                _TexCoordP3ui_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<TexCoordPointerType, uint*, void> _TexCoordP3uiv_fnptr = &TexCoordP3uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordP3uiv(TexCoordPointerType type, uint* coords) => _TexCoordP3uiv_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void TexCoordP3uiv_Lazy(TexCoordPointerType type, uint* coords)
            {
                _TexCoordP3uiv_fnptr = (delegate* unmanaged<TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP3uiv");
                _TexCoordP3uiv_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<TexCoordPointerType, uint, void> _TexCoordP4ui_fnptr = &TexCoordP4ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordP4ui(TexCoordPointerType type, uint coords) => _TexCoordP4ui_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void TexCoordP4ui_Lazy(TexCoordPointerType type, uint coords)
            {
                _TexCoordP4ui_fnptr = (delegate* unmanaged<TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP4ui");
                _TexCoordP4ui_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<TexCoordPointerType, uint*, void> _TexCoordP4uiv_fnptr = &TexCoordP4uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordP4uiv(TexCoordPointerType type, uint* coords) => _TexCoordP4uiv_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void TexCoordP4uiv_Lazy(TexCoordPointerType type, uint* coords)
            {
                _TexCoordP4uiv_fnptr = (delegate* unmanaged<TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordP4uiv");
                _TexCoordP4uiv_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void> _MultiTexCoordP1ui_fnptr = &MultiTexCoordP1ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordP1ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP1ui_fnptr(texture, type, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoordP1ui_Lazy(TextureUnit texture, TexCoordPointerType type, uint coords)
            {
                _MultiTexCoordP1ui_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP1ui");
                _MultiTexCoordP1ui_fnptr(texture, type, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void> _MultiTexCoordP1uiv_fnptr = &MultiTexCoordP1uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => _MultiTexCoordP1uiv_fnptr(texture, type, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoordP1uiv_Lazy(TextureUnit texture, TexCoordPointerType type, uint* coords)
            {
                _MultiTexCoordP1uiv_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP1uiv");
                _MultiTexCoordP1uiv_fnptr(texture, type, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void> _MultiTexCoordP2ui_fnptr = &MultiTexCoordP2ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordP2ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP2ui_fnptr(texture, type, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoordP2ui_Lazy(TextureUnit texture, TexCoordPointerType type, uint coords)
            {
                _MultiTexCoordP2ui_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP2ui");
                _MultiTexCoordP2ui_fnptr(texture, type, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void> _MultiTexCoordP2uiv_fnptr = &MultiTexCoordP2uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => _MultiTexCoordP2uiv_fnptr(texture, type, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoordP2uiv_Lazy(TextureUnit texture, TexCoordPointerType type, uint* coords)
            {
                _MultiTexCoordP2uiv_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP2uiv");
                _MultiTexCoordP2uiv_fnptr(texture, type, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void> _MultiTexCoordP3ui_fnptr = &MultiTexCoordP3ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordP3ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP3ui_fnptr(texture, type, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoordP3ui_Lazy(TextureUnit texture, TexCoordPointerType type, uint coords)
            {
                _MultiTexCoordP3ui_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP3ui");
                _MultiTexCoordP3ui_fnptr(texture, type, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void> _MultiTexCoordP3uiv_fnptr = &MultiTexCoordP3uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => _MultiTexCoordP3uiv_fnptr(texture, type, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoordP3uiv_Lazy(TextureUnit texture, TexCoordPointerType type, uint* coords)
            {
                _MultiTexCoordP3uiv_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP3uiv");
                _MultiTexCoordP3uiv_fnptr(texture, type, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void> _MultiTexCoordP4ui_fnptr = &MultiTexCoordP4ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordP4ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP4ui_fnptr(texture, type, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoordP4ui_Lazy(TextureUnit texture, TexCoordPointerType type, uint coords)
            {
                _MultiTexCoordP4ui_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP4ui");
                _MultiTexCoordP4ui_fnptr(texture, type, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void> _MultiTexCoordP4uiv_fnptr = &MultiTexCoordP4uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => _MultiTexCoordP4uiv_fnptr(texture, type, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoordP4uiv_Lazy(TextureUnit texture, TexCoordPointerType type, uint* coords)
            {
                _MultiTexCoordP4uiv_fnptr = (delegate* unmanaged<TextureUnit, TexCoordPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordP4uiv");
                _MultiTexCoordP4uiv_fnptr(texture, type, coords);
            }
            
            private static delegate* unmanaged<NormalPointerType, uint, void> _NormalP3ui_fnptr = &NormalP3ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalP3ui(NormalPointerType type, uint coords) => _NormalP3ui_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void NormalP3ui_Lazy(NormalPointerType type, uint coords)
            {
                _NormalP3ui_fnptr = (delegate* unmanaged<NormalPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glNormalP3ui");
                _NormalP3ui_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<NormalPointerType, uint*, void> _NormalP3uiv_fnptr = &NormalP3uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalP3uiv(NormalPointerType type, uint* coords) => _NormalP3uiv_fnptr(type, coords);
            [UnmanagedCallersOnly]
            private static void NormalP3uiv_Lazy(NormalPointerType type, uint* coords)
            {
                _NormalP3uiv_fnptr = (delegate* unmanaged<NormalPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glNormalP3uiv");
                _NormalP3uiv_fnptr(type, coords);
            }
            
            private static delegate* unmanaged<ColorPointerType, uint, void> _ColorP3ui_fnptr = &ColorP3ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorP3ui(ColorPointerType type, uint color) => _ColorP3ui_fnptr(type, color);
            [UnmanagedCallersOnly]
            private static void ColorP3ui_Lazy(ColorPointerType type, uint color)
            {
                _ColorP3ui_fnptr = (delegate* unmanaged<ColorPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glColorP3ui");
                _ColorP3ui_fnptr(type, color);
            }
            
            private static delegate* unmanaged<ColorPointerType, uint*, void> _ColorP3uiv_fnptr = &ColorP3uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorP3uiv(ColorPointerType type, uint* color) => _ColorP3uiv_fnptr(type, color);
            [UnmanagedCallersOnly]
            private static void ColorP3uiv_Lazy(ColorPointerType type, uint* color)
            {
                _ColorP3uiv_fnptr = (delegate* unmanaged<ColorPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glColorP3uiv");
                _ColorP3uiv_fnptr(type, color);
            }
            
            private static delegate* unmanaged<ColorPointerType, uint, void> _ColorP4ui_fnptr = &ColorP4ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorP4ui(ColorPointerType type, uint color) => _ColorP4ui_fnptr(type, color);
            [UnmanagedCallersOnly]
            private static void ColorP4ui_Lazy(ColorPointerType type, uint color)
            {
                _ColorP4ui_fnptr = (delegate* unmanaged<ColorPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glColorP4ui");
                _ColorP4ui_fnptr(type, color);
            }
            
            private static delegate* unmanaged<ColorPointerType, uint*, void> _ColorP4uiv_fnptr = &ColorP4uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorP4uiv(ColorPointerType type, uint* color) => _ColorP4uiv_fnptr(type, color);
            [UnmanagedCallersOnly]
            private static void ColorP4uiv_Lazy(ColorPointerType type, uint* color)
            {
                _ColorP4uiv_fnptr = (delegate* unmanaged<ColorPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glColorP4uiv");
                _ColorP4uiv_fnptr(type, color);
            }
            
            private static delegate* unmanaged<ColorPointerType, uint, void> _SecondaryColorP3ui_fnptr = &SecondaryColorP3ui_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColorP3ui(ColorPointerType type, uint color) => _SecondaryColorP3ui_fnptr(type, color);
            [UnmanagedCallersOnly]
            private static void SecondaryColorP3ui_Lazy(ColorPointerType type, uint color)
            {
                _SecondaryColorP3ui_fnptr = (delegate* unmanaged<ColorPointerType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColorP3ui");
                _SecondaryColorP3ui_fnptr(type, color);
            }
            
            private static delegate* unmanaged<ColorPointerType, uint*, void> _SecondaryColorP3uiv_fnptr = &SecondaryColorP3uiv_Lazy;
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColorP3uiv(ColorPointerType type, uint* color) => _SecondaryColorP3uiv_fnptr(type, color);
            [UnmanagedCallersOnly]
            private static void SecondaryColorP3uiv_Lazy(ColorPointerType type, uint* color)
            {
                _SecondaryColorP3uiv_fnptr = (delegate* unmanaged<ColorPointerType, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColorP3uiv");
                _SecondaryColorP3uiv_fnptr(type, color);
            }
            
            private static delegate* unmanaged<uint, int, float*, void> _ViewportArrayv_fnptr = &ViewportArrayv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set multiple viewports. </summary>
            /// <param name="first"> Specify the first viewport to set. </param>
            /// <param name="count"> Specify the number of viewports to set. </param>
            /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml" /></remarks>
            public static void ViewportArrayv(uint first, int count, float* v) => _ViewportArrayv_fnptr(first, count, v);
            [UnmanagedCallersOnly]
            private static void ViewportArrayv_Lazy(uint first, int count, float* v)
            {
                _ViewportArrayv_fnptr = (delegate* unmanaged<uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glViewportArrayv");
                _ViewportArrayv_fnptr(first, count, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, float, void> _ViewportIndexedf_fnptr = &ViewportIndexedf_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
            public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => _ViewportIndexedf_fnptr(index, x, y, w, h);
            [UnmanagedCallersOnly]
            private static void ViewportIndexedf_Lazy(uint index, float x, float y, float w, float h)
            {
                _ViewportIndexedf_fnptr = (delegate* unmanaged<uint, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glViewportIndexedf");
                _ViewportIndexedf_fnptr(index, x, y, w, h);
            }
            
            private static delegate* unmanaged<uint, float*, void> _ViewportIndexedfv_fnptr = &ViewportIndexedfv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
            public static void ViewportIndexedfv(uint index, float* v) => _ViewportIndexedfv_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void ViewportIndexedfv_Lazy(uint index, float* v)
            {
                _ViewportIndexedfv_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glViewportIndexedfv");
                _ViewportIndexedfv_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int, int*, void> _ScissorArrayv_fnptr = &ScissorArrayv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for multiple viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
            /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
            /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml" /></remarks>
            public static void ScissorArrayv(uint first, int count, int* v) => _ScissorArrayv_fnptr(first, count, v);
            [UnmanagedCallersOnly]
            private static void ScissorArrayv_Lazy(uint first, int count, int* v)
            {
                _ScissorArrayv_fnptr = (delegate* unmanaged<uint, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glScissorArrayv");
                _ScissorArrayv_fnptr(first, count, v);
            }
            
            private static delegate* unmanaged<uint, int, int, int, int, void> _ScissorIndexed_fnptr = &ScissorIndexed_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
            public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => _ScissorIndexed_fnptr(index, left, bottom, width, height);
            [UnmanagedCallersOnly]
            private static void ScissorIndexed_Lazy(uint index, int left, int bottom, int width, int height)
            {
                _ScissorIndexed_fnptr = (delegate* unmanaged<uint, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glScissorIndexed");
                _ScissorIndexed_fnptr(index, left, bottom, width, height);
            }
            
            private static delegate* unmanaged<uint, int*, void> _ScissorIndexedv_fnptr = &ScissorIndexedv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
            public static void ScissorIndexedv(uint index, int* v) => _ScissorIndexedv_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void ScissorIndexedv_Lazy(uint index, int* v)
            {
                _ScissorIndexedv_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glScissorIndexedv");
                _ScissorIndexedv_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int, double*, void> _DepthRangeArrayv_fnptr = &DepthRangeArrayv_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
            /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
            /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml" /></remarks>
            public static void DepthRangeArrayv(uint first, int count, double* v) => _DepthRangeArrayv_fnptr(first, count, v);
            [UnmanagedCallersOnly]
            private static void DepthRangeArrayv_Lazy(uint first, int count, double* v)
            {
                _DepthRangeArrayv_fnptr = (delegate* unmanaged<uint, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangeArrayv");
                _DepthRangeArrayv_fnptr(first, count, v);
            }
            
            private static delegate* unmanaged<uint, double, double, void> _DepthRangeIndexed_fnptr = &DepthRangeIndexed_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
            /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml" /></remarks>
            public static void DepthRangeIndexed(uint index, double n, double f) => _DepthRangeIndexed_fnptr(index, n, f);
            [UnmanagedCallersOnly]
            private static void DepthRangeIndexed_Lazy(uint index, double n, double f)
            {
                _DepthRangeIndexed_fnptr = (delegate* unmanaged<uint, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangeIndexed");
                _DepthRangeIndexed_fnptr(index, n, f);
            }
            
            private static delegate* unmanaged<GetPName, uint, float*, void> _GetFloati_v_fnptr = &GetFloati_v_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetFloati_v(GetPName target, uint index, float* data) => _GetFloati_v_fnptr(target, index, data);
            [UnmanagedCallersOnly]
            private static void GetFloati_v_Lazy(GetPName target, uint index, float* data)
            {
                _GetFloati_v_fnptr = (delegate* unmanaged<GetPName, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFloati_v");
                _GetFloati_v_fnptr(target, index, data);
            }
            
            private static delegate* unmanaged<GetPName, uint, double*, void> _GetDoublei_v_fnptr = &GetDoublei_v_Lazy;
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetDoublei_v(GetPName target, uint index, double* data) => _GetDoublei_v_fnptr(target, index, data);
            [UnmanagedCallersOnly]
            private static void GetDoublei_v_Lazy(GetPName target, uint index, double* data)
            {
                _GetDoublei_v_fnptr = (delegate* unmanaged<GetPName, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetDoublei_v");
                _GetDoublei_v_fnptr(target, index, data);
            }
            
            private static delegate* unmanaged<uint, int, double*, void> _DepthRangeArraydvNV_fnptr = &DepthRangeArraydvNV_Lazy;
            /// <summary> <b>[requires: GL_ARB_viewport_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangeArraydvNV(uint first, int count, double* v) => _DepthRangeArraydvNV_fnptr(first, count, v);
            [UnmanagedCallersOnly]
            private static void DepthRangeArraydvNV_Lazy(uint first, int count, double* v)
            {
                _DepthRangeArraydvNV_fnptr = (delegate* unmanaged<uint, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangeArraydvNV");
                _DepthRangeArraydvNV_fnptr(first, count, v);
            }
            
            private static delegate* unmanaged<uint, double, double, void> _DepthRangeIndexeddNV_fnptr = &DepthRangeIndexeddNV_Lazy;
            /// <summary> <b>[requires: GL_ARB_viewport_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangeIndexeddNV(uint index, double n, double f) => _DepthRangeIndexeddNV_fnptr(index, n, f);
            [UnmanagedCallersOnly]
            private static void DepthRangeIndexeddNV_Lazy(uint index, double n, double f)
            {
                _DepthRangeIndexeddNV_fnptr = (delegate* unmanaged<uint, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangeIndexeddNV");
                _DepthRangeIndexeddNV_fnptr(index, n, f);
            }
            
            private static delegate* unmanaged<double, double, void> _WindowPos2dARB_fnptr = &WindowPos2dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2dARB(double x, double y) => _WindowPos2dARB_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void WindowPos2dARB_Lazy(double x, double y)
            {
                _WindowPos2dARB_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2dARB");
                _WindowPos2dARB_fnptr(x, y);
            }
            
            private static delegate* unmanaged<double*, void> _WindowPos2dvARB_fnptr = &WindowPos2dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2dvARB(double* v) => _WindowPos2dvARB_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos2dvARB_Lazy(double* v)
            {
                _WindowPos2dvARB_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2dvARB");
                _WindowPos2dvARB_fnptr(v);
            }
            
            private static delegate* unmanaged<float, float, void> _WindowPos2fARB_fnptr = &WindowPos2fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2fARB(float x, float y) => _WindowPos2fARB_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void WindowPos2fARB_Lazy(float x, float y)
            {
                _WindowPos2fARB_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2fARB");
                _WindowPos2fARB_fnptr(x, y);
            }
            
            private static delegate* unmanaged<float*, void> _WindowPos2fvARB_fnptr = &WindowPos2fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2fvARB(float* v) => _WindowPos2fvARB_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos2fvARB_Lazy(float* v)
            {
                _WindowPos2fvARB_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2fvARB");
                _WindowPos2fvARB_fnptr(v);
            }
            
            private static delegate* unmanaged<int, int, void> _WindowPos2iARB_fnptr = &WindowPos2iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2iARB(int x, int y) => _WindowPos2iARB_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void WindowPos2iARB_Lazy(int x, int y)
            {
                _WindowPos2iARB_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2iARB");
                _WindowPos2iARB_fnptr(x, y);
            }
            
            private static delegate* unmanaged<int*, void> _WindowPos2ivARB_fnptr = &WindowPos2ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2ivARB(int* v) => _WindowPos2ivARB_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos2ivARB_Lazy(int* v)
            {
                _WindowPos2ivARB_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2ivARB");
                _WindowPos2ivARB_fnptr(v);
            }
            
            private static delegate* unmanaged<short, short, void> _WindowPos2sARB_fnptr = &WindowPos2sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2sARB(short x, short y) => _WindowPos2sARB_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void WindowPos2sARB_Lazy(short x, short y)
            {
                _WindowPos2sARB_fnptr = (delegate* unmanaged<short, short, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2sARB");
                _WindowPos2sARB_fnptr(x, y);
            }
            
            private static delegate* unmanaged<short*, void> _WindowPos2svARB_fnptr = &WindowPos2svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2svARB(short* v) => _WindowPos2svARB_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos2svARB_Lazy(short* v)
            {
                _WindowPos2svARB_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2svARB");
                _WindowPos2svARB_fnptr(v);
            }
            
            private static delegate* unmanaged<double, double, double, void> _WindowPos3dARB_fnptr = &WindowPos3dARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3dARB(double x, double y, double z) => _WindowPos3dARB_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void WindowPos3dARB_Lazy(double x, double y, double z)
            {
                _WindowPos3dARB_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3dARB");
                _WindowPos3dARB_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<double*, void> _WindowPos3dvARB_fnptr = &WindowPos3dvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3dvARB(double* v) => _WindowPos3dvARB_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos3dvARB_Lazy(double* v)
            {
                _WindowPos3dvARB_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3dvARB");
                _WindowPos3dvARB_fnptr(v);
            }
            
            private static delegate* unmanaged<float, float, float, void> _WindowPos3fARB_fnptr = &WindowPos3fARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3fARB(float x, float y, float z) => _WindowPos3fARB_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void WindowPos3fARB_Lazy(float x, float y, float z)
            {
                _WindowPos3fARB_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3fARB");
                _WindowPos3fARB_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<float*, void> _WindowPos3fvARB_fnptr = &WindowPos3fvARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3fvARB(float* v) => _WindowPos3fvARB_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos3fvARB_Lazy(float* v)
            {
                _WindowPos3fvARB_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3fvARB");
                _WindowPos3fvARB_fnptr(v);
            }
            
            private static delegate* unmanaged<int, int, int, void> _WindowPos3iARB_fnptr = &WindowPos3iARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3iARB(int x, int y, int z) => _WindowPos3iARB_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void WindowPos3iARB_Lazy(int x, int y, int z)
            {
                _WindowPos3iARB_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3iARB");
                _WindowPos3iARB_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<int*, void> _WindowPos3ivARB_fnptr = &WindowPos3ivARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3ivARB(int* v) => _WindowPos3ivARB_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos3ivARB_Lazy(int* v)
            {
                _WindowPos3ivARB_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3ivARB");
                _WindowPos3ivARB_fnptr(v);
            }
            
            private static delegate* unmanaged<short, short, short, void> _WindowPos3sARB_fnptr = &WindowPos3sARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3sARB(short x, short y, short z) => _WindowPos3sARB_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void WindowPos3sARB_Lazy(short x, short y, short z)
            {
                _WindowPos3sARB_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3sARB");
                _WindowPos3sARB_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<short*, void> _WindowPos3svARB_fnptr = &WindowPos3svARB_Lazy;
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3svARB(short* v) => _WindowPos3svARB_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos3svARB_Lazy(short* v)
            {
                _WindowPos3svARB_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3svARB");
                _WindowPos3svARB_fnptr(v);
            }
            
        }
        public static unsafe partial class ATI
        {
            private static delegate* unmanaged<int, DrawBufferMode*, void> _DrawBuffersATI_fnptr = &DrawBuffersATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_draw_buffers]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawBuffersATI(int n, DrawBufferMode* bufs) => _DrawBuffersATI_fnptr(n, bufs);
            [UnmanagedCallersOnly]
            private static void DrawBuffersATI_Lazy(int n, DrawBufferMode* bufs)
            {
                _DrawBuffersATI_fnptr = (delegate* unmanaged<int, DrawBufferMode*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawBuffersATI");
                _DrawBuffersATI_fnptr(n, bufs);
            }
            
            private static delegate* unmanaged<ElementPointerTypeATI, void*, void> _ElementPointerATI_fnptr = &ElementPointerATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ElementPointerATI(ElementPointerTypeATI type, void* pointer) => _ElementPointerATI_fnptr(type, pointer);
            [UnmanagedCallersOnly]
            private static void ElementPointerATI_Lazy(ElementPointerTypeATI type, void* pointer)
            {
                _ElementPointerATI_fnptr = (delegate* unmanaged<ElementPointerTypeATI, void*, void>)GLLoader.BindingsContext.GetProcAddress("glElementPointerATI");
                _ElementPointerATI_fnptr(type, pointer);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, void> _DrawElementArrayATI_fnptr = &DrawElementArrayATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawElementArrayATI(PrimitiveType mode, int count) => _DrawElementArrayATI_fnptr(mode, count);
            [UnmanagedCallersOnly]
            private static void DrawElementArrayATI_Lazy(PrimitiveType mode, int count)
            {
                _DrawElementArrayATI_fnptr = (delegate* unmanaged<PrimitiveType, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementArrayATI");
                _DrawElementArrayATI_fnptr(mode, count);
            }
            
            private static delegate* unmanaged<PrimitiveType, uint, uint, int, void> _DrawRangeElementArrayATI_fnptr = &DrawRangeElementArrayATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawRangeElementArrayATI(PrimitiveType mode, uint start, uint end, int count) => _DrawRangeElementArrayATI_fnptr(mode, start, end, count);
            [UnmanagedCallersOnly]
            private static void DrawRangeElementArrayATI_Lazy(PrimitiveType mode, uint start, uint end, int count)
            {
                _DrawRangeElementArrayATI_fnptr = (delegate* unmanaged<PrimitiveType, uint, uint, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawRangeElementArrayATI");
                _DrawRangeElementArrayATI_fnptr(mode, start, end, count);
            }
            
            private static delegate* unmanaged<TexBumpParameterATI, int*, void> _TexBumpParameterivATI_fnptr = &TexBumpParameterivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexBumpParameterivATI(TexBumpParameterATI pname, int* param) => _TexBumpParameterivATI_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void TexBumpParameterivATI_Lazy(TexBumpParameterATI pname, int* param)
            {
                _TexBumpParameterivATI_fnptr = (delegate* unmanaged<TexBumpParameterATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexBumpParameterivATI");
                _TexBumpParameterivATI_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<TexBumpParameterATI, float*, void> _TexBumpParameterfvATI_fnptr = &TexBumpParameterfvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexBumpParameterfvATI(TexBumpParameterATI pname, float* param) => _TexBumpParameterfvATI_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void TexBumpParameterfvATI_Lazy(TexBumpParameterATI pname, float* param)
            {
                _TexBumpParameterfvATI_fnptr = (delegate* unmanaged<TexBumpParameterATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexBumpParameterfvATI");
                _TexBumpParameterfvATI_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<GetTexBumpParameterATI, int*, void> _GetTexBumpParameterivATI_fnptr = &GetTexBumpParameterivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, int* param) => _GetTexBumpParameterivATI_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void GetTexBumpParameterivATI_Lazy(GetTexBumpParameterATI pname, int* param)
            {
                _GetTexBumpParameterivATI_fnptr = (delegate* unmanaged<GetTexBumpParameterATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexBumpParameterivATI");
                _GetTexBumpParameterivATI_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<GetTexBumpParameterATI, float*, void> _GetTexBumpParameterfvATI_fnptr = &GetTexBumpParameterfvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, float* param) => _GetTexBumpParameterfvATI_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void GetTexBumpParameterfvATI_Lazy(GetTexBumpParameterATI pname, float* param)
            {
                _GetTexBumpParameterfvATI_fnptr = (delegate* unmanaged<GetTexBumpParameterATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexBumpParameterfvATI");
                _GetTexBumpParameterfvATI_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<uint, uint> _GenFragmentShadersATI_fnptr = &GenFragmentShadersATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenFragmentShadersATI(uint range) => _GenFragmentShadersATI_fnptr(range);
            [UnmanagedCallersOnly]
            private static uint GenFragmentShadersATI_Lazy(uint range)
            {
                _GenFragmentShadersATI_fnptr = (delegate* unmanaged<uint, uint>)GLLoader.BindingsContext.GetProcAddress("glGenFragmentShadersATI");
                return _GenFragmentShadersATI_fnptr(range);
            }
            
            private static delegate* unmanaged<uint, void> _BindFragmentShaderATI_fnptr = &BindFragmentShaderATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindFragmentShaderATI(uint id) => _BindFragmentShaderATI_fnptr(id);
            [UnmanagedCallersOnly]
            private static void BindFragmentShaderATI_Lazy(uint id)
            {
                _BindFragmentShaderATI_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glBindFragmentShaderATI");
                _BindFragmentShaderATI_fnptr(id);
            }
            
            private static delegate* unmanaged<uint, void> _DeleteFragmentShaderATI_fnptr = &DeleteFragmentShaderATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteFragmentShaderATI(uint id) => _DeleteFragmentShaderATI_fnptr(id);
            [UnmanagedCallersOnly]
            private static void DeleteFragmentShaderATI_Lazy(uint id)
            {
                _DeleteFragmentShaderATI_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteFragmentShaderATI");
                _DeleteFragmentShaderATI_fnptr(id);
            }
            
            private static delegate* unmanaged<void> _BeginFragmentShaderATI_fnptr = &BeginFragmentShaderATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginFragmentShaderATI() => _BeginFragmentShaderATI_fnptr();
            [UnmanagedCallersOnly]
            private static void BeginFragmentShaderATI_Lazy()
            {
                _BeginFragmentShaderATI_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glBeginFragmentShaderATI");
                _BeginFragmentShaderATI_fnptr();
            }
            
            private static delegate* unmanaged<void> _EndFragmentShaderATI_fnptr = &EndFragmentShaderATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndFragmentShaderATI() => _EndFragmentShaderATI_fnptr();
            [UnmanagedCallersOnly]
            private static void EndFragmentShaderATI_Lazy()
            {
                _EndFragmentShaderATI_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndFragmentShaderATI");
                _EndFragmentShaderATI_fnptr();
            }
            
            private static delegate* unmanaged<uint, uint, SwizzleOpATI, void> _PassTexCoordATI_fnptr = &PassTexCoordATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PassTexCoordATI(uint dst, uint coord, SwizzleOpATI swizzle) => _PassTexCoordATI_fnptr(dst, coord, swizzle);
            [UnmanagedCallersOnly]
            private static void PassTexCoordATI_Lazy(uint dst, uint coord, SwizzleOpATI swizzle)
            {
                _PassTexCoordATI_fnptr = (delegate* unmanaged<uint, uint, SwizzleOpATI, void>)GLLoader.BindingsContext.GetProcAddress("glPassTexCoordATI");
                _PassTexCoordATI_fnptr(dst, coord, swizzle);
            }
            
            private static delegate* unmanaged<uint, uint, SwizzleOpATI, void> _SampleMapATI_fnptr = &SampleMapATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleMapATI(uint dst, uint interp, SwizzleOpATI swizzle) => _SampleMapATI_fnptr(dst, interp, swizzle);
            [UnmanagedCallersOnly]
            private static void SampleMapATI_Lazy(uint dst, uint interp, SwizzleOpATI swizzle)
            {
                _SampleMapATI_fnptr = (delegate* unmanaged<uint, uint, SwizzleOpATI, void>)GLLoader.BindingsContext.GetProcAddress("glSampleMapATI");
                _SampleMapATI_fnptr(dst, interp, swizzle);
            }
            
            private static delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, void> _ColorFragmentOp1ATI_fnptr = &ColorFragmentOp1ATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorFragmentOp1ATI(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) => _ColorFragmentOp1ATI_fnptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
            [UnmanagedCallersOnly]
            private static void ColorFragmentOp1ATI_Lazy(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod)
            {
                _ColorFragmentOp1ATI_fnptr = (delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glColorFragmentOp1ATI");
                _ColorFragmentOp1ATI_fnptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
            }
            
            private static delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, uint, uint, uint, void> _ColorFragmentOp2ATI_fnptr = &ColorFragmentOp2ATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorFragmentOp2ATI(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) => _ColorFragmentOp2ATI_fnptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
            [UnmanagedCallersOnly]
            private static void ColorFragmentOp2ATI_Lazy(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod)
            {
                _ColorFragmentOp2ATI_fnptr = (delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glColorFragmentOp2ATI");
                _ColorFragmentOp2ATI_fnptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
            }
            
            private static delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, void> _ColorFragmentOp3ATI_fnptr = &ColorFragmentOp3ATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorFragmentOp3ATI(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) => _ColorFragmentOp3ATI_fnptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
            [UnmanagedCallersOnly]
            private static void ColorFragmentOp3ATI_Lazy(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod)
            {
                _ColorFragmentOp3ATI_fnptr = (delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glColorFragmentOp3ATI");
                _ColorFragmentOp3ATI_fnptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
            }
            
            private static delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, void> _AlphaFragmentOp1ATI_fnptr = &AlphaFragmentOp1ATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaFragmentOp1ATI(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) => _AlphaFragmentOp1ATI_fnptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
            [UnmanagedCallersOnly]
            private static void AlphaFragmentOp1ATI_Lazy(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod)
            {
                _AlphaFragmentOp1ATI_fnptr = (delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glAlphaFragmentOp1ATI");
                _AlphaFragmentOp1ATI_fnptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
            }
            
            private static delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, uint, uint, void> _AlphaFragmentOp2ATI_fnptr = &AlphaFragmentOp2ATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaFragmentOp2ATI(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) => _AlphaFragmentOp2ATI_fnptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
            [UnmanagedCallersOnly]
            private static void AlphaFragmentOp2ATI_Lazy(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod)
            {
                _AlphaFragmentOp2ATI_fnptr = (delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glAlphaFragmentOp2ATI");
                _AlphaFragmentOp2ATI_fnptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
            }
            
            private static delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, void> _AlphaFragmentOp3ATI_fnptr = &AlphaFragmentOp3ATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaFragmentOp3ATI(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) => _AlphaFragmentOp3ATI_fnptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
            [UnmanagedCallersOnly]
            private static void AlphaFragmentOp3ATI_Lazy(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod)
            {
                _AlphaFragmentOp3ATI_fnptr = (delegate* unmanaged<FragmentOpATI, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glAlphaFragmentOp3ATI");
                _AlphaFragmentOp3ATI_fnptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
            }
            
            private static delegate* unmanaged<uint, float*, void> _SetFragmentShaderConstantATI_fnptr = &SetFragmentShaderConstantATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetFragmentShaderConstantATI(uint dst, float* value) => _SetFragmentShaderConstantATI_fnptr(dst, value);
            [UnmanagedCallersOnly]
            private static void SetFragmentShaderConstantATI_Lazy(uint dst, float* value)
            {
                _SetFragmentShaderConstantATI_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glSetFragmentShaderConstantATI");
                _SetFragmentShaderConstantATI_fnptr(dst, value);
            }
            
            private static delegate* unmanaged<BufferHandle, void*> _MapObjectBufferATI_fnptr = &MapObjectBufferATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_map_object_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapObjectBufferATI(BufferHandle buffer) => _MapObjectBufferATI_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static void* MapObjectBufferATI_Lazy(BufferHandle buffer)
            {
                _MapObjectBufferATI_fnptr = (delegate* unmanaged<BufferHandle, void*>)GLLoader.BindingsContext.GetProcAddress("glMapObjectBufferATI");
                return _MapObjectBufferATI_fnptr(buffer);
            }
            
            private static delegate* unmanaged<BufferHandle, void> _UnmapObjectBufferATI_fnptr = &UnmapObjectBufferATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_map_object_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UnmapObjectBufferATI(BufferHandle buffer) => _UnmapObjectBufferATI_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static void UnmapObjectBufferATI_Lazy(BufferHandle buffer)
            {
                _UnmapObjectBufferATI_fnptr = (delegate* unmanaged<BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glUnmapObjectBufferATI");
                _UnmapObjectBufferATI_fnptr(buffer);
            }
            
            private static delegate* unmanaged<PNTrianglesPNameATI, int, void> _PNTrianglesiATI_fnptr = &PNTrianglesiATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_pn_triangles]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PNTrianglesiATI(PNTrianglesPNameATI pname, int param) => _PNTrianglesiATI_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PNTrianglesiATI_Lazy(PNTrianglesPNameATI pname, int param)
            {
                _PNTrianglesiATI_fnptr = (delegate* unmanaged<PNTrianglesPNameATI, int, void>)GLLoader.BindingsContext.GetProcAddress("glPNTrianglesiATI");
                _PNTrianglesiATI_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<PNTrianglesPNameATI, float, void> _PNTrianglesfATI_fnptr = &PNTrianglesfATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_pn_triangles]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PNTrianglesfATI(PNTrianglesPNameATI pname, float param) => _PNTrianglesfATI_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PNTrianglesfATI_Lazy(PNTrianglesPNameATI pname, float param)
            {
                _PNTrianglesfATI_fnptr = (delegate* unmanaged<PNTrianglesPNameATI, float, void>)GLLoader.BindingsContext.GetProcAddress("glPNTrianglesfATI");
                _PNTrianglesfATI_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<StencilFaceDirection, StencilOp, StencilOp, StencilOp, void> _StencilOpSeparateATI_fnptr = &StencilOpSeparateATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_separate_stencil]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilOpSeparateATI(StencilFaceDirection face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => _StencilOpSeparateATI_fnptr(face, sfail, dpfail, dppass);
            [UnmanagedCallersOnly]
            private static void StencilOpSeparateATI_Lazy(StencilFaceDirection face, StencilOp sfail, StencilOp dpfail, StencilOp dppass)
            {
                _StencilOpSeparateATI_fnptr = (delegate* unmanaged<StencilFaceDirection, StencilOp, StencilOp, StencilOp, void>)GLLoader.BindingsContext.GetProcAddress("glStencilOpSeparateATI");
                _StencilOpSeparateATI_fnptr(face, sfail, dpfail, dppass);
            }
            
            private static delegate* unmanaged<StencilFunction, StencilFunction, int, uint, void> _StencilFuncSeparateATI_fnptr = &StencilFuncSeparateATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_separate_stencil]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilFuncSeparateATI(StencilFunction frontfunc, StencilFunction backfunc, int reference, uint mask) => _StencilFuncSeparateATI_fnptr(frontfunc, backfunc, reference, mask);
            [UnmanagedCallersOnly]
            private static void StencilFuncSeparateATI_Lazy(StencilFunction frontfunc, StencilFunction backfunc, int reference, uint mask)
            {
                _StencilFuncSeparateATI_fnptr = (delegate* unmanaged<StencilFunction, StencilFunction, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glStencilFuncSeparateATI");
                _StencilFuncSeparateATI_fnptr(frontfunc, backfunc, reference, mask);
            }
            
            private static delegate* unmanaged<int, void*, ArrayObjectUsageATI, uint> _NewObjectBufferATI_fnptr = &NewObjectBufferATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint NewObjectBufferATI(int size, void* pointer, ArrayObjectUsageATI usage) => _NewObjectBufferATI_fnptr(size, pointer, usage);
            [UnmanagedCallersOnly]
            private static uint NewObjectBufferATI_Lazy(int size, void* pointer, ArrayObjectUsageATI usage)
            {
                _NewObjectBufferATI_fnptr = (delegate* unmanaged<int, void*, ArrayObjectUsageATI, uint>)GLLoader.BindingsContext.GetProcAddress("glNewObjectBufferATI");
                return _NewObjectBufferATI_fnptr(size, pointer, usage);
            }
            
            private static delegate* unmanaged<BufferHandle, byte> _IsObjectBufferATI_fnptr = &IsObjectBufferATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsObjectBufferATI(BufferHandle buffer) => _IsObjectBufferATI_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static byte IsObjectBufferATI_Lazy(BufferHandle buffer)
            {
                _IsObjectBufferATI_fnptr = (delegate* unmanaged<BufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsObjectBufferATI");
                return _IsObjectBufferATI_fnptr(buffer);
            }
            
            private static delegate* unmanaged<BufferHandle, uint, int, void*, PreserveModeATI, void> _UpdateObjectBufferATI_fnptr = &UpdateObjectBufferATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UpdateObjectBufferATI(BufferHandle buffer, uint offset, int size, void* pointer, PreserveModeATI preserve) => _UpdateObjectBufferATI_fnptr(buffer, offset, size, pointer, preserve);
            [UnmanagedCallersOnly]
            private static void UpdateObjectBufferATI_Lazy(BufferHandle buffer, uint offset, int size, void* pointer, PreserveModeATI preserve)
            {
                _UpdateObjectBufferATI_fnptr = (delegate* unmanaged<BufferHandle, uint, int, void*, PreserveModeATI, void>)GLLoader.BindingsContext.GetProcAddress("glUpdateObjectBufferATI");
                _UpdateObjectBufferATI_fnptr(buffer, offset, size, pointer, preserve);
            }
            
            private static delegate* unmanaged<BufferHandle, ArrayObjectPNameATI, float*, void> _GetObjectBufferfvATI_fnptr = &GetObjectBufferfvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectBufferfvATI(BufferHandle buffer, ArrayObjectPNameATI pname, float* parameters) => _GetObjectBufferfvATI_fnptr(buffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetObjectBufferfvATI_Lazy(BufferHandle buffer, ArrayObjectPNameATI pname, float* parameters)
            {
                _GetObjectBufferfvATI_fnptr = (delegate* unmanaged<BufferHandle, ArrayObjectPNameATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectBufferfvATI");
                _GetObjectBufferfvATI_fnptr(buffer, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferHandle, ArrayObjectPNameATI, int*, void> _GetObjectBufferivATI_fnptr = &GetObjectBufferivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectBufferivATI(BufferHandle buffer, ArrayObjectPNameATI pname, int* parameters) => _GetObjectBufferivATI_fnptr(buffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetObjectBufferivATI_Lazy(BufferHandle buffer, ArrayObjectPNameATI pname, int* parameters)
            {
                _GetObjectBufferivATI_fnptr = (delegate* unmanaged<BufferHandle, ArrayObjectPNameATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectBufferivATI");
                _GetObjectBufferivATI_fnptr(buffer, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferHandle, void> _FreeObjectBufferATI_fnptr = &FreeObjectBufferATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FreeObjectBufferATI(BufferHandle buffer) => _FreeObjectBufferATI_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static void FreeObjectBufferATI_Lazy(BufferHandle buffer)
            {
                _FreeObjectBufferATI_fnptr = (delegate* unmanaged<BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glFreeObjectBufferATI");
                _FreeObjectBufferATI_fnptr(buffer);
            }
            
            private static delegate* unmanaged<EnableCap, int, ScalarType, int, BufferHandle, uint, void> _ArrayObjectATI_fnptr = &ArrayObjectATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ArrayObjectATI(EnableCap array, int size, ScalarType type, int stride, BufferHandle buffer, uint offset) => _ArrayObjectATI_fnptr(array, size, type, stride, buffer, offset);
            [UnmanagedCallersOnly]
            private static void ArrayObjectATI_Lazy(EnableCap array, int size, ScalarType type, int stride, BufferHandle buffer, uint offset)
            {
                _ArrayObjectATI_fnptr = (delegate* unmanaged<EnableCap, int, ScalarType, int, BufferHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glArrayObjectATI");
                _ArrayObjectATI_fnptr(array, size, type, stride, buffer, offset);
            }
            
            private static delegate* unmanaged<EnableCap, ArrayObjectPNameATI, float*, void> _GetArrayObjectfvATI_fnptr = &GetArrayObjectfvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetArrayObjectfvATI(EnableCap array, ArrayObjectPNameATI pname, float* parameters) => _GetArrayObjectfvATI_fnptr(array, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetArrayObjectfvATI_Lazy(EnableCap array, ArrayObjectPNameATI pname, float* parameters)
            {
                _GetArrayObjectfvATI_fnptr = (delegate* unmanaged<EnableCap, ArrayObjectPNameATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetArrayObjectfvATI");
                _GetArrayObjectfvATI_fnptr(array, pname, parameters);
            }
            
            private static delegate* unmanaged<EnableCap, ArrayObjectPNameATI, int*, void> _GetArrayObjectivATI_fnptr = &GetArrayObjectivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetArrayObjectivATI(EnableCap array, ArrayObjectPNameATI pname, int* parameters) => _GetArrayObjectivATI_fnptr(array, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetArrayObjectivATI_Lazy(EnableCap array, ArrayObjectPNameATI pname, int* parameters)
            {
                _GetArrayObjectivATI_fnptr = (delegate* unmanaged<EnableCap, ArrayObjectPNameATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetArrayObjectivATI");
                _GetArrayObjectivATI_fnptr(array, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, ScalarType, int, BufferHandle, uint, void> _VariantArrayObjectATI_fnptr = &VariantArrayObjectATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantArrayObjectATI(uint id, ScalarType type, int stride, BufferHandle buffer, uint offset) => _VariantArrayObjectATI_fnptr(id, type, stride, buffer, offset);
            [UnmanagedCallersOnly]
            private static void VariantArrayObjectATI_Lazy(uint id, ScalarType type, int stride, BufferHandle buffer, uint offset)
            {
                _VariantArrayObjectATI_fnptr = (delegate* unmanaged<uint, ScalarType, int, BufferHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVariantArrayObjectATI");
                _VariantArrayObjectATI_fnptr(id, type, stride, buffer, offset);
            }
            
            private static delegate* unmanaged<uint, ArrayObjectPNameATI, float*, void> _GetVariantArrayObjectfvATI_fnptr = &GetVariantArrayObjectfvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantArrayObjectfvATI(uint id, ArrayObjectPNameATI pname, float* parameters) => _GetVariantArrayObjectfvATI_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVariantArrayObjectfvATI_Lazy(uint id, ArrayObjectPNameATI pname, float* parameters)
            {
                _GetVariantArrayObjectfvATI_fnptr = (delegate* unmanaged<uint, ArrayObjectPNameATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVariantArrayObjectfvATI");
                _GetVariantArrayObjectfvATI_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, ArrayObjectPNameATI, int*, void> _GetVariantArrayObjectivATI_fnptr = &GetVariantArrayObjectivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantArrayObjectivATI(uint id, ArrayObjectPNameATI pname, int* parameters) => _GetVariantArrayObjectivATI_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVariantArrayObjectivATI_Lazy(uint id, ArrayObjectPNameATI pname, int* parameters)
            {
                _GetVariantArrayObjectivATI_fnptr = (delegate* unmanaged<uint, ArrayObjectPNameATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVariantArrayObjectivATI");
                _GetVariantArrayObjectivATI_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribPointerType, byte, int, BufferHandle, uint, void> _VertexAttribArrayObjectATI_fnptr = &VertexAttribArrayObjectATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribArrayObjectATI(uint index, int size, VertexAttribPointerType type, byte normalized, int stride, BufferHandle buffer, uint offset) => _VertexAttribArrayObjectATI_fnptr(index, size, type, normalized, stride, buffer, offset);
            [UnmanagedCallersOnly]
            private static void VertexAttribArrayObjectATI_Lazy(uint index, int size, VertexAttribPointerType type, byte normalized, int stride, BufferHandle buffer, uint offset)
            {
                _VertexAttribArrayObjectATI_fnptr = (delegate* unmanaged<uint, int, VertexAttribPointerType, byte, int, BufferHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribArrayObjectATI");
                _VertexAttribArrayObjectATI_fnptr(index, size, type, normalized, stride, buffer, offset);
            }
            
            private static delegate* unmanaged<uint, ArrayObjectPNameATI, float*, void> _GetVertexAttribArrayObjectfvATI_fnptr = &GetVertexAttribArrayObjectfvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, float* parameters) => _GetVertexAttribArrayObjectfvATI_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribArrayObjectfvATI_Lazy(uint index, ArrayObjectPNameATI pname, float* parameters)
            {
                _GetVertexAttribArrayObjectfvATI_fnptr = (delegate* unmanaged<uint, ArrayObjectPNameATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribArrayObjectfvATI");
                _GetVertexAttribArrayObjectfvATI_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, ArrayObjectPNameATI, int*, void> _GetVertexAttribArrayObjectivATI_fnptr = &GetVertexAttribArrayObjectivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, int* parameters) => _GetVertexAttribArrayObjectivATI_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribArrayObjectivATI_Lazy(uint index, ArrayObjectPNameATI pname, int* parameters)
            {
                _GetVertexAttribArrayObjectivATI_fnptr = (delegate* unmanaged<uint, ArrayObjectPNameATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribArrayObjectivATI");
                _GetVertexAttribArrayObjectivATI_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short, void> _VertexStream1sATI_fnptr = &VertexStream1sATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1sATI(VertexStreamATI stream, short x) => _VertexStream1sATI_fnptr(stream, x);
            [UnmanagedCallersOnly]
            private static void VertexStream1sATI_Lazy(VertexStreamATI stream, short x)
            {
                _VertexStream1sATI_fnptr = (delegate* unmanaged<VertexStreamATI, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream1sATI");
                _VertexStream1sATI_fnptr(stream, x);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short*, void> _VertexStream1svATI_fnptr = &VertexStream1svATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1svATI(VertexStreamATI stream, short* coords) => _VertexStream1svATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream1svATI_Lazy(VertexStreamATI stream, short* coords)
            {
                _VertexStream1svATI_fnptr = (delegate* unmanaged<VertexStreamATI, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream1svATI");
                _VertexStream1svATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int, void> _VertexStream1iATI_fnptr = &VertexStream1iATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1iATI(VertexStreamATI stream, int x) => _VertexStream1iATI_fnptr(stream, x);
            [UnmanagedCallersOnly]
            private static void VertexStream1iATI_Lazy(VertexStreamATI stream, int x)
            {
                _VertexStream1iATI_fnptr = (delegate* unmanaged<VertexStreamATI, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream1iATI");
                _VertexStream1iATI_fnptr(stream, x);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int*, void> _VertexStream1ivATI_fnptr = &VertexStream1ivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1ivATI(VertexStreamATI stream, int* coords) => _VertexStream1ivATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream1ivATI_Lazy(VertexStreamATI stream, int* coords)
            {
                _VertexStream1ivATI_fnptr = (delegate* unmanaged<VertexStreamATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream1ivATI");
                _VertexStream1ivATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float, void> _VertexStream1fATI_fnptr = &VertexStream1fATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1fATI(VertexStreamATI stream, float x) => _VertexStream1fATI_fnptr(stream, x);
            [UnmanagedCallersOnly]
            private static void VertexStream1fATI_Lazy(VertexStreamATI stream, float x)
            {
                _VertexStream1fATI_fnptr = (delegate* unmanaged<VertexStreamATI, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream1fATI");
                _VertexStream1fATI_fnptr(stream, x);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float*, void> _VertexStream1fvATI_fnptr = &VertexStream1fvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1fvATI(VertexStreamATI stream, float* coords) => _VertexStream1fvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream1fvATI_Lazy(VertexStreamATI stream, float* coords)
            {
                _VertexStream1fvATI_fnptr = (delegate* unmanaged<VertexStreamATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream1fvATI");
                _VertexStream1fvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double, void> _VertexStream1dATI_fnptr = &VertexStream1dATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1dATI(VertexStreamATI stream, double x) => _VertexStream1dATI_fnptr(stream, x);
            [UnmanagedCallersOnly]
            private static void VertexStream1dATI_Lazy(VertexStreamATI stream, double x)
            {
                _VertexStream1dATI_fnptr = (delegate* unmanaged<VertexStreamATI, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream1dATI");
                _VertexStream1dATI_fnptr(stream, x);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double*, void> _VertexStream1dvATI_fnptr = &VertexStream1dvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1dvATI(VertexStreamATI stream, double* coords) => _VertexStream1dvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream1dvATI_Lazy(VertexStreamATI stream, double* coords)
            {
                _VertexStream1dvATI_fnptr = (delegate* unmanaged<VertexStreamATI, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream1dvATI");
                _VertexStream1dvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short, short, void> _VertexStream2sATI_fnptr = &VertexStream2sATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2sATI(VertexStreamATI stream, short x, short y) => _VertexStream2sATI_fnptr(stream, x, y);
            [UnmanagedCallersOnly]
            private static void VertexStream2sATI_Lazy(VertexStreamATI stream, short x, short y)
            {
                _VertexStream2sATI_fnptr = (delegate* unmanaged<VertexStreamATI, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream2sATI");
                _VertexStream2sATI_fnptr(stream, x, y);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short*, void> _VertexStream2svATI_fnptr = &VertexStream2svATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2svATI(VertexStreamATI stream, short* coords) => _VertexStream2svATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream2svATI_Lazy(VertexStreamATI stream, short* coords)
            {
                _VertexStream2svATI_fnptr = (delegate* unmanaged<VertexStreamATI, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream2svATI");
                _VertexStream2svATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int, int, void> _VertexStream2iATI_fnptr = &VertexStream2iATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2iATI(VertexStreamATI stream, int x, int y) => _VertexStream2iATI_fnptr(stream, x, y);
            [UnmanagedCallersOnly]
            private static void VertexStream2iATI_Lazy(VertexStreamATI stream, int x, int y)
            {
                _VertexStream2iATI_fnptr = (delegate* unmanaged<VertexStreamATI, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream2iATI");
                _VertexStream2iATI_fnptr(stream, x, y);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int*, void> _VertexStream2ivATI_fnptr = &VertexStream2ivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2ivATI(VertexStreamATI stream, int* coords) => _VertexStream2ivATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream2ivATI_Lazy(VertexStreamATI stream, int* coords)
            {
                _VertexStream2ivATI_fnptr = (delegate* unmanaged<VertexStreamATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream2ivATI");
                _VertexStream2ivATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float, float, void> _VertexStream2fATI_fnptr = &VertexStream2fATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2fATI(VertexStreamATI stream, float x, float y) => _VertexStream2fATI_fnptr(stream, x, y);
            [UnmanagedCallersOnly]
            private static void VertexStream2fATI_Lazy(VertexStreamATI stream, float x, float y)
            {
                _VertexStream2fATI_fnptr = (delegate* unmanaged<VertexStreamATI, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream2fATI");
                _VertexStream2fATI_fnptr(stream, x, y);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float*, void> _VertexStream2fvATI_fnptr = &VertexStream2fvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2fvATI(VertexStreamATI stream, float* coords) => _VertexStream2fvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream2fvATI_Lazy(VertexStreamATI stream, float* coords)
            {
                _VertexStream2fvATI_fnptr = (delegate* unmanaged<VertexStreamATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream2fvATI");
                _VertexStream2fvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double, double, void> _VertexStream2dATI_fnptr = &VertexStream2dATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2dATI(VertexStreamATI stream, double x, double y) => _VertexStream2dATI_fnptr(stream, x, y);
            [UnmanagedCallersOnly]
            private static void VertexStream2dATI_Lazy(VertexStreamATI stream, double x, double y)
            {
                _VertexStream2dATI_fnptr = (delegate* unmanaged<VertexStreamATI, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream2dATI");
                _VertexStream2dATI_fnptr(stream, x, y);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double*, void> _VertexStream2dvATI_fnptr = &VertexStream2dvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2dvATI(VertexStreamATI stream, double* coords) => _VertexStream2dvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream2dvATI_Lazy(VertexStreamATI stream, double* coords)
            {
                _VertexStream2dvATI_fnptr = (delegate* unmanaged<VertexStreamATI, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream2dvATI");
                _VertexStream2dvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short, short, short, void> _VertexStream3sATI_fnptr = &VertexStream3sATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3sATI(VertexStreamATI stream, short x, short y, short z) => _VertexStream3sATI_fnptr(stream, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexStream3sATI_Lazy(VertexStreamATI stream, short x, short y, short z)
            {
                _VertexStream3sATI_fnptr = (delegate* unmanaged<VertexStreamATI, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream3sATI");
                _VertexStream3sATI_fnptr(stream, x, y, z);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short*, void> _VertexStream3svATI_fnptr = &VertexStream3svATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3svATI(VertexStreamATI stream, short* coords) => _VertexStream3svATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream3svATI_Lazy(VertexStreamATI stream, short* coords)
            {
                _VertexStream3svATI_fnptr = (delegate* unmanaged<VertexStreamATI, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream3svATI");
                _VertexStream3svATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int, int, int, void> _VertexStream3iATI_fnptr = &VertexStream3iATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3iATI(VertexStreamATI stream, int x, int y, int z) => _VertexStream3iATI_fnptr(stream, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexStream3iATI_Lazy(VertexStreamATI stream, int x, int y, int z)
            {
                _VertexStream3iATI_fnptr = (delegate* unmanaged<VertexStreamATI, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream3iATI");
                _VertexStream3iATI_fnptr(stream, x, y, z);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int*, void> _VertexStream3ivATI_fnptr = &VertexStream3ivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3ivATI(VertexStreamATI stream, int* coords) => _VertexStream3ivATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream3ivATI_Lazy(VertexStreamATI stream, int* coords)
            {
                _VertexStream3ivATI_fnptr = (delegate* unmanaged<VertexStreamATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream3ivATI");
                _VertexStream3ivATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float, float, float, void> _VertexStream3fATI_fnptr = &VertexStream3fATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3fATI(VertexStreamATI stream, float x, float y, float z) => _VertexStream3fATI_fnptr(stream, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexStream3fATI_Lazy(VertexStreamATI stream, float x, float y, float z)
            {
                _VertexStream3fATI_fnptr = (delegate* unmanaged<VertexStreamATI, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream3fATI");
                _VertexStream3fATI_fnptr(stream, x, y, z);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float*, void> _VertexStream3fvATI_fnptr = &VertexStream3fvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3fvATI(VertexStreamATI stream, float* coords) => _VertexStream3fvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream3fvATI_Lazy(VertexStreamATI stream, float* coords)
            {
                _VertexStream3fvATI_fnptr = (delegate* unmanaged<VertexStreamATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream3fvATI");
                _VertexStream3fvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double, double, double, void> _VertexStream3dATI_fnptr = &VertexStream3dATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3dATI(VertexStreamATI stream, double x, double y, double z) => _VertexStream3dATI_fnptr(stream, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexStream3dATI_Lazy(VertexStreamATI stream, double x, double y, double z)
            {
                _VertexStream3dATI_fnptr = (delegate* unmanaged<VertexStreamATI, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream3dATI");
                _VertexStream3dATI_fnptr(stream, x, y, z);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double*, void> _VertexStream3dvATI_fnptr = &VertexStream3dvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3dvATI(VertexStreamATI stream, double* coords) => _VertexStream3dvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream3dvATI_Lazy(VertexStreamATI stream, double* coords)
            {
                _VertexStream3dvATI_fnptr = (delegate* unmanaged<VertexStreamATI, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream3dvATI");
                _VertexStream3dvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short, short, short, short, void> _VertexStream4sATI_fnptr = &VertexStream4sATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4sATI(VertexStreamATI stream, short x, short y, short z, short w) => _VertexStream4sATI_fnptr(stream, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexStream4sATI_Lazy(VertexStreamATI stream, short x, short y, short z, short w)
            {
                _VertexStream4sATI_fnptr = (delegate* unmanaged<VertexStreamATI, short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream4sATI");
                _VertexStream4sATI_fnptr(stream, x, y, z, w);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short*, void> _VertexStream4svATI_fnptr = &VertexStream4svATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4svATI(VertexStreamATI stream, short* coords) => _VertexStream4svATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream4svATI_Lazy(VertexStreamATI stream, short* coords)
            {
                _VertexStream4svATI_fnptr = (delegate* unmanaged<VertexStreamATI, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream4svATI");
                _VertexStream4svATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int, int, int, int, void> _VertexStream4iATI_fnptr = &VertexStream4iATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4iATI(VertexStreamATI stream, int x, int y, int z, int w) => _VertexStream4iATI_fnptr(stream, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexStream4iATI_Lazy(VertexStreamATI stream, int x, int y, int z, int w)
            {
                _VertexStream4iATI_fnptr = (delegate* unmanaged<VertexStreamATI, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream4iATI");
                _VertexStream4iATI_fnptr(stream, x, y, z, w);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int*, void> _VertexStream4ivATI_fnptr = &VertexStream4ivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4ivATI(VertexStreamATI stream, int* coords) => _VertexStream4ivATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream4ivATI_Lazy(VertexStreamATI stream, int* coords)
            {
                _VertexStream4ivATI_fnptr = (delegate* unmanaged<VertexStreamATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream4ivATI");
                _VertexStream4ivATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float, float, float, float, void> _VertexStream4fATI_fnptr = &VertexStream4fATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4fATI(VertexStreamATI stream, float x, float y, float z, float w) => _VertexStream4fATI_fnptr(stream, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexStream4fATI_Lazy(VertexStreamATI stream, float x, float y, float z, float w)
            {
                _VertexStream4fATI_fnptr = (delegate* unmanaged<VertexStreamATI, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream4fATI");
                _VertexStream4fATI_fnptr(stream, x, y, z, w);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float*, void> _VertexStream4fvATI_fnptr = &VertexStream4fvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4fvATI(VertexStreamATI stream, float* coords) => _VertexStream4fvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream4fvATI_Lazy(VertexStreamATI stream, float* coords)
            {
                _VertexStream4fvATI_fnptr = (delegate* unmanaged<VertexStreamATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream4fvATI");
                _VertexStream4fvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double, double, double, double, void> _VertexStream4dATI_fnptr = &VertexStream4dATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4dATI(VertexStreamATI stream, double x, double y, double z, double w) => _VertexStream4dATI_fnptr(stream, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexStream4dATI_Lazy(VertexStreamATI stream, double x, double y, double z, double w)
            {
                _VertexStream4dATI_fnptr = (delegate* unmanaged<VertexStreamATI, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream4dATI");
                _VertexStream4dATI_fnptr(stream, x, y, z, w);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double*, void> _VertexStream4dvATI_fnptr = &VertexStream4dvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4dvATI(VertexStreamATI stream, double* coords) => _VertexStream4dvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void VertexStream4dvATI_Lazy(VertexStreamATI stream, double* coords)
            {
                _VertexStream4dvATI_fnptr = (delegate* unmanaged<VertexStreamATI, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexStream4dvATI");
                _VertexStream4dvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, sbyte, sbyte, sbyte, void> _NormalStream3bATI_fnptr = &NormalStream3bATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3bATI(VertexStreamATI stream, sbyte nx, sbyte ny, sbyte nz) => _NormalStream3bATI_fnptr(stream, nx, ny, nz);
            [UnmanagedCallersOnly]
            private static void NormalStream3bATI_Lazy(VertexStreamATI stream, sbyte nx, sbyte ny, sbyte nz)
            {
                _NormalStream3bATI_fnptr = (delegate* unmanaged<VertexStreamATI, sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3bATI");
                _NormalStream3bATI_fnptr(stream, nx, ny, nz);
            }
            
            private static delegate* unmanaged<VertexStreamATI, sbyte*, void> _NormalStream3bvATI_fnptr = &NormalStream3bvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3bvATI(VertexStreamATI stream, sbyte* coords) => _NormalStream3bvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void NormalStream3bvATI_Lazy(VertexStreamATI stream, sbyte* coords)
            {
                _NormalStream3bvATI_fnptr = (delegate* unmanaged<VertexStreamATI, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3bvATI");
                _NormalStream3bvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short, short, short, void> _NormalStream3sATI_fnptr = &NormalStream3sATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3sATI(VertexStreamATI stream, short nx, short ny, short nz) => _NormalStream3sATI_fnptr(stream, nx, ny, nz);
            [UnmanagedCallersOnly]
            private static void NormalStream3sATI_Lazy(VertexStreamATI stream, short nx, short ny, short nz)
            {
                _NormalStream3sATI_fnptr = (delegate* unmanaged<VertexStreamATI, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3sATI");
                _NormalStream3sATI_fnptr(stream, nx, ny, nz);
            }
            
            private static delegate* unmanaged<VertexStreamATI, short*, void> _NormalStream3svATI_fnptr = &NormalStream3svATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3svATI(VertexStreamATI stream, short* coords) => _NormalStream3svATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void NormalStream3svATI_Lazy(VertexStreamATI stream, short* coords)
            {
                _NormalStream3svATI_fnptr = (delegate* unmanaged<VertexStreamATI, short*, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3svATI");
                _NormalStream3svATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int, int, int, void> _NormalStream3iATI_fnptr = &NormalStream3iATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3iATI(VertexStreamATI stream, int nx, int ny, int nz) => _NormalStream3iATI_fnptr(stream, nx, ny, nz);
            [UnmanagedCallersOnly]
            private static void NormalStream3iATI_Lazy(VertexStreamATI stream, int nx, int ny, int nz)
            {
                _NormalStream3iATI_fnptr = (delegate* unmanaged<VertexStreamATI, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3iATI");
                _NormalStream3iATI_fnptr(stream, nx, ny, nz);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int*, void> _NormalStream3ivATI_fnptr = &NormalStream3ivATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3ivATI(VertexStreamATI stream, int* coords) => _NormalStream3ivATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void NormalStream3ivATI_Lazy(VertexStreamATI stream, int* coords)
            {
                _NormalStream3ivATI_fnptr = (delegate* unmanaged<VertexStreamATI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3ivATI");
                _NormalStream3ivATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float, float, float, void> _NormalStream3fATI_fnptr = &NormalStream3fATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3fATI(VertexStreamATI stream, float nx, float ny, float nz) => _NormalStream3fATI_fnptr(stream, nx, ny, nz);
            [UnmanagedCallersOnly]
            private static void NormalStream3fATI_Lazy(VertexStreamATI stream, float nx, float ny, float nz)
            {
                _NormalStream3fATI_fnptr = (delegate* unmanaged<VertexStreamATI, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3fATI");
                _NormalStream3fATI_fnptr(stream, nx, ny, nz);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float*, void> _NormalStream3fvATI_fnptr = &NormalStream3fvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3fvATI(VertexStreamATI stream, float* coords) => _NormalStream3fvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void NormalStream3fvATI_Lazy(VertexStreamATI stream, float* coords)
            {
                _NormalStream3fvATI_fnptr = (delegate* unmanaged<VertexStreamATI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3fvATI");
                _NormalStream3fvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double, double, double, void> _NormalStream3dATI_fnptr = &NormalStream3dATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3dATI(VertexStreamATI stream, double nx, double ny, double nz) => _NormalStream3dATI_fnptr(stream, nx, ny, nz);
            [UnmanagedCallersOnly]
            private static void NormalStream3dATI_Lazy(VertexStreamATI stream, double nx, double ny, double nz)
            {
                _NormalStream3dATI_fnptr = (delegate* unmanaged<VertexStreamATI, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3dATI");
                _NormalStream3dATI_fnptr(stream, nx, ny, nz);
            }
            
            private static delegate* unmanaged<VertexStreamATI, double*, void> _NormalStream3dvATI_fnptr = &NormalStream3dvATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3dvATI(VertexStreamATI stream, double* coords) => _NormalStream3dvATI_fnptr(stream, coords);
            [UnmanagedCallersOnly]
            private static void NormalStream3dvATI_Lazy(VertexStreamATI stream, double* coords)
            {
                _NormalStream3dvATI_fnptr = (delegate* unmanaged<VertexStreamATI, double*, void>)GLLoader.BindingsContext.GetProcAddress("glNormalStream3dvATI");
                _NormalStream3dvATI_fnptr(stream, coords);
            }
            
            private static delegate* unmanaged<VertexStreamATI, void> _ClientActiveVertexStreamATI_fnptr = &ClientActiveVertexStreamATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClientActiveVertexStreamATI(VertexStreamATI stream) => _ClientActiveVertexStreamATI_fnptr(stream);
            [UnmanagedCallersOnly]
            private static void ClientActiveVertexStreamATI_Lazy(VertexStreamATI stream)
            {
                _ClientActiveVertexStreamATI_fnptr = (delegate* unmanaged<VertexStreamATI, void>)GLLoader.BindingsContext.GetProcAddress("glClientActiveVertexStreamATI");
                _ClientActiveVertexStreamATI_fnptr(stream);
            }
            
            private static delegate* unmanaged<VertexStreamATI, int, void> _VertexBlendEnviATI_fnptr = &VertexBlendEnviATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexBlendEnviATI(VertexStreamATI pname, int param) => _VertexBlendEnviATI_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void VertexBlendEnviATI_Lazy(VertexStreamATI pname, int param)
            {
                _VertexBlendEnviATI_fnptr = (delegate* unmanaged<VertexStreamATI, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexBlendEnviATI");
                _VertexBlendEnviATI_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<VertexStreamATI, float, void> _VertexBlendEnvfATI_fnptr = &VertexBlendEnvfATI_Lazy;
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexBlendEnvfATI(VertexStreamATI pname, float param) => _VertexBlendEnvfATI_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void VertexBlendEnvfATI_Lazy(VertexStreamATI pname, float param)
            {
                _VertexBlendEnvfATI_fnptr = (delegate* unmanaged<VertexStreamATI, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexBlendEnvfATI");
                _VertexBlendEnvfATI_fnptr(pname, param);
            }
            
        }
        public static unsafe partial class EXT
        {
            private static delegate* unmanaged<All, void*, int*, void> _EGLImageTargetTexStorageEXT_fnptr = &EGLImageTargetTexStorageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EGLImageTargetTexStorageEXT(All target, void* image, int* attrib_list) => _EGLImageTargetTexStorageEXT_fnptr(target, image, attrib_list);
            [UnmanagedCallersOnly]
            private static void EGLImageTargetTexStorageEXT_Lazy(All target, void* image, int* attrib_list)
            {
                _EGLImageTargetTexStorageEXT_fnptr = (delegate* unmanaged<All, void*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glEGLImageTargetTexStorageEXT");
                _EGLImageTargetTexStorageEXT_fnptr(target, image, attrib_list);
            }
            
            private static delegate* unmanaged<TextureHandle, void*, int*, void> _EGLImageTargetTextureStorageEXT_fnptr = &EGLImageTargetTextureStorageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EGLImageTargetTextureStorageEXT(TextureHandle texture, void* image, int* attrib_list) => _EGLImageTargetTextureStorageEXT_fnptr(texture, image, attrib_list);
            [UnmanagedCallersOnly]
            private static void EGLImageTargetTextureStorageEXT_Lazy(TextureHandle texture, void* image, int* attrib_list)
            {
                _EGLImageTargetTextureStorageEXT_fnptr = (delegate* unmanaged<TextureHandle, void*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glEGLImageTargetTextureStorageEXT");
                _EGLImageTargetTextureStorageEXT_fnptr(texture, image, attrib_list);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, BufferHandle, void> _UniformBufferEXT_fnptr = &UniformBufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformBufferEXT(ProgramHandle program, int location, BufferHandle buffer) => _UniformBufferEXT_fnptr(program, location, buffer);
            [UnmanagedCallersOnly]
            private static void UniformBufferEXT_Lazy(ProgramHandle program, int location, BufferHandle buffer)
            {
                _UniformBufferEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glUniformBufferEXT");
                _UniformBufferEXT_fnptr(program, location, buffer);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int> _GetUniformBufferSizeEXT_fnptr = &GetUniformBufferSizeEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetUniformBufferSizeEXT(ProgramHandle program, int location) => _GetUniformBufferSizeEXT_fnptr(program, location);
            [UnmanagedCallersOnly]
            private static int GetUniformBufferSizeEXT_Lazy(ProgramHandle program, int location)
            {
                _GetUniformBufferSizeEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int>)GLLoader.BindingsContext.GetProcAddress("glGetUniformBufferSizeEXT");
                return _GetUniformBufferSizeEXT_fnptr(program, location);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, IntPtr> _GetUniformOffsetEXT_fnptr = &GetUniformOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr GetUniformOffsetEXT(ProgramHandle program, int location) => _GetUniformOffsetEXT_fnptr(program, location);
            [UnmanagedCallersOnly]
            private static IntPtr GetUniformOffsetEXT_Lazy(ProgramHandle program, int location)
            {
                _GetUniformOffsetEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glGetUniformOffsetEXT");
                return _GetUniformOffsetEXT_fnptr(program, location);
            }
            
            private static delegate* unmanaged<float, float, float, float, void> _BlendColorEXT_fnptr = &BlendColorEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_blend_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendColorEXT(float red, float green, float blue, float alpha) => _BlendColorEXT_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void BlendColorEXT_Lazy(float red, float green, float blue, float alpha)
            {
                _BlendColorEXT_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glBlendColorEXT");
                _BlendColorEXT_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<BlendEquationModeEXT, BlendEquationModeEXT, void> _BlendEquationSeparateEXT_fnptr = &BlendEquationSeparateEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_blend_equation_separate]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationSeparateEXT(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparateEXT_fnptr(modeRGB, modeAlpha);
            [UnmanagedCallersOnly]
            private static void BlendEquationSeparateEXT_Lazy(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha)
            {
                _BlendEquationSeparateEXT_fnptr = (delegate* unmanaged<BlendEquationModeEXT, BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquationSeparateEXT");
                _BlendEquationSeparateEXT_fnptr(modeRGB, modeAlpha);
            }
            
            private static delegate* unmanaged<BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void> _BlendFuncSeparateEXT_fnptr = &BlendFuncSeparateEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_blend_func_separate]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncSeparateEXT(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => _BlendFuncSeparateEXT_fnptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
            [UnmanagedCallersOnly]
            private static void BlendFuncSeparateEXT_Lazy(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha)
            {
                _BlendFuncSeparateEXT_fnptr = (delegate* unmanaged<BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFuncSeparateEXT");
                _BlendFuncSeparateEXT_fnptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
            }
            
            private static delegate* unmanaged<BlendEquationModeEXT, void> _BlendEquationEXT_fnptr = &BlendEquationEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_blend_minmax]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationEXT(BlendEquationModeEXT mode) => _BlendEquationEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void BlendEquationEXT_Lazy(BlendEquationModeEXT mode)
            {
                _BlendEquationEXT_fnptr = (delegate* unmanaged<BlendEquationModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glBlendEquationEXT");
                _BlendEquationEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<ColorTableTarget, int, int, PixelFormat, PixelType, void*, void> _ColorSubTableEXT_fnptr = &ColorSubTableEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_color_subtable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorSubTableEXT(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data) => _ColorSubTableEXT_fnptr(target, start, count, format, type, data);
            [UnmanagedCallersOnly]
            private static void ColorSubTableEXT_Lazy(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data)
            {
                _ColorSubTableEXT_fnptr = (delegate* unmanaged<ColorTableTarget, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glColorSubTableEXT");
                _ColorSubTableEXT_fnptr(target, start, count, format, type, data);
            }
            
            private static delegate* unmanaged<ColorTableTarget, int, int, int, int, void> _CopyColorSubTableEXT_fnptr = &CopyColorSubTableEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_color_subtable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyColorSubTableEXT(ColorTableTarget target, int start, int x, int y, int width) => _CopyColorSubTableEXT_fnptr(target, start, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyColorSubTableEXT_Lazy(ColorTableTarget target, int start, int x, int y, int width)
            {
                _CopyColorSubTableEXT_fnptr = (delegate* unmanaged<ColorTableTarget, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyColorSubTableEXT");
                _CopyColorSubTableEXT_fnptr(target, start, x, y, width);
            }
            
            private static delegate* unmanaged<int, int, void> _LockArraysEXT_fnptr = &LockArraysEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LockArraysEXT(int first, int count) => _LockArraysEXT_fnptr(first, count);
            [UnmanagedCallersOnly]
            private static void LockArraysEXT_Lazy(int first, int count)
            {
                _LockArraysEXT_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glLockArraysEXT");
                _LockArraysEXT_fnptr(first, count);
            }
            
            private static delegate* unmanaged<void> _UnlockArraysEXT_fnptr = &UnlockArraysEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UnlockArraysEXT() => _UnlockArraysEXT_fnptr();
            [UnmanagedCallersOnly]
            private static void UnlockArraysEXT_Lazy()
            {
                _UnlockArraysEXT_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glUnlockArraysEXT");
                _UnlockArraysEXT_fnptr();
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, InternalFormat, int, PixelFormat, PixelType, void*, void> _ConvolutionFilter1DEXT_fnptr = &ConvolutionFilter1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image) => _ConvolutionFilter1DEXT_fnptr(target, internalformat, width, format, type, image);
            [UnmanagedCallersOnly]
            private static void ConvolutionFilter1DEXT_Lazy(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image)
            {
                _ConvolutionFilter1DEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, InternalFormat, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionFilter1DEXT");
                _ConvolutionFilter1DEXT_fnptr(target, internalformat, width, format, type, image);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, InternalFormat, int, int, PixelFormat, PixelType, void*, void> _ConvolutionFilter2DEXT_fnptr = &ConvolutionFilter2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image) => _ConvolutionFilter2DEXT_fnptr(target, internalformat, width, height, format, type, image);
            [UnmanagedCallersOnly]
            private static void ConvolutionFilter2DEXT_Lazy(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image)
            {
                _ConvolutionFilter2DEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, InternalFormat, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionFilter2DEXT");
                _ConvolutionFilter2DEXT_fnptr(target, internalformat, width, height, format, type, image);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, float, void> _ConvolutionParameterfEXT_fnptr = &ConvolutionParameterfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterfEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float parameters) => _ConvolutionParameterfEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameterfEXT_Lazy(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float parameters)
            {
                _ConvolutionParameterfEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, float, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameterfEXT");
                _ConvolutionParameterfEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, float*, void> _ConvolutionParameterfvEXT_fnptr = &ConvolutionParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float* parameters) => _ConvolutionParameterfvEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameterfvEXT_Lazy(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float* parameters)
            {
                _ConvolutionParameterfvEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameterfvEXT");
                _ConvolutionParameterfvEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int, void> _ConvolutionParameteriEXT_fnptr = &ConvolutionParameteriEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameteriEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int parameters) => _ConvolutionParameteriEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameteriEXT_Lazy(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int parameters)
            {
                _ConvolutionParameteriEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameteriEXT");
                _ConvolutionParameteriEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int*, void> _ConvolutionParameterivEXT_fnptr = &ConvolutionParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int* parameters) => _ConvolutionParameterivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameterivEXT_Lazy(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int* parameters)
            {
                _ConvolutionParameterivEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameterivEXT");
                _ConvolutionParameterivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, InternalFormat, int, int, int, void> _CopyConvolutionFilter1DEXT_fnptr = &CopyConvolutionFilter1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width) => _CopyConvolutionFilter1DEXT_fnptr(target, internalformat, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyConvolutionFilter1DEXT_Lazy(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width)
            {
                _CopyConvolutionFilter1DEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, InternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyConvolutionFilter1DEXT");
                _CopyConvolutionFilter1DEXT_fnptr(target, internalformat, x, y, width);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, InternalFormat, int, int, int, int, void> _CopyConvolutionFilter2DEXT_fnptr = &CopyConvolutionFilter2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width, int height) => _CopyConvolutionFilter2DEXT_fnptr(target, internalformat, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyConvolutionFilter2DEXT_Lazy(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width, int height)
            {
                _CopyConvolutionFilter2DEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, InternalFormat, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyConvolutionFilter2DEXT");
                _CopyConvolutionFilter2DEXT_fnptr(target, internalformat, x, y, width, height);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, PixelFormat, PixelType, void*, void> _GetConvolutionFilterEXT_fnptr = &GetConvolutionFilterEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetConvolutionFilterEXT(ConvolutionTargetEXT target, PixelFormat format, PixelType type, void* image) => _GetConvolutionFilterEXT_fnptr(target, format, type, image);
            [UnmanagedCallersOnly]
            private static void GetConvolutionFilterEXT_Lazy(ConvolutionTargetEXT target, PixelFormat format, PixelType type, void* image)
            {
                _GetConvolutionFilterEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetConvolutionFilterEXT");
                _GetConvolutionFilterEXT_fnptr(target, format, type, image);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, float*, void> _GetConvolutionParameterfvEXT_fnptr = &GetConvolutionParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float* parameters) => _GetConvolutionParameterfvEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetConvolutionParameterfvEXT_Lazy(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float* parameters)
            {
                _GetConvolutionParameterfvEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetConvolutionParameterfvEXT");
                _GetConvolutionParameterfvEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int*, void> _GetConvolutionParameterivEXT_fnptr = &GetConvolutionParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int* parameters) => _GetConvolutionParameterivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetConvolutionParameterivEXT_Lazy(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int* parameters)
            {
                _GetConvolutionParameterivEXT_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetConvolutionParameterivEXT");
                _GetConvolutionParameterivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<SeparableTargetEXT, PixelFormat, PixelType, void*, void*, void*, void> _GetSeparableFilterEXT_fnptr = &GetSeparableFilterEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetSeparableFilterEXT(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span) => _GetSeparableFilterEXT_fnptr(target, format, type, row, column, span);
            [UnmanagedCallersOnly]
            private static void GetSeparableFilterEXT_Lazy(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span)
            {
                _GetSeparableFilterEXT_fnptr = (delegate* unmanaged<SeparableTargetEXT, PixelFormat, PixelType, void*, void*, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSeparableFilterEXT");
                _GetSeparableFilterEXT_fnptr(target, format, type, row, column, span);
            }
            
            private static delegate* unmanaged<SeparableTargetEXT, InternalFormat, int, int, PixelFormat, PixelType, void*, void*, void> _SeparableFilter2DEXT_fnptr = &SeparableFilter2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SeparableFilter2DEXT(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column) => _SeparableFilter2DEXT_fnptr(target, internalformat, width, height, format, type, row, column);
            [UnmanagedCallersOnly]
            private static void SeparableFilter2DEXT_Lazy(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column)
            {
                _SeparableFilter2DEXT_fnptr = (delegate* unmanaged<SeparableTargetEXT, InternalFormat, int, int, PixelFormat, PixelType, void*, void*, void>)GLLoader.BindingsContext.GetProcAddress("glSeparableFilter2DEXT");
                _SeparableFilter2DEXT_fnptr(target, internalformat, width, height, format, type, row, column);
            }
            
            private static delegate* unmanaged<sbyte, sbyte, sbyte, void> _Tangent3bEXT_fnptr = &Tangent3bEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3bEXT(sbyte tx, sbyte ty, sbyte tz) => _Tangent3bEXT_fnptr(tx, ty, tz);
            [UnmanagedCallersOnly]
            private static void Tangent3bEXT_Lazy(sbyte tx, sbyte ty, sbyte tz)
            {
                _Tangent3bEXT_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3bEXT");
                _Tangent3bEXT_fnptr(tx, ty, tz);
            }
            
            private static delegate* unmanaged<sbyte*, void> _Tangent3bvEXT_fnptr = &Tangent3bvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3bvEXT(sbyte* v) => _Tangent3bvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Tangent3bvEXT_Lazy(sbyte* v)
            {
                _Tangent3bvEXT_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3bvEXT");
                _Tangent3bvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<double, double, double, void> _Tangent3dEXT_fnptr = &Tangent3dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3dEXT(double tx, double ty, double tz) => _Tangent3dEXT_fnptr(tx, ty, tz);
            [UnmanagedCallersOnly]
            private static void Tangent3dEXT_Lazy(double tx, double ty, double tz)
            {
                _Tangent3dEXT_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3dEXT");
                _Tangent3dEXT_fnptr(tx, ty, tz);
            }
            
            private static delegate* unmanaged<double*, void> _Tangent3dvEXT_fnptr = &Tangent3dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3dvEXT(double* v) => _Tangent3dvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Tangent3dvEXT_Lazy(double* v)
            {
                _Tangent3dvEXT_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3dvEXT");
                _Tangent3dvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<float, float, float, void> _Tangent3fEXT_fnptr = &Tangent3fEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3fEXT(float tx, float ty, float tz) => _Tangent3fEXT_fnptr(tx, ty, tz);
            [UnmanagedCallersOnly]
            private static void Tangent3fEXT_Lazy(float tx, float ty, float tz)
            {
                _Tangent3fEXT_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3fEXT");
                _Tangent3fEXT_fnptr(tx, ty, tz);
            }
            
            private static delegate* unmanaged<float*, void> _Tangent3fvEXT_fnptr = &Tangent3fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3fvEXT(float* v) => _Tangent3fvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Tangent3fvEXT_Lazy(float* v)
            {
                _Tangent3fvEXT_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3fvEXT");
                _Tangent3fvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<int, int, int, void> _Tangent3iEXT_fnptr = &Tangent3iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3iEXT(int tx, int ty, int tz) => _Tangent3iEXT_fnptr(tx, ty, tz);
            [UnmanagedCallersOnly]
            private static void Tangent3iEXT_Lazy(int tx, int ty, int tz)
            {
                _Tangent3iEXT_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3iEXT");
                _Tangent3iEXT_fnptr(tx, ty, tz);
            }
            
            private static delegate* unmanaged<int*, void> _Tangent3ivEXT_fnptr = &Tangent3ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3ivEXT(int* v) => _Tangent3ivEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Tangent3ivEXT_Lazy(int* v)
            {
                _Tangent3ivEXT_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3ivEXT");
                _Tangent3ivEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<short, short, short, void> _Tangent3sEXT_fnptr = &Tangent3sEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3sEXT(short tx, short ty, short tz) => _Tangent3sEXT_fnptr(tx, ty, tz);
            [UnmanagedCallersOnly]
            private static void Tangent3sEXT_Lazy(short tx, short ty, short tz)
            {
                _Tangent3sEXT_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3sEXT");
                _Tangent3sEXT_fnptr(tx, ty, tz);
            }
            
            private static delegate* unmanaged<short*, void> _Tangent3svEXT_fnptr = &Tangent3svEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3svEXT(short* v) => _Tangent3svEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Tangent3svEXT_Lazy(short* v)
            {
                _Tangent3svEXT_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glTangent3svEXT");
                _Tangent3svEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<sbyte, sbyte, sbyte, void> _Binormal3bEXT_fnptr = &Binormal3bEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3bEXT(sbyte bx, sbyte by, sbyte bz) => _Binormal3bEXT_fnptr(bx, by, bz);
            [UnmanagedCallersOnly]
            private static void Binormal3bEXT_Lazy(sbyte bx, sbyte by, sbyte bz)
            {
                _Binormal3bEXT_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3bEXT");
                _Binormal3bEXT_fnptr(bx, by, bz);
            }
            
            private static delegate* unmanaged<sbyte*, void> _Binormal3bvEXT_fnptr = &Binormal3bvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3bvEXT(sbyte* v) => _Binormal3bvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Binormal3bvEXT_Lazy(sbyte* v)
            {
                _Binormal3bvEXT_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3bvEXT");
                _Binormal3bvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<double, double, double, void> _Binormal3dEXT_fnptr = &Binormal3dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3dEXT(double bx, double by, double bz) => _Binormal3dEXT_fnptr(bx, by, bz);
            [UnmanagedCallersOnly]
            private static void Binormal3dEXT_Lazy(double bx, double by, double bz)
            {
                _Binormal3dEXT_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3dEXT");
                _Binormal3dEXT_fnptr(bx, by, bz);
            }
            
            private static delegate* unmanaged<double*, void> _Binormal3dvEXT_fnptr = &Binormal3dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3dvEXT(double* v) => _Binormal3dvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Binormal3dvEXT_Lazy(double* v)
            {
                _Binormal3dvEXT_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3dvEXT");
                _Binormal3dvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<float, float, float, void> _Binormal3fEXT_fnptr = &Binormal3fEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3fEXT(float bx, float by, float bz) => _Binormal3fEXT_fnptr(bx, by, bz);
            [UnmanagedCallersOnly]
            private static void Binormal3fEXT_Lazy(float bx, float by, float bz)
            {
                _Binormal3fEXT_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3fEXT");
                _Binormal3fEXT_fnptr(bx, by, bz);
            }
            
            private static delegate* unmanaged<float*, void> _Binormal3fvEXT_fnptr = &Binormal3fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3fvEXT(float* v) => _Binormal3fvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Binormal3fvEXT_Lazy(float* v)
            {
                _Binormal3fvEXT_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3fvEXT");
                _Binormal3fvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<int, int, int, void> _Binormal3iEXT_fnptr = &Binormal3iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3iEXT(int bx, int by, int bz) => _Binormal3iEXT_fnptr(bx, by, bz);
            [UnmanagedCallersOnly]
            private static void Binormal3iEXT_Lazy(int bx, int by, int bz)
            {
                _Binormal3iEXT_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3iEXT");
                _Binormal3iEXT_fnptr(bx, by, bz);
            }
            
            private static delegate* unmanaged<int*, void> _Binormal3ivEXT_fnptr = &Binormal3ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3ivEXT(int* v) => _Binormal3ivEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Binormal3ivEXT_Lazy(int* v)
            {
                _Binormal3ivEXT_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3ivEXT");
                _Binormal3ivEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<short, short, short, void> _Binormal3sEXT_fnptr = &Binormal3sEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3sEXT(short bx, short by, short bz) => _Binormal3sEXT_fnptr(bx, by, bz);
            [UnmanagedCallersOnly]
            private static void Binormal3sEXT_Lazy(short bx, short by, short bz)
            {
                _Binormal3sEXT_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3sEXT");
                _Binormal3sEXT_fnptr(bx, by, bz);
            }
            
            private static delegate* unmanaged<short*, void> _Binormal3svEXT_fnptr = &Binormal3svEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3svEXT(short* v) => _Binormal3svEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Binormal3svEXT_Lazy(short* v)
            {
                _Binormal3svEXT_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glBinormal3svEXT");
                _Binormal3svEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<TangentPointerTypeEXT, int, void*, void> _TangentPointerEXT_fnptr = &TangentPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TangentPointerEXT(TangentPointerTypeEXT type, int stride, void* pointer) => _TangentPointerEXT_fnptr(type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void TangentPointerEXT_Lazy(TangentPointerTypeEXT type, int stride, void* pointer)
            {
                _TangentPointerEXT_fnptr = (delegate* unmanaged<TangentPointerTypeEXT, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTangentPointerEXT");
                _TangentPointerEXT_fnptr(type, stride, pointer);
            }
            
            private static delegate* unmanaged<BinormalPointerTypeEXT, int, void*, void> _BinormalPointerEXT_fnptr = &BinormalPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BinormalPointerEXT(BinormalPointerTypeEXT type, int stride, void* pointer) => _BinormalPointerEXT_fnptr(type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void BinormalPointerEXT_Lazy(BinormalPointerTypeEXT type, int stride, void* pointer)
            {
                _BinormalPointerEXT_fnptr = (delegate* unmanaged<BinormalPointerTypeEXT, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glBinormalPointerEXT");
                _BinormalPointerEXT_fnptr(type, stride, pointer);
            }
            
            private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, void> _CopyTexImage1DEXT_fnptr = &CopyTexImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexImage1DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => _CopyTexImage1DEXT_fnptr(target, level, internalformat, x, y, width, border);
            [UnmanagedCallersOnly]
            private static void CopyTexImage1DEXT_Lazy(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border)
            {
                _CopyTexImage1DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexImage1DEXT");
                _CopyTexImage1DEXT_fnptr(target, level, internalformat, x, y, width, border);
            }
            
            private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, void> _CopyTexImage2DEXT_fnptr = &CopyTexImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexImage2DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => _CopyTexImage2DEXT_fnptr(target, level, internalformat, x, y, width, height, border);
            [UnmanagedCallersOnly]
            private static void CopyTexImage2DEXT_Lazy(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border)
            {
                _CopyTexImage2DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexImage2DEXT");
                _CopyTexImage2DEXT_fnptr(target, level, internalformat, x, y, width, height, border);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, void> _CopyTexSubImage1DEXT_fnptr = &CopyTexSubImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexSubImage1DEXT(TextureTarget target, int level, int xoffset, int x, int y, int width) => _CopyTexSubImage1DEXT_fnptr(target, level, xoffset, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyTexSubImage1DEXT_Lazy(TextureTarget target, int level, int xoffset, int x, int y, int width)
            {
                _CopyTexSubImage1DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexSubImage1DEXT");
                _CopyTexSubImage1DEXT_fnptr(target, level, xoffset, x, y, width);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, void> _CopyTexSubImage2DEXT_fnptr = &CopyTexSubImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyTexSubImage2DEXT_fnptr(target, level, xoffset, yoffset, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyTexSubImage2DEXT_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
            {
                _CopyTexSubImage2DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexSubImage2DEXT");
                _CopyTexSubImage2DEXT_fnptr(target, level, xoffset, yoffset, x, y, width, height);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, int, void> _CopyTexSubImage3DEXT_fnptr = &CopyTexSubImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTexSubImage3DEXT_fnptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyTexSubImage3DEXT_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
            {
                _CopyTexSubImage3DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTexSubImage3DEXT");
                _CopyTexSubImage3DEXT_fnptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            
            private static delegate* unmanaged<CullParameterEXT, double*, void> _CullParameterdvEXT_fnptr = &CullParameterdvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_cull_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CullParameterdvEXT(CullParameterEXT pname, double* parameters) => _CullParameterdvEXT_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void CullParameterdvEXT_Lazy(CullParameterEXT pname, double* parameters)
            {
                _CullParameterdvEXT_fnptr = (delegate* unmanaged<CullParameterEXT, double*, void>)GLLoader.BindingsContext.GetProcAddress("glCullParameterdvEXT");
                _CullParameterdvEXT_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<CullParameterEXT, float*, void> _CullParameterfvEXT_fnptr = &CullParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_cull_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CullParameterfvEXT(CullParameterEXT pname, float* parameters) => _CullParameterfvEXT_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void CullParameterfvEXT_Lazy(CullParameterEXT pname, float* parameters)
            {
                _CullParameterfvEXT_fnptr = (delegate* unmanaged<CullParameterEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glCullParameterfvEXT");
                _CullParameterfvEXT_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<All, uint, int, byte*, void> _LabelObjectEXT_fnptr = &LabelObjectEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_debug_label]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LabelObjectEXT(All type, uint obj, int length, byte* label) => _LabelObjectEXT_fnptr(type, obj, length, label);
            [UnmanagedCallersOnly]
            private static void LabelObjectEXT_Lazy(All type, uint obj, int length, byte* label)
            {
                _LabelObjectEXT_fnptr = (delegate* unmanaged<All, uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glLabelObjectEXT");
                _LabelObjectEXT_fnptr(type, obj, length, label);
            }
            
            private static delegate* unmanaged<All, uint, int, int*, byte*, void> _GetObjectLabelEXT_fnptr = &GetObjectLabelEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_debug_label]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectLabelEXT(All type, uint obj, int bufSize, int* length, byte* label) => _GetObjectLabelEXT_fnptr(type, obj, bufSize, length, label);
            [UnmanagedCallersOnly]
            private static void GetObjectLabelEXT_Lazy(All type, uint obj, int bufSize, int* length, byte* label)
            {
                _GetObjectLabelEXT_fnptr = (delegate* unmanaged<All, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectLabelEXT");
                _GetObjectLabelEXT_fnptr(type, obj, bufSize, length, label);
            }
            
            private static delegate* unmanaged<int, byte*, void> _InsertEventMarkerEXT_fnptr = &InsertEventMarkerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void InsertEventMarkerEXT(int length, byte* marker) => _InsertEventMarkerEXT_fnptr(length, marker);
            [UnmanagedCallersOnly]
            private static void InsertEventMarkerEXT_Lazy(int length, byte* marker)
            {
                _InsertEventMarkerEXT_fnptr = (delegate* unmanaged<int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glInsertEventMarkerEXT");
                _InsertEventMarkerEXT_fnptr(length, marker);
            }
            
            private static delegate* unmanaged<int, byte*, void> _PushGroupMarkerEXT_fnptr = &PushGroupMarkerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PushGroupMarkerEXT(int length, byte* marker) => _PushGroupMarkerEXT_fnptr(length, marker);
            [UnmanagedCallersOnly]
            private static void PushGroupMarkerEXT_Lazy(int length, byte* marker)
            {
                _PushGroupMarkerEXT_fnptr = (delegate* unmanaged<int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glPushGroupMarkerEXT");
                _PushGroupMarkerEXT_fnptr(length, marker);
            }
            
            private static delegate* unmanaged<void> _PopGroupMarkerEXT_fnptr = &PopGroupMarkerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PopGroupMarkerEXT() => _PopGroupMarkerEXT_fnptr();
            [UnmanagedCallersOnly]
            private static void PopGroupMarkerEXT_Lazy()
            {
                _PopGroupMarkerEXT_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPopGroupMarkerEXT");
                _PopGroupMarkerEXT_fnptr();
            }
            
            private static delegate* unmanaged<double, double, void> _DepthBoundsEXT_fnptr = &DepthBoundsEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_depth_bounds_test]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthBoundsEXT(double zmin, double zmax) => _DepthBoundsEXT_fnptr(zmin, zmax);
            [UnmanagedCallersOnly]
            private static void DepthBoundsEXT_Lazy(double zmin, double zmax)
            {
                _DepthBoundsEXT_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glDepthBoundsEXT");
                _DepthBoundsEXT_fnptr(zmin, zmax);
            }
            
            private static delegate* unmanaged<MatrixMode, float*, void> _MatrixLoadfEXT_fnptr = &MatrixLoadfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadfEXT(MatrixMode mode, float* m) => _MatrixLoadfEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoadfEXT_Lazy(MatrixMode mode, float* m)
            {
                _MatrixLoadfEXT_fnptr = (delegate* unmanaged<MatrixMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoadfEXT");
                _MatrixLoadfEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, double*, void> _MatrixLoaddEXT_fnptr = &MatrixLoaddEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoaddEXT(MatrixMode mode, double* m) => _MatrixLoaddEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoaddEXT_Lazy(MatrixMode mode, double* m)
            {
                _MatrixLoaddEXT_fnptr = (delegate* unmanaged<MatrixMode, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoaddEXT");
                _MatrixLoaddEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, float*, void> _MatrixMultfEXT_fnptr = &MatrixMultfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultfEXT(MatrixMode mode, float* m) => _MatrixMultfEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMultfEXT_Lazy(MatrixMode mode, float* m)
            {
                _MatrixMultfEXT_fnptr = (delegate* unmanaged<MatrixMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMultfEXT");
                _MatrixMultfEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, double*, void> _MatrixMultdEXT_fnptr = &MatrixMultdEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultdEXT(MatrixMode mode, double* m) => _MatrixMultdEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMultdEXT_Lazy(MatrixMode mode, double* m)
            {
                _MatrixMultdEXT_fnptr = (delegate* unmanaged<MatrixMode, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMultdEXT");
                _MatrixMultdEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, void> _MatrixLoadIdentityEXT_fnptr = &MatrixLoadIdentityEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadIdentityEXT(MatrixMode mode) => _MatrixLoadIdentityEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void MatrixLoadIdentityEXT_Lazy(MatrixMode mode)
            {
                _MatrixLoadIdentityEXT_fnptr = (delegate* unmanaged<MatrixMode, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoadIdentityEXT");
                _MatrixLoadIdentityEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<MatrixMode, float, float, float, float, void> _MatrixRotatefEXT_fnptr = &MatrixRotatefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => _MatrixRotatefEXT_fnptr(mode, angle, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixRotatefEXT_Lazy(MatrixMode mode, float angle, float x, float y, float z)
            {
                _MatrixRotatefEXT_fnptr = (delegate* unmanaged<MatrixMode, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixRotatefEXT");
                _MatrixRotatefEXT_fnptr(mode, angle, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, double, void> _MatrixRotatedEXT_fnptr = &MatrixRotatedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => _MatrixRotatedEXT_fnptr(mode, angle, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixRotatedEXT_Lazy(MatrixMode mode, double angle, double x, double y, double z)
            {
                _MatrixRotatedEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixRotatedEXT");
                _MatrixRotatedEXT_fnptr(mode, angle, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, float, float, float, void> _MatrixScalefEXT_fnptr = &MatrixScalefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => _MatrixScalefEXT_fnptr(mode, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixScalefEXT_Lazy(MatrixMode mode, float x, float y, float z)
            {
                _MatrixScalefEXT_fnptr = (delegate* unmanaged<MatrixMode, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixScalefEXT");
                _MatrixScalefEXT_fnptr(mode, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, void> _MatrixScaledEXT_fnptr = &MatrixScaledEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => _MatrixScaledEXT_fnptr(mode, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixScaledEXT_Lazy(MatrixMode mode, double x, double y, double z)
            {
                _MatrixScaledEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixScaledEXT");
                _MatrixScaledEXT_fnptr(mode, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, float, float, float, void> _MatrixTranslatefEXT_fnptr = &MatrixTranslatefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => _MatrixTranslatefEXT_fnptr(mode, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixTranslatefEXT_Lazy(MatrixMode mode, float x, float y, float z)
            {
                _MatrixTranslatefEXT_fnptr = (delegate* unmanaged<MatrixMode, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixTranslatefEXT");
                _MatrixTranslatefEXT_fnptr(mode, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, void> _MatrixTranslatedEXT_fnptr = &MatrixTranslatedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => _MatrixTranslatedEXT_fnptr(mode, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixTranslatedEXT_Lazy(MatrixMode mode, double x, double y, double z)
            {
                _MatrixTranslatedEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixTranslatedEXT");
                _MatrixTranslatedEXT_fnptr(mode, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, double, double, double, void> _MatrixFrustumEXT_fnptr = &MatrixFrustumEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => _MatrixFrustumEXT_fnptr(mode, left, right, bottom, top, zNear, zFar);
            [UnmanagedCallersOnly]
            private static void MatrixFrustumEXT_Lazy(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
            {
                _MatrixFrustumEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixFrustumEXT");
                _MatrixFrustumEXT_fnptr(mode, left, right, bottom, top, zNear, zFar);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, double, double, double, void> _MatrixOrthoEXT_fnptr = &MatrixOrthoEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => _MatrixOrthoEXT_fnptr(mode, left, right, bottom, top, zNear, zFar);
            [UnmanagedCallersOnly]
            private static void MatrixOrthoEXT_Lazy(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
            {
                _MatrixOrthoEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixOrthoEXT");
                _MatrixOrthoEXT_fnptr(mode, left, right, bottom, top, zNear, zFar);
            }
            
            private static delegate* unmanaged<MatrixMode, void> _MatrixPopEXT_fnptr = &MatrixPopEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixPopEXT(MatrixMode mode) => _MatrixPopEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void MatrixPopEXT_Lazy(MatrixMode mode)
            {
                _MatrixPopEXT_fnptr = (delegate* unmanaged<MatrixMode, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixPopEXT");
                _MatrixPopEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<MatrixMode, void> _MatrixPushEXT_fnptr = &MatrixPushEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixPushEXT(MatrixMode mode) => _MatrixPushEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void MatrixPushEXT_Lazy(MatrixMode mode)
            {
                _MatrixPushEXT_fnptr = (delegate* unmanaged<MatrixMode, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixPushEXT");
                _MatrixPushEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<ClientAttribMask, void> _ClientAttribDefaultEXT_fnptr = &ClientAttribDefaultEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClientAttribDefaultEXT(ClientAttribMask mask) => _ClientAttribDefaultEXT_fnptr(mask);
            [UnmanagedCallersOnly]
            private static void ClientAttribDefaultEXT_Lazy(ClientAttribMask mask)
            {
                _ClientAttribDefaultEXT_fnptr = (delegate* unmanaged<ClientAttribMask, void>)GLLoader.BindingsContext.GetProcAddress("glClientAttribDefaultEXT");
                _ClientAttribDefaultEXT_fnptr(mask);
            }
            
            private static delegate* unmanaged<ClientAttribMask, void> _PushClientAttribDefaultEXT_fnptr = &PushClientAttribDefaultEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PushClientAttribDefaultEXT(ClientAttribMask mask) => _PushClientAttribDefaultEXT_fnptr(mask);
            [UnmanagedCallersOnly]
            private static void PushClientAttribDefaultEXT_Lazy(ClientAttribMask mask)
            {
                _PushClientAttribDefaultEXT_fnptr = (delegate* unmanaged<ClientAttribMask, void>)GLLoader.BindingsContext.GetProcAddress("glPushClientAttribDefaultEXT");
                _PushClientAttribDefaultEXT_fnptr(mask);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, float, void> _TextureParameterfEXT_fnptr = &TextureParameterfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterfEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, float param) => _TextureParameterfEXT_fnptr(texture, target, pname, param);
            [UnmanagedCallersOnly]
            private static void TextureParameterfEXT_Lazy(TextureHandle texture, TextureTarget target, TextureParameterName pname, float param)
            {
                _TextureParameterfEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, float, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterfEXT");
                _TextureParameterfEXT_fnptr(texture, target, pname, param);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, float*, void> _TextureParameterfvEXT_fnptr = &TextureParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterfvEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, float* parameters) => _TextureParameterfvEXT_fnptr(texture, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TextureParameterfvEXT_Lazy(TextureHandle texture, TextureTarget target, TextureParameterName pname, float* parameters)
            {
                _TextureParameterfvEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterfvEXT");
                _TextureParameterfvEXT_fnptr(texture, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, int, void> _TextureParameteriEXT_fnptr = &TextureParameteriEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameteriEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, int param) => _TextureParameteriEXT_fnptr(texture, target, pname, param);
            [UnmanagedCallersOnly]
            private static void TextureParameteriEXT_Lazy(TextureHandle texture, TextureTarget target, TextureParameterName pname, int param)
            {
                _TextureParameteriEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameteriEXT");
                _TextureParameteriEXT_fnptr(texture, target, pname, param);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, int*, void> _TextureParameterivEXT_fnptr = &TextureParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, int* parameters) => _TextureParameterivEXT_fnptr(texture, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TextureParameterivEXT_Lazy(TextureHandle texture, TextureTarget target, TextureParameterName pname, int* parameters)
            {
                _TextureParameterivEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterivEXT");
                _TextureParameterivEXT_fnptr(texture, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, PixelFormat, PixelType, void*, void> _TextureImage1DEXT_fnptr = &TextureImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage1DEXT(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => _TextureImage1DEXT_fnptr(texture, target, level, internalformat, width, border, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TextureImage1DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels)
            {
                _TextureImage1DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureImage1DEXT");
                _TextureImage1DEXT_fnptr(texture, target, level, internalformat, width, border, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TextureImage2DEXT_fnptr = &TextureImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage2DEXT(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => _TextureImage2DEXT_fnptr(texture, target, level, internalformat, width, height, border, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TextureImage2DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels)
            {
                _TextureImage2DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureImage2DEXT");
                _TextureImage2DEXT_fnptr(texture, target, level, internalformat, width, height, border, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, PixelFormat, PixelType, void*, void> _TextureSubImage1DEXT_fnptr = &TextureSubImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureSubImage1DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => _TextureSubImage1DEXT_fnptr(texture, target, level, xoffset, width, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TextureSubImage1DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels)
            {
                _TextureSubImage1DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureSubImage1DEXT");
                _TextureSubImage1DEXT_fnptr(texture, target, level, xoffset, width, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TextureSubImage2DEXT_fnptr = &TextureSubImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureSubImage2DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => _TextureSubImage2DEXT_fnptr(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TextureSubImage2DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels)
            {
                _TextureSubImage2DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureSubImage2DEXT");
                _TextureSubImage2DEXT_fnptr(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, int, void> _CopyTextureImage1DEXT_fnptr = &CopyTextureImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureImage1DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => _CopyTextureImage1DEXT_fnptr(texture, target, level, internalformat, x, y, width, border);
            [UnmanagedCallersOnly]
            private static void CopyTextureImage1DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border)
            {
                _CopyTextureImage1DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureImage1DEXT");
                _CopyTextureImage1DEXT_fnptr(texture, target, level, internalformat, x, y, width, border);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, int, int, void> _CopyTextureImage2DEXT_fnptr = &CopyTextureImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureImage2DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => _CopyTextureImage2DEXT_fnptr(texture, target, level, internalformat, x, y, width, height, border);
            [UnmanagedCallersOnly]
            private static void CopyTextureImage2DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border)
            {
                _CopyTextureImage2DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureImage2DEXT");
                _CopyTextureImage2DEXT_fnptr(texture, target, level, internalformat, x, y, width, height, border);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, void> _CopyTextureSubImage1DEXT_fnptr = &CopyTextureSubImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureSubImage1DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int x, int y, int width) => _CopyTextureSubImage1DEXT_fnptr(texture, target, level, xoffset, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyTextureSubImage1DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int xoffset, int x, int y, int width)
            {
                _CopyTextureSubImage1DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureSubImage1DEXT");
                _CopyTextureSubImage1DEXT_fnptr(texture, target, level, xoffset, x, y, width);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, int, void> _CopyTextureSubImage2DEXT_fnptr = &CopyTextureSubImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureSubImage2DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyTextureSubImage2DEXT_fnptr(texture, target, level, xoffset, yoffset, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyTextureSubImage2DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
            {
                _CopyTextureSubImage2DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureSubImage2DEXT");
                _CopyTextureSubImage2DEXT_fnptr(texture, target, level, xoffset, yoffset, x, y, width, height);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, PixelFormat, PixelType, void*, void> _GetTextureImageEXT_fnptr = &GetTextureImageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureImageEXT(TextureHandle texture, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => _GetTextureImageEXT_fnptr(texture, target, level, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void GetTextureImageEXT_Lazy(TextureHandle texture, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels)
            {
                _GetTextureImageEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureImageEXT");
                _GetTextureImageEXT_fnptr(texture, target, level, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, GetTextureParameter, float*, void> _GetTextureParameterfvEXT_fnptr = &GetTextureParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureParameterfvEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, float* parameters) => _GetTextureParameterfvEXT_fnptr(texture, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureParameterfvEXT_Lazy(TextureHandle texture, TextureTarget target, GetTextureParameter pname, float* parameters)
            {
                _GetTextureParameterfvEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterfvEXT");
                _GetTextureParameterfvEXT_fnptr(texture, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, GetTextureParameter, int*, void> _GetTextureParameterivEXT_fnptr = &GetTextureParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureParameterivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, int* parameters) => _GetTextureParameterivEXT_fnptr(texture, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureParameterivEXT_Lazy(TextureHandle texture, TextureTarget target, GetTextureParameter pname, int* parameters)
            {
                _GetTextureParameterivEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterivEXT");
                _GetTextureParameterivEXT_fnptr(texture, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, GetTextureParameter, float*, void> _GetTextureLevelParameterfvEXT_fnptr = &GetTextureLevelParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureLevelParameterfvEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => _GetTextureLevelParameterfvEXT_fnptr(texture, target, level, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureLevelParameterfvEXT_Lazy(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, float* parameters)
            {
                _GetTextureLevelParameterfvEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureLevelParameterfvEXT");
                _GetTextureLevelParameterfvEXT_fnptr(texture, target, level, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, GetTextureParameter, int*, void> _GetTextureLevelParameterivEXT_fnptr = &GetTextureLevelParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureLevelParameterivEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => _GetTextureLevelParameterivEXT_fnptr(texture, target, level, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureLevelParameterivEXT_Lazy(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, int* parameters)
            {
                _GetTextureLevelParameterivEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureLevelParameterivEXT");
                _GetTextureLevelParameterivEXT_fnptr(texture, target, level, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TextureImage3DEXT_fnptr = &TextureImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage3DEXT(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => _TextureImage3DEXT_fnptr(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TextureImage3DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels)
            {
                _TextureImage3DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureImage3DEXT");
                _TextureImage3DEXT_fnptr(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TextureSubImage3DEXT_fnptr = &TextureSubImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureSubImage3DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => _TextureSubImage3DEXT_fnptr(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TextureSubImage3DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels)
            {
                _TextureSubImage3DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureSubImage3DEXT");
                _TextureSubImage3DEXT_fnptr(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, int, int, void> _CopyTextureSubImage3DEXT_fnptr = &CopyTextureSubImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureSubImage3DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTextureSubImage3DEXT_fnptr(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyTextureSubImage3DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
            {
                _CopyTextureSubImage3DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyTextureSubImage3DEXT");
                _CopyTextureSubImage3DEXT_fnptr(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, TextureHandle, void> _BindMultiTextureEXT_fnptr = &BindMultiTextureEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindMultiTextureEXT(TextureUnit texunit, TextureTarget target, TextureHandle texture) => _BindMultiTextureEXT_fnptr(texunit, target, texture);
            [UnmanagedCallersOnly]
            private static void BindMultiTextureEXT_Lazy(TextureUnit texunit, TextureTarget target, TextureHandle texture)
            {
                _BindMultiTextureEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindMultiTextureEXT");
                _BindMultiTextureEXT_fnptr(texunit, target, texture);
            }
            
            private static delegate* unmanaged<TextureUnit, int, TexCoordPointerType, int, void*, void> _MultiTexCoordPointerEXT_fnptr = &MultiTexCoordPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordPointerEXT(TextureUnit texunit, int size, TexCoordPointerType type, int stride, void* pointer) => _MultiTexCoordPointerEXT_fnptr(texunit, size, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void MultiTexCoordPointerEXT_Lazy(TextureUnit texunit, int size, TexCoordPointerType type, int stride, void* pointer)
            {
                _MultiTexCoordPointerEXT_fnptr = (delegate* unmanaged<TextureUnit, int, TexCoordPointerType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoordPointerEXT");
                _MultiTexCoordPointerEXT_fnptr(texunit, size, type, stride, pointer);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, float, void> _MultiTexEnvfEXT_fnptr = &MultiTexEnvfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexEnvfEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float param) => _MultiTexEnvfEXT_fnptr(texunit, target, pname, param);
            [UnmanagedCallersOnly]
            private static void MultiTexEnvfEXT_Lazy(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float param)
            {
                _MultiTexEnvfEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexEnvfEXT");
                _MultiTexEnvfEXT_fnptr(texunit, target, pname, param);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, float*, void> _MultiTexEnvfvEXT_fnptr = &MultiTexEnvfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => _MultiTexEnvfvEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MultiTexEnvfvEXT_Lazy(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters)
            {
                _MultiTexEnvfvEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexEnvfvEXT");
                _MultiTexEnvfvEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, int, void> _MultiTexEnviEXT_fnptr = &MultiTexEnviEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexEnviEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int param) => _MultiTexEnviEXT_fnptr(texunit, target, pname, param);
            [UnmanagedCallersOnly]
            private static void MultiTexEnviEXT_Lazy(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int param)
            {
                _MultiTexEnviEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexEnviEXT");
                _MultiTexEnviEXT_fnptr(texunit, target, pname, param);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, int*, void> _MultiTexEnvivEXT_fnptr = &MultiTexEnvivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => _MultiTexEnvivEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MultiTexEnvivEXT_Lazy(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters)
            {
                _MultiTexEnvivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexEnvivEXT");
                _MultiTexEnvivEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, double, void> _MultiTexGendEXT_fnptr = &MultiTexGendEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGendEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double param) => _MultiTexGendEXT_fnptr(texunit, coord, pname, param);
            [UnmanagedCallersOnly]
            private static void MultiTexGendEXT_Lazy(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double param)
            {
                _MultiTexGendEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, double, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexGendEXT");
                _MultiTexGendEXT_fnptr(texunit, coord, pname, param);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, double*, void> _MultiTexGendvEXT_fnptr = &MultiTexGendvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => _MultiTexGendvEXT_fnptr(texunit, coord, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MultiTexGendvEXT_Lazy(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters)
            {
                _MultiTexGendvEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexGendvEXT");
                _MultiTexGendvEXT_fnptr(texunit, coord, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, float, void> _MultiTexGenfEXT_fnptr = &MultiTexGenfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGenfEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float param) => _MultiTexGenfEXT_fnptr(texunit, coord, pname, param);
            [UnmanagedCallersOnly]
            private static void MultiTexGenfEXT_Lazy(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float param)
            {
                _MultiTexGenfEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexGenfEXT");
                _MultiTexGenfEXT_fnptr(texunit, coord, pname, param);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, float*, void> _MultiTexGenfvEXT_fnptr = &MultiTexGenfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => _MultiTexGenfvEXT_fnptr(texunit, coord, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MultiTexGenfvEXT_Lazy(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters)
            {
                _MultiTexGenfvEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexGenfvEXT");
                _MultiTexGenfvEXT_fnptr(texunit, coord, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, int, void> _MultiTexGeniEXT_fnptr = &MultiTexGeniEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGeniEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int param) => _MultiTexGeniEXT_fnptr(texunit, coord, pname, param);
            [UnmanagedCallersOnly]
            private static void MultiTexGeniEXT_Lazy(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int param)
            {
                _MultiTexGeniEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexGeniEXT");
                _MultiTexGeniEXT_fnptr(texunit, coord, pname, param);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, int*, void> _MultiTexGenivEXT_fnptr = &MultiTexGenivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => _MultiTexGenivEXT_fnptr(texunit, coord, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MultiTexGenivEXT_Lazy(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters)
            {
                _MultiTexGenivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexGenivEXT");
                _MultiTexGenivEXT_fnptr(texunit, coord, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, float*, void> _GetMultiTexEnvfvEXT_fnptr = &GetMultiTexEnvfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => _GetMultiTexEnvfvEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexEnvfvEXT_Lazy(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters)
            {
                _GetMultiTexEnvfvEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexEnvfvEXT");
                _GetMultiTexEnvfvEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, int*, void> _GetMultiTexEnvivEXT_fnptr = &GetMultiTexEnvivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => _GetMultiTexEnvivEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexEnvivEXT_Lazy(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters)
            {
                _GetMultiTexEnvivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureEnvTarget, TextureEnvParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexEnvivEXT");
                _GetMultiTexEnvivEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, double*, void> _GetMultiTexGendvEXT_fnptr = &GetMultiTexGendvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => _GetMultiTexGendvEXT_fnptr(texunit, coord, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexGendvEXT_Lazy(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters)
            {
                _GetMultiTexGendvEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexGendvEXT");
                _GetMultiTexGendvEXT_fnptr(texunit, coord, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, float*, void> _GetMultiTexGenfvEXT_fnptr = &GetMultiTexGenfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => _GetMultiTexGenfvEXT_fnptr(texunit, coord, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexGenfvEXT_Lazy(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters)
            {
                _GetMultiTexGenfvEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexGenfvEXT");
                _GetMultiTexGenfvEXT_fnptr(texunit, coord, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, int*, void> _GetMultiTexGenivEXT_fnptr = &GetMultiTexGenivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => _GetMultiTexGenivEXT_fnptr(texunit, coord, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexGenivEXT_Lazy(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters)
            {
                _GetMultiTexGenivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexGenivEXT");
                _GetMultiTexGenivEXT_fnptr(texunit, coord, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, int, void> _MultiTexParameteriEXT_fnptr = &MultiTexParameteriEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameteriEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int param) => _MultiTexParameteriEXT_fnptr(texunit, target, pname, param);
            [UnmanagedCallersOnly]
            private static void MultiTexParameteriEXT_Lazy(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int param)
            {
                _MultiTexParameteriEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexParameteriEXT");
                _MultiTexParameteriEXT_fnptr(texunit, target, pname, param);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, int*, void> _MultiTexParameterivEXT_fnptr = &MultiTexParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => _MultiTexParameterivEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MultiTexParameterivEXT_Lazy(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters)
            {
                _MultiTexParameterivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexParameterivEXT");
                _MultiTexParameterivEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, float, void> _MultiTexParameterfEXT_fnptr = &MultiTexParameterfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterfEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float param) => _MultiTexParameterfEXT_fnptr(texunit, target, pname, param);
            [UnmanagedCallersOnly]
            private static void MultiTexParameterfEXT_Lazy(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float param)
            {
                _MultiTexParameterfEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, float, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexParameterfEXT");
                _MultiTexParameterfEXT_fnptr(texunit, target, pname, param);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, float*, void> _MultiTexParameterfvEXT_fnptr = &MultiTexParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float* parameters) => _MultiTexParameterfvEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MultiTexParameterfvEXT_Lazy(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float* parameters)
            {
                _MultiTexParameterfvEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexParameterfvEXT");
                _MultiTexParameterfvEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, PixelFormat, PixelType, void*, void> _MultiTexImage1DEXT_fnptr = &MultiTexImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => _MultiTexImage1DEXT_fnptr(texunit, target, level, internalformat, width, border, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void MultiTexImage1DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels)
            {
                _MultiTexImage1DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexImage1DEXT");
                _MultiTexImage1DEXT_fnptr(texunit, target, level, internalformat, width, border, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void> _MultiTexImage2DEXT_fnptr = &MultiTexImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => _MultiTexImage2DEXT_fnptr(texunit, target, level, internalformat, width, height, border, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void MultiTexImage2DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels)
            {
                _MultiTexImage2DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexImage2DEXT");
                _MultiTexImage2DEXT_fnptr(texunit, target, level, internalformat, width, height, border, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, PixelFormat, PixelType, void*, void> _MultiTexSubImage1DEXT_fnptr = &MultiTexSubImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => _MultiTexSubImage1DEXT_fnptr(texunit, target, level, xoffset, width, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void MultiTexSubImage1DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels)
            {
                _MultiTexSubImage1DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexSubImage1DEXT");
                _MultiTexSubImage1DEXT_fnptr(texunit, target, level, xoffset, width, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void> _MultiTexSubImage2DEXT_fnptr = &MultiTexSubImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => _MultiTexSubImage2DEXT_fnptr(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void MultiTexSubImage2DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels)
            {
                _MultiTexSubImage2DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexSubImage2DEXT");
                _MultiTexSubImage2DEXT_fnptr(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, int, void> _CopyMultiTexImage1DEXT_fnptr = &CopyMultiTexImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => _CopyMultiTexImage1DEXT_fnptr(texunit, target, level, internalformat, x, y, width, border);
            [UnmanagedCallersOnly]
            private static void CopyMultiTexImage1DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border)
            {
                _CopyMultiTexImage1DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyMultiTexImage1DEXT");
                _CopyMultiTexImage1DEXT_fnptr(texunit, target, level, internalformat, x, y, width, border);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, int, int, void> _CopyMultiTexImage2DEXT_fnptr = &CopyMultiTexImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => _CopyMultiTexImage2DEXT_fnptr(texunit, target, level, internalformat, x, y, width, height, border);
            [UnmanagedCallersOnly]
            private static void CopyMultiTexImage2DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border)
            {
                _CopyMultiTexImage2DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyMultiTexImage2DEXT");
                _CopyMultiTexImage2DEXT_fnptr(texunit, target, level, internalformat, x, y, width, height, border);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, void> _CopyMultiTexSubImage1DEXT_fnptr = &CopyMultiTexSubImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int x, int y, int width) => _CopyMultiTexSubImage1DEXT_fnptr(texunit, target, level, xoffset, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyMultiTexSubImage1DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int xoffset, int x, int y, int width)
            {
                _CopyMultiTexSubImage1DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyMultiTexSubImage1DEXT");
                _CopyMultiTexSubImage1DEXT_fnptr(texunit, target, level, xoffset, x, y, width);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, int, void> _CopyMultiTexSubImage2DEXT_fnptr = &CopyMultiTexSubImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyMultiTexSubImage2DEXT_fnptr(texunit, target, level, xoffset, yoffset, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyMultiTexSubImage2DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
            {
                _CopyMultiTexSubImage2DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyMultiTexSubImage2DEXT");
                _CopyMultiTexSubImage2DEXT_fnptr(texunit, target, level, xoffset, yoffset, x, y, width, height);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, PixelFormat, PixelType, void*, void> _GetMultiTexImageEXT_fnptr = &GetMultiTexImageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => _GetMultiTexImageEXT_fnptr(texunit, target, level, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void GetMultiTexImageEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels)
            {
                _GetMultiTexImageEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexImageEXT");
                _GetMultiTexImageEXT_fnptr(texunit, target, level, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, GetTextureParameter, float*, void> _GetMultiTexParameterfvEXT_fnptr = &GetMultiTexParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, float* parameters) => _GetMultiTexParameterfvEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexParameterfvEXT_Lazy(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, float* parameters)
            {
                _GetMultiTexParameterfvEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexParameterfvEXT");
                _GetMultiTexParameterfvEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, GetTextureParameter, int*, void> _GetMultiTexParameterivEXT_fnptr = &GetMultiTexParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => _GetMultiTexParameterivEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexParameterivEXT_Lazy(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters)
            {
                _GetMultiTexParameterivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexParameterivEXT");
                _GetMultiTexParameterivEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, GetTextureParameter, float*, void> _GetMultiTexLevelParameterfvEXT_fnptr = &GetMultiTexLevelParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => _GetMultiTexLevelParameterfvEXT_fnptr(texunit, target, level, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexLevelParameterfvEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, float* parameters)
            {
                _GetMultiTexLevelParameterfvEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, GetTextureParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexLevelParameterfvEXT");
                _GetMultiTexLevelParameterfvEXT_fnptr(texunit, target, level, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, GetTextureParameter, int*, void> _GetMultiTexLevelParameterivEXT_fnptr = &GetMultiTexLevelParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => _GetMultiTexLevelParameterivEXT_fnptr(texunit, target, level, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexLevelParameterivEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, int* parameters)
            {
                _GetMultiTexLevelParameterivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexLevelParameterivEXT");
                _GetMultiTexLevelParameterivEXT_fnptr(texunit, target, level, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _MultiTexImage3DEXT_fnptr = &MultiTexImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => _MultiTexImage3DEXT_fnptr(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void MultiTexImage3DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels)
            {
                _MultiTexImage3DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexImage3DEXT");
                _MultiTexImage3DEXT_fnptr(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _MultiTexSubImage3DEXT_fnptr = &MultiTexSubImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => _MultiTexSubImage3DEXT_fnptr(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void MultiTexSubImage3DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels)
            {
                _MultiTexSubImage3DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexSubImage3DEXT");
                _MultiTexSubImage3DEXT_fnptr(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, int, int, void> _CopyMultiTexSubImage3DEXT_fnptr = &CopyMultiTexSubImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyMultiTexSubImage3DEXT_fnptr(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
            [UnmanagedCallersOnly]
            private static void CopyMultiTexSubImage3DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
            {
                _CopyMultiTexSubImage3DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyMultiTexSubImage3DEXT");
                _CopyMultiTexSubImage3DEXT_fnptr(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            
            private static delegate* unmanaged<EnableCap, uint, void> _EnableClientStateIndexedEXT_fnptr = &EnableClientStateIndexedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableClientStateIndexedEXT(EnableCap array, uint index) => _EnableClientStateIndexedEXT_fnptr(array, index);
            [UnmanagedCallersOnly]
            private static void EnableClientStateIndexedEXT_Lazy(EnableCap array, uint index)
            {
                _EnableClientStateIndexedEXT_fnptr = (delegate* unmanaged<EnableCap, uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnableClientStateIndexedEXT");
                _EnableClientStateIndexedEXT_fnptr(array, index);
            }
            
            private static delegate* unmanaged<EnableCap, uint, void> _DisableClientStateIndexedEXT_fnptr = &DisableClientStateIndexedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableClientStateIndexedEXT(EnableCap array, uint index) => _DisableClientStateIndexedEXT_fnptr(array, index);
            [UnmanagedCallersOnly]
            private static void DisableClientStateIndexedEXT_Lazy(EnableCap array, uint index)
            {
                _DisableClientStateIndexedEXT_fnptr = (delegate* unmanaged<EnableCap, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisableClientStateIndexedEXT");
                _DisableClientStateIndexedEXT_fnptr(array, index);
            }
            
            private static delegate* unmanaged<GetPName, uint, float*, void> _GetFloatIndexedvEXT_fnptr = &GetFloatIndexedvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFloatIndexedvEXT(GetPName target, uint index, float* data) => _GetFloatIndexedvEXT_fnptr(target, index, data);
            [UnmanagedCallersOnly]
            private static void GetFloatIndexedvEXT_Lazy(GetPName target, uint index, float* data)
            {
                _GetFloatIndexedvEXT_fnptr = (delegate* unmanaged<GetPName, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFloatIndexedvEXT");
                _GetFloatIndexedvEXT_fnptr(target, index, data);
            }
            
            private static delegate* unmanaged<GetPName, uint, double*, void> _GetDoubleIndexedvEXT_fnptr = &GetDoubleIndexedvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetDoubleIndexedvEXT(GetPName target, uint index, double* data) => _GetDoubleIndexedvEXT_fnptr(target, index, data);
            [UnmanagedCallersOnly]
            private static void GetDoubleIndexedvEXT_Lazy(GetPName target, uint index, double* data)
            {
                _GetDoubleIndexedvEXT_fnptr = (delegate* unmanaged<GetPName, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetDoubleIndexedvEXT");
                _GetDoubleIndexedvEXT_fnptr(target, index, data);
            }
            
            private static delegate* unmanaged<All, uint, void**, void> _GetPointerIndexedvEXT_fnptr = &GetPointerIndexedvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPointerIndexedvEXT(All target, uint index, void** data) => _GetPointerIndexedvEXT_fnptr(target, index, data);
            [UnmanagedCallersOnly]
            private static void GetPointerIndexedvEXT_Lazy(All target, uint index, void** data)
            {
                _GetPointerIndexedvEXT_fnptr = (delegate* unmanaged<All, uint, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetPointerIndexedvEXT");
                _GetPointerIndexedvEXT_fnptr(target, index, data);
            }
            
            private static delegate* unmanaged<EnableCap, uint, void> _EnableIndexedEXT_fnptr = &EnableIndexedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableIndexedEXT(EnableCap target, uint index) => _EnableIndexedEXT_fnptr(target, index);
            [UnmanagedCallersOnly]
            private static void EnableIndexedEXT_Lazy(EnableCap target, uint index)
            {
                _EnableIndexedEXT_fnptr = (delegate* unmanaged<EnableCap, uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnableIndexedEXT");
                _EnableIndexedEXT_fnptr(target, index);
            }
            
            private static delegate* unmanaged<EnableCap, uint, void> _DisableIndexedEXT_fnptr = &DisableIndexedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableIndexedEXT(EnableCap target, uint index) => _DisableIndexedEXT_fnptr(target, index);
            [UnmanagedCallersOnly]
            private static void DisableIndexedEXT_Lazy(EnableCap target, uint index)
            {
                _DisableIndexedEXT_fnptr = (delegate* unmanaged<EnableCap, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisableIndexedEXT");
                _DisableIndexedEXT_fnptr(target, index);
            }
            
            private static delegate* unmanaged<EnableCap, uint, byte> _IsEnabledIndexedEXT_fnptr = &IsEnabledIndexedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsEnabledIndexedEXT(EnableCap target, uint index) => _IsEnabledIndexedEXT_fnptr(target, index);
            [UnmanagedCallersOnly]
            private static byte IsEnabledIndexedEXT_Lazy(EnableCap target, uint index)
            {
                _IsEnabledIndexedEXT_fnptr = (delegate* unmanaged<EnableCap, uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsEnabledIndexedEXT");
                return _IsEnabledIndexedEXT_fnptr(target, index);
            }
            
            private static delegate* unmanaged<GetPName, uint, int*, void> _GetIntegerIndexedvEXT_fnptr = &GetIntegerIndexedvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetIntegerIndexedvEXT(GetPName target, uint index, int* data) => _GetIntegerIndexedvEXT_fnptr(target, index, data);
            [UnmanagedCallersOnly]
            private static void GetIntegerIndexedvEXT_Lazy(GetPName target, uint index, int* data)
            {
                _GetIntegerIndexedvEXT_fnptr = (delegate* unmanaged<GetPName, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetIntegerIndexedvEXT");
                _GetIntegerIndexedvEXT_fnptr(target, index, data);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, byte*, void> _GetBooleanIndexedvEXT_fnptr = &GetBooleanIndexedvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBooleanIndexedvEXT(BufferTargetARB target, uint index, byte* data) => _GetBooleanIndexedvEXT_fnptr(target, index, data);
            [UnmanagedCallersOnly]
            private static void GetBooleanIndexedvEXT_Lazy(BufferTargetARB target, uint index, byte* data)
            {
                _GetBooleanIndexedvEXT_fnptr = (delegate* unmanaged<BufferTargetARB, uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetBooleanIndexedvEXT");
                _GetBooleanIndexedvEXT_fnptr(target, index, data);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, int, int, void*, void> _CompressedTextureImage3DEXT_fnptr = &CompressedTextureImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureImage3DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => _CompressedTextureImage3DEXT_fnptr(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedTextureImage3DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
            {
                _CompressedTextureImage3DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureImage3DEXT");
                _CompressedTextureImage3DEXT_fnptr(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, int, void*, void> _CompressedTextureImage2DEXT_fnptr = &CompressedTextureImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureImage2DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => _CompressedTextureImage2DEXT_fnptr(texture, target, level, internalformat, width, height, border, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedTextureImage2DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
            {
                _CompressedTextureImage2DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureImage2DEXT");
                _CompressedTextureImage2DEXT_fnptr(texture, target, level, internalformat, width, height, border, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, void*, void> _CompressedTextureImage1DEXT_fnptr = &CompressedTextureImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureImage1DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => _CompressedTextureImage1DEXT_fnptr(texture, target, level, internalformat, width, border, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedTextureImage1DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits)
            {
                _CompressedTextureImage1DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, InternalFormat, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureImage1DEXT");
                _CompressedTextureImage1DEXT_fnptr(texture, target, level, internalformat, width, border, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTextureSubImage3DEXT_fnptr = &CompressedTextureSubImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureSubImage3DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => _CompressedTextureSubImage3DEXT_fnptr(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedTextureSubImage3DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits)
            {
                _CompressedTextureSubImage3DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureSubImage3DEXT");
                _CompressedTextureSubImage3DEXT_fnptr(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedTextureSubImage2DEXT_fnptr = &CompressedTextureSubImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureSubImage2DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => _CompressedTextureSubImage2DEXT_fnptr(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedTextureSubImage2DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits)
            {
                _CompressedTextureSubImage2DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureSubImage2DEXT");
                _CompressedTextureSubImage2DEXT_fnptr(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, InternalFormat, int, void*, void> _CompressedTextureSubImage1DEXT_fnptr = &CompressedTextureSubImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureSubImage1DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => _CompressedTextureSubImage1DEXT_fnptr(texture, target, level, xoffset, width, format, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedTextureSubImage1DEXT_Lazy(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits)
            {
                _CompressedTextureSubImage1DEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedTextureSubImage1DEXT");
                _CompressedTextureSubImage1DEXT_fnptr(texture, target, level, xoffset, width, format, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, void*, void> _GetCompressedTextureImageEXT_fnptr = &GetCompressedTextureImageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCompressedTextureImageEXT(TextureHandle texture, TextureTarget target, int lod, void* img) => _GetCompressedTextureImageEXT_fnptr(texture, target, lod, img);
            [UnmanagedCallersOnly]
            private static void GetCompressedTextureImageEXT_Lazy(TextureHandle texture, TextureTarget target, int lod, void* img)
            {
                _GetCompressedTextureImageEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCompressedTextureImageEXT");
                _GetCompressedTextureImageEXT_fnptr(texture, target, lod, img);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, int, int, void*, void> _CompressedMultiTexImage3DEXT_fnptr = &CompressedMultiTexImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => _CompressedMultiTexImage3DEXT_fnptr(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedMultiTexImage3DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
            {
                _CompressedMultiTexImage3DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedMultiTexImage3DEXT");
                _CompressedMultiTexImage3DEXT_fnptr(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, int, void*, void> _CompressedMultiTexImage2DEXT_fnptr = &CompressedMultiTexImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => _CompressedMultiTexImage2DEXT_fnptr(texunit, target, level, internalformat, width, height, border, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedMultiTexImage2DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
            {
                _CompressedMultiTexImage2DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedMultiTexImage2DEXT");
                _CompressedMultiTexImage2DEXT_fnptr(texunit, target, level, internalformat, width, height, border, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, void*, void> _CompressedMultiTexImage1DEXT_fnptr = &CompressedMultiTexImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => _CompressedMultiTexImage1DEXT_fnptr(texunit, target, level, internalformat, width, border, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedMultiTexImage1DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits)
            {
                _CompressedMultiTexImage1DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, InternalFormat, int, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedMultiTexImage1DEXT");
                _CompressedMultiTexImage1DEXT_fnptr(texunit, target, level, internalformat, width, border, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedMultiTexSubImage3DEXT_fnptr = &CompressedMultiTexSubImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => _CompressedMultiTexSubImage3DEXT_fnptr(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedMultiTexSubImage3DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits)
            {
                _CompressedMultiTexSubImage3DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedMultiTexSubImage3DEXT");
                _CompressedMultiTexSubImage3DEXT_fnptr(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, InternalFormat, int, void*, void> _CompressedMultiTexSubImage2DEXT_fnptr = &CompressedMultiTexSubImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => _CompressedMultiTexSubImage2DEXT_fnptr(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedMultiTexSubImage2DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits)
            {
                _CompressedMultiTexSubImage2DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedMultiTexSubImage2DEXT");
                _CompressedMultiTexSubImage2DEXT_fnptr(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, InternalFormat, int, void*, void> _CompressedMultiTexSubImage1DEXT_fnptr = &CompressedMultiTexSubImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => _CompressedMultiTexSubImage1DEXT_fnptr(texunit, target, level, xoffset, width, format, imageSize, bits);
            [UnmanagedCallersOnly]
            private static void CompressedMultiTexSubImage1DEXT_Lazy(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits)
            {
                _CompressedMultiTexSubImage1DEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, int, int, InternalFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glCompressedMultiTexSubImage1DEXT");
                _CompressedMultiTexSubImage1DEXT_fnptr(texunit, target, level, xoffset, width, format, imageSize, bits);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, int, void*, void> _GetCompressedMultiTexImageEXT_fnptr = &GetCompressedMultiTexImageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCompressedMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int lod, void* img) => _GetCompressedMultiTexImageEXT_fnptr(texunit, target, lod, img);
            [UnmanagedCallersOnly]
            private static void GetCompressedMultiTexImageEXT_Lazy(TextureUnit texunit, TextureTarget target, int lod, void* img)
            {
                _GetCompressedMultiTexImageEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCompressedMultiTexImageEXT");
                _GetCompressedMultiTexImageEXT_fnptr(texunit, target, lod, img);
            }
            
            private static delegate* unmanaged<MatrixMode, float*, void> _MatrixLoadTransposefEXT_fnptr = &MatrixLoadTransposefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTransposefEXT(MatrixMode mode, float* m) => _MatrixLoadTransposefEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoadTransposefEXT_Lazy(MatrixMode mode, float* m)
            {
                _MatrixLoadTransposefEXT_fnptr = (delegate* unmanaged<MatrixMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoadTransposefEXT");
                _MatrixLoadTransposefEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, double*, void> _MatrixLoadTransposedEXT_fnptr = &MatrixLoadTransposedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTransposedEXT(MatrixMode mode, double* m) => _MatrixLoadTransposedEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoadTransposedEXT_Lazy(MatrixMode mode, double* m)
            {
                _MatrixLoadTransposedEXT_fnptr = (delegate* unmanaged<MatrixMode, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoadTransposedEXT");
                _MatrixLoadTransposedEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, float*, void> _MatrixMultTransposefEXT_fnptr = &MatrixMultTransposefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTransposefEXT(MatrixMode mode, float* m) => _MatrixMultTransposefEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMultTransposefEXT_Lazy(MatrixMode mode, float* m)
            {
                _MatrixMultTransposefEXT_fnptr = (delegate* unmanaged<MatrixMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMultTransposefEXT");
                _MatrixMultTransposefEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, double*, void> _MatrixMultTransposedEXT_fnptr = &MatrixMultTransposedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTransposedEXT(MatrixMode mode, double* m) => _MatrixMultTransposedEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMultTransposedEXT_Lazy(MatrixMode mode, double* m)
            {
                _MatrixMultTransposedEXT_fnptr = (delegate* unmanaged<MatrixMode, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMultTransposedEXT");
                _MatrixMultTransposedEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<BufferHandle, nint, void*, VertexBufferObjectUsage, void> _NamedBufferDataEXT_fnptr = &NamedBufferDataEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferDataEXT(BufferHandle buffer, nint size, void* data, VertexBufferObjectUsage usage) => _NamedBufferDataEXT_fnptr(buffer, size, data, usage);
            [UnmanagedCallersOnly]
            private static void NamedBufferDataEXT_Lazy(BufferHandle buffer, nint size, void* data, VertexBufferObjectUsage usage)
            {
                _NamedBufferDataEXT_fnptr = (delegate* unmanaged<BufferHandle, nint, void*, VertexBufferObjectUsage, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferDataEXT");
                _NamedBufferDataEXT_fnptr(buffer, size, data, usage);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void> _NamedBufferSubDataEXT_fnptr = &NamedBufferSubDataEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferSubDataEXT(BufferHandle buffer, IntPtr offset, nint size, void* data) => _NamedBufferSubDataEXT_fnptr(buffer, offset, size, data);
            [UnmanagedCallersOnly]
            private static void NamedBufferSubDataEXT_Lazy(BufferHandle buffer, IntPtr offset, nint size, void* data)
            {
                _NamedBufferSubDataEXT_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferSubDataEXT");
                _NamedBufferSubDataEXT_fnptr(buffer, offset, size, data);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferAccessARB, void*> _MapNamedBufferEXT_fnptr = &MapNamedBufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapNamedBufferEXT(BufferHandle buffer, BufferAccessARB access) => _MapNamedBufferEXT_fnptr(buffer, access);
            [UnmanagedCallersOnly]
            private static void* MapNamedBufferEXT_Lazy(BufferHandle buffer, BufferAccessARB access)
            {
                _MapNamedBufferEXT_fnptr = (delegate* unmanaged<BufferHandle, BufferAccessARB, void*>)GLLoader.BindingsContext.GetProcAddress("glMapNamedBufferEXT");
                return _MapNamedBufferEXT_fnptr(buffer, access);
            }
            
            private static delegate* unmanaged<BufferHandle, byte> _UnmapNamedBufferEXT_fnptr = &UnmapNamedBufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte UnmapNamedBufferEXT(BufferHandle buffer) => _UnmapNamedBufferEXT_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static byte UnmapNamedBufferEXT_Lazy(BufferHandle buffer)
            {
                _UnmapNamedBufferEXT_fnptr = (delegate* unmanaged<BufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glUnmapNamedBufferEXT");
                return _UnmapNamedBufferEXT_fnptr(buffer);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferPNameARB, int*, void> _GetNamedBufferParameterivEXT_fnptr = &GetNamedBufferParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedBufferParameterivEXT(BufferHandle buffer, BufferPNameARB pname, int* parameters) => _GetNamedBufferParameterivEXT_fnptr(buffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedBufferParameterivEXT_Lazy(BufferHandle buffer, BufferPNameARB pname, int* parameters)
            {
                _GetNamedBufferParameterivEXT_fnptr = (delegate* unmanaged<BufferHandle, BufferPNameARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferParameterivEXT");
                _GetNamedBufferParameterivEXT_fnptr(buffer, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferPointerNameARB, void**, void> _GetNamedBufferPointervEXT_fnptr = &GetNamedBufferPointervEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedBufferPointervEXT(BufferHandle buffer, BufferPointerNameARB pname, void** parameters) => _GetNamedBufferPointervEXT_fnptr(buffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedBufferPointervEXT_Lazy(BufferHandle buffer, BufferPointerNameARB pname, void** parameters)
            {
                _GetNamedBufferPointervEXT_fnptr = (delegate* unmanaged<BufferHandle, BufferPointerNameARB, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferPointervEXT");
                _GetNamedBufferPointervEXT_fnptr(buffer, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void> _GetNamedBufferSubDataEXT_fnptr = &GetNamedBufferSubDataEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedBufferSubDataEXT(BufferHandle buffer, IntPtr offset, nint size, void* data) => _GetNamedBufferSubDataEXT_fnptr(buffer, offset, size, data);
            [UnmanagedCallersOnly]
            private static void GetNamedBufferSubDataEXT_Lazy(BufferHandle buffer, IntPtr offset, nint size, void* data)
            {
                _GetNamedBufferSubDataEXT_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferSubDataEXT");
                _GetNamedBufferSubDataEXT_fnptr(buffer, offset, size, data);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, float, void> _ProgramUniform1fEXT_fnptr = &ProgramUniform1fEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1fEXT(ProgramHandle program, int location, float v0) => _ProgramUniform1fEXT_fnptr(program, location, v0);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1fEXT_Lazy(ProgramHandle program, int location, float v0)
            {
                _ProgramUniform1fEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1fEXT");
                _ProgramUniform1fEXT_fnptr(program, location, v0);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, float, float, void> _ProgramUniform2fEXT_fnptr = &ProgramUniform2fEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2fEXT(ProgramHandle program, int location, float v0, float v1) => _ProgramUniform2fEXT_fnptr(program, location, v0, v1);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2fEXT_Lazy(ProgramHandle program, int location, float v0, float v1)
            {
                _ProgramUniform2fEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2fEXT");
                _ProgramUniform2fEXT_fnptr(program, location, v0, v1);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, float, float, float, void> _ProgramUniform3fEXT_fnptr = &ProgramUniform3fEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3fEXT(ProgramHandle program, int location, float v0, float v1, float v2) => _ProgramUniform3fEXT_fnptr(program, location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3fEXT_Lazy(ProgramHandle program, int location, float v0, float v1, float v2)
            {
                _ProgramUniform3fEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3fEXT");
                _ProgramUniform3fEXT_fnptr(program, location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, float, float, float, float, void> _ProgramUniform4fEXT_fnptr = &ProgramUniform4fEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4fEXT(ProgramHandle program, int location, float v0, float v1, float v2, float v3) => _ProgramUniform4fEXT_fnptr(program, location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4fEXT_Lazy(ProgramHandle program, int location, float v0, float v1, float v2, float v3)
            {
                _ProgramUniform4fEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4fEXT");
                _ProgramUniform4fEXT_fnptr(program, location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, void> _ProgramUniform1iEXT_fnptr = &ProgramUniform1iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1iEXT(ProgramHandle program, int location, int v0) => _ProgramUniform1iEXT_fnptr(program, location, v0);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1iEXT_Lazy(ProgramHandle program, int location, int v0)
            {
                _ProgramUniform1iEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1iEXT");
                _ProgramUniform1iEXT_fnptr(program, location, v0);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int, void> _ProgramUniform2iEXT_fnptr = &ProgramUniform2iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2iEXT(ProgramHandle program, int location, int v0, int v1) => _ProgramUniform2iEXT_fnptr(program, location, v0, v1);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2iEXT_Lazy(ProgramHandle program, int location, int v0, int v1)
            {
                _ProgramUniform2iEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2iEXT");
                _ProgramUniform2iEXT_fnptr(program, location, v0, v1);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int, int, void> _ProgramUniform3iEXT_fnptr = &ProgramUniform3iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3iEXT(ProgramHandle program, int location, int v0, int v1, int v2) => _ProgramUniform3iEXT_fnptr(program, location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3iEXT_Lazy(ProgramHandle program, int location, int v0, int v1, int v2)
            {
                _ProgramUniform3iEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3iEXT");
                _ProgramUniform3iEXT_fnptr(program, location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int, int, int, void> _ProgramUniform4iEXT_fnptr = &ProgramUniform4iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4iEXT(ProgramHandle program, int location, int v0, int v1, int v2, int v3) => _ProgramUniform4iEXT_fnptr(program, location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4iEXT_Lazy(ProgramHandle program, int location, int v0, int v1, int v2, int v3)
            {
                _ProgramUniform4iEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4iEXT");
                _ProgramUniform4iEXT_fnptr(program, location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform1fvEXT_fnptr = &ProgramUniform1fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1fvEXT(ProgramHandle program, int location, int count, float* value) => _ProgramUniform1fvEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1fvEXT_Lazy(ProgramHandle program, int location, int count, float* value)
            {
                _ProgramUniform1fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1fvEXT");
                _ProgramUniform1fvEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform2fvEXT_fnptr = &ProgramUniform2fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2fvEXT(ProgramHandle program, int location, int count, float* value) => _ProgramUniform2fvEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2fvEXT_Lazy(ProgramHandle program, int location, int count, float* value)
            {
                _ProgramUniform2fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2fvEXT");
                _ProgramUniform2fvEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform3fvEXT_fnptr = &ProgramUniform3fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3fvEXT(ProgramHandle program, int location, int count, float* value) => _ProgramUniform3fvEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3fvEXT_Lazy(ProgramHandle program, int location, int count, float* value)
            {
                _ProgramUniform3fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3fvEXT");
                _ProgramUniform3fvEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _ProgramUniform4fvEXT_fnptr = &ProgramUniform4fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4fvEXT(ProgramHandle program, int location, int count, float* value) => _ProgramUniform4fvEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4fvEXT_Lazy(ProgramHandle program, int location, int count, float* value)
            {
                _ProgramUniform4fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4fvEXT");
                _ProgramUniform4fvEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform1ivEXT_fnptr = &ProgramUniform1ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ivEXT(ProgramHandle program, int location, int count, int* value) => _ProgramUniform1ivEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1ivEXT_Lazy(ProgramHandle program, int location, int count, int* value)
            {
                _ProgramUniform1ivEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1ivEXT");
                _ProgramUniform1ivEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform2ivEXT_fnptr = &ProgramUniform2ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ivEXT(ProgramHandle program, int location, int count, int* value) => _ProgramUniform2ivEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2ivEXT_Lazy(ProgramHandle program, int location, int count, int* value)
            {
                _ProgramUniform2ivEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2ivEXT");
                _ProgramUniform2ivEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform3ivEXT_fnptr = &ProgramUniform3ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ivEXT(ProgramHandle program, int location, int count, int* value) => _ProgramUniform3ivEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3ivEXT_Lazy(ProgramHandle program, int location, int count, int* value)
            {
                _ProgramUniform3ivEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3ivEXT");
                _ProgramUniform3ivEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _ProgramUniform4ivEXT_fnptr = &ProgramUniform4ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ivEXT(ProgramHandle program, int location, int count, int* value) => _ProgramUniform4ivEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4ivEXT_Lazy(ProgramHandle program, int location, int count, int* value)
            {
                _ProgramUniform4ivEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4ivEXT");
                _ProgramUniform4ivEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix2fvEXT_fnptr = &ProgramUniformMatrix2fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2fvEXT(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix2fvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2fvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix2fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2fvEXT");
                _ProgramUniformMatrix2fvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix3fvEXT_fnptr = &ProgramUniformMatrix3fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3fvEXT(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix3fvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3fvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix3fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3fvEXT");
                _ProgramUniformMatrix3fvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix4fvEXT_fnptr = &ProgramUniformMatrix4fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4fvEXT(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix4fvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4fvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix4fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4fvEXT");
                _ProgramUniformMatrix4fvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix2x3fvEXT_fnptr = &ProgramUniformMatrix2x3fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x3fvEXT(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix2x3fvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2x3fvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix2x3fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x3fvEXT");
                _ProgramUniformMatrix2x3fvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix3x2fvEXT_fnptr = &ProgramUniformMatrix3x2fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x2fvEXT(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix3x2fvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3x2fvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix3x2fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x2fvEXT");
                _ProgramUniformMatrix3x2fvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix2x4fvEXT_fnptr = &ProgramUniformMatrix2x4fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x4fvEXT(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix2x4fvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2x4fvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix2x4fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x4fvEXT");
                _ProgramUniformMatrix2x4fvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix4x2fvEXT_fnptr = &ProgramUniformMatrix4x2fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x2fvEXT(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix4x2fvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4x2fvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix4x2fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x2fvEXT");
                _ProgramUniformMatrix4x2fvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix3x4fvEXT_fnptr = &ProgramUniformMatrix3x4fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x4fvEXT(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix3x4fvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3x4fvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix3x4fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x4fvEXT");
                _ProgramUniformMatrix3x4fvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, float*, void> _ProgramUniformMatrix4x3fvEXT_fnptr = &ProgramUniformMatrix4x3fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x3fvEXT(ProgramHandle program, int location, int count, byte transpose, float* value) => _ProgramUniformMatrix4x3fvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4x3fvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, float* value)
            {
                _ProgramUniformMatrix4x3fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x3fvEXT");
                _ProgramUniformMatrix4x3fvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, SizedInternalFormat, BufferHandle, void> _TextureBufferEXT_fnptr = &TextureBufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureBufferEXT(TextureHandle texture, TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer) => _TextureBufferEXT_fnptr(texture, target, internalformat, buffer);
            [UnmanagedCallersOnly]
            private static void TextureBufferEXT_Lazy(TextureHandle texture, TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer)
            {
                _TextureBufferEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, SizedInternalFormat, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTextureBufferEXT");
                _TextureBufferEXT_fnptr(texture, target, internalformat, buffer);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, InternalFormat, BufferHandle, void> _MultiTexBufferEXT_fnptr = &MultiTexBufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexBufferEXT(TextureUnit texunit, TextureTarget target, InternalFormat internalformat, BufferHandle buffer) => _MultiTexBufferEXT_fnptr(texunit, target, internalformat, buffer);
            [UnmanagedCallersOnly]
            private static void MultiTexBufferEXT_Lazy(TextureUnit texunit, TextureTarget target, InternalFormat internalformat, BufferHandle buffer)
            {
                _MultiTexBufferEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, InternalFormat, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexBufferEXT");
                _MultiTexBufferEXT_fnptr(texunit, target, internalformat, buffer);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, int*, void> _TextureParameterIivEXT_fnptr = &TextureParameterIivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterIivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, int* parameters) => _TextureParameterIivEXT_fnptr(texture, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TextureParameterIivEXT_Lazy(TextureHandle texture, TextureTarget target, TextureParameterName pname, int* parameters)
            {
                _TextureParameterIivEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterIivEXT");
                _TextureParameterIivEXT_fnptr(texture, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, uint*, void> _TextureParameterIuivEXT_fnptr = &TextureParameterIuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterIuivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, uint* parameters) => _TextureParameterIuivEXT_fnptr(texture, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TextureParameterIuivEXT_Lazy(TextureHandle texture, TextureTarget target, TextureParameterName pname, uint* parameters)
            {
                _TextureParameterIuivEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, TextureParameterName, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTextureParameterIuivEXT");
                _TextureParameterIuivEXT_fnptr(texture, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, GetTextureParameter, int*, void> _GetTextureParameterIivEXT_fnptr = &GetTextureParameterIivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureParameterIivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, int* parameters) => _GetTextureParameterIivEXT_fnptr(texture, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureParameterIivEXT_Lazy(TextureHandle texture, TextureTarget target, GetTextureParameter pname, int* parameters)
            {
                _GetTextureParameterIivEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterIivEXT");
                _GetTextureParameterIivEXT_fnptr(texture, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, GetTextureParameter, uint*, void> _GetTextureParameterIuivEXT_fnptr = &GetTextureParameterIuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureParameterIuivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, uint* parameters) => _GetTextureParameterIuivEXT_fnptr(texture, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTextureParameterIuivEXT_Lazy(TextureHandle texture, TextureTarget target, GetTextureParameter pname, uint* parameters)
            {
                _GetTextureParameterIuivEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, GetTextureParameter, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTextureParameterIuivEXT");
                _GetTextureParameterIuivEXT_fnptr(texture, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, int*, void> _MultiTexParameterIivEXT_fnptr = &MultiTexParameterIivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => _MultiTexParameterIivEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MultiTexParameterIivEXT_Lazy(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters)
            {
                _MultiTexParameterIivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexParameterIivEXT");
                _MultiTexParameterIivEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, uint*, void> _MultiTexParameterIuivEXT_fnptr = &MultiTexParameterIuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, uint* parameters) => _MultiTexParameterIuivEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MultiTexParameterIuivEXT_Lazy(TextureUnit texunit, TextureTarget target, TextureParameterName pname, uint* parameters)
            {
                _MultiTexParameterIuivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, TextureParameterName, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexParameterIuivEXT");
                _MultiTexParameterIuivEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, GetTextureParameter, int*, void> _GetMultiTexParameterIivEXT_fnptr = &GetMultiTexParameterIivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => _GetMultiTexParameterIivEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexParameterIivEXT_Lazy(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters)
            {
                _GetMultiTexParameterIivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexParameterIivEXT");
                _GetMultiTexParameterIivEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, GetTextureParameter, uint*, void> _GetMultiTexParameterIuivEXT_fnptr = &GetMultiTexParameterIuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, uint* parameters) => _GetMultiTexParameterIuivEXT_fnptr(texunit, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMultiTexParameterIuivEXT_Lazy(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, uint* parameters)
            {
                _GetMultiTexParameterIuivEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, GetTextureParameter, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultiTexParameterIuivEXT");
                _GetMultiTexParameterIuivEXT_fnptr(texunit, target, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint, void> _ProgramUniform1uiEXT_fnptr = &ProgramUniform1uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1uiEXT(ProgramHandle program, int location, uint v0) => _ProgramUniform1uiEXT_fnptr(program, location, v0);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1uiEXT_Lazy(ProgramHandle program, int location, uint v0)
            {
                _ProgramUniform1uiEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1uiEXT");
                _ProgramUniform1uiEXT_fnptr(program, location, v0);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint, uint, void> _ProgramUniform2uiEXT_fnptr = &ProgramUniform2uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2uiEXT(ProgramHandle program, int location, uint v0, uint v1) => _ProgramUniform2uiEXT_fnptr(program, location, v0, v1);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2uiEXT_Lazy(ProgramHandle program, int location, uint v0, uint v1)
            {
                _ProgramUniform2uiEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2uiEXT");
                _ProgramUniform2uiEXT_fnptr(program, location, v0, v1);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint, uint, uint, void> _ProgramUniform3uiEXT_fnptr = &ProgramUniform3uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3uiEXT(ProgramHandle program, int location, uint v0, uint v1, uint v2) => _ProgramUniform3uiEXT_fnptr(program, location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3uiEXT_Lazy(ProgramHandle program, int location, uint v0, uint v1, uint v2)
            {
                _ProgramUniform3uiEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3uiEXT");
                _ProgramUniform3uiEXT_fnptr(program, location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint, uint, uint, uint, void> _ProgramUniform4uiEXT_fnptr = &ProgramUniform4uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4uiEXT(ProgramHandle program, int location, uint v0, uint v1, uint v2, uint v3) => _ProgramUniform4uiEXT_fnptr(program, location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4uiEXT_Lazy(ProgramHandle program, int location, uint v0, uint v1, uint v2, uint v3)
            {
                _ProgramUniform4uiEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4uiEXT");
                _ProgramUniform4uiEXT_fnptr(program, location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform1uivEXT_fnptr = &ProgramUniform1uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1uivEXT(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform1uivEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1uivEXT_Lazy(ProgramHandle program, int location, int count, uint* value)
            {
                _ProgramUniform1uivEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1uivEXT");
                _ProgramUniform1uivEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform2uivEXT_fnptr = &ProgramUniform2uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2uivEXT(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform2uivEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2uivEXT_Lazy(ProgramHandle program, int location, int count, uint* value)
            {
                _ProgramUniform2uivEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2uivEXT");
                _ProgramUniform2uivEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform3uivEXT_fnptr = &ProgramUniform3uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3uivEXT(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform3uivEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3uivEXT_Lazy(ProgramHandle program, int location, int count, uint* value)
            {
                _ProgramUniform3uivEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3uivEXT");
                _ProgramUniform3uivEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _ProgramUniform4uivEXT_fnptr = &ProgramUniform4uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4uivEXT(ProgramHandle program, int location, int count, uint* value) => _ProgramUniform4uivEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4uivEXT_Lazy(ProgramHandle program, int location, int count, uint* value)
            {
                _ProgramUniform4uivEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4uivEXT");
                _ProgramUniform4uivEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int, float*, void> _NamedProgramLocalParameters4fvEXT_fnptr = &NamedProgramLocalParameters4fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameters4fvEXT(ProgramHandle program, ProgramTarget target, uint index, int count, float* parameters) => _NamedProgramLocalParameters4fvEXT_fnptr(program, target, index, count, parameters);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParameters4fvEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, int count, float* parameters)
            {
                _NamedProgramLocalParameters4fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParameters4fvEXT");
                _NamedProgramLocalParameters4fvEXT_fnptr(program, target, index, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int, int, int, int, void> _NamedProgramLocalParameterI4iEXT_fnptr = &NamedProgramLocalParameterI4iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameterI4iEXT(ProgramHandle program, ProgramTarget target, uint index, int x, int y, int z, int w) => _NamedProgramLocalParameterI4iEXT_fnptr(program, target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParameterI4iEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, int x, int y, int z, int w)
            {
                _NamedProgramLocalParameterI4iEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParameterI4iEXT");
                _NamedProgramLocalParameterI4iEXT_fnptr(program, target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int*, void> _NamedProgramLocalParameterI4ivEXT_fnptr = &NamedProgramLocalParameterI4ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameterI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, int* parameters) => _NamedProgramLocalParameterI4ivEXT_fnptr(program, target, index, parameters);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParameterI4ivEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, int* parameters)
            {
                _NamedProgramLocalParameterI4ivEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParameterI4ivEXT");
                _NamedProgramLocalParameterI4ivEXT_fnptr(program, target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int, int*, void> _NamedProgramLocalParametersI4ivEXT_fnptr = &NamedProgramLocalParametersI4ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParametersI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, int count, int* parameters) => _NamedProgramLocalParametersI4ivEXT_fnptr(program, target, index, count, parameters);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParametersI4ivEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, int count, int* parameters)
            {
                _NamedProgramLocalParametersI4ivEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParametersI4ivEXT");
                _NamedProgramLocalParametersI4ivEXT_fnptr(program, target, index, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, uint, uint, uint, uint, void> _NamedProgramLocalParameterI4uiEXT_fnptr = &NamedProgramLocalParameterI4uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameterI4uiEXT(ProgramHandle program, ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => _NamedProgramLocalParameterI4uiEXT_fnptr(program, target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParameterI4uiEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, uint x, uint y, uint z, uint w)
            {
                _NamedProgramLocalParameterI4uiEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParameterI4uiEXT");
                _NamedProgramLocalParameterI4uiEXT_fnptr(program, target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, uint*, void> _NamedProgramLocalParameterI4uivEXT_fnptr = &NamedProgramLocalParameterI4uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameterI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, uint* parameters) => _NamedProgramLocalParameterI4uivEXT_fnptr(program, target, index, parameters);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParameterI4uivEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, uint* parameters)
            {
                _NamedProgramLocalParameterI4uivEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParameterI4uivEXT");
                _NamedProgramLocalParameterI4uivEXT_fnptr(program, target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int, uint*, void> _NamedProgramLocalParametersI4uivEXT_fnptr = &NamedProgramLocalParametersI4uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParametersI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, int count, uint* parameters) => _NamedProgramLocalParametersI4uivEXT_fnptr(program, target, index, count, parameters);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParametersI4uivEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, int count, uint* parameters)
            {
                _NamedProgramLocalParametersI4uivEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParametersI4uivEXT");
                _NamedProgramLocalParametersI4uivEXT_fnptr(program, target, index, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int*, void> _GetNamedProgramLocalParameterIivEXT_fnptr = &GetNamedProgramLocalParameterIivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramLocalParameterIivEXT(ProgramHandle program, ProgramTarget target, uint index, int* parameters) => _GetNamedProgramLocalParameterIivEXT_fnptr(program, target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedProgramLocalParameterIivEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, int* parameters)
            {
                _GetNamedProgramLocalParameterIivEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedProgramLocalParameterIivEXT");
                _GetNamedProgramLocalParameterIivEXT_fnptr(program, target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, uint*, void> _GetNamedProgramLocalParameterIuivEXT_fnptr = &GetNamedProgramLocalParameterIuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramLocalParameterIuivEXT(ProgramHandle program, ProgramTarget target, uint index, uint* parameters) => _GetNamedProgramLocalParameterIuivEXT_fnptr(program, target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedProgramLocalParameterIuivEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, uint* parameters)
            {
                _GetNamedProgramLocalParameterIuivEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedProgramLocalParameterIuivEXT");
                _GetNamedProgramLocalParameterIuivEXT_fnptr(program, target, index, parameters);
            }
            
            private static delegate* unmanaged<EnableCap, uint, void> _EnableClientStateiEXT_fnptr = &EnableClientStateiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableClientStateiEXT(EnableCap array, uint index) => _EnableClientStateiEXT_fnptr(array, index);
            [UnmanagedCallersOnly]
            private static void EnableClientStateiEXT_Lazy(EnableCap array, uint index)
            {
                _EnableClientStateiEXT_fnptr = (delegate* unmanaged<EnableCap, uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnableClientStateiEXT");
                _EnableClientStateiEXT_fnptr(array, index);
            }
            
            private static delegate* unmanaged<EnableCap, uint, void> _DisableClientStateiEXT_fnptr = &DisableClientStateiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableClientStateiEXT(EnableCap array, uint index) => _DisableClientStateiEXT_fnptr(array, index);
            [UnmanagedCallersOnly]
            private static void DisableClientStateiEXT_Lazy(EnableCap array, uint index)
            {
                _DisableClientStateiEXT_fnptr = (delegate* unmanaged<EnableCap, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisableClientStateiEXT");
                _DisableClientStateiEXT_fnptr(array, index);
            }
            
            private static delegate* unmanaged<GetPName, uint, float*, void> _GetFloati_vEXT_fnptr = &GetFloati_vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFloati_vEXT(GetPName pname, uint index, float* parameters) => _GetFloati_vEXT_fnptr(pname, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetFloati_vEXT_Lazy(GetPName pname, uint index, float* parameters)
            {
                _GetFloati_vEXT_fnptr = (delegate* unmanaged<GetPName, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFloati_vEXT");
                _GetFloati_vEXT_fnptr(pname, index, parameters);
            }
            
            private static delegate* unmanaged<GetPName, uint, double*, void> _GetDoublei_vEXT_fnptr = &GetDoublei_vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetDoublei_vEXT(GetPName pname, uint index, double* parameters) => _GetDoublei_vEXT_fnptr(pname, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetDoublei_vEXT_Lazy(GetPName pname, uint index, double* parameters)
            {
                _GetDoublei_vEXT_fnptr = (delegate* unmanaged<GetPName, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetDoublei_vEXT");
                _GetDoublei_vEXT_fnptr(pname, index, parameters);
            }
            
            private static delegate* unmanaged<All, uint, void**, void> _GetPointeri_vEXT_fnptr = &GetPointeri_vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPointeri_vEXT(All pname, uint index, void** parameters) => _GetPointeri_vEXT_fnptr(pname, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetPointeri_vEXT_Lazy(All pname, uint index, void** parameters)
            {
                _GetPointeri_vEXT_fnptr = (delegate* unmanaged<All, uint, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetPointeri_vEXT");
                _GetPointeri_vEXT_fnptr(pname, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, ProgramFormat, int, void*, void> _NamedProgramStringEXT_fnptr = &NamedProgramStringEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramStringEXT(ProgramHandle program, ProgramTarget target, ProgramFormat format, int len, void* str) => _NamedProgramStringEXT_fnptr(program, target, format, len, str);
            [UnmanagedCallersOnly]
            private static void NamedProgramStringEXT_Lazy(ProgramHandle program, ProgramTarget target, ProgramFormat format, int len, void* str)
            {
                _NamedProgramStringEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, ProgramFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramStringEXT");
                _NamedProgramStringEXT_fnptr(program, target, format, len, str);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, double, double, double, double, void> _NamedProgramLocalParameter4dEXT_fnptr = &NamedProgramLocalParameter4dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameter4dEXT(ProgramHandle program, ProgramTarget target, uint index, double x, double y, double z, double w) => _NamedProgramLocalParameter4dEXT_fnptr(program, target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParameter4dEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, double x, double y, double z, double w)
            {
                _NamedProgramLocalParameter4dEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParameter4dEXT");
                _NamedProgramLocalParameter4dEXT_fnptr(program, target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, double*, void> _NamedProgramLocalParameter4dvEXT_fnptr = &NamedProgramLocalParameter4dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameter4dvEXT(ProgramHandle program, ProgramTarget target, uint index, double* parameters) => _NamedProgramLocalParameter4dvEXT_fnptr(program, target, index, parameters);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParameter4dvEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, double* parameters)
            {
                _NamedProgramLocalParameter4dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParameter4dvEXT");
                _NamedProgramLocalParameter4dvEXT_fnptr(program, target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, float, float, float, float, void> _NamedProgramLocalParameter4fEXT_fnptr = &NamedProgramLocalParameter4fEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameter4fEXT(ProgramHandle program, ProgramTarget target, uint index, float x, float y, float z, float w) => _NamedProgramLocalParameter4fEXT_fnptr(program, target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParameter4fEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, float x, float y, float z, float w)
            {
                _NamedProgramLocalParameter4fEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParameter4fEXT");
                _NamedProgramLocalParameter4fEXT_fnptr(program, target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, float*, void> _NamedProgramLocalParameter4fvEXT_fnptr = &NamedProgramLocalParameter4fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameter4fvEXT(ProgramHandle program, ProgramTarget target, uint index, float* parameters) => _NamedProgramLocalParameter4fvEXT_fnptr(program, target, index, parameters);
            [UnmanagedCallersOnly]
            private static void NamedProgramLocalParameter4fvEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, float* parameters)
            {
                _NamedProgramLocalParameter4fvEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedProgramLocalParameter4fvEXT");
                _NamedProgramLocalParameter4fvEXT_fnptr(program, target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, double*, void> _GetNamedProgramLocalParameterdvEXT_fnptr = &GetNamedProgramLocalParameterdvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramLocalParameterdvEXT(ProgramHandle program, ProgramTarget target, uint index, double* parameters) => _GetNamedProgramLocalParameterdvEXT_fnptr(program, target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedProgramLocalParameterdvEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, double* parameters)
            {
                _GetNamedProgramLocalParameterdvEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedProgramLocalParameterdvEXT");
                _GetNamedProgramLocalParameterdvEXT_fnptr(program, target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, uint, float*, void> _GetNamedProgramLocalParameterfvEXT_fnptr = &GetNamedProgramLocalParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramLocalParameterfvEXT(ProgramHandle program, ProgramTarget target, uint index, float* parameters) => _GetNamedProgramLocalParameterfvEXT_fnptr(program, target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedProgramLocalParameterfvEXT_Lazy(ProgramHandle program, ProgramTarget target, uint index, float* parameters)
            {
                _GetNamedProgramLocalParameterfvEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedProgramLocalParameterfvEXT");
                _GetNamedProgramLocalParameterfvEXT_fnptr(program, target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, ProgramPropertyARB, int*, void> _GetNamedProgramivEXT_fnptr = &GetNamedProgramivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramivEXT(ProgramHandle program, ProgramTarget target, ProgramPropertyARB pname, int* parameters) => _GetNamedProgramivEXT_fnptr(program, target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedProgramivEXT_Lazy(ProgramHandle program, ProgramTarget target, ProgramPropertyARB pname, int* parameters)
            {
                _GetNamedProgramivEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, ProgramPropertyARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedProgramivEXT");
                _GetNamedProgramivEXT_fnptr(program, target, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramTarget, ProgramStringProperty, void*, void> _GetNamedProgramStringEXT_fnptr = &GetNamedProgramStringEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramStringEXT(ProgramHandle program, ProgramTarget target, ProgramStringProperty pname, void* str) => _GetNamedProgramStringEXT_fnptr(program, target, pname, str);
            [UnmanagedCallersOnly]
            private static void GetNamedProgramStringEXT_Lazy(ProgramHandle program, ProgramTarget target, ProgramStringProperty pname, void* str)
            {
                _GetNamedProgramStringEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramTarget, ProgramStringProperty, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedProgramStringEXT");
                _GetNamedProgramStringEXT_fnptr(program, target, pname, str);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, InternalFormat, int, int, void> _NamedRenderbufferStorageEXT_fnptr = &NamedRenderbufferStorageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedRenderbufferStorageEXT(RenderbufferHandle renderbuffer, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageEXT_fnptr(renderbuffer, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void NamedRenderbufferStorageEXT_Lazy(RenderbufferHandle renderbuffer, InternalFormat internalformat, int width, int height)
            {
                _NamedRenderbufferStorageEXT_fnptr = (delegate* unmanaged<RenderbufferHandle, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedRenderbufferStorageEXT");
                _NamedRenderbufferStorageEXT_fnptr(renderbuffer, internalformat, width, height);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, RenderbufferParameterName, int*, void> _GetNamedRenderbufferParameterivEXT_fnptr = &GetNamedRenderbufferParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedRenderbufferParameterivEXT(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int* parameters) => _GetNamedRenderbufferParameterivEXT_fnptr(renderbuffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedRenderbufferParameterivEXT_Lazy(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int* parameters)
            {
                _GetNamedRenderbufferParameterivEXT_fnptr = (delegate* unmanaged<RenderbufferHandle, RenderbufferParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedRenderbufferParameterivEXT");
                _GetNamedRenderbufferParameterivEXT_fnptr(renderbuffer, pname, parameters);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, int, InternalFormat, int, int, void> _NamedRenderbufferStorageMultisampleEXT_fnptr = &NamedRenderbufferStorageMultisampleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedRenderbufferStorageMultisampleEXT(RenderbufferHandle renderbuffer, int samples, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageMultisampleEXT_fnptr(renderbuffer, samples, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void NamedRenderbufferStorageMultisampleEXT_Lazy(RenderbufferHandle renderbuffer, int samples, InternalFormat internalformat, int width, int height)
            {
                _NamedRenderbufferStorageMultisampleEXT_fnptr = (delegate* unmanaged<RenderbufferHandle, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedRenderbufferStorageMultisampleEXT");
                _NamedRenderbufferStorageMultisampleEXT_fnptr(renderbuffer, samples, internalformat, width, height);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, int, int, InternalFormat, int, int, void> _NamedRenderbufferStorageMultisampleCoverageEXT_fnptr = &NamedRenderbufferStorageMultisampleCoverageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedRenderbufferStorageMultisampleCoverageEXT(RenderbufferHandle renderbuffer, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageMultisampleCoverageEXT_fnptr(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void NamedRenderbufferStorageMultisampleCoverageEXT_Lazy(RenderbufferHandle renderbuffer, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height)
            {
                _NamedRenderbufferStorageMultisampleCoverageEXT_fnptr = (delegate* unmanaged<RenderbufferHandle, int, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedRenderbufferStorageMultisampleCoverageEXT");
                _NamedRenderbufferStorageMultisampleCoverageEXT_fnptr(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferTarget, FramebufferStatus> _CheckNamedFramebufferStatusEXT_fnptr = &CheckNamedFramebufferStatusEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static FramebufferStatus CheckNamedFramebufferStatusEXT(FramebufferHandle framebuffer, FramebufferTarget target) => _CheckNamedFramebufferStatusEXT_fnptr(framebuffer, target);
            [UnmanagedCallersOnly]
            private static FramebufferStatus CheckNamedFramebufferStatusEXT_Lazy(FramebufferHandle framebuffer, FramebufferTarget target)
            {
                _CheckNamedFramebufferStatusEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferTarget, FramebufferStatus>)GLLoader.BindingsContext.GetProcAddress("glCheckNamedFramebufferStatusEXT");
                return _CheckNamedFramebufferStatusEXT_fnptr(framebuffer, target);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureTarget, TextureHandle, int, void> _NamedFramebufferTexture1DEXT_fnptr = &NamedFramebufferTexture1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTexture1DEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => _NamedFramebufferTexture1DEXT_fnptr(framebuffer, attachment, textarget, texture, level);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferTexture1DEXT_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level)
            {
                _NamedFramebufferTexture1DEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureTarget, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTexture1DEXT");
                _NamedFramebufferTexture1DEXT_fnptr(framebuffer, attachment, textarget, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureTarget, TextureHandle, int, void> _NamedFramebufferTexture2DEXT_fnptr = &NamedFramebufferTexture2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTexture2DEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => _NamedFramebufferTexture2DEXT_fnptr(framebuffer, attachment, textarget, texture, level);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferTexture2DEXT_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level)
            {
                _NamedFramebufferTexture2DEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureTarget, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTexture2DEXT");
                _NamedFramebufferTexture2DEXT_fnptr(framebuffer, attachment, textarget, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureTarget, TextureHandle, int, int, void> _NamedFramebufferTexture3DEXT_fnptr = &NamedFramebufferTexture3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTexture3DEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset) => _NamedFramebufferTexture3DEXT_fnptr(framebuffer, attachment, textarget, texture, level, zoffset);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferTexture3DEXT_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset)
            {
                _NamedFramebufferTexture3DEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureTarget, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTexture3DEXT");
                _NamedFramebufferTexture3DEXT_fnptr(framebuffer, attachment, textarget, texture, level, zoffset);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void> _NamedFramebufferRenderbufferEXT_fnptr = &NamedFramebufferRenderbufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferRenderbufferEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => _NamedFramebufferRenderbufferEXT_fnptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferRenderbufferEXT_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer)
            {
                _NamedFramebufferRenderbufferEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferRenderbufferEXT");
                _NamedFramebufferRenderbufferEXT_fnptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void> _GetNamedFramebufferAttachmentParameterivEXT_fnptr = &GetNamedFramebufferAttachmentParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedFramebufferAttachmentParameterivEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => _GetNamedFramebufferAttachmentParameterivEXT_fnptr(framebuffer, attachment, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedFramebufferAttachmentParameterivEXT_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters)
            {
                _GetNamedFramebufferAttachmentParameterivEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedFramebufferAttachmentParameterivEXT");
                _GetNamedFramebufferAttachmentParameterivEXT_fnptr(framebuffer, attachment, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, void> _GenerateTextureMipmapEXT_fnptr = &GenerateTextureMipmapEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenerateTextureMipmapEXT(TextureHandle texture, TextureTarget target) => _GenerateTextureMipmapEXT_fnptr(texture, target);
            [UnmanagedCallersOnly]
            private static void GenerateTextureMipmapEXT_Lazy(TextureHandle texture, TextureTarget target)
            {
                _GenerateTextureMipmapEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, void>)GLLoader.BindingsContext.GetProcAddress("glGenerateTextureMipmapEXT");
                _GenerateTextureMipmapEXT_fnptr(texture, target);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, void> _GenerateMultiTexMipmapEXT_fnptr = &GenerateMultiTexMipmapEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenerateMultiTexMipmapEXT(TextureUnit texunit, TextureTarget target) => _GenerateMultiTexMipmapEXT_fnptr(texunit, target);
            [UnmanagedCallersOnly]
            private static void GenerateMultiTexMipmapEXT_Lazy(TextureUnit texunit, TextureTarget target)
            {
                _GenerateMultiTexMipmapEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, void>)GLLoader.BindingsContext.GetProcAddress("glGenerateMultiTexMipmapEXT");
                _GenerateMultiTexMipmapEXT_fnptr(texunit, target);
            }
            
            private static delegate* unmanaged<FramebufferHandle, DrawBufferMode, void> _FramebufferDrawBufferEXT_fnptr = &FramebufferDrawBufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferDrawBufferEXT(FramebufferHandle framebuffer, DrawBufferMode mode) => _FramebufferDrawBufferEXT_fnptr(framebuffer, mode);
            [UnmanagedCallersOnly]
            private static void FramebufferDrawBufferEXT_Lazy(FramebufferHandle framebuffer, DrawBufferMode mode)
            {
                _FramebufferDrawBufferEXT_fnptr = (delegate* unmanaged<FramebufferHandle, DrawBufferMode, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferDrawBufferEXT");
                _FramebufferDrawBufferEXT_fnptr(framebuffer, mode);
            }
            
            private static delegate* unmanaged<FramebufferHandle, int, DrawBufferMode*, void> _FramebufferDrawBuffersEXT_fnptr = &FramebufferDrawBuffersEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferDrawBuffersEXT(FramebufferHandle framebuffer, int n, DrawBufferMode* bufs) => _FramebufferDrawBuffersEXT_fnptr(framebuffer, n, bufs);
            [UnmanagedCallersOnly]
            private static void FramebufferDrawBuffersEXT_Lazy(FramebufferHandle framebuffer, int n, DrawBufferMode* bufs)
            {
                _FramebufferDrawBuffersEXT_fnptr = (delegate* unmanaged<FramebufferHandle, int, DrawBufferMode*, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferDrawBuffersEXT");
                _FramebufferDrawBuffersEXT_fnptr(framebuffer, n, bufs);
            }
            
            private static delegate* unmanaged<FramebufferHandle, ReadBufferMode, void> _FramebufferReadBufferEXT_fnptr = &FramebufferReadBufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferReadBufferEXT(FramebufferHandle framebuffer, ReadBufferMode mode) => _FramebufferReadBufferEXT_fnptr(framebuffer, mode);
            [UnmanagedCallersOnly]
            private static void FramebufferReadBufferEXT_Lazy(FramebufferHandle framebuffer, ReadBufferMode mode)
            {
                _FramebufferReadBufferEXT_fnptr = (delegate* unmanaged<FramebufferHandle, ReadBufferMode, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferReadBufferEXT");
                _FramebufferReadBufferEXT_fnptr(framebuffer, mode);
            }
            
            private static delegate* unmanaged<FramebufferHandle, GetFramebufferParameter, int*, void> _GetFramebufferParameterivEXT_fnptr = &GetFramebufferParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* parameters) => _GetFramebufferParameterivEXT_fnptr(framebuffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFramebufferParameterivEXT_Lazy(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* parameters)
            {
                _GetFramebufferParameterivEXT_fnptr = (delegate* unmanaged<FramebufferHandle, GetFramebufferParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFramebufferParameterivEXT");
                _GetFramebufferParameterivEXT_fnptr(framebuffer, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferHandle, IntPtr, IntPtr, nint, void> _NamedCopyBufferSubDataEXT_fnptr = &NamedCopyBufferSubDataEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedCopyBufferSubDataEXT(BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => _NamedCopyBufferSubDataEXT_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
            [UnmanagedCallersOnly]
            private static void NamedCopyBufferSubDataEXT_Lazy(BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size)
            {
                _NamedCopyBufferSubDataEXT_fnptr = (delegate* unmanaged<BufferHandle, BufferHandle, IntPtr, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glNamedCopyBufferSubDataEXT");
                _NamedCopyBufferSubDataEXT_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, void> _NamedFramebufferTextureEXT_fnptr = &NamedFramebufferTextureEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTextureEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level) => _NamedFramebufferTextureEXT_fnptr(framebuffer, attachment, texture, level);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferTextureEXT_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level)
            {
                _NamedFramebufferTextureEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTextureEXT");
                _NamedFramebufferTextureEXT_fnptr(framebuffer, attachment, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, int, void> _NamedFramebufferTextureLayerEXT_fnptr = &NamedFramebufferTextureLayerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTextureLayerEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => _NamedFramebufferTextureLayerEXT_fnptr(framebuffer, attachment, texture, level, layer);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferTextureLayerEXT_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, int layer)
            {
                _NamedFramebufferTextureLayerEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTextureLayerEXT");
                _NamedFramebufferTextureLayerEXT_fnptr(framebuffer, attachment, texture, level, layer);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, TextureTarget, void> _NamedFramebufferTextureFaceEXT_fnptr = &NamedFramebufferTextureFaceEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTextureFaceEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, TextureTarget face) => _NamedFramebufferTextureFaceEXT_fnptr(framebuffer, attachment, texture, level, face);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferTextureFaceEXT_Lazy(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, TextureTarget face)
            {
                _NamedFramebufferTextureFaceEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferAttachment, TextureHandle, int, TextureTarget, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferTextureFaceEXT");
                _NamedFramebufferTextureFaceEXT_fnptr(framebuffer, attachment, texture, level, face);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, RenderbufferHandle, void> _TextureRenderbufferEXT_fnptr = &TextureRenderbufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureRenderbufferEXT(TextureHandle texture, TextureTarget target, RenderbufferHandle renderbuffer) => _TextureRenderbufferEXT_fnptr(texture, target, renderbuffer);
            [UnmanagedCallersOnly]
            private static void TextureRenderbufferEXT_Lazy(TextureHandle texture, TextureTarget target, RenderbufferHandle renderbuffer)
            {
                _TextureRenderbufferEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTextureRenderbufferEXT");
                _TextureRenderbufferEXT_fnptr(texture, target, renderbuffer);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureTarget, RenderbufferHandle, void> _MultiTexRenderbufferEXT_fnptr = &MultiTexRenderbufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexRenderbufferEXT(TextureUnit texunit, TextureTarget target, RenderbufferHandle renderbuffer) => _MultiTexRenderbufferEXT_fnptr(texunit, target, renderbuffer);
            [UnmanagedCallersOnly]
            private static void MultiTexRenderbufferEXT_Lazy(TextureUnit texunit, TextureTarget target, RenderbufferHandle renderbuffer)
            {
                _MultiTexRenderbufferEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexRenderbufferEXT");
                _MultiTexRenderbufferEXT_fnptr(texunit, target, renderbuffer);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, int, VertexPointerType, int, IntPtr, void> _VertexArrayVertexOffsetEXT_fnptr = &VertexArrayVertexOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int size, VertexPointerType type, int stride, IntPtr offset) => _VertexArrayVertexOffsetEXT_fnptr(vaobj, buffer, size, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, int size, VertexPointerType type, int stride, IntPtr offset)
            {
                _VertexArrayVertexOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, int, VertexPointerType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexOffsetEXT");
                _VertexArrayVertexOffsetEXT_fnptr(vaobj, buffer, size, type, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, int, ColorPointerType, int, IntPtr, void> _VertexArrayColorOffsetEXT_fnptr = &VertexArrayColorOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayColorOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int size, ColorPointerType type, int stride, IntPtr offset) => _VertexArrayColorOffsetEXT_fnptr(vaobj, buffer, size, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayColorOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, int size, ColorPointerType type, int stride, IntPtr offset)
            {
                _VertexArrayColorOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, int, ColorPointerType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayColorOffsetEXT");
                _VertexArrayColorOffsetEXT_fnptr(vaobj, buffer, size, type, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, int, IntPtr, void> _VertexArrayEdgeFlagOffsetEXT_fnptr = &VertexArrayEdgeFlagOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayEdgeFlagOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int stride, IntPtr offset) => _VertexArrayEdgeFlagOffsetEXT_fnptr(vaobj, buffer, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayEdgeFlagOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, int stride, IntPtr offset)
            {
                _VertexArrayEdgeFlagOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayEdgeFlagOffsetEXT");
                _VertexArrayEdgeFlagOffsetEXT_fnptr(vaobj, buffer, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, IndexPointerType, int, IntPtr, void> _VertexArrayIndexOffsetEXT_fnptr = &VertexArrayIndexOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayIndexOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, IndexPointerType type, int stride, IntPtr offset) => _VertexArrayIndexOffsetEXT_fnptr(vaobj, buffer, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayIndexOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, IndexPointerType type, int stride, IntPtr offset)
            {
                _VertexArrayIndexOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, IndexPointerType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayIndexOffsetEXT");
                _VertexArrayIndexOffsetEXT_fnptr(vaobj, buffer, type, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, NormalPointerType, int, IntPtr, void> _VertexArrayNormalOffsetEXT_fnptr = &VertexArrayNormalOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayNormalOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, NormalPointerType type, int stride, IntPtr offset) => _VertexArrayNormalOffsetEXT_fnptr(vaobj, buffer, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayNormalOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, NormalPointerType type, int stride, IntPtr offset)
            {
                _VertexArrayNormalOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, NormalPointerType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayNormalOffsetEXT");
                _VertexArrayNormalOffsetEXT_fnptr(vaobj, buffer, type, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, int, TexCoordPointerType, int, IntPtr, void> _VertexArrayTexCoordOffsetEXT_fnptr = &VertexArrayTexCoordOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayTexCoordOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int size, TexCoordPointerType type, int stride, IntPtr offset) => _VertexArrayTexCoordOffsetEXT_fnptr(vaobj, buffer, size, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayTexCoordOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, int size, TexCoordPointerType type, int stride, IntPtr offset)
            {
                _VertexArrayTexCoordOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, int, TexCoordPointerType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayTexCoordOffsetEXT");
                _VertexArrayTexCoordOffsetEXT_fnptr(vaobj, buffer, size, type, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, All, int, TexCoordPointerType, int, IntPtr, void> _VertexArrayMultiTexCoordOffsetEXT_fnptr = &VertexArrayMultiTexCoordOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayMultiTexCoordOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, All texunit, int size, TexCoordPointerType type, int stride, IntPtr offset) => _VertexArrayMultiTexCoordOffsetEXT_fnptr(vaobj, buffer, texunit, size, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayMultiTexCoordOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, All texunit, int size, TexCoordPointerType type, int stride, IntPtr offset)
            {
                _VertexArrayMultiTexCoordOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, All, int, TexCoordPointerType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayMultiTexCoordOffsetEXT");
                _VertexArrayMultiTexCoordOffsetEXT_fnptr(vaobj, buffer, texunit, size, type, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, FogCoordinatePointerType, int, IntPtr, void> _VertexArrayFogCoordOffsetEXT_fnptr = &VertexArrayFogCoordOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayFogCoordOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, FogCoordinatePointerType type, int stride, IntPtr offset) => _VertexArrayFogCoordOffsetEXT_fnptr(vaobj, buffer, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayFogCoordOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, FogCoordinatePointerType type, int stride, IntPtr offset)
            {
                _VertexArrayFogCoordOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, FogCoordinatePointerType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayFogCoordOffsetEXT");
                _VertexArrayFogCoordOffsetEXT_fnptr(vaobj, buffer, type, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, int, ColorPointerType, int, IntPtr, void> _VertexArraySecondaryColorOffsetEXT_fnptr = &VertexArraySecondaryColorOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArraySecondaryColorOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int size, ColorPointerType type, int stride, IntPtr offset) => _VertexArraySecondaryColorOffsetEXT_fnptr(vaobj, buffer, size, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArraySecondaryColorOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, int size, ColorPointerType type, int stride, IntPtr offset)
            {
                _VertexArraySecondaryColorOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, int, ColorPointerType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArraySecondaryColorOffsetEXT");
                _VertexArraySecondaryColorOffsetEXT_fnptr(vaobj, buffer, size, type, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, uint, int, VertexAttribPointerType, byte, int, IntPtr, void> _VertexArrayVertexAttribOffsetEXT_fnptr = &VertexArrayVertexAttribOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribPointerType type, byte normalized, int stride, IntPtr offset) => _VertexArrayVertexAttribOffsetEXT_fnptr(vaobj, buffer, index, size, type, normalized, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexAttribOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribPointerType type, byte normalized, int stride, IntPtr offset)
            {
                _VertexArrayVertexAttribOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, uint, int, VertexAttribPointerType, byte, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexAttribOffsetEXT");
                _VertexArrayVertexAttribOffsetEXT_fnptr(vaobj, buffer, index, size, type, normalized, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, uint, int, VertexAttribType, int, IntPtr, void> _VertexArrayVertexAttribIOffsetEXT_fnptr = &VertexArrayVertexAttribIOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribIOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribType type, int stride, IntPtr offset) => _VertexArrayVertexAttribIOffsetEXT_fnptr(vaobj, buffer, index, size, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexAttribIOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribType type, int stride, IntPtr offset)
            {
                _VertexArrayVertexAttribIOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, uint, int, VertexAttribType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexAttribIOffsetEXT");
                _VertexArrayVertexAttribIOffsetEXT_fnptr(vaobj, buffer, index, size, type, stride, offset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, EnableCap, void> _EnableVertexArrayEXT_fnptr = &EnableVertexArrayEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVertexArrayEXT(VertexArrayHandle vaobj, EnableCap array) => _EnableVertexArrayEXT_fnptr(vaobj, array);
            [UnmanagedCallersOnly]
            private static void EnableVertexArrayEXT_Lazy(VertexArrayHandle vaobj, EnableCap array)
            {
                _EnableVertexArrayEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, EnableCap, void>)GLLoader.BindingsContext.GetProcAddress("glEnableVertexArrayEXT");
                _EnableVertexArrayEXT_fnptr(vaobj, array);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, EnableCap, void> _DisableVertexArrayEXT_fnptr = &DisableVertexArrayEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVertexArrayEXT(VertexArrayHandle vaobj, EnableCap array) => _DisableVertexArrayEXT_fnptr(vaobj, array);
            [UnmanagedCallersOnly]
            private static void DisableVertexArrayEXT_Lazy(VertexArrayHandle vaobj, EnableCap array)
            {
                _DisableVertexArrayEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, EnableCap, void>)GLLoader.BindingsContext.GetProcAddress("glDisableVertexArrayEXT");
                _DisableVertexArrayEXT_fnptr(vaobj, array);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, void> _EnableVertexArrayAttribEXT_fnptr = &EnableVertexArrayAttribEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVertexArrayAttribEXT(VertexArrayHandle vaobj, uint index) => _EnableVertexArrayAttribEXT_fnptr(vaobj, index);
            [UnmanagedCallersOnly]
            private static void EnableVertexArrayAttribEXT_Lazy(VertexArrayHandle vaobj, uint index)
            {
                _EnableVertexArrayAttribEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnableVertexArrayAttribEXT");
                _EnableVertexArrayAttribEXT_fnptr(vaobj, index);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, void> _DisableVertexArrayAttribEXT_fnptr = &DisableVertexArrayAttribEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVertexArrayAttribEXT(VertexArrayHandle vaobj, uint index) => _DisableVertexArrayAttribEXT_fnptr(vaobj, index);
            [UnmanagedCallersOnly]
            private static void DisableVertexArrayAttribEXT_Lazy(VertexArrayHandle vaobj, uint index)
            {
                _DisableVertexArrayAttribEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisableVertexArrayAttribEXT");
                _DisableVertexArrayAttribEXT_fnptr(vaobj, index);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, VertexArrayPName, int*, void> _GetVertexArrayIntegervEXT_fnptr = &GetVertexArrayIntegervEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexArrayIntegervEXT(VertexArrayHandle vaobj, VertexArrayPName pname, int* param) => _GetVertexArrayIntegervEXT_fnptr(vaobj, pname, param);
            [UnmanagedCallersOnly]
            private static void GetVertexArrayIntegervEXT_Lazy(VertexArrayHandle vaobj, VertexArrayPName pname, int* param)
            {
                _GetVertexArrayIntegervEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, VertexArrayPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayIntegervEXT");
                _GetVertexArrayIntegervEXT_fnptr(vaobj, pname, param);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, VertexArrayPName, void**, void> _GetVertexArrayPointervEXT_fnptr = &GetVertexArrayPointervEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexArrayPointervEXT(VertexArrayHandle vaobj, VertexArrayPName pname, void** param) => _GetVertexArrayPointervEXT_fnptr(vaobj, pname, param);
            [UnmanagedCallersOnly]
            private static void GetVertexArrayPointervEXT_Lazy(VertexArrayHandle vaobj, VertexArrayPName pname, void** param)
            {
                _GetVertexArrayPointervEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, VertexArrayPName, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayPointervEXT");
                _GetVertexArrayPointervEXT_fnptr(vaobj, pname, param);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, int*, void> _GetVertexArrayIntegeri_vEXT_fnptr = &GetVertexArrayIntegeri_vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexArrayIntegeri_vEXT(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, int* param) => _GetVertexArrayIntegeri_vEXT_fnptr(vaobj, index, pname, param);
            [UnmanagedCallersOnly]
            private static void GetVertexArrayIntegeri_vEXT_Lazy(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, int* param)
            {
                _GetVertexArrayIntegeri_vEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayIntegeri_vEXT");
                _GetVertexArrayIntegeri_vEXT_fnptr(vaobj, index, pname, param);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, void**, void> _GetVertexArrayPointeri_vEXT_fnptr = &GetVertexArrayPointeri_vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexArrayPointeri_vEXT(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, void** param) => _GetVertexArrayPointeri_vEXT_fnptr(vaobj, index, pname, param);
            [UnmanagedCallersOnly]
            private static void GetVertexArrayPointeri_vEXT_Lazy(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, void** param)
            {
                _GetVertexArrayPointeri_vEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, VertexArrayPName, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexArrayPointeri_vEXT");
                _GetVertexArrayPointeri_vEXT_fnptr(vaobj, index, pname, param);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, MapBufferAccessMask, void*> _MapNamedBufferRangeEXT_fnptr = &MapNamedBufferRangeEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapNamedBufferRangeEXT(BufferHandle buffer, IntPtr offset, nint length, MapBufferAccessMask access) => _MapNamedBufferRangeEXT_fnptr(buffer, offset, length, access);
            [UnmanagedCallersOnly]
            private static void* MapNamedBufferRangeEXT_Lazy(BufferHandle buffer, IntPtr offset, nint length, MapBufferAccessMask access)
            {
                _MapNamedBufferRangeEXT_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, MapBufferAccessMask, void*>)GLLoader.BindingsContext.GetProcAddress("glMapNamedBufferRangeEXT");
                return _MapNamedBufferRangeEXT_fnptr(buffer, offset, length, access);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, void> _FlushMappedNamedBufferRangeEXT_fnptr = &FlushMappedNamedBufferRangeEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushMappedNamedBufferRangeEXT(BufferHandle buffer, IntPtr offset, nint length) => _FlushMappedNamedBufferRangeEXT_fnptr(buffer, offset, length);
            [UnmanagedCallersOnly]
            private static void FlushMappedNamedBufferRangeEXT_Lazy(BufferHandle buffer, IntPtr offset, nint length)
            {
                _FlushMappedNamedBufferRangeEXT_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glFlushMappedNamedBufferRangeEXT");
                _FlushMappedNamedBufferRangeEXT_fnptr(buffer, offset, length);
            }
            
            private static delegate* unmanaged<BufferHandle, nint, void*, BufferStorageMask, void> _NamedBufferStorageEXT_fnptr = &NamedBufferStorageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferStorageEXT(BufferHandle buffer, nint size, void* data, BufferStorageMask flags) => _NamedBufferStorageEXT_fnptr(buffer, size, data, flags);
            [UnmanagedCallersOnly]
            private static void NamedBufferStorageEXT_Lazy(BufferHandle buffer, nint size, void* data, BufferStorageMask flags)
            {
                _NamedBufferStorageEXT_fnptr = (delegate* unmanaged<BufferHandle, nint, void*, BufferStorageMask, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferStorageEXT");
                _NamedBufferStorageEXT_fnptr(buffer, size, data, flags);
            }
            
            private static delegate* unmanaged<BufferHandle, SizedInternalFormat, PixelFormat, PixelType, void*, void> _ClearNamedBufferDataEXT_fnptr = &ClearNamedBufferDataEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearNamedBufferDataEXT(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => _ClearNamedBufferDataEXT_fnptr(buffer, internalformat, format, type, data);
            [UnmanagedCallersOnly]
            private static void ClearNamedBufferDataEXT_Lazy(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data)
            {
                _ClearNamedBufferDataEXT_fnptr = (delegate* unmanaged<BufferHandle, SizedInternalFormat, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedBufferDataEXT");
                _ClearNamedBufferDataEXT_fnptr(buffer, internalformat, format, type, data);
            }
            
            private static delegate* unmanaged<BufferHandle, SizedInternalFormat, nint, nint, PixelFormat, PixelType, void*, void> _ClearNamedBufferSubDataEXT_fnptr = &ClearNamedBufferSubDataEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearNamedBufferSubDataEXT(BufferHandle buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, void* data) => _ClearNamedBufferSubDataEXT_fnptr(buffer, internalformat, offset, size, format, type, data);
            [UnmanagedCallersOnly]
            private static void ClearNamedBufferSubDataEXT_Lazy(BufferHandle buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, void* data)
            {
                _ClearNamedBufferSubDataEXT_fnptr = (delegate* unmanaged<BufferHandle, SizedInternalFormat, nint, nint, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glClearNamedBufferSubDataEXT");
                _ClearNamedBufferSubDataEXT_fnptr(buffer, internalformat, offset, size, format, type, data);
            }
            
            private static delegate* unmanaged<FramebufferHandle, FramebufferParameterName, int, void> _NamedFramebufferParameteriEXT_fnptr = &NamedFramebufferParameteriEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferParameteriEXT(FramebufferHandle framebuffer, FramebufferParameterName pname, int param) => _NamedFramebufferParameteriEXT_fnptr(framebuffer, pname, param);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferParameteriEXT_Lazy(FramebufferHandle framebuffer, FramebufferParameterName pname, int param)
            {
                _NamedFramebufferParameteriEXT_fnptr = (delegate* unmanaged<FramebufferHandle, FramebufferParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferParameteriEXT");
                _NamedFramebufferParameteriEXT_fnptr(framebuffer, pname, param);
            }
            
            private static delegate* unmanaged<FramebufferHandle, GetFramebufferParameter, int*, void> _GetNamedFramebufferParameterivEXT_fnptr = &GetNamedFramebufferParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* parameters) => _GetNamedFramebufferParameterivEXT_fnptr(framebuffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedFramebufferParameterivEXT_Lazy(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* parameters)
            {
                _GetNamedFramebufferParameterivEXT_fnptr = (delegate* unmanaged<FramebufferHandle, GetFramebufferParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedFramebufferParameterivEXT");
                _GetNamedFramebufferParameterivEXT_fnptr(framebuffer, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, double, void> _ProgramUniform1dEXT_fnptr = &ProgramUniform1dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1dEXT(ProgramHandle program, int location, double x) => _ProgramUniform1dEXT_fnptr(program, location, x);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1dEXT_Lazy(ProgramHandle program, int location, double x)
            {
                _ProgramUniform1dEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1dEXT");
                _ProgramUniform1dEXT_fnptr(program, location, x);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, double, double, void> _ProgramUniform2dEXT_fnptr = &ProgramUniform2dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2dEXT(ProgramHandle program, int location, double x, double y) => _ProgramUniform2dEXT_fnptr(program, location, x, y);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2dEXT_Lazy(ProgramHandle program, int location, double x, double y)
            {
                _ProgramUniform2dEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2dEXT");
                _ProgramUniform2dEXT_fnptr(program, location, x, y);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, double, double, double, void> _ProgramUniform3dEXT_fnptr = &ProgramUniform3dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3dEXT(ProgramHandle program, int location, double x, double y, double z) => _ProgramUniform3dEXT_fnptr(program, location, x, y, z);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3dEXT_Lazy(ProgramHandle program, int location, double x, double y, double z)
            {
                _ProgramUniform3dEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3dEXT");
                _ProgramUniform3dEXT_fnptr(program, location, x, y, z);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, double, double, double, double, void> _ProgramUniform4dEXT_fnptr = &ProgramUniform4dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4dEXT(ProgramHandle program, int location, double x, double y, double z, double w) => _ProgramUniform4dEXT_fnptr(program, location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4dEXT_Lazy(ProgramHandle program, int location, double x, double y, double z, double w)
            {
                _ProgramUniform4dEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4dEXT");
                _ProgramUniform4dEXT_fnptr(program, location, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform1dvEXT_fnptr = &ProgramUniform1dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1dvEXT(ProgramHandle program, int location, int count, double* value) => _ProgramUniform1dvEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1dvEXT_Lazy(ProgramHandle program, int location, int count, double* value)
            {
                _ProgramUniform1dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1dvEXT");
                _ProgramUniform1dvEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform2dvEXT_fnptr = &ProgramUniform2dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2dvEXT(ProgramHandle program, int location, int count, double* value) => _ProgramUniform2dvEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2dvEXT_Lazy(ProgramHandle program, int location, int count, double* value)
            {
                _ProgramUniform2dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2dvEXT");
                _ProgramUniform2dvEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform3dvEXT_fnptr = &ProgramUniform3dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3dvEXT(ProgramHandle program, int location, int count, double* value) => _ProgramUniform3dvEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3dvEXT_Lazy(ProgramHandle program, int location, int count, double* value)
            {
                _ProgramUniform3dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3dvEXT");
                _ProgramUniform3dvEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, double*, void> _ProgramUniform4dvEXT_fnptr = &ProgramUniform4dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4dvEXT(ProgramHandle program, int location, int count, double* value) => _ProgramUniform4dvEXT_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4dvEXT_Lazy(ProgramHandle program, int location, int count, double* value)
            {
                _ProgramUniform4dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4dvEXT");
                _ProgramUniform4dvEXT_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix2dvEXT_fnptr = &ProgramUniformMatrix2dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2dvEXT(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix2dvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2dvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix2dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2dvEXT");
                _ProgramUniformMatrix2dvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix3dvEXT_fnptr = &ProgramUniformMatrix3dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3dvEXT(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix3dvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3dvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix3dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3dvEXT");
                _ProgramUniformMatrix3dvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix4dvEXT_fnptr = &ProgramUniformMatrix4dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4dvEXT(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix4dvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4dvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix4dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4dvEXT");
                _ProgramUniformMatrix4dvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix2x3dvEXT_fnptr = &ProgramUniformMatrix2x3dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x3dvEXT(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix2x3dvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2x3dvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix2x3dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x3dvEXT");
                _ProgramUniformMatrix2x3dvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix2x4dvEXT_fnptr = &ProgramUniformMatrix2x4dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x4dvEXT(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix2x4dvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix2x4dvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix2x4dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix2x4dvEXT");
                _ProgramUniformMatrix2x4dvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix3x2dvEXT_fnptr = &ProgramUniformMatrix3x2dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x2dvEXT(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix3x2dvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3x2dvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix3x2dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x2dvEXT");
                _ProgramUniformMatrix3x2dvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix3x4dvEXT_fnptr = &ProgramUniformMatrix3x4dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x4dvEXT(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix3x4dvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix3x4dvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix3x4dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix3x4dvEXT");
                _ProgramUniformMatrix3x4dvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix4x2dvEXT_fnptr = &ProgramUniformMatrix4x2dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x2dvEXT(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix4x2dvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4x2dvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix4x2dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x2dvEXT");
                _ProgramUniformMatrix4x2dvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, byte, double*, void> _ProgramUniformMatrix4x3dvEXT_fnptr = &ProgramUniformMatrix4x3dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x3dvEXT(ProgramHandle program, int location, int count, byte transpose, double* value) => _ProgramUniformMatrix4x3dvEXT_fnptr(program, location, count, transpose, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformMatrix4x3dvEXT_Lazy(ProgramHandle program, int location, int count, byte transpose, double* value)
            {
                _ProgramUniformMatrix4x3dvEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, int, byte, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformMatrix4x3dvEXT");
                _ProgramUniformMatrix4x3dvEXT_fnptr(program, location, count, transpose, value);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, SizedInternalFormat, BufferHandle, IntPtr, nint, void> _TextureBufferRangeEXT_fnptr = &TextureBufferRangeEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureBufferRangeEXT(TextureHandle texture, TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => _TextureBufferRangeEXT_fnptr(texture, target, internalformat, buffer, offset, size);
            [UnmanagedCallersOnly]
            private static void TextureBufferRangeEXT_Lazy(TextureHandle texture, TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size)
            {
                _TextureBufferRangeEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, SizedInternalFormat, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glTextureBufferRangeEXT");
                _TextureBufferRangeEXT_fnptr(texture, target, internalformat, buffer, offset, size);
            }
            
            private static delegate* unmanaged<TextureHandle, All, int, SizedInternalFormat, int, void> _TextureStorage1DEXT_fnptr = &TextureStorage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage1DEXT(TextureHandle texture, All target, int levels, SizedInternalFormat internalformat, int width) => _TextureStorage1DEXT_fnptr(texture, target, levels, internalformat, width);
            [UnmanagedCallersOnly]
            private static void TextureStorage1DEXT_Lazy(TextureHandle texture, All target, int levels, SizedInternalFormat internalformat, int width)
            {
                _TextureStorage1DEXT_fnptr = (delegate* unmanaged<TextureHandle, All, int, SizedInternalFormat, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage1DEXT");
                _TextureStorage1DEXT_fnptr(texture, target, levels, internalformat, width);
            }
            
            private static delegate* unmanaged<TextureHandle, All, int, SizedInternalFormat, int, int, void> _TextureStorage2DEXT_fnptr = &TextureStorage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage2DEXT(TextureHandle texture, All target, int levels, SizedInternalFormat internalformat, int width, int height) => _TextureStorage2DEXT_fnptr(texture, target, levels, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void TextureStorage2DEXT_Lazy(TextureHandle texture, All target, int levels, SizedInternalFormat internalformat, int width, int height)
            {
                _TextureStorage2DEXT_fnptr = (delegate* unmanaged<TextureHandle, All, int, SizedInternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage2DEXT");
                _TextureStorage2DEXT_fnptr(texture, target, levels, internalformat, width, height);
            }
            
            private static delegate* unmanaged<TextureHandle, All, int, SizedInternalFormat, int, int, int, void> _TextureStorage3DEXT_fnptr = &TextureStorage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage3DEXT(TextureHandle texture, All target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => _TextureStorage3DEXT_fnptr(texture, target, levels, internalformat, width, height, depth);
            [UnmanagedCallersOnly]
            private static void TextureStorage3DEXT_Lazy(TextureHandle texture, All target, int levels, SizedInternalFormat internalformat, int width, int height, int depth)
            {
                _TextureStorage3DEXT_fnptr = (delegate* unmanaged<TextureHandle, All, int, SizedInternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage3DEXT");
                _TextureStorage3DEXT_fnptr(texture, target, levels, internalformat, width, height, depth);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, SizedInternalFormat, int, int, byte, void> _TextureStorage2DMultisampleEXT_fnptr = &TextureStorage2DMultisampleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage2DMultisampleEXT(TextureHandle texture, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations) => _TextureStorage2DMultisampleEXT_fnptr(texture, target, samples, internalformat, width, height, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void TextureStorage2DMultisampleEXT_Lazy(TextureHandle texture, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations)
            {
                _TextureStorage2DMultisampleEXT_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, SizedInternalFormat, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage2DMultisampleEXT");
                _TextureStorage2DMultisampleEXT_fnptr(texture, target, samples, internalformat, width, height, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<TextureHandle, All, int, SizedInternalFormat, int, int, int, byte, void> _TextureStorage3DMultisampleEXT_fnptr = &TextureStorage3DMultisampleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage3DMultisampleEXT(TextureHandle texture, All target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations) => _TextureStorage3DMultisampleEXT_fnptr(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void TextureStorage3DMultisampleEXT_Lazy(TextureHandle texture, All target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations)
            {
                _TextureStorage3DMultisampleEXT_fnptr = (delegate* unmanaged<TextureHandle, All, int, SizedInternalFormat, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorage3DMultisampleEXT");
                _TextureStorage3DMultisampleEXT_fnptr(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, BufferHandle, IntPtr, int, void> _VertexArrayBindVertexBufferEXT_fnptr = &VertexArrayBindVertexBufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayBindVertexBufferEXT(VertexArrayHandle vaobj, uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => _VertexArrayBindVertexBufferEXT_fnptr(vaobj, bindingindex, buffer, offset, stride);
            [UnmanagedCallersOnly]
            private static void VertexArrayBindVertexBufferEXT_Lazy(VertexArrayHandle vaobj, uint bindingindex, BufferHandle buffer, IntPtr offset, int stride)
            {
                _VertexArrayBindVertexBufferEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, BufferHandle, IntPtr, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayBindVertexBufferEXT");
                _VertexArrayBindVertexBufferEXT_fnptr(vaobj, bindingindex, buffer, offset, stride);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribType, byte, uint, void> _VertexArrayVertexAttribFormatEXT_fnptr = &VertexArrayVertexAttribFormatEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribFormatEXT(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset) => _VertexArrayVertexAttribFormatEXT_fnptr(vaobj, attribindex, size, type, normalized, relativeoffset);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexAttribFormatEXT_Lazy(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, byte normalized, uint relativeoffset)
            {
                _VertexArrayVertexAttribFormatEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribType, byte, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexAttribFormatEXT");
                _VertexArrayVertexAttribFormatEXT_fnptr(vaobj, attribindex, size, type, normalized, relativeoffset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribIType, uint, void> _VertexArrayVertexAttribIFormatEXT_fnptr = &VertexArrayVertexAttribIFormatEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribIFormatEXT(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => _VertexArrayVertexAttribIFormatEXT_fnptr(vaobj, attribindex, size, type, relativeoffset);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexAttribIFormatEXT_Lazy(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset)
            {
                _VertexArrayVertexAttribIFormatEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribIType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexAttribIFormatEXT");
                _VertexArrayVertexAttribIFormatEXT_fnptr(vaobj, attribindex, size, type, relativeoffset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribLType, uint, void> _VertexArrayVertexAttribLFormatEXT_fnptr = &VertexArrayVertexAttribLFormatEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribLFormatEXT(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => _VertexArrayVertexAttribLFormatEXT_fnptr(vaobj, attribindex, size, type, relativeoffset);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexAttribLFormatEXT_Lazy(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset)
            {
                _VertexArrayVertexAttribLFormatEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, int, VertexAttribLType, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexAttribLFormatEXT");
                _VertexArrayVertexAttribLFormatEXT_fnptr(vaobj, attribindex, size, type, relativeoffset);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, uint, void> _VertexArrayVertexAttribBindingEXT_fnptr = &VertexArrayVertexAttribBindingEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribBindingEXT(VertexArrayHandle vaobj, uint attribindex, uint bindingindex) => _VertexArrayVertexAttribBindingEXT_fnptr(vaobj, attribindex, bindingindex);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexAttribBindingEXT_Lazy(VertexArrayHandle vaobj, uint attribindex, uint bindingindex)
            {
                _VertexArrayVertexAttribBindingEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexAttribBindingEXT");
                _VertexArrayVertexAttribBindingEXT_fnptr(vaobj, attribindex, bindingindex);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, uint, void> _VertexArrayVertexBindingDivisorEXT_fnptr = &VertexArrayVertexBindingDivisorEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexBindingDivisorEXT(VertexArrayHandle vaobj, uint bindingindex, uint divisor) => _VertexArrayVertexBindingDivisorEXT_fnptr(vaobj, bindingindex, divisor);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexBindingDivisorEXT_Lazy(VertexArrayHandle vaobj, uint bindingindex, uint divisor)
            {
                _VertexArrayVertexBindingDivisorEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexBindingDivisorEXT");
                _VertexArrayVertexBindingDivisorEXT_fnptr(vaobj, bindingindex, divisor);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, BufferHandle, uint, int, VertexAttribLType, int, IntPtr, void> _VertexArrayVertexAttribLOffsetEXT_fnptr = &VertexArrayVertexAttribLOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribLOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribLType type, int stride, IntPtr offset) => _VertexArrayVertexAttribLOffsetEXT_fnptr(vaobj, buffer, index, size, type, stride, offset);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexAttribLOffsetEXT_Lazy(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribLType type, int stride, IntPtr offset)
            {
                _VertexArrayVertexAttribLOffsetEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, BufferHandle, uint, int, VertexAttribLType, int, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexAttribLOffsetEXT");
                _VertexArrayVertexAttribLOffsetEXT_fnptr(vaobj, buffer, index, size, type, stride, offset);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, byte, void> _TexturePageCommitmentEXT_fnptr = &TexturePageCommitmentEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexturePageCommitmentEXT(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, byte commit) => _TexturePageCommitmentEXT_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
            [UnmanagedCallersOnly]
            private static void TexturePageCommitmentEXT_Lazy(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, byte commit)
            {
                _TexturePageCommitmentEXT_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexturePageCommitmentEXT");
                _TexturePageCommitmentEXT_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
            }
            
            private static delegate* unmanaged<VertexArrayHandle, uint, uint, void> _VertexArrayVertexAttribDivisorEXT_fnptr = &VertexArrayVertexAttribDivisorEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribDivisorEXT(VertexArrayHandle vaobj, uint index, uint divisor) => _VertexArrayVertexAttribDivisorEXT_fnptr(vaobj, index, divisor);
            [UnmanagedCallersOnly]
            private static void VertexArrayVertexAttribDivisorEXT_Lazy(VertexArrayHandle vaobj, uint index, uint divisor)
            {
                _VertexArrayVertexAttribDivisorEXT_fnptr = (delegate* unmanaged<VertexArrayHandle, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayVertexAttribDivisorEXT");
                _VertexArrayVertexAttribDivisorEXT_fnptr(vaobj, index, divisor);
            }
            
            private static delegate* unmanaged<uint, byte, byte, byte, byte, void> _ColorMaskIndexedEXT_fnptr = &ColorMaskIndexedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorMaskIndexedEXT(uint index, byte r, byte g, byte b, byte a) => _ColorMaskIndexedEXT_fnptr(index, r, g, b, a);
            [UnmanagedCallersOnly]
            private static void ColorMaskIndexedEXT_Lazy(uint index, byte r, byte g, byte b, byte a)
            {
                _ColorMaskIndexedEXT_fnptr = (delegate* unmanaged<uint, byte, byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glColorMaskIndexedEXT");
                _ColorMaskIndexedEXT_fnptr(index, r, g, b, a);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, int, int, void> _DrawArraysInstancedEXT_fnptr = &DrawArraysInstancedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_draw_instanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawArraysInstancedEXT(PrimitiveType mode, int start, int count, int primcount) => _DrawArraysInstancedEXT_fnptr(mode, start, count, primcount);
            [UnmanagedCallersOnly]
            private static void DrawArraysInstancedEXT_Lazy(PrimitiveType mode, int start, int count, int primcount)
            {
                _DrawArraysInstancedEXT_fnptr = (delegate* unmanaged<PrimitiveType, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawArraysInstancedEXT");
                _DrawArraysInstancedEXT_fnptr(mode, start, count, primcount);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void> _DrawElementsInstancedEXT_fnptr = &DrawElementsInstancedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_draw_instanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawElementsInstancedEXT(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => _DrawElementsInstancedEXT_fnptr(mode, count, type, indices, primcount);
            [UnmanagedCallersOnly]
            private static void DrawElementsInstancedEXT_Lazy(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount)
            {
                _DrawElementsInstancedEXT_fnptr = (delegate* unmanaged<PrimitiveType, int, DrawElementsType, void*, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawElementsInstancedEXT");
                _DrawElementsInstancedEXT_fnptr(mode, count, type, indices, primcount);
            }
            
            private static delegate* unmanaged<PrimitiveType, uint, uint, int, DrawElementsType, void*, void> _DrawRangeElementsEXT_fnptr = &DrawRangeElementsEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_draw_range_elements]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawRangeElementsEXT(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => _DrawRangeElementsEXT_fnptr(mode, start, end, count, type, indices);
            [UnmanagedCallersOnly]
            private static void DrawRangeElementsEXT_Lazy(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices)
            {
                _DrawRangeElementsEXT_fnptr = (delegate* unmanaged<PrimitiveType, uint, uint, int, DrawElementsType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDrawRangeElementsEXT");
                _DrawRangeElementsEXT_fnptr(mode, start, end, count, type, indices);
            }
            
            private static delegate* unmanaged<All, IntPtr, nint, void*, BufferStorageMask, void> _BufferStorageExternalEXT_fnptr = &BufferStorageExternalEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_external_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferStorageExternalEXT(All target, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => _BufferStorageExternalEXT_fnptr(target, offset, size, clientBuffer, flags);
            [UnmanagedCallersOnly]
            private static void BufferStorageExternalEXT_Lazy(All target, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags)
            {
                _BufferStorageExternalEXT_fnptr = (delegate* unmanaged<All, IntPtr, nint, void*, BufferStorageMask, void>)GLLoader.BindingsContext.GetProcAddress("glBufferStorageExternalEXT");
                _BufferStorageExternalEXT_fnptr(target, offset, size, clientBuffer, flags);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, void*, BufferStorageMask, void> _NamedBufferStorageExternalEXT_fnptr = &NamedBufferStorageExternalEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_external_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferStorageExternalEXT(BufferHandle buffer, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => _NamedBufferStorageExternalEXT_fnptr(buffer, offset, size, clientBuffer, flags);
            [UnmanagedCallersOnly]
            private static void NamedBufferStorageExternalEXT_Lazy(BufferHandle buffer, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags)
            {
                _NamedBufferStorageExternalEXT_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, void*, BufferStorageMask, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferStorageExternalEXT");
                _NamedBufferStorageExternalEXT_fnptr(buffer, offset, size, clientBuffer, flags);
            }
            
            private static delegate* unmanaged<float, void> _FogCoordfEXT_fnptr = &FogCoordfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordfEXT(float coord) => _FogCoordfEXT_fnptr(coord);
            [UnmanagedCallersOnly]
            private static void FogCoordfEXT_Lazy(float coord)
            {
                _FogCoordfEXT_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordfEXT");
                _FogCoordfEXT_fnptr(coord);
            }
            
            private static delegate* unmanaged<float*, void> _FogCoordfvEXT_fnptr = &FogCoordfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordfvEXT(float* coord) => _FogCoordfvEXT_fnptr(coord);
            [UnmanagedCallersOnly]
            private static void FogCoordfvEXT_Lazy(float* coord)
            {
                _FogCoordfvEXT_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordfvEXT");
                _FogCoordfvEXT_fnptr(coord);
            }
            
            private static delegate* unmanaged<double, void> _FogCoorddEXT_fnptr = &FogCoorddEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoorddEXT(double coord) => _FogCoorddEXT_fnptr(coord);
            [UnmanagedCallersOnly]
            private static void FogCoorddEXT_Lazy(double coord)
            {
                _FogCoorddEXT_fnptr = (delegate* unmanaged<double, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoorddEXT");
                _FogCoorddEXT_fnptr(coord);
            }
            
            private static delegate* unmanaged<double*, void> _FogCoorddvEXT_fnptr = &FogCoorddvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoorddvEXT(double* coord) => _FogCoorddvEXT_fnptr(coord);
            [UnmanagedCallersOnly]
            private static void FogCoorddvEXT_Lazy(double* coord)
            {
                _FogCoorddvEXT_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoorddvEXT");
                _FogCoorddvEXT_fnptr(coord);
            }
            
            private static delegate* unmanaged<FogPointerTypeEXT, int, void*, void> _FogCoordPointerEXT_fnptr = &FogCoordPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordPointerEXT(FogPointerTypeEXT type, int stride, void* pointer) => _FogCoordPointerEXT_fnptr(type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void FogCoordPointerEXT_Lazy(FogPointerTypeEXT type, int stride, void* pointer)
            {
                _FogCoordPointerEXT_fnptr = (delegate* unmanaged<FogPointerTypeEXT, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordPointerEXT");
                _FogCoordPointerEXT_fnptr(type, stride, pointer);
            }
            
            private static delegate* unmanaged<int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void> _BlitFramebufferEXT_fnptr = &BlitFramebufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => _BlitFramebufferEXT_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            [UnmanagedCallersOnly]
            private static void BlitFramebufferEXT_Lazy(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter)
            {
                _BlitFramebufferEXT_fnptr = (delegate* unmanaged<int, int, int, int, int, int, int, int, ClearBufferMask, BlitFramebufferFilter, void>)GLLoader.BindingsContext.GetProcAddress("glBlitFramebufferEXT");
                _BlitFramebufferEXT_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, int, InternalFormat, int, int, void> _RenderbufferStorageMultisampleEXT_fnptr = &RenderbufferStorageMultisampleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderbufferStorageMultisampleEXT(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleEXT_fnptr(target, samples, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void RenderbufferStorageMultisampleEXT_Lazy(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height)
            {
                _RenderbufferStorageMultisampleEXT_fnptr = (delegate* unmanaged<RenderbufferTarget, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRenderbufferStorageMultisampleEXT");
                _RenderbufferStorageMultisampleEXT_fnptr(target, samples, internalformat, width, height);
            }
            
            private static delegate* unmanaged<RenderbufferHandle, byte> _IsRenderbufferEXT_fnptr = &IsRenderbufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsRenderbufferEXT(RenderbufferHandle renderbuffer) => _IsRenderbufferEXT_fnptr(renderbuffer);
            [UnmanagedCallersOnly]
            private static byte IsRenderbufferEXT_Lazy(RenderbufferHandle renderbuffer)
            {
                _IsRenderbufferEXT_fnptr = (delegate* unmanaged<RenderbufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsRenderbufferEXT");
                return _IsRenderbufferEXT_fnptr(renderbuffer);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, RenderbufferHandle, void> _BindRenderbufferEXT_fnptr = &BindRenderbufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindRenderbufferEXT(RenderbufferTarget target, RenderbufferHandle renderbuffer) => _BindRenderbufferEXT_fnptr(target, renderbuffer);
            [UnmanagedCallersOnly]
            private static void BindRenderbufferEXT_Lazy(RenderbufferTarget target, RenderbufferHandle renderbuffer)
            {
                _BindRenderbufferEXT_fnptr = (delegate* unmanaged<RenderbufferTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindRenderbufferEXT");
                _BindRenderbufferEXT_fnptr(target, renderbuffer);
            }
            
            private static delegate* unmanaged<int, RenderbufferHandle*, void> _DeleteRenderbuffersEXT_fnptr = &DeleteRenderbuffersEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteRenderbuffersEXT(int n, RenderbufferHandle* renderbuffers) => _DeleteRenderbuffersEXT_fnptr(n, renderbuffers);
            [UnmanagedCallersOnly]
            private static void DeleteRenderbuffersEXT_Lazy(int n, RenderbufferHandle* renderbuffers)
            {
                _DeleteRenderbuffersEXT_fnptr = (delegate* unmanaged<int, RenderbufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteRenderbuffersEXT");
                _DeleteRenderbuffersEXT_fnptr(n, renderbuffers);
            }
            
            private static delegate* unmanaged<int, RenderbufferHandle*, void> _GenRenderbuffersEXT_fnptr = &GenRenderbuffersEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenRenderbuffersEXT(int n, RenderbufferHandle* renderbuffers) => _GenRenderbuffersEXT_fnptr(n, renderbuffers);
            [UnmanagedCallersOnly]
            private static void GenRenderbuffersEXT_Lazy(int n, RenderbufferHandle* renderbuffers)
            {
                _GenRenderbuffersEXT_fnptr = (delegate* unmanaged<int, RenderbufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenRenderbuffersEXT");
                _GenRenderbuffersEXT_fnptr(n, renderbuffers);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, InternalFormat, int, int, void> _RenderbufferStorageEXT_fnptr = &RenderbufferStorageEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderbufferStorageEXT(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => _RenderbufferStorageEXT_fnptr(target, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void RenderbufferStorageEXT_Lazy(RenderbufferTarget target, InternalFormat internalformat, int width, int height)
            {
                _RenderbufferStorageEXT_fnptr = (delegate* unmanaged<RenderbufferTarget, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRenderbufferStorageEXT");
                _RenderbufferStorageEXT_fnptr(target, internalformat, width, height);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, RenderbufferParameterName, int*, void> _GetRenderbufferParameterivEXT_fnptr = &GetRenderbufferParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => _GetRenderbufferParameterivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetRenderbufferParameterivEXT_Lazy(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters)
            {
                _GetRenderbufferParameterivEXT_fnptr = (delegate* unmanaged<RenderbufferTarget, RenderbufferParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetRenderbufferParameterivEXT");
                _GetRenderbufferParameterivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<FramebufferHandle, byte> _IsFramebufferEXT_fnptr = &IsFramebufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsFramebufferEXT(FramebufferHandle framebuffer) => _IsFramebufferEXT_fnptr(framebuffer);
            [UnmanagedCallersOnly]
            private static byte IsFramebufferEXT_Lazy(FramebufferHandle framebuffer)
            {
                _IsFramebufferEXT_fnptr = (delegate* unmanaged<FramebufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsFramebufferEXT");
                return _IsFramebufferEXT_fnptr(framebuffer);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferHandle, void> _BindFramebufferEXT_fnptr = &BindFramebufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindFramebufferEXT(FramebufferTarget target, FramebufferHandle framebuffer) => _BindFramebufferEXT_fnptr(target, framebuffer);
            [UnmanagedCallersOnly]
            private static void BindFramebufferEXT_Lazy(FramebufferTarget target, FramebufferHandle framebuffer)
            {
                _BindFramebufferEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindFramebufferEXT");
                _BindFramebufferEXT_fnptr(target, framebuffer);
            }
            
            private static delegate* unmanaged<int, FramebufferHandle*, void> _DeleteFramebuffersEXT_fnptr = &DeleteFramebuffersEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteFramebuffersEXT(int n, FramebufferHandle* framebuffers) => _DeleteFramebuffersEXT_fnptr(n, framebuffers);
            [UnmanagedCallersOnly]
            private static void DeleteFramebuffersEXT_Lazy(int n, FramebufferHandle* framebuffers)
            {
                _DeleteFramebuffersEXT_fnptr = (delegate* unmanaged<int, FramebufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteFramebuffersEXT");
                _DeleteFramebuffersEXT_fnptr(n, framebuffers);
            }
            
            private static delegate* unmanaged<int, FramebufferHandle*, void> _GenFramebuffersEXT_fnptr = &GenFramebuffersEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenFramebuffersEXT(int n, FramebufferHandle* framebuffers) => _GenFramebuffersEXT_fnptr(n, framebuffers);
            [UnmanagedCallersOnly]
            private static void GenFramebuffersEXT_Lazy(int n, FramebufferHandle* framebuffers)
            {
                _GenFramebuffersEXT_fnptr = (delegate* unmanaged<int, FramebufferHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenFramebuffersEXT");
                _GenFramebuffersEXT_fnptr(n, framebuffers);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferStatus> _CheckFramebufferStatusEXT_fnptr = &CheckFramebufferStatusEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static FramebufferStatus CheckFramebufferStatusEXT(FramebufferTarget target) => _CheckFramebufferStatusEXT_fnptr(target);
            [UnmanagedCallersOnly]
            private static FramebufferStatus CheckFramebufferStatusEXT_Lazy(FramebufferTarget target)
            {
                _CheckFramebufferStatusEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferStatus>)GLLoader.BindingsContext.GetProcAddress("glCheckFramebufferStatusEXT");
                return _CheckFramebufferStatusEXT_fnptr(target);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void> _FramebufferTexture1DEXT_fnptr = &FramebufferTexture1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTexture1DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => _FramebufferTexture1DEXT_fnptr(target, attachment, textarget, texture, level);
            [UnmanagedCallersOnly]
            private static void FramebufferTexture1DEXT_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level)
            {
                _FramebufferTexture1DEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture1DEXT");
                _FramebufferTexture1DEXT_fnptr(target, attachment, textarget, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void> _FramebufferTexture2DEXT_fnptr = &FramebufferTexture2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTexture2DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => _FramebufferTexture2DEXT_fnptr(target, attachment, textarget, texture, level);
            [UnmanagedCallersOnly]
            private static void FramebufferTexture2DEXT_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level)
            {
                _FramebufferTexture2DEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture2DEXT");
                _FramebufferTexture2DEXT_fnptr(target, attachment, textarget, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, int, void> _FramebufferTexture3DEXT_fnptr = &FramebufferTexture3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTexture3DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset) => _FramebufferTexture3DEXT_fnptr(target, attachment, textarget, texture, level, zoffset);
            [UnmanagedCallersOnly]
            private static void FramebufferTexture3DEXT_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset)
            {
                _FramebufferTexture3DEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureTarget, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTexture3DEXT");
                _FramebufferTexture3DEXT_fnptr(target, attachment, textarget, texture, level, zoffset);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void> _FramebufferRenderbufferEXT_fnptr = &FramebufferRenderbufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferRenderbufferEXT(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => _FramebufferRenderbufferEXT_fnptr(target, attachment, renderbuffertarget, renderbuffer);
            [UnmanagedCallersOnly]
            private static void FramebufferRenderbufferEXT_Lazy(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer)
            {
                _FramebufferRenderbufferEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, RenderbufferTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferRenderbufferEXT");
                _FramebufferRenderbufferEXT_fnptr(target, attachment, renderbuffertarget, renderbuffer);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void> _GetFramebufferAttachmentParameterivEXT_fnptr = &GetFramebufferAttachmentParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => _GetFramebufferAttachmentParameterivEXT_fnptr(target, attachment, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFramebufferAttachmentParameterivEXT_Lazy(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters)
            {
                _GetFramebufferAttachmentParameterivEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, FramebufferAttachmentParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFramebufferAttachmentParameterivEXT");
                _GetFramebufferAttachmentParameterivEXT_fnptr(target, attachment, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, void> _GenerateMipmapEXT_fnptr = &GenerateMipmapEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenerateMipmapEXT(TextureTarget target) => _GenerateMipmapEXT_fnptr(target);
            [UnmanagedCallersOnly]
            private static void GenerateMipmapEXT_Lazy(TextureTarget target)
            {
                _GenerateMipmapEXT_fnptr = (delegate* unmanaged<TextureTarget, void>)GLLoader.BindingsContext.GetProcAddress("glGenerateMipmapEXT");
                _GenerateMipmapEXT_fnptr(target);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramParameterPName, int, void> _ProgramParameteriEXT_fnptr = &ProgramParameteriEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_geometry_shader4 | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameteriEXT(ProgramHandle program, ProgramParameterPName pname, int value) => _ProgramParameteriEXT_fnptr(program, pname, value);
            [UnmanagedCallersOnly]
            private static void ProgramParameteriEXT_Lazy(ProgramHandle program, ProgramParameterPName pname, int value)
            {
                _ProgramParameteriEXT_fnptr = (delegate* unmanaged<ProgramHandle, ProgramParameterPName, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameteriEXT");
                _ProgramParameteriEXT_fnptr(program, pname, value);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int, float*, void> _ProgramEnvParameters4fvEXT_fnptr = &ProgramEnvParameters4fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, int count, float* parameters) => _ProgramEnvParameters4fvEXT_fnptr(target, index, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParameters4fvEXT_Lazy(ProgramTarget target, uint index, int count, float* parameters)
            {
                _ProgramEnvParameters4fvEXT_fnptr = (delegate* unmanaged<ProgramTarget, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParameters4fvEXT");
                _ProgramEnvParameters4fvEXT_fnptr(target, index, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int, float*, void> _ProgramLocalParameters4fvEXT_fnptr = &ProgramLocalParameters4fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, int count, float* parameters) => _ProgramLocalParameters4fvEXT_fnptr(target, index, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParameters4fvEXT_Lazy(ProgramTarget target, uint index, int count, float* parameters)
            {
                _ProgramLocalParameters4fvEXT_fnptr = (delegate* unmanaged<ProgramTarget, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParameters4fvEXT");
                _ProgramLocalParameters4fvEXT_fnptr(target, index, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, uint*, void> _GetUniformuivEXT_fnptr = &GetUniformuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformuivEXT(ProgramHandle program, int location, uint* parameters) => _GetUniformuivEXT_fnptr(program, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformuivEXT_Lazy(ProgramHandle program, int location, uint* parameters)
            {
                _GetUniformuivEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformuivEXT");
                _GetUniformuivEXT_fnptr(program, location, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, byte*, void> _BindFragDataLocationEXT_fnptr = &BindFragDataLocationEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindFragDataLocationEXT(ProgramHandle program, uint color, byte* name) => _BindFragDataLocationEXT_fnptr(program, color, name);
            [UnmanagedCallersOnly]
            private static void BindFragDataLocationEXT_Lazy(ProgramHandle program, uint color, byte* name)
            {
                _BindFragDataLocationEXT_fnptr = (delegate* unmanaged<ProgramHandle, uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glBindFragDataLocationEXT");
                _BindFragDataLocationEXT_fnptr(program, color, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, byte*, int> _GetFragDataLocationEXT_fnptr = &GetFragDataLocationEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetFragDataLocationEXT(ProgramHandle program, byte* name) => _GetFragDataLocationEXT_fnptr(program, name);
            [UnmanagedCallersOnly]
            private static int GetFragDataLocationEXT_Lazy(ProgramHandle program, byte* name)
            {
                _GetFragDataLocationEXT_fnptr = (delegate* unmanaged<ProgramHandle, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetFragDataLocationEXT");
                return _GetFragDataLocationEXT_fnptr(program, name);
            }
            
            private static delegate* unmanaged<int, uint, void> _Uniform1uiEXT_fnptr = &Uniform1uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1uiEXT(int location, uint v0) => _Uniform1uiEXT_fnptr(location, v0);
            [UnmanagedCallersOnly]
            private static void Uniform1uiEXT_Lazy(int location, uint v0)
            {
                _Uniform1uiEXT_fnptr = (delegate* unmanaged<int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1uiEXT");
                _Uniform1uiEXT_fnptr(location, v0);
            }
            
            private static delegate* unmanaged<int, uint, uint, void> _Uniform2uiEXT_fnptr = &Uniform2uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2uiEXT(int location, uint v0, uint v1) => _Uniform2uiEXT_fnptr(location, v0, v1);
            [UnmanagedCallersOnly]
            private static void Uniform2uiEXT_Lazy(int location, uint v0, uint v1)
            {
                _Uniform2uiEXT_fnptr = (delegate* unmanaged<int, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2uiEXT");
                _Uniform2uiEXT_fnptr(location, v0, v1);
            }
            
            private static delegate* unmanaged<int, uint, uint, uint, void> _Uniform3uiEXT_fnptr = &Uniform3uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3uiEXT(int location, uint v0, uint v1, uint v2) => _Uniform3uiEXT_fnptr(location, v0, v1, v2);
            [UnmanagedCallersOnly]
            private static void Uniform3uiEXT_Lazy(int location, uint v0, uint v1, uint v2)
            {
                _Uniform3uiEXT_fnptr = (delegate* unmanaged<int, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3uiEXT");
                _Uniform3uiEXT_fnptr(location, v0, v1, v2);
            }
            
            private static delegate* unmanaged<int, uint, uint, uint, uint, void> _Uniform4uiEXT_fnptr = &Uniform4uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4uiEXT(int location, uint v0, uint v1, uint v2, uint v3) => _Uniform4uiEXT_fnptr(location, v0, v1, v2, v3);
            [UnmanagedCallersOnly]
            private static void Uniform4uiEXT_Lazy(int location, uint v0, uint v1, uint v2, uint v3)
            {
                _Uniform4uiEXT_fnptr = (delegate* unmanaged<int, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4uiEXT");
                _Uniform4uiEXT_fnptr(location, v0, v1, v2, v3);
            }
            
            private static delegate* unmanaged<int, int, uint*, void> _Uniform1uivEXT_fnptr = &Uniform1uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1uivEXT(int location, int count, uint* value) => _Uniform1uivEXT_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1uivEXT_Lazy(int location, int count, uint* value)
            {
                _Uniform1uivEXT_fnptr = (delegate* unmanaged<int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1uivEXT");
                _Uniform1uivEXT_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, uint*, void> _Uniform2uivEXT_fnptr = &Uniform2uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2uivEXT(int location, int count, uint* value) => _Uniform2uivEXT_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2uivEXT_Lazy(int location, int count, uint* value)
            {
                _Uniform2uivEXT_fnptr = (delegate* unmanaged<int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2uivEXT");
                _Uniform2uivEXT_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, uint*, void> _Uniform3uivEXT_fnptr = &Uniform3uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3uivEXT(int location, int count, uint* value) => _Uniform3uivEXT_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3uivEXT_Lazy(int location, int count, uint* value)
            {
                _Uniform3uivEXT_fnptr = (delegate* unmanaged<int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3uivEXT");
                _Uniform3uivEXT_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, uint*, void> _Uniform4uivEXT_fnptr = &Uniform4uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4uivEXT(int location, int count, uint* value) => _Uniform4uivEXT_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4uivEXT_Lazy(int location, int count, uint* value)
            {
                _Uniform4uivEXT_fnptr = (delegate* unmanaged<int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4uivEXT");
                _Uniform4uivEXT_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<uint, int, void> _VertexAttribI1iEXT_fnptr = &VertexAttribI1iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1iEXT(uint index, int x) => _VertexAttribI1iEXT_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttribI1iEXT_Lazy(uint index, int x)
            {
                _VertexAttribI1iEXT_fnptr = (delegate* unmanaged<uint, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1iEXT");
                _VertexAttribI1iEXT_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, int, int, void> _VertexAttribI2iEXT_fnptr = &VertexAttribI2iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2iEXT(uint index, int x, int y) => _VertexAttribI2iEXT_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttribI2iEXT_Lazy(uint index, int x, int y)
            {
                _VertexAttribI2iEXT_fnptr = (delegate* unmanaged<uint, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2iEXT");
                _VertexAttribI2iEXT_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, int, int, int, void> _VertexAttribI3iEXT_fnptr = &VertexAttribI3iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3iEXT(uint index, int x, int y, int z) => _VertexAttribI3iEXT_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttribI3iEXT_Lazy(uint index, int x, int y, int z)
            {
                _VertexAttribI3iEXT_fnptr = (delegate* unmanaged<uint, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3iEXT");
                _VertexAttribI3iEXT_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, int, int, int, int, void> _VertexAttribI4iEXT_fnptr = &VertexAttribI4iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => _VertexAttribI4iEXT_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4iEXT_Lazy(uint index, int x, int y, int z, int w)
            {
                _VertexAttribI4iEXT_fnptr = (delegate* unmanaged<uint, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4iEXT");
                _VertexAttribI4iEXT_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, uint, void> _VertexAttribI1uiEXT_fnptr = &VertexAttribI1uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1uiEXT(uint index, uint x) => _VertexAttribI1uiEXT_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttribI1uiEXT_Lazy(uint index, uint x)
            {
                _VertexAttribI1uiEXT_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1uiEXT");
                _VertexAttribI1uiEXT_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, uint, uint, void> _VertexAttribI2uiEXT_fnptr = &VertexAttribI2uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2uiEXT(uint index, uint x, uint y) => _VertexAttribI2uiEXT_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttribI2uiEXT_Lazy(uint index, uint x, uint y)
            {
                _VertexAttribI2uiEXT_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2uiEXT");
                _VertexAttribI2uiEXT_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, uint, uint, uint, void> _VertexAttribI3uiEXT_fnptr = &VertexAttribI3uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => _VertexAttribI3uiEXT_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttribI3uiEXT_Lazy(uint index, uint x, uint y, uint z)
            {
                _VertexAttribI3uiEXT_fnptr = (delegate* unmanaged<uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3uiEXT");
                _VertexAttribI3uiEXT_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, uint, uint, uint, uint, void> _VertexAttribI4uiEXT_fnptr = &VertexAttribI4uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => _VertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4uiEXT_Lazy(uint index, uint x, uint y, uint z, uint w)
            {
                _VertexAttribI4uiEXT_fnptr = (delegate* unmanaged<uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4uiEXT");
                _VertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttribI1ivEXT_fnptr = &VertexAttribI1ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1ivEXT(uint index, int* v) => _VertexAttribI1ivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI1ivEXT_Lazy(uint index, int* v)
            {
                _VertexAttribI1ivEXT_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1ivEXT");
                _VertexAttribI1ivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttribI2ivEXT_fnptr = &VertexAttribI2ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2ivEXT(uint index, int* v) => _VertexAttribI2ivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI2ivEXT_Lazy(uint index, int* v)
            {
                _VertexAttribI2ivEXT_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2ivEXT");
                _VertexAttribI2ivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttribI3ivEXT_fnptr = &VertexAttribI3ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3ivEXT(uint index, int* v) => _VertexAttribI3ivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI3ivEXT_Lazy(uint index, int* v)
            {
                _VertexAttribI3ivEXT_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3ivEXT");
                _VertexAttribI3ivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttribI4ivEXT_fnptr = &VertexAttribI4ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4ivEXT(uint index, int* v) => _VertexAttribI4ivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4ivEXT_Lazy(uint index, int* v)
            {
                _VertexAttribI4ivEXT_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4ivEXT");
                _VertexAttribI4ivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttribI1uivEXT_fnptr = &VertexAttribI1uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1uivEXT(uint index, uint* v) => _VertexAttribI1uivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI1uivEXT_Lazy(uint index, uint* v)
            {
                _VertexAttribI1uivEXT_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1uivEXT");
                _VertexAttribI1uivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttribI2uivEXT_fnptr = &VertexAttribI2uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2uivEXT(uint index, uint* v) => _VertexAttribI2uivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI2uivEXT_Lazy(uint index, uint* v)
            {
                _VertexAttribI2uivEXT_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2uivEXT");
                _VertexAttribI2uivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttribI3uivEXT_fnptr = &VertexAttribI3uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3uivEXT(uint index, uint* v) => _VertexAttribI3uivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI3uivEXT_Lazy(uint index, uint* v)
            {
                _VertexAttribI3uivEXT_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3uivEXT");
                _VertexAttribI3uivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttribI4uivEXT_fnptr = &VertexAttribI4uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4uivEXT(uint index, uint* v) => _VertexAttribI4uivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4uivEXT_Lazy(uint index, uint* v)
            {
                _VertexAttribI4uivEXT_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4uivEXT");
                _VertexAttribI4uivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, sbyte*, void> _VertexAttribI4bvEXT_fnptr = &VertexAttribI4bvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4bvEXT(uint index, sbyte* v) => _VertexAttribI4bvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4bvEXT_Lazy(uint index, sbyte* v)
            {
                _VertexAttribI4bvEXT_fnptr = (delegate* unmanaged<uint, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4bvEXT");
                _VertexAttribI4bvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttribI4svEXT_fnptr = &VertexAttribI4svEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4svEXT(uint index, short* v) => _VertexAttribI4svEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4svEXT_Lazy(uint index, short* v)
            {
                _VertexAttribI4svEXT_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4svEXT");
                _VertexAttribI4svEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, byte*, void> _VertexAttribI4ubvEXT_fnptr = &VertexAttribI4ubvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4ubvEXT(uint index, byte* v) => _VertexAttribI4ubvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4ubvEXT_Lazy(uint index, byte* v)
            {
                _VertexAttribI4ubvEXT_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4ubvEXT");
                _VertexAttribI4ubvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, ushort*, void> _VertexAttribI4usvEXT_fnptr = &VertexAttribI4usvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4usvEXT(uint index, ushort* v) => _VertexAttribI4usvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4usvEXT_Lazy(uint index, ushort* v)
            {
                _VertexAttribI4usvEXT_fnptr = (delegate* unmanaged<uint, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4usvEXT");
                _VertexAttribI4usvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribIType, int, void*, void> _VertexAttribIPointerEXT_fnptr = &VertexAttribIPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, void* pointer) => _VertexAttribIPointerEXT_fnptr(index, size, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void VertexAttribIPointerEXT_Lazy(uint index, int size, VertexAttribIType type, int stride, void* pointer)
            {
                _VertexAttribIPointerEXT_fnptr = (delegate* unmanaged<uint, int, VertexAttribIType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribIPointerEXT");
                _VertexAttribIPointerEXT_fnptr(index, size, type, stride, pointer);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnum, int*, void> _GetVertexAttribIivEXT_fnptr = &GetVertexAttribIivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int* parameters) => _GetVertexAttribIivEXT_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribIivEXT_Lazy(uint index, VertexAttribEnum pname, int* parameters)
            {
                _GetVertexAttribIivEXT_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribIivEXT");
                _GetVertexAttribIivEXT_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnum, uint*, void> _GetVertexAttribIuivEXT_fnptr = &GetVertexAttribIuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint* parameters) => _GetVertexAttribIuivEXT_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribIuivEXT_Lazy(uint index, VertexAttribEnum pname, uint* parameters)
            {
                _GetVertexAttribIuivEXT_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribIuivEXT");
                _GetVertexAttribIuivEXT_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, byte, PixelFormat, PixelType, void*, void> _GetHistogramEXT_fnptr = &GetHistogramEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetHistogramEXT(HistogramTargetEXT target, byte reset, PixelFormat format, PixelType type, void* values) => _GetHistogramEXT_fnptr(target, reset, format, type, values);
            [UnmanagedCallersOnly]
            private static void GetHistogramEXT_Lazy(HistogramTargetEXT target, byte reset, PixelFormat format, PixelType type, void* values)
            {
                _GetHistogramEXT_fnptr = (delegate* unmanaged<HistogramTargetEXT, byte, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetHistogramEXT");
                _GetHistogramEXT_fnptr(target, reset, format, type, values);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, float*, void> _GetHistogramParameterfvEXT_fnptr = &GetHistogramParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters) => _GetHistogramParameterfvEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetHistogramParameterfvEXT_Lazy(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters)
            {
                _GetHistogramParameterfvEXT_fnptr = (delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetHistogramParameterfvEXT");
                _GetHistogramParameterfvEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, int*, void> _GetHistogramParameterivEXT_fnptr = &GetHistogramParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => _GetHistogramParameterivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetHistogramParameterivEXT_Lazy(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters)
            {
                _GetHistogramParameterivEXT_fnptr = (delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetHistogramParameterivEXT");
                _GetHistogramParameterivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, byte, PixelFormat, PixelType, void*, void> _GetMinmaxEXT_fnptr = &GetMinmaxEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMinmaxEXT(MinmaxTargetEXT target, byte reset, PixelFormat format, PixelType type, void* values) => _GetMinmaxEXT_fnptr(target, reset, format, type, values);
            [UnmanagedCallersOnly]
            private static void GetMinmaxEXT_Lazy(MinmaxTargetEXT target, byte reset, PixelFormat format, PixelType type, void* values)
            {
                _GetMinmaxEXT_fnptr = (delegate* unmanaged<MinmaxTargetEXT, byte, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMinmaxEXT");
                _GetMinmaxEXT_fnptr(target, reset, format, type, values);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, GetMinmaxParameterPNameEXT, float*, void> _GetMinmaxParameterfvEXT_fnptr = &GetMinmaxParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters) => _GetMinmaxParameterfvEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMinmaxParameterfvEXT_Lazy(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters)
            {
                _GetMinmaxParameterfvEXT_fnptr = (delegate* unmanaged<MinmaxTargetEXT, GetMinmaxParameterPNameEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMinmaxParameterfvEXT");
                _GetMinmaxParameterfvEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, GetMinmaxParameterPNameEXT, int*, void> _GetMinmaxParameterivEXT_fnptr = &GetMinmaxParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters) => _GetMinmaxParameterivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMinmaxParameterivEXT_Lazy(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters)
            {
                _GetMinmaxParameterivEXT_fnptr = (delegate* unmanaged<MinmaxTargetEXT, GetMinmaxParameterPNameEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMinmaxParameterivEXT");
                _GetMinmaxParameterivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, int, InternalFormat, byte, void> _HistogramEXT_fnptr = &HistogramEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void HistogramEXT(HistogramTargetEXT target, int width, InternalFormat internalformat, byte sink) => _HistogramEXT_fnptr(target, width, internalformat, sink);
            [UnmanagedCallersOnly]
            private static void HistogramEXT_Lazy(HistogramTargetEXT target, int width, InternalFormat internalformat, byte sink)
            {
                _HistogramEXT_fnptr = (delegate* unmanaged<HistogramTargetEXT, int, InternalFormat, byte, void>)GLLoader.BindingsContext.GetProcAddress("glHistogramEXT");
                _HistogramEXT_fnptr(target, width, internalformat, sink);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, InternalFormat, byte, void> _MinmaxEXT_fnptr = &MinmaxEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MinmaxEXT(MinmaxTargetEXT target, InternalFormat internalformat, byte sink) => _MinmaxEXT_fnptr(target, internalformat, sink);
            [UnmanagedCallersOnly]
            private static void MinmaxEXT_Lazy(MinmaxTargetEXT target, InternalFormat internalformat, byte sink)
            {
                _MinmaxEXT_fnptr = (delegate* unmanaged<MinmaxTargetEXT, InternalFormat, byte, void>)GLLoader.BindingsContext.GetProcAddress("glMinmaxEXT");
                _MinmaxEXT_fnptr(target, internalformat, sink);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, void> _ResetHistogramEXT_fnptr = &ResetHistogramEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResetHistogramEXT(HistogramTargetEXT target) => _ResetHistogramEXT_fnptr(target);
            [UnmanagedCallersOnly]
            private static void ResetHistogramEXT_Lazy(HistogramTargetEXT target)
            {
                _ResetHistogramEXT_fnptr = (delegate* unmanaged<HistogramTargetEXT, void>)GLLoader.BindingsContext.GetProcAddress("glResetHistogramEXT");
                _ResetHistogramEXT_fnptr(target);
            }
            
            private static delegate* unmanaged<MinmaxTargetEXT, void> _ResetMinmaxEXT_fnptr = &ResetMinmaxEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResetMinmaxEXT(MinmaxTargetEXT target) => _ResetMinmaxEXT_fnptr(target);
            [UnmanagedCallersOnly]
            private static void ResetMinmaxEXT_Lazy(MinmaxTargetEXT target)
            {
                _ResetMinmaxEXT_fnptr = (delegate* unmanaged<MinmaxTargetEXT, void>)GLLoader.BindingsContext.GetProcAddress("glResetMinmaxEXT");
                _ResetMinmaxEXT_fnptr(target);
            }
            
            private static delegate* unmanaged<IndexFunctionEXT, float, void> _IndexFuncEXT_fnptr = &IndexFuncEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_index_func]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexFuncEXT(IndexFunctionEXT func, float reference) => _IndexFuncEXT_fnptr(func, reference);
            [UnmanagedCallersOnly]
            private static void IndexFuncEXT_Lazy(IndexFunctionEXT func, float reference)
            {
                _IndexFuncEXT_fnptr = (delegate* unmanaged<IndexFunctionEXT, float, void>)GLLoader.BindingsContext.GetProcAddress("glIndexFuncEXT");
                _IndexFuncEXT_fnptr(func, reference);
            }
            
            private static delegate* unmanaged<MaterialFace, IndexMaterialParameterEXT, void> _IndexMaterialEXT_fnptr = &IndexMaterialEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_index_material]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexMaterialEXT(MaterialFace face, IndexMaterialParameterEXT mode) => _IndexMaterialEXT_fnptr(face, mode);
            [UnmanagedCallersOnly]
            private static void IndexMaterialEXT_Lazy(MaterialFace face, IndexMaterialParameterEXT mode)
            {
                _IndexMaterialEXT_fnptr = (delegate* unmanaged<MaterialFace, IndexMaterialParameterEXT, void>)GLLoader.BindingsContext.GetProcAddress("glIndexMaterialEXT");
                _IndexMaterialEXT_fnptr(face, mode);
            }
            
            private static delegate* unmanaged<LightTextureModeEXT, void> _ApplyTextureEXT_fnptr = &ApplyTextureEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_light_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ApplyTextureEXT(LightTextureModeEXT mode) => _ApplyTextureEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void ApplyTextureEXT_Lazy(LightTextureModeEXT mode)
            {
                _ApplyTextureEXT_fnptr = (delegate* unmanaged<LightTextureModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glApplyTextureEXT");
                _ApplyTextureEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<LightTexturePNameEXT, void> _TextureLightEXT_fnptr = &TextureLightEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_light_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureLightEXT(LightTexturePNameEXT pname) => _TextureLightEXT_fnptr(pname);
            [UnmanagedCallersOnly]
            private static void TextureLightEXT_Lazy(LightTexturePNameEXT pname)
            {
                _TextureLightEXT_fnptr = (delegate* unmanaged<LightTexturePNameEXT, void>)GLLoader.BindingsContext.GetProcAddress("glTextureLightEXT");
                _TextureLightEXT_fnptr(pname);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, void> _TextureMaterialEXT_fnptr = &TextureMaterialEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_light_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureMaterialEXT(MaterialFace face, MaterialParameter mode) => _TextureMaterialEXT_fnptr(face, mode);
            [UnmanagedCallersOnly]
            private static void TextureMaterialEXT_Lazy(MaterialFace face, MaterialParameter mode)
            {
                _TextureMaterialEXT_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, void>)GLLoader.BindingsContext.GetProcAddress("glTextureMaterialEXT");
                _TextureMaterialEXT_fnptr(face, mode);
            }
            
            private static delegate* unmanaged<GetPName, byte*, void> _GetUnsignedBytevEXT_fnptr = &GetUnsignedBytevEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUnsignedBytevEXT(GetPName pname, byte* data) => _GetUnsignedBytevEXT_fnptr(pname, data);
            [UnmanagedCallersOnly]
            private static void GetUnsignedBytevEXT_Lazy(GetPName pname, byte* data)
            {
                _GetUnsignedBytevEXT_fnptr = (delegate* unmanaged<GetPName, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUnsignedBytevEXT");
                _GetUnsignedBytevEXT_fnptr(pname, data);
            }
            
            private static delegate* unmanaged<All, uint, byte*, void> _GetUnsignedBytei_vEXT_fnptr = &GetUnsignedBytei_vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUnsignedBytei_vEXT(All target, uint index, byte* data) => _GetUnsignedBytei_vEXT_fnptr(target, index, data);
            [UnmanagedCallersOnly]
            private static void GetUnsignedBytei_vEXT_Lazy(All target, uint index, byte* data)
            {
                _GetUnsignedBytei_vEXT_fnptr = (delegate* unmanaged<All, uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUnsignedBytei_vEXT");
                _GetUnsignedBytei_vEXT_fnptr(target, index, data);
            }
            
            private static delegate* unmanaged<int, uint*, void> _DeleteMemoryObjectsEXT_fnptr = &DeleteMemoryObjectsEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteMemoryObjectsEXT(int n, uint* memoryObjects) => _DeleteMemoryObjectsEXT_fnptr(n, memoryObjects);
            [UnmanagedCallersOnly]
            private static void DeleteMemoryObjectsEXT_Lazy(int n, uint* memoryObjects)
            {
                _DeleteMemoryObjectsEXT_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteMemoryObjectsEXT");
                _DeleteMemoryObjectsEXT_fnptr(n, memoryObjects);
            }
            
            private static delegate* unmanaged<uint, byte> _IsMemoryObjectEXT_fnptr = &IsMemoryObjectEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsMemoryObjectEXT(uint memoryObject) => _IsMemoryObjectEXT_fnptr(memoryObject);
            [UnmanagedCallersOnly]
            private static byte IsMemoryObjectEXT_Lazy(uint memoryObject)
            {
                _IsMemoryObjectEXT_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsMemoryObjectEXT");
                return _IsMemoryObjectEXT_fnptr(memoryObject);
            }
            
            private static delegate* unmanaged<int, uint*, void> _CreateMemoryObjectsEXT_fnptr = &CreateMemoryObjectsEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreateMemoryObjectsEXT(int n, uint* memoryObjects) => _CreateMemoryObjectsEXT_fnptr(n, memoryObjects);
            [UnmanagedCallersOnly]
            private static void CreateMemoryObjectsEXT_Lazy(int n, uint* memoryObjects)
            {
                _CreateMemoryObjectsEXT_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateMemoryObjectsEXT");
                _CreateMemoryObjectsEXT_fnptr(n, memoryObjects);
            }
            
            private static delegate* unmanaged<uint, MemoryObjectParameterName, int*, void> _MemoryObjectParameterivEXT_fnptr = &MemoryObjectParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => _MemoryObjectParameterivEXT_fnptr(memoryObject, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MemoryObjectParameterivEXT_Lazy(uint memoryObject, MemoryObjectParameterName pname, int* parameters)
            {
                _MemoryObjectParameterivEXT_fnptr = (delegate* unmanaged<uint, MemoryObjectParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMemoryObjectParameterivEXT");
                _MemoryObjectParameterivEXT_fnptr(memoryObject, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, MemoryObjectParameterName, int*, void> _GetMemoryObjectParameterivEXT_fnptr = &GetMemoryObjectParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => _GetMemoryObjectParameterivEXT_fnptr(memoryObject, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMemoryObjectParameterivEXT_Lazy(uint memoryObject, MemoryObjectParameterName pname, int* parameters)
            {
                _GetMemoryObjectParameterivEXT_fnptr = (delegate* unmanaged<uint, MemoryObjectParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMemoryObjectParameterivEXT");
                _GetMemoryObjectParameterivEXT_fnptr(memoryObject, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, uint, ulong, void> _TexStorageMem2DEXT_fnptr = &TexStorageMem2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem2DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => _TexStorageMem2DEXT_fnptr(target, levels, internalFormat, width, height, memory, offset);
            [UnmanagedCallersOnly]
            private static void TexStorageMem2DEXT_Lazy(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
            {
                _TexStorageMem2DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorageMem2DEXT");
                _TexStorageMem2DEXT_fnptr(target, levels, internalFormat, width, height, memory, offset);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, byte, uint, ulong, void> _TexStorageMem2DMultisampleEXT_fnptr = &TexStorageMem2DMultisampleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem2DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, byte fixedSampleLocations, uint memory, ulong offset) => _TexStorageMem2DMultisampleEXT_fnptr(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
            [UnmanagedCallersOnly]
            private static void TexStorageMem2DMultisampleEXT_Lazy(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, byte fixedSampleLocations, uint memory, ulong offset)
            {
                _TexStorageMem2DMultisampleEXT_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, byte, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorageMem2DMultisampleEXT");
                _TexStorageMem2DMultisampleEXT_fnptr(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, uint, ulong, void> _TexStorageMem3DEXT_fnptr = &TexStorageMem3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem3DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => _TexStorageMem3DEXT_fnptr(target, levels, internalFormat, width, height, depth, memory, offset);
            [UnmanagedCallersOnly]
            private static void TexStorageMem3DEXT_Lazy(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
            {
                _TexStorageMem3DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorageMem3DEXT");
                _TexStorageMem3DEXT_fnptr(target, levels, internalFormat, width, height, depth, memory, offset);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, byte, uint, ulong, void> _TexStorageMem3DMultisampleEXT_fnptr = &TexStorageMem3DMultisampleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem3DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations, uint memory, ulong offset) => _TexStorageMem3DMultisampleEXT_fnptr(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
            [UnmanagedCallersOnly]
            private static void TexStorageMem3DMultisampleEXT_Lazy(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations, uint memory, ulong offset)
            {
                _TexStorageMem3DMultisampleEXT_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, byte, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorageMem3DMultisampleEXT");
                _TexStorageMem3DMultisampleEXT_fnptr(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
            }
            
            private static delegate* unmanaged<BufferTargetARB, nint, uint, ulong, void> _BufferStorageMemEXT_fnptr = &BufferStorageMemEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferStorageMemEXT(BufferTargetARB target, nint size, uint memory, ulong offset) => _BufferStorageMemEXT_fnptr(target, size, memory, offset);
            [UnmanagedCallersOnly]
            private static void BufferStorageMemEXT_Lazy(BufferTargetARB target, nint size, uint memory, ulong offset)
            {
                _BufferStorageMemEXT_fnptr = (delegate* unmanaged<BufferTargetARB, nint, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glBufferStorageMemEXT");
                _BufferStorageMemEXT_fnptr(target, size, memory, offset);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, uint, ulong, void> _TextureStorageMem2DEXT_fnptr = &TextureStorageMem2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem2DEXT(TextureHandle texture, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => _TextureStorageMem2DEXT_fnptr(texture, levels, internalFormat, width, height, memory, offset);
            [UnmanagedCallersOnly]
            private static void TextureStorageMem2DEXT_Lazy(TextureHandle texture, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
            {
                _TextureStorageMem2DEXT_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorageMem2DEXT");
                _TextureStorageMem2DEXT_fnptr(texture, levels, internalFormat, width, height, memory, offset);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, byte, uint, ulong, void> _TextureStorageMem2DMultisampleEXT_fnptr = &TextureStorageMem2DMultisampleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem2DMultisampleEXT(TextureHandle texture, int samples, SizedInternalFormat internalFormat, int width, int height, byte fixedSampleLocations, uint memory, ulong offset) => _TextureStorageMem2DMultisampleEXT_fnptr(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
            [UnmanagedCallersOnly]
            private static void TextureStorageMem2DMultisampleEXT_Lazy(TextureHandle texture, int samples, SizedInternalFormat internalFormat, int width, int height, byte fixedSampleLocations, uint memory, ulong offset)
            {
                _TextureStorageMem2DMultisampleEXT_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, byte, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorageMem2DMultisampleEXT");
                _TextureStorageMem2DMultisampleEXT_fnptr(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, uint, ulong, void> _TextureStorageMem3DEXT_fnptr = &TextureStorageMem3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem3DEXT(TextureHandle texture, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => _TextureStorageMem3DEXT_fnptr(texture, levels, internalFormat, width, height, depth, memory, offset);
            [UnmanagedCallersOnly]
            private static void TextureStorageMem3DEXT_Lazy(TextureHandle texture, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
            {
                _TextureStorageMem3DEXT_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorageMem3DEXT");
                _TextureStorageMem3DEXT_fnptr(texture, levels, internalFormat, width, height, depth, memory, offset);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, byte, uint, ulong, void> _TextureStorageMem3DMultisampleEXT_fnptr = &TextureStorageMem3DMultisampleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem3DMultisampleEXT(TextureHandle texture, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations, uint memory, ulong offset) => _TextureStorageMem3DMultisampleEXT_fnptr(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
            [UnmanagedCallersOnly]
            private static void TextureStorageMem3DMultisampleEXT_Lazy(TextureHandle texture, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations, uint memory, ulong offset)
            {
                _TextureStorageMem3DMultisampleEXT_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, int, int, byte, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorageMem3DMultisampleEXT");
                _TextureStorageMem3DMultisampleEXT_fnptr(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
            }
            
            private static delegate* unmanaged<BufferHandle, nint, uint, ulong, void> _NamedBufferStorageMemEXT_fnptr = &NamedBufferStorageMemEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferStorageMemEXT(BufferHandle buffer, nint size, uint memory, ulong offset) => _NamedBufferStorageMemEXT_fnptr(buffer, size, memory, offset);
            [UnmanagedCallersOnly]
            private static void NamedBufferStorageMemEXT_Lazy(BufferHandle buffer, nint size, uint memory, ulong offset)
            {
                _NamedBufferStorageMemEXT_fnptr = (delegate* unmanaged<BufferHandle, nint, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferStorageMemEXT");
                _NamedBufferStorageMemEXT_fnptr(buffer, size, memory, offset);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, uint, ulong, void> _TexStorageMem1DEXT_fnptr = &TexStorageMem1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem1DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => _TexStorageMem1DEXT_fnptr(target, levels, internalFormat, width, memory, offset);
            [UnmanagedCallersOnly]
            private static void TexStorageMem1DEXT_Lazy(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset)
            {
                _TexStorageMem1DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorageMem1DEXT");
                _TexStorageMem1DEXT_fnptr(target, levels, internalFormat, width, memory, offset);
            }
            
            private static delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, uint, ulong, void> _TextureStorageMem1DEXT_fnptr = &TextureStorageMem1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem1DEXT(TextureHandle texture, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => _TextureStorageMem1DEXT_fnptr(texture, levels, internalFormat, width, memory, offset);
            [UnmanagedCallersOnly]
            private static void TextureStorageMem1DEXT_Lazy(TextureHandle texture, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset)
            {
                _TextureStorageMem1DEXT_fnptr = (delegate* unmanaged<TextureHandle, int, SizedInternalFormat, int, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTextureStorageMem1DEXT");
                _TextureStorageMem1DEXT_fnptr(texture, levels, internalFormat, width, memory, offset);
            }
            
            private static delegate* unmanaged<uint, ulong, ExternalHandleType, int, void> _ImportMemoryFdEXT_fnptr = &ImportMemoryFdEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object_fd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportMemoryFdEXT(uint memory, ulong size, ExternalHandleType handleType, int fd) => _ImportMemoryFdEXT_fnptr(memory, size, handleType, fd);
            [UnmanagedCallersOnly]
            private static void ImportMemoryFdEXT_Lazy(uint memory, ulong size, ExternalHandleType handleType, int fd)
            {
                _ImportMemoryFdEXT_fnptr = (delegate* unmanaged<uint, ulong, ExternalHandleType, int, void>)GLLoader.BindingsContext.GetProcAddress("glImportMemoryFdEXT");
                _ImportMemoryFdEXT_fnptr(memory, size, handleType, fd);
            }
            
            private static delegate* unmanaged<uint, ulong, ExternalHandleType, void*, void> _ImportMemoryWin32HandleEXT_fnptr = &ImportMemoryWin32HandleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object_win32]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportMemoryWin32HandleEXT(uint memory, ulong size, ExternalHandleType handleType, void* handle) => _ImportMemoryWin32HandleEXT_fnptr(memory, size, handleType, handle);
            [UnmanagedCallersOnly]
            private static void ImportMemoryWin32HandleEXT_Lazy(uint memory, ulong size, ExternalHandleType handleType, void* handle)
            {
                _ImportMemoryWin32HandleEXT_fnptr = (delegate* unmanaged<uint, ulong, ExternalHandleType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glImportMemoryWin32HandleEXT");
                _ImportMemoryWin32HandleEXT_fnptr(memory, size, handleType, handle);
            }
            
            private static delegate* unmanaged<uint, ulong, ExternalHandleType, void*, void> _ImportMemoryWin32NameEXT_fnptr = &ImportMemoryWin32NameEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_memory_object_win32]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportMemoryWin32NameEXT(uint memory, ulong size, ExternalHandleType handleType, void* name) => _ImportMemoryWin32NameEXT_fnptr(memory, size, handleType, name);
            [UnmanagedCallersOnly]
            private static void ImportMemoryWin32NameEXT_Lazy(uint memory, ulong size, ExternalHandleType handleType, void* name)
            {
                _ImportMemoryWin32NameEXT_fnptr = (delegate* unmanaged<uint, ulong, ExternalHandleType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glImportMemoryWin32NameEXT");
                _ImportMemoryWin32NameEXT_fnptr(memory, size, handleType, name);
            }
            
            private static delegate* unmanaged<PrimitiveType, int*, int*, int, void> _MultiDrawArraysEXT_fnptr = &MultiDrawArraysEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysEXT(PrimitiveType mode, int* first, int* count, int primcount) => _MultiDrawArraysEXT_fnptr(mode, first, count, primcount);
            [UnmanagedCallersOnly]
            private static void MultiDrawArraysEXT_Lazy(PrimitiveType mode, int* first, int* count, int primcount)
            {
                _MultiDrawArraysEXT_fnptr = (delegate* unmanaged<PrimitiveType, int*, int*, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawArraysEXT");
                _MultiDrawArraysEXT_fnptr(mode, first, count, primcount);
            }
            
            private static delegate* unmanaged<PrimitiveType, int*, DrawElementsType, void**, int, void> _MultiDrawElementsEXT_fnptr = &MultiDrawElementsEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsEXT(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int primcount) => _MultiDrawElementsEXT_fnptr(mode, count, type, indices, primcount);
            [UnmanagedCallersOnly]
            private static void MultiDrawElementsEXT_Lazy(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int primcount)
            {
                _MultiDrawElementsEXT_fnptr = (delegate* unmanaged<PrimitiveType, int*, DrawElementsType, void**, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsEXT");
                _MultiDrawElementsEXT_fnptr(mode, count, type, indices, primcount);
            }
            
            private static delegate* unmanaged<float, byte, void> _SampleMaskEXT_fnptr = &SampleMaskEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleMaskEXT(float value, byte invert) => _SampleMaskEXT_fnptr(value, invert);
            [UnmanagedCallersOnly]
            private static void SampleMaskEXT_Lazy(float value, byte invert)
            {
                _SampleMaskEXT_fnptr = (delegate* unmanaged<float, byte, void>)GLLoader.BindingsContext.GetProcAddress("glSampleMaskEXT");
                _SampleMaskEXT_fnptr(value, invert);
            }
            
            private static delegate* unmanaged<SamplePatternEXT, void> _SamplePatternEXT_fnptr = &SamplePatternEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SamplePatternEXT(SamplePatternEXT pattern) => _SamplePatternEXT_fnptr(pattern);
            [UnmanagedCallersOnly]
            private static void SamplePatternEXT_Lazy(SamplePatternEXT pattern)
            {
                _SamplePatternEXT_fnptr = (delegate* unmanaged<SamplePatternEXT, void>)GLLoader.BindingsContext.GetProcAddress("glSamplePatternEXT");
                _SamplePatternEXT_fnptr(pattern);
            }
            
            private static delegate* unmanaged<ColorTableTarget, InternalFormat, int, PixelFormat, PixelType, void*, void> _ColorTableEXT_fnptr = &ColorTableEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorTableEXT(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, void* table) => _ColorTableEXT_fnptr(target, internalFormat, width, format, type, table);
            [UnmanagedCallersOnly]
            private static void ColorTableEXT_Lazy(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, void* table)
            {
                _ColorTableEXT_fnptr = (delegate* unmanaged<ColorTableTarget, InternalFormat, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glColorTableEXT");
                _ColorTableEXT_fnptr(target, internalFormat, width, format, type, table);
            }
            
            private static delegate* unmanaged<ColorTableTarget, PixelFormat, PixelType, void*, void> _GetColorTableEXT_fnptr = &GetColorTableEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableEXT(ColorTableTarget target, PixelFormat format, PixelType type, void* data) => _GetColorTableEXT_fnptr(target, format, type, data);
            [UnmanagedCallersOnly]
            private static void GetColorTableEXT_Lazy(ColorTableTarget target, PixelFormat format, PixelType type, void* data)
            {
                _GetColorTableEXT_fnptr = (delegate* unmanaged<ColorTableTarget, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetColorTableEXT");
                _GetColorTableEXT_fnptr(target, format, type, data);
            }
            
            private static delegate* unmanaged<ColorTableTarget, GetColorTableParameterPNameSGI, int*, void> _GetColorTableParameterivEXT_fnptr = &GetColorTableParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableParameterivEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, int* parameters) => _GetColorTableParameterivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetColorTableParameterivEXT_Lazy(ColorTableTarget target, GetColorTableParameterPNameSGI pname, int* parameters)
            {
                _GetColorTableParameterivEXT_fnptr = (delegate* unmanaged<ColorTableTarget, GetColorTableParameterPNameSGI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetColorTableParameterivEXT");
                _GetColorTableParameterivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ColorTableTarget, GetColorTableParameterPNameSGI, float*, void> _GetColorTableParameterfvEXT_fnptr = &GetColorTableParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableParameterfvEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, float* parameters) => _GetColorTableParameterfvEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetColorTableParameterfvEXT_Lazy(ColorTableTarget target, GetColorTableParameterPNameSGI pname, float* parameters)
            {
                _GetColorTableParameterfvEXT_fnptr = (delegate* unmanaged<ColorTableTarget, GetColorTableParameterPNameSGI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetColorTableParameterfvEXT");
                _GetColorTableParameterfvEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<PixelTransformTargetEXT, PixelTransformPNameEXT, int, void> _PixelTransformParameteriEXT_fnptr = &PixelTransformParameteriEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransformParameteriEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int param) => _PixelTransformParameteriEXT_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void PixelTransformParameteriEXT_Lazy(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int param)
            {
                _PixelTransformParameteriEXT_fnptr = (delegate* unmanaged<PixelTransformTargetEXT, PixelTransformPNameEXT, int, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTransformParameteriEXT");
                _PixelTransformParameteriEXT_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<PixelTransformTargetEXT, PixelTransformPNameEXT, float, void> _PixelTransformParameterfEXT_fnptr = &PixelTransformParameterfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransformParameterfEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float param) => _PixelTransformParameterfEXT_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void PixelTransformParameterfEXT_Lazy(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float param)
            {
                _PixelTransformParameterfEXT_fnptr = (delegate* unmanaged<PixelTransformTargetEXT, PixelTransformPNameEXT, float, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTransformParameterfEXT");
                _PixelTransformParameterfEXT_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<PixelTransformTargetEXT, PixelTransformPNameEXT, int*, void> _PixelTransformParameterivEXT_fnptr = &PixelTransformParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int* parameters) => _PixelTransformParameterivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void PixelTransformParameterivEXT_Lazy(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int* parameters)
            {
                _PixelTransformParameterivEXT_fnptr = (delegate* unmanaged<PixelTransformTargetEXT, PixelTransformPNameEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTransformParameterivEXT");
                _PixelTransformParameterivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<PixelTransformTargetEXT, PixelTransformPNameEXT, float*, void> _PixelTransformParameterfvEXT_fnptr = &PixelTransformParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float* parameters) => _PixelTransformParameterfvEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void PixelTransformParameterfvEXT_Lazy(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float* parameters)
            {
                _PixelTransformParameterfvEXT_fnptr = (delegate* unmanaged<PixelTransformTargetEXT, PixelTransformPNameEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTransformParameterfvEXT");
                _PixelTransformParameterfvEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<All, All, int*, void> _GetPixelTransformParameterivEXT_fnptr = &GetPixelTransformParameterivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelTransformParameterivEXT(All target, All pname, int* parameters) => _GetPixelTransformParameterivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetPixelTransformParameterivEXT_Lazy(All target, All pname, int* parameters)
            {
                _GetPixelTransformParameterivEXT_fnptr = (delegate* unmanaged<All, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPixelTransformParameterivEXT");
                _GetPixelTransformParameterivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<All, All, float*, void> _GetPixelTransformParameterfvEXT_fnptr = &GetPixelTransformParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelTransformParameterfvEXT(All target, All pname, float* parameters) => _GetPixelTransformParameterfvEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetPixelTransformParameterfvEXT_Lazy(All target, All pname, float* parameters)
            {
                _GetPixelTransformParameterfvEXT_fnptr = (delegate* unmanaged<All, All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPixelTransformParameterfvEXT");
                _GetPixelTransformParameterfvEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, float, void> _PointParameterfEXT_fnptr = &PointParameterfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfEXT(PointParameterNameARB pname, float param) => _PointParameterfEXT_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PointParameterfEXT_Lazy(PointParameterNameARB pname, float param)
            {
                _PointParameterfEXT_fnptr = (delegate* unmanaged<PointParameterNameARB, float, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterfEXT");
                _PointParameterfEXT_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, float*, void> _PointParameterfvEXT_fnptr = &PointParameterfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfvEXT(PointParameterNameARB pname, float* parameters) => _PointParameterfvEXT_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void PointParameterfvEXT_Lazy(PointParameterNameARB pname, float* parameters)
            {
                _PointParameterfvEXT_fnptr = (delegate* unmanaged<PointParameterNameARB, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterfvEXT");
                _PointParameterfvEXT_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<float, float, void> _PolygonOffsetEXT_fnptr = &PolygonOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_polygon_offset]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PolygonOffsetEXT(float factor, float bias) => _PolygonOffsetEXT_fnptr(factor, bias);
            [UnmanagedCallersOnly]
            private static void PolygonOffsetEXT_Lazy(float factor, float bias)
            {
                _PolygonOffsetEXT_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glPolygonOffsetEXT");
                _PolygonOffsetEXT_fnptr(factor, bias);
            }
            
            private static delegate* unmanaged<float, float, float, void> _PolygonOffsetClampEXT_fnptr = &PolygonOffsetClampEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_polygon_offset_clamp]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PolygonOffsetClampEXT(float factor, float units, float clamp) => _PolygonOffsetClampEXT_fnptr(factor, units, clamp);
            [UnmanagedCallersOnly]
            private static void PolygonOffsetClampEXT_Lazy(float factor, float units, float clamp)
            {
                _PolygonOffsetClampEXT_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glPolygonOffsetClampEXT");
                _PolygonOffsetClampEXT_fnptr(factor, units, clamp);
            }
            
            private static delegate* unmanaged<VertexProvokingMode, void> _ProvokingVertexEXT_fnptr = &ProvokingVertexEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_provoking_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProvokingVertexEXT(VertexProvokingMode mode) => _ProvokingVertexEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void ProvokingVertexEXT_Lazy(VertexProvokingMode mode)
            {
                _ProvokingVertexEXT_fnptr = (delegate* unmanaged<VertexProvokingMode, void>)GLLoader.BindingsContext.GetProcAddress("glProvokingVertexEXT");
                _ProvokingVertexEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<uint, byte, void> _RasterSamplesEXT_fnptr = &RasterSamplesEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterSamplesEXT(uint samples, byte fixedsamplelocations) => _RasterSamplesEXT_fnptr(samples, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void RasterSamplesEXT_Lazy(uint samples, byte fixedsamplelocations)
            {
                _RasterSamplesEXT_fnptr = (delegate* unmanaged<uint, byte, void>)GLLoader.BindingsContext.GetProcAddress("glRasterSamplesEXT");
                _RasterSamplesEXT_fnptr(samples, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<int, uint*, void> _GenSemaphoresEXT_fnptr = &GenSemaphoresEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenSemaphoresEXT(int n, uint* semaphores) => _GenSemaphoresEXT_fnptr(n, semaphores);
            [UnmanagedCallersOnly]
            private static void GenSemaphoresEXT_Lazy(int n, uint* semaphores)
            {
                _GenSemaphoresEXT_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGenSemaphoresEXT");
                _GenSemaphoresEXT_fnptr(n, semaphores);
            }
            
            private static delegate* unmanaged<int, uint*, void> _DeleteSemaphoresEXT_fnptr = &DeleteSemaphoresEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteSemaphoresEXT(int n, uint* semaphores) => _DeleteSemaphoresEXT_fnptr(n, semaphores);
            [UnmanagedCallersOnly]
            private static void DeleteSemaphoresEXT_Lazy(int n, uint* semaphores)
            {
                _DeleteSemaphoresEXT_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteSemaphoresEXT");
                _DeleteSemaphoresEXT_fnptr(n, semaphores);
            }
            
            private static delegate* unmanaged<uint, byte> _IsSemaphoreEXT_fnptr = &IsSemaphoreEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsSemaphoreEXT(uint semaphore) => _IsSemaphoreEXT_fnptr(semaphore);
            [UnmanagedCallersOnly]
            private static byte IsSemaphoreEXT_Lazy(uint semaphore)
            {
                _IsSemaphoreEXT_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsSemaphoreEXT");
                return _IsSemaphoreEXT_fnptr(semaphore);
            }
            
            private static delegate* unmanaged<uint, SemaphoreParameterName, ulong*, void> _SemaphoreParameterui64vEXT_fnptr = &SemaphoreParameterui64vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => _SemaphoreParameterui64vEXT_fnptr(semaphore, pname, parameters);
            [UnmanagedCallersOnly]
            private static void SemaphoreParameterui64vEXT_Lazy(uint semaphore, SemaphoreParameterName pname, ulong* parameters)
            {
                _SemaphoreParameterui64vEXT_fnptr = (delegate* unmanaged<uint, SemaphoreParameterName, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glSemaphoreParameterui64vEXT");
                _SemaphoreParameterui64vEXT_fnptr(semaphore, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, SemaphoreParameterName, ulong*, void> _GetSemaphoreParameterui64vEXT_fnptr = &GetSemaphoreParameterui64vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetSemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => _GetSemaphoreParameterui64vEXT_fnptr(semaphore, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetSemaphoreParameterui64vEXT_Lazy(uint semaphore, SemaphoreParameterName pname, ulong* parameters)
            {
                _GetSemaphoreParameterui64vEXT_fnptr = (delegate* unmanaged<uint, SemaphoreParameterName, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSemaphoreParameterui64vEXT");
                _GetSemaphoreParameterui64vEXT_fnptr(semaphore, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint, BufferHandle*, uint, TextureHandle*, TextureLayout*, void> _WaitSemaphoreEXT_fnptr = &WaitSemaphoreEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, BufferHandle* buffers, uint numTextureBarriers, TextureHandle* textures, TextureLayout* srcLayouts) => _WaitSemaphoreEXT_fnptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
            [UnmanagedCallersOnly]
            private static void WaitSemaphoreEXT_Lazy(uint semaphore, uint numBufferBarriers, BufferHandle* buffers, uint numTextureBarriers, TextureHandle* textures, TextureLayout* srcLayouts)
            {
                _WaitSemaphoreEXT_fnptr = (delegate* unmanaged<uint, uint, BufferHandle*, uint, TextureHandle*, TextureLayout*, void>)GLLoader.BindingsContext.GetProcAddress("glWaitSemaphoreEXT");
                _WaitSemaphoreEXT_fnptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
            }
            
            private static delegate* unmanaged<uint, uint, BufferHandle*, uint, TextureHandle*, TextureLayout*, void> _SignalSemaphoreEXT_fnptr = &SignalSemaphoreEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, BufferHandle* buffers, uint numTextureBarriers, TextureHandle* textures, TextureLayout* dstLayouts) => _SignalSemaphoreEXT_fnptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
            [UnmanagedCallersOnly]
            private static void SignalSemaphoreEXT_Lazy(uint semaphore, uint numBufferBarriers, BufferHandle* buffers, uint numTextureBarriers, TextureHandle* textures, TextureLayout* dstLayouts)
            {
                _SignalSemaphoreEXT_fnptr = (delegate* unmanaged<uint, uint, BufferHandle*, uint, TextureHandle*, TextureLayout*, void>)GLLoader.BindingsContext.GetProcAddress("glSignalSemaphoreEXT");
                _SignalSemaphoreEXT_fnptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
            }
            
            private static delegate* unmanaged<uint, ExternalHandleType, int, void> _ImportSemaphoreFdEXT_fnptr = &ImportSemaphoreFdEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore_fd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportSemaphoreFdEXT(uint semaphore, ExternalHandleType handleType, int fd) => _ImportSemaphoreFdEXT_fnptr(semaphore, handleType, fd);
            [UnmanagedCallersOnly]
            private static void ImportSemaphoreFdEXT_Lazy(uint semaphore, ExternalHandleType handleType, int fd)
            {
                _ImportSemaphoreFdEXT_fnptr = (delegate* unmanaged<uint, ExternalHandleType, int, void>)GLLoader.BindingsContext.GetProcAddress("glImportSemaphoreFdEXT");
                _ImportSemaphoreFdEXT_fnptr(semaphore, handleType, fd);
            }
            
            private static delegate* unmanaged<uint, ExternalHandleType, void*, void> _ImportSemaphoreWin32HandleEXT_fnptr = &ImportSemaphoreWin32HandleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore_win32]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportSemaphoreWin32HandleEXT(uint semaphore, ExternalHandleType handleType, void* handle) => _ImportSemaphoreWin32HandleEXT_fnptr(semaphore, handleType, handle);
            [UnmanagedCallersOnly]
            private static void ImportSemaphoreWin32HandleEXT_Lazy(uint semaphore, ExternalHandleType handleType, void* handle)
            {
                _ImportSemaphoreWin32HandleEXT_fnptr = (delegate* unmanaged<uint, ExternalHandleType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glImportSemaphoreWin32HandleEXT");
                _ImportSemaphoreWin32HandleEXT_fnptr(semaphore, handleType, handle);
            }
            
            private static delegate* unmanaged<uint, ExternalHandleType, void*, void> _ImportSemaphoreWin32NameEXT_fnptr = &ImportSemaphoreWin32NameEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_semaphore_win32]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportSemaphoreWin32NameEXT(uint semaphore, ExternalHandleType handleType, void* name) => _ImportSemaphoreWin32NameEXT_fnptr(semaphore, handleType, name);
            [UnmanagedCallersOnly]
            private static void ImportSemaphoreWin32NameEXT_Lazy(uint semaphore, ExternalHandleType handleType, void* name)
            {
                _ImportSemaphoreWin32NameEXT_fnptr = (delegate* unmanaged<uint, ExternalHandleType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glImportSemaphoreWin32NameEXT");
                _ImportSemaphoreWin32NameEXT_fnptr(semaphore, handleType, name);
            }
            
            private static delegate* unmanaged<sbyte, sbyte, sbyte, void> _SecondaryColor3bEXT_fnptr = &SecondaryColor3bEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3bEXT(sbyte red, sbyte green, sbyte blue) => _SecondaryColor3bEXT_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3bEXT_Lazy(sbyte red, sbyte green, sbyte blue)
            {
                _SecondaryColor3bEXT_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3bEXT");
                _SecondaryColor3bEXT_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<sbyte*, void> _SecondaryColor3bvEXT_fnptr = &SecondaryColor3bvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3bvEXT(sbyte* v) => _SecondaryColor3bvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3bvEXT_Lazy(sbyte* v)
            {
                _SecondaryColor3bvEXT_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3bvEXT");
                _SecondaryColor3bvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<double, double, double, void> _SecondaryColor3dEXT_fnptr = &SecondaryColor3dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3dEXT(double red, double green, double blue) => _SecondaryColor3dEXT_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3dEXT_Lazy(double red, double green, double blue)
            {
                _SecondaryColor3dEXT_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3dEXT");
                _SecondaryColor3dEXT_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<double*, void> _SecondaryColor3dvEXT_fnptr = &SecondaryColor3dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3dvEXT(double* v) => _SecondaryColor3dvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3dvEXT_Lazy(double* v)
            {
                _SecondaryColor3dvEXT_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3dvEXT");
                _SecondaryColor3dvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<float, float, float, void> _SecondaryColor3fEXT_fnptr = &SecondaryColor3fEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3fEXT(float red, float green, float blue) => _SecondaryColor3fEXT_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3fEXT_Lazy(float red, float green, float blue)
            {
                _SecondaryColor3fEXT_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3fEXT");
                _SecondaryColor3fEXT_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<float*, void> _SecondaryColor3fvEXT_fnptr = &SecondaryColor3fvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3fvEXT(float* v) => _SecondaryColor3fvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3fvEXT_Lazy(float* v)
            {
                _SecondaryColor3fvEXT_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3fvEXT");
                _SecondaryColor3fvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<int, int, int, void> _SecondaryColor3iEXT_fnptr = &SecondaryColor3iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3iEXT(int red, int green, int blue) => _SecondaryColor3iEXT_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3iEXT_Lazy(int red, int green, int blue)
            {
                _SecondaryColor3iEXT_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3iEXT");
                _SecondaryColor3iEXT_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<int*, void> _SecondaryColor3ivEXT_fnptr = &SecondaryColor3ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3ivEXT(int* v) => _SecondaryColor3ivEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3ivEXT_Lazy(int* v)
            {
                _SecondaryColor3ivEXT_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3ivEXT");
                _SecondaryColor3ivEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<short, short, short, void> _SecondaryColor3sEXT_fnptr = &SecondaryColor3sEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3sEXT(short red, short green, short blue) => _SecondaryColor3sEXT_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3sEXT_Lazy(short red, short green, short blue)
            {
                _SecondaryColor3sEXT_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3sEXT");
                _SecondaryColor3sEXT_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<short*, void> _SecondaryColor3svEXT_fnptr = &SecondaryColor3svEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3svEXT(short* v) => _SecondaryColor3svEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3svEXT_Lazy(short* v)
            {
                _SecondaryColor3svEXT_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3svEXT");
                _SecondaryColor3svEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<byte, byte, byte, void> _SecondaryColor3ubEXT_fnptr = &SecondaryColor3ubEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3ubEXT(byte red, byte green, byte blue) => _SecondaryColor3ubEXT_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3ubEXT_Lazy(byte red, byte green, byte blue)
            {
                _SecondaryColor3ubEXT_fnptr = (delegate* unmanaged<byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3ubEXT");
                _SecondaryColor3ubEXT_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<byte*, void> _SecondaryColor3ubvEXT_fnptr = &SecondaryColor3ubvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3ubvEXT(byte* v) => _SecondaryColor3ubvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3ubvEXT_Lazy(byte* v)
            {
                _SecondaryColor3ubvEXT_fnptr = (delegate* unmanaged<byte*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3ubvEXT");
                _SecondaryColor3ubvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<uint, uint, uint, void> _SecondaryColor3uiEXT_fnptr = &SecondaryColor3uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3uiEXT(uint red, uint green, uint blue) => _SecondaryColor3uiEXT_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3uiEXT_Lazy(uint red, uint green, uint blue)
            {
                _SecondaryColor3uiEXT_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3uiEXT");
                _SecondaryColor3uiEXT_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<uint*, void> _SecondaryColor3uivEXT_fnptr = &SecondaryColor3uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3uivEXT(uint* v) => _SecondaryColor3uivEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3uivEXT_Lazy(uint* v)
            {
                _SecondaryColor3uivEXT_fnptr = (delegate* unmanaged<uint*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3uivEXT");
                _SecondaryColor3uivEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<ushort, ushort, ushort, void> _SecondaryColor3usEXT_fnptr = &SecondaryColor3usEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3usEXT(ushort red, ushort green, ushort blue) => _SecondaryColor3usEXT_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3usEXT_Lazy(ushort red, ushort green, ushort blue)
            {
                _SecondaryColor3usEXT_fnptr = (delegate* unmanaged<ushort, ushort, ushort, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3usEXT");
                _SecondaryColor3usEXT_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<ushort*, void> _SecondaryColor3usvEXT_fnptr = &SecondaryColor3usvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3usvEXT(ushort* v) => _SecondaryColor3usvEXT_fnptr(v);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3usvEXT_Lazy(ushort* v)
            {
                _SecondaryColor3usvEXT_fnptr = (delegate* unmanaged<ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3usvEXT");
                _SecondaryColor3usvEXT_fnptr(v);
            }
            
            private static delegate* unmanaged<int, ColorPointerType, int, void*, void> _SecondaryColorPointerEXT_fnptr = &SecondaryColorPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColorPointerEXT(int size, ColorPointerType type, int stride, void* pointer) => _SecondaryColorPointerEXT_fnptr(size, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void SecondaryColorPointerEXT_Lazy(int size, ColorPointerType type, int stride, void* pointer)
            {
                _SecondaryColorPointerEXT_fnptr = (delegate* unmanaged<int, ColorPointerType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColorPointerEXT");
                _SecondaryColorPointerEXT_fnptr(size, type, stride, pointer);
            }
            
            private static delegate* unmanaged<All, ProgramHandle, void> _UseShaderProgramEXT_fnptr = &UseShaderProgramEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UseShaderProgramEXT(All type, ProgramHandle program) => _UseShaderProgramEXT_fnptr(type, program);
            [UnmanagedCallersOnly]
            private static void UseShaderProgramEXT_Lazy(All type, ProgramHandle program)
            {
                _UseShaderProgramEXT_fnptr = (delegate* unmanaged<All, ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glUseShaderProgramEXT");
                _UseShaderProgramEXT_fnptr(type, program);
            }
            
            private static delegate* unmanaged<ProgramHandle, void> _ActiveProgramEXT_fnptr = &ActiveProgramEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveProgramEXT(ProgramHandle program) => _ActiveProgramEXT_fnptr(program);
            [UnmanagedCallersOnly]
            private static void ActiveProgramEXT_Lazy(ProgramHandle program)
            {
                _ActiveProgramEXT_fnptr = (delegate* unmanaged<ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glActiveProgramEXT");
                _ActiveProgramEXT_fnptr(program);
            }
            
            private static delegate* unmanaged<ShaderType, byte*, int> _CreateShaderProgramEXT_fnptr = &CreateShaderProgramEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ProgramHandle CreateShaderProgramEXT(ShaderType type, byte* str) => (ProgramHandle) _CreateShaderProgramEXT_fnptr(type, str);
            [UnmanagedCallersOnly]
            private static int CreateShaderProgramEXT_Lazy(ShaderType type, byte* str)
            {
                _CreateShaderProgramEXT_fnptr = (delegate* unmanaged<ShaderType, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glCreateShaderProgramEXT");
                return _CreateShaderProgramEXT_fnptr(type, str);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, ProgramHandle, void> _ActiveShaderProgramEXT_fnptr = &ActiveShaderProgramEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveShaderProgramEXT(ProgramPipelineHandle pipeline, ProgramHandle program) => _ActiveShaderProgramEXT_fnptr(pipeline, program);
            [UnmanagedCallersOnly]
            private static void ActiveShaderProgramEXT_Lazy(ProgramPipelineHandle pipeline, ProgramHandle program)
            {
                _ActiveShaderProgramEXT_fnptr = (delegate* unmanaged<ProgramPipelineHandle, ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glActiveShaderProgramEXT");
                _ActiveShaderProgramEXT_fnptr(pipeline, program);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, void> _BindProgramPipelineEXT_fnptr = &BindProgramPipelineEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindProgramPipelineEXT(ProgramPipelineHandle pipeline) => _BindProgramPipelineEXT_fnptr(pipeline);
            [UnmanagedCallersOnly]
            private static void BindProgramPipelineEXT_Lazy(ProgramPipelineHandle pipeline)
            {
                _BindProgramPipelineEXT_fnptr = (delegate* unmanaged<ProgramPipelineHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindProgramPipelineEXT");
                _BindProgramPipelineEXT_fnptr(pipeline);
            }
            
            private static delegate* unmanaged<ShaderType, int, byte**, int> _CreateShaderProgramvEXT_fnptr = &CreateShaderProgramvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ProgramHandle CreateShaderProgramvEXT(ShaderType type, int count, byte** strings) => (ProgramHandle) _CreateShaderProgramvEXT_fnptr(type, count, strings);
            [UnmanagedCallersOnly]
            private static int CreateShaderProgramvEXT_Lazy(ShaderType type, int count, byte** strings)
            {
                _CreateShaderProgramvEXT_fnptr = (delegate* unmanaged<ShaderType, int, byte**, int>)GLLoader.BindingsContext.GetProcAddress("glCreateShaderProgramvEXT");
                return _CreateShaderProgramvEXT_fnptr(type, count, strings);
            }
            
            private static delegate* unmanaged<int, ProgramPipelineHandle*, void> _DeleteProgramPipelinesEXT_fnptr = &DeleteProgramPipelinesEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteProgramPipelinesEXT(int n, ProgramPipelineHandle* pipelines) => _DeleteProgramPipelinesEXT_fnptr(n, pipelines);
            [UnmanagedCallersOnly]
            private static void DeleteProgramPipelinesEXT_Lazy(int n, ProgramPipelineHandle* pipelines)
            {
                _DeleteProgramPipelinesEXT_fnptr = (delegate* unmanaged<int, ProgramPipelineHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteProgramPipelinesEXT");
                _DeleteProgramPipelinesEXT_fnptr(n, pipelines);
            }
            
            private static delegate* unmanaged<int, ProgramPipelineHandle*, void> _GenProgramPipelinesEXT_fnptr = &GenProgramPipelinesEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenProgramPipelinesEXT(int n, ProgramPipelineHandle* pipelines) => _GenProgramPipelinesEXT_fnptr(n, pipelines);
            [UnmanagedCallersOnly]
            private static void GenProgramPipelinesEXT_Lazy(int n, ProgramPipelineHandle* pipelines)
            {
                _GenProgramPipelinesEXT_fnptr = (delegate* unmanaged<int, ProgramPipelineHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenProgramPipelinesEXT");
                _GenProgramPipelinesEXT_fnptr(n, pipelines);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, int, int*, byte*, void> _GetProgramPipelineInfoLogEXT_fnptr = &GetProgramPipelineInfoLogEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramPipelineInfoLogEXT(ProgramPipelineHandle pipeline, int bufSize, int* length, byte* infoLog) => _GetProgramPipelineInfoLogEXT_fnptr(pipeline, bufSize, length, infoLog);
            [UnmanagedCallersOnly]
            private static void GetProgramPipelineInfoLogEXT_Lazy(ProgramPipelineHandle pipeline, int bufSize, int* length, byte* infoLog)
            {
                _GetProgramPipelineInfoLogEXT_fnptr = (delegate* unmanaged<ProgramPipelineHandle, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramPipelineInfoLogEXT");
                _GetProgramPipelineInfoLogEXT_fnptr(pipeline, bufSize, length, infoLog);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, PipelineParameterName, int*, void> _GetProgramPipelineivEXT_fnptr = &GetProgramPipelineivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramPipelineivEXT(ProgramPipelineHandle pipeline, PipelineParameterName pname, int* parameters) => _GetProgramPipelineivEXT_fnptr(pipeline, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramPipelineivEXT_Lazy(ProgramPipelineHandle pipeline, PipelineParameterName pname, int* parameters)
            {
                _GetProgramPipelineivEXT_fnptr = (delegate* unmanaged<ProgramPipelineHandle, PipelineParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramPipelineivEXT");
                _GetProgramPipelineivEXT_fnptr(pipeline, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, byte> _IsProgramPipelineEXT_fnptr = &IsProgramPipelineEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsProgramPipelineEXT(ProgramPipelineHandle pipeline) => _IsProgramPipelineEXT_fnptr(pipeline);
            [UnmanagedCallersOnly]
            private static byte IsProgramPipelineEXT_Lazy(ProgramPipelineHandle pipeline)
            {
                _IsProgramPipelineEXT_fnptr = (delegate* unmanaged<ProgramPipelineHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsProgramPipelineEXT");
                return _IsProgramPipelineEXT_fnptr(pipeline);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, UseProgramStageMask, ProgramHandle, void> _UseProgramStagesEXT_fnptr = &UseProgramStagesEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UseProgramStagesEXT(ProgramPipelineHandle pipeline, UseProgramStageMask stages, ProgramHandle program) => _UseProgramStagesEXT_fnptr(pipeline, stages, program);
            [UnmanagedCallersOnly]
            private static void UseProgramStagesEXT_Lazy(ProgramPipelineHandle pipeline, UseProgramStageMask stages, ProgramHandle program)
            {
                _UseProgramStagesEXT_fnptr = (delegate* unmanaged<ProgramPipelineHandle, UseProgramStageMask, ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glUseProgramStagesEXT");
                _UseProgramStagesEXT_fnptr(pipeline, stages, program);
            }
            
            private static delegate* unmanaged<ProgramPipelineHandle, void> _ValidateProgramPipelineEXT_fnptr = &ValidateProgramPipelineEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ValidateProgramPipelineEXT(ProgramPipelineHandle pipeline) => _ValidateProgramPipelineEXT_fnptr(pipeline);
            [UnmanagedCallersOnly]
            private static void ValidateProgramPipelineEXT_Lazy(ProgramPipelineHandle pipeline)
            {
                _ValidateProgramPipelineEXT_fnptr = (delegate* unmanaged<ProgramPipelineHandle, void>)GLLoader.BindingsContext.GetProcAddress("glValidateProgramPipelineEXT");
                _ValidateProgramPipelineEXT_fnptr(pipeline);
            }
            
            private static delegate* unmanaged<void> _FramebufferFetchBarrierEXT_fnptr = &FramebufferFetchBarrierEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_shader_framebuffer_fetch_non_coherent]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferFetchBarrierEXT() => _FramebufferFetchBarrierEXT_fnptr();
            [UnmanagedCallersOnly]
            private static void FramebufferFetchBarrierEXT_Lazy()
            {
                _FramebufferFetchBarrierEXT_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferFetchBarrierEXT");
                _FramebufferFetchBarrierEXT_fnptr();
            }
            
            private static delegate* unmanaged<uint, TextureHandle, int, byte, int, BufferAccessARB, int, void> _BindImageTextureEXT_fnptr = &BindImageTextureEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindImageTextureEXT(uint index, TextureHandle texture, int level, byte layered, int layer, BufferAccessARB access, int format) => _BindImageTextureEXT_fnptr(index, texture, level, layered, layer, access, format);
            [UnmanagedCallersOnly]
            private static void BindImageTextureEXT_Lazy(uint index, TextureHandle texture, int level, byte layered, int layer, BufferAccessARB access, int format)
            {
                _BindImageTextureEXT_fnptr = (delegate* unmanaged<uint, TextureHandle, int, byte, int, BufferAccessARB, int, void>)GLLoader.BindingsContext.GetProcAddress("glBindImageTextureEXT");
                _BindImageTextureEXT_fnptr(index, texture, level, layered, layer, access, format);
            }
            
            private static delegate* unmanaged<MemoryBarrierMask, void> _MemoryBarrierEXT_fnptr = &MemoryBarrierEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MemoryBarrierEXT(MemoryBarrierMask barriers) => _MemoryBarrierEXT_fnptr(barriers);
            [UnmanagedCallersOnly]
            private static void MemoryBarrierEXT_Lazy(MemoryBarrierMask barriers)
            {
                _MemoryBarrierEXT_fnptr = (delegate* unmanaged<MemoryBarrierMask, void>)GLLoader.BindingsContext.GetProcAddress("glMemoryBarrierEXT");
                _MemoryBarrierEXT_fnptr(barriers);
            }
            
            private static delegate* unmanaged<int, uint, void> _StencilClearTagEXT_fnptr = &StencilClearTagEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_stencil_clear_tag]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilClearTagEXT(int stencilTagBits, uint stencilClearTag) => _StencilClearTagEXT_fnptr(stencilTagBits, stencilClearTag);
            [UnmanagedCallersOnly]
            private static void StencilClearTagEXT_Lazy(int stencilTagBits, uint stencilClearTag)
            {
                _StencilClearTagEXT_fnptr = (delegate* unmanaged<int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glStencilClearTagEXT");
                _StencilClearTagEXT_fnptr(stencilTagBits, stencilClearTag);
            }
            
            private static delegate* unmanaged<StencilFaceDirection, void> _ActiveStencilFaceEXT_fnptr = &ActiveStencilFaceEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_stencil_two_side]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveStencilFaceEXT(StencilFaceDirection face) => _ActiveStencilFaceEXT_fnptr(face);
            [UnmanagedCallersOnly]
            private static void ActiveStencilFaceEXT_Lazy(StencilFaceDirection face)
            {
                _ActiveStencilFaceEXT_fnptr = (delegate* unmanaged<StencilFaceDirection, void>)GLLoader.BindingsContext.GetProcAddress("glActiveStencilFaceEXT");
                _ActiveStencilFaceEXT_fnptr(face);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, PixelFormat, PixelType, void*, void> _TexSubImage1DEXT_fnptr = &TexSubImage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_subtexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexSubImage1DEXT(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => _TexSubImage1DEXT_fnptr(target, level, xoffset, width, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TexSubImage1DEXT_Lazy(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels)
            {
                _TexSubImage1DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexSubImage1DEXT");
                _TexSubImage1DEXT_fnptr(target, level, xoffset, width, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TexSubImage2DEXT_fnptr = &TexSubImage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_subtexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => _TexSubImage2DEXT_fnptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TexSubImage2DEXT_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels)
            {
                _TexSubImage2DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexSubImage2DEXT");
                _TexSubImage2DEXT_fnptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, PixelFormat, PixelType, void*, void> _TexImage3DEXT_fnptr = &TexImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture3D]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexImage3DEXT(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => _TexImage3DEXT_fnptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TexImage3DEXT_Lazy(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels)
            {
                _TexImage3DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage3DEXT");
                _TexImage3DEXT_fnptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TexSubImage3DEXT_fnptr = &TexSubImage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture3D]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => _TexSubImage3DEXT_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TexSubImage3DEXT_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels)
            {
                _TexSubImage3DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexSubImage3DEXT");
                _TexSubImage3DEXT_fnptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void> _FramebufferTextureLayerEXT_fnptr = &FramebufferTextureLayerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => _FramebufferTextureLayerEXT_fnptr(target, attachment, texture, level, layer);
            [UnmanagedCallersOnly]
            private static void FramebufferTextureLayerEXT_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer)
            {
                _FramebufferTextureLayerEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureLayerEXT");
                _FramebufferTextureLayerEXT_fnptr(target, attachment, texture, level, layer);
            }
            
            private static delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, void> _TexBufferEXT_fnptr = &TexBufferEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexBufferEXT(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer) => _TexBufferEXT_fnptr(target, internalformat, buffer);
            [UnmanagedCallersOnly]
            private static void TexBufferEXT_Lazy(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer)
            {
                _TexBufferEXT_fnptr = (delegate* unmanaged<TextureTarget, SizedInternalFormat, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTexBufferEXT");
                _TexBufferEXT_fnptr(target, internalformat, buffer);
            }
            
            private static delegate* unmanaged<TextureTarget, TextureParameterName, int*, void> _TexParameterIivEXT_fnptr = &TexParameterIivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, int* parameters) => _TexParameterIivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TexParameterIivEXT_Lazy(TextureTarget target, TextureParameterName pname, int* parameters)
            {
                _TexParameterIivEXT_fnptr = (delegate* unmanaged<TextureTarget, TextureParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameterIivEXT");
                _TexParameterIivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, TextureParameterName, uint*, void> _TexParameterIuivEXT_fnptr = &TexParameterIuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, uint* parameters) => _TexParameterIuivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TexParameterIuivEXT_Lazy(TextureTarget target, TextureParameterName pname, uint* parameters)
            {
                _TexParameterIuivEXT_fnptr = (delegate* unmanaged<TextureTarget, TextureParameterName, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameterIuivEXT");
                _TexParameterIuivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void> _GetTexParameterIivEXT_fnptr = &GetTexParameterIivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, int* parameters) => _GetTexParameterIivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTexParameterIivEXT_Lazy(TextureTarget target, GetTextureParameter pname, int* parameters)
            {
                _GetTexParameterIivEXT_fnptr = (delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexParameterIivEXT");
                _GetTexParameterIivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, GetTextureParameter, uint*, void> _GetTexParameterIuivEXT_fnptr = &GetTexParameterIuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, uint* parameters) => _GetTexParameterIuivEXT_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTexParameterIuivEXT_Lazy(TextureTarget target, GetTextureParameter pname, uint* parameters)
            {
                _GetTexParameterIuivEXT_fnptr = (delegate* unmanaged<TextureTarget, GetTextureParameter, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexParameterIuivEXT");
                _GetTexParameterIuivEXT_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _ClearColorIiEXT_fnptr = &ClearColorIiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearColorIiEXT(int red, int green, int blue, int alpha) => _ClearColorIiEXT_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void ClearColorIiEXT_Lazy(int red, int green, int blue, int alpha)
            {
                _ClearColorIiEXT_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glClearColorIiEXT");
                _ClearColorIiEXT_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<uint, uint, uint, uint, void> _ClearColorIuiEXT_fnptr = &ClearColorIuiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearColorIuiEXT(uint red, uint green, uint blue, uint alpha) => _ClearColorIuiEXT_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void ClearColorIuiEXT_Lazy(uint red, uint green, uint blue, uint alpha)
            {
                _ClearColorIuiEXT_fnptr = (delegate* unmanaged<uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glClearColorIuiEXT");
                _ClearColorIuiEXT_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<int, TextureHandle*, byte*, byte> _AreTexturesResidentEXT_fnptr = &AreTexturesResidentEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte AreTexturesResidentEXT(int n, TextureHandle* textures, byte* residences) => _AreTexturesResidentEXT_fnptr(n, textures, residences);
            [UnmanagedCallersOnly]
            private static byte AreTexturesResidentEXT_Lazy(int n, TextureHandle* textures, byte* residences)
            {
                _AreTexturesResidentEXT_fnptr = (delegate* unmanaged<int, TextureHandle*, byte*, byte>)GLLoader.BindingsContext.GetProcAddress("glAreTexturesResidentEXT");
                return _AreTexturesResidentEXT_fnptr(n, textures, residences);
            }
            
            private static delegate* unmanaged<TextureTarget, TextureHandle, void> _BindTextureEXT_fnptr = &BindTextureEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindTextureEXT(TextureTarget target, TextureHandle texture) => _BindTextureEXT_fnptr(target, texture);
            [UnmanagedCallersOnly]
            private static void BindTextureEXT_Lazy(TextureTarget target, TextureHandle texture)
            {
                _BindTextureEXT_fnptr = (delegate* unmanaged<TextureTarget, TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindTextureEXT");
                _BindTextureEXT_fnptr(target, texture);
            }
            
            private static delegate* unmanaged<int, TextureHandle*, void> _DeleteTexturesEXT_fnptr = &DeleteTexturesEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteTexturesEXT(int n, TextureHandle* textures) => _DeleteTexturesEXT_fnptr(n, textures);
            [UnmanagedCallersOnly]
            private static void DeleteTexturesEXT_Lazy(int n, TextureHandle* textures)
            {
                _DeleteTexturesEXT_fnptr = (delegate* unmanaged<int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteTexturesEXT");
                _DeleteTexturesEXT_fnptr(n, textures);
            }
            
            private static delegate* unmanaged<int, TextureHandle*, void> _GenTexturesEXT_fnptr = &GenTexturesEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenTexturesEXT(int n, TextureHandle* textures) => _GenTexturesEXT_fnptr(n, textures);
            [UnmanagedCallersOnly]
            private static void GenTexturesEXT_Lazy(int n, TextureHandle* textures)
            {
                _GenTexturesEXT_fnptr = (delegate* unmanaged<int, TextureHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenTexturesEXT");
                _GenTexturesEXT_fnptr(n, textures);
            }
            
            private static delegate* unmanaged<TextureHandle, byte> _IsTextureEXT_fnptr = &IsTextureEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsTextureEXT(TextureHandle texture) => _IsTextureEXT_fnptr(texture);
            [UnmanagedCallersOnly]
            private static byte IsTextureEXT_Lazy(TextureHandle texture)
            {
                _IsTextureEXT_fnptr = (delegate* unmanaged<TextureHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsTextureEXT");
                return _IsTextureEXT_fnptr(texture);
            }
            
            private static delegate* unmanaged<int, TextureHandle*, float*, void> _PrioritizeTexturesEXT_fnptr = &PrioritizeTexturesEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrioritizeTexturesEXT(int n, TextureHandle* textures, float* priorities) => _PrioritizeTexturesEXT_fnptr(n, textures, priorities);
            [UnmanagedCallersOnly]
            private static void PrioritizeTexturesEXT_Lazy(int n, TextureHandle* textures, float* priorities)
            {
                _PrioritizeTexturesEXT_fnptr = (delegate* unmanaged<int, TextureHandle*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPrioritizeTexturesEXT");
                _PrioritizeTexturesEXT_fnptr(n, textures, priorities);
            }
            
            private static delegate* unmanaged<TextureNormalModeEXT, void> _TextureNormalEXT_fnptr = &TextureNormalEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_perturb_normal]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureNormalEXT(TextureNormalModeEXT mode) => _TextureNormalEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void TextureNormalEXT_Lazy(TextureNormalModeEXT mode)
            {
                _TextureNormalEXT_fnptr = (delegate* unmanaged<TextureNormalModeEXT, void>)GLLoader.BindingsContext.GetProcAddress("glTextureNormalEXT");
                _TextureNormalEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, void> _TexStorage1DEXT_fnptr = &TexStorage1DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorage1DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => _TexStorage1DEXT_fnptr(target, levels, internalformat, width);
            [UnmanagedCallersOnly]
            private static void TexStorage1DEXT_Lazy(TextureTarget target, int levels, SizedInternalFormat internalformat, int width)
            {
                _TexStorage1DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage1DEXT");
                _TexStorage1DEXT_fnptr(target, levels, internalformat, width);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, void> _TexStorage2DEXT_fnptr = &TexStorage2DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorage2DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => _TexStorage2DEXT_fnptr(target, levels, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void TexStorage2DEXT_Lazy(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height)
            {
                _TexStorage2DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage2DEXT");
                _TexStorage2DEXT_fnptr(target, levels, internalformat, width, height);
            }
            
            private static delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, void> _TexStorage3DEXT_fnptr = &TexStorage3DEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorage3DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => _TexStorage3DEXT_fnptr(target, levels, internalformat, width, height, depth);
            [UnmanagedCallersOnly]
            private static void TexStorage3DEXT_Lazy(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth)
            {
                _TexStorage3DEXT_fnptr = (delegate* unmanaged<TextureTarget, int, SizedInternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexStorage3DEXT");
                _TexStorage3DEXT_fnptr(target, levels, internalformat, width, height, depth);
            }
            
            private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, long*, void> _GetQueryObjecti64vEXT_fnptr = &GetQueryObjecti64vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_timer_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryObjecti64vEXT(QueryHandle id, QueryObjectParameterName pname, long* parameters) => _GetQueryObjecti64vEXT_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetQueryObjecti64vEXT_Lazy(QueryHandle id, QueryObjectParameterName pname, long* parameters)
            {
                _GetQueryObjecti64vEXT_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjecti64vEXT");
                _GetQueryObjecti64vEXT_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<QueryHandle, QueryObjectParameterName, ulong*, void> _GetQueryObjectui64vEXT_fnptr = &GetQueryObjectui64vEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_timer_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryObjectui64vEXT(QueryHandle id, QueryObjectParameterName pname, ulong* parameters) => _GetQueryObjectui64vEXT_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetQueryObjectui64vEXT_Lazy(QueryHandle id, QueryObjectParameterName pname, ulong* parameters)
            {
                _GetQueryObjectui64vEXT_fnptr = (delegate* unmanaged<QueryHandle, QueryObjectParameterName, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetQueryObjectui64vEXT");
                _GetQueryObjectui64vEXT_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<PrimitiveType, void> _BeginTransformFeedbackEXT_fnptr = &BeginTransformFeedbackEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginTransformFeedbackEXT(PrimitiveType primitiveMode) => _BeginTransformFeedbackEXT_fnptr(primitiveMode);
            [UnmanagedCallersOnly]
            private static void BeginTransformFeedbackEXT_Lazy(PrimitiveType primitiveMode)
            {
                _BeginTransformFeedbackEXT_fnptr = (delegate* unmanaged<PrimitiveType, void>)GLLoader.BindingsContext.GetProcAddress("glBeginTransformFeedbackEXT");
                _BeginTransformFeedbackEXT_fnptr(primitiveMode);
            }
            
            private static delegate* unmanaged<void> _EndTransformFeedbackEXT_fnptr = &EndTransformFeedbackEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndTransformFeedbackEXT() => _EndTransformFeedbackEXT_fnptr();
            [UnmanagedCallersOnly]
            private static void EndTransformFeedbackEXT_Lazy()
            {
                _EndTransformFeedbackEXT_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndTransformFeedbackEXT");
                _EndTransformFeedbackEXT_fnptr();
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, nint, void> _BindBufferRangeEXT_fnptr = &BindBufferRangeEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferRangeEXT(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size) => _BindBufferRangeEXT_fnptr(target, index, buffer, offset, size);
            [UnmanagedCallersOnly]
            private static void BindBufferRangeEXT_Lazy(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size)
            {
                _BindBufferRangeEXT_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferRangeEXT");
                _BindBufferRangeEXT_fnptr(target, index, buffer, offset, size);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, void> _BindBufferOffsetEXT_fnptr = &BindBufferOffsetEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferOffsetEXT(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset) => _BindBufferOffsetEXT_fnptr(target, index, buffer, offset);
            [UnmanagedCallersOnly]
            private static void BindBufferOffsetEXT_Lazy(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset)
            {
                _BindBufferOffsetEXT_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferOffsetEXT");
                _BindBufferOffsetEXT_fnptr(target, index, buffer, offset);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, void> _BindBufferBaseEXT_fnptr = &BindBufferBaseEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferBaseEXT(BufferTargetARB target, uint index, BufferHandle buffer) => _BindBufferBaseEXT_fnptr(target, index, buffer);
            [UnmanagedCallersOnly]
            private static void BindBufferBaseEXT_Lazy(BufferTargetARB target, uint index, BufferHandle buffer)
            {
                _BindBufferBaseEXT_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferBaseEXT");
                _BindBufferBaseEXT_fnptr(target, index, buffer);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, byte**, All, void> _TransformFeedbackVaryingsEXT_fnptr = &TransformFeedbackVaryingsEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformFeedbackVaryingsEXT(ProgramHandle program, int count, byte** varyings, All bufferMode) => _TransformFeedbackVaryingsEXT_fnptr(program, count, varyings, bufferMode);
            [UnmanagedCallersOnly]
            private static void TransformFeedbackVaryingsEXT_Lazy(ProgramHandle program, int count, byte** varyings, All bufferMode)
            {
                _TransformFeedbackVaryingsEXT_fnptr = (delegate* unmanaged<ProgramHandle, int, byte**, All, void>)GLLoader.BindingsContext.GetProcAddress("glTransformFeedbackVaryingsEXT");
                _TransformFeedbackVaryingsEXT_fnptr(program, count, varyings, bufferMode);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, int, int*, int*, AttributeType*, byte*, void> _GetTransformFeedbackVaryingEXT_fnptr = &GetTransformFeedbackVaryingEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTransformFeedbackVaryingEXT(ProgramHandle program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => _GetTransformFeedbackVaryingEXT_fnptr(program, index, bufSize, length, size, type, name);
            [UnmanagedCallersOnly]
            private static void GetTransformFeedbackVaryingEXT_Lazy(ProgramHandle program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name)
            {
                _GetTransformFeedbackVaryingEXT_fnptr = (delegate* unmanaged<ProgramHandle, uint, int, int*, int*, AttributeType*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTransformFeedbackVaryingEXT");
                _GetTransformFeedbackVaryingEXT_fnptr(program, index, bufSize, length, size, type, name);
            }
            
            private static delegate* unmanaged<int, void> _ArrayElementEXT_fnptr = &ArrayElementEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ArrayElementEXT(int i) => _ArrayElementEXT_fnptr(i);
            [UnmanagedCallersOnly]
            private static void ArrayElementEXT_Lazy(int i)
            {
                _ArrayElementEXT_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glArrayElementEXT");
                _ArrayElementEXT_fnptr(i);
            }
            
            private static delegate* unmanaged<int, ColorPointerType, int, int, void*, void> _ColorPointerEXT_fnptr = &ColorPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorPointerEXT(int size, ColorPointerType type, int stride, int count, void* pointer) => _ColorPointerEXT_fnptr(size, type, stride, count, pointer);
            [UnmanagedCallersOnly]
            private static void ColorPointerEXT_Lazy(int size, ColorPointerType type, int stride, int count, void* pointer)
            {
                _ColorPointerEXT_fnptr = (delegate* unmanaged<int, ColorPointerType, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glColorPointerEXT");
                _ColorPointerEXT_fnptr(size, type, stride, count, pointer);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, int, void> _DrawArraysEXT_fnptr = &DrawArraysEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawArraysEXT(PrimitiveType mode, int first, int count) => _DrawArraysEXT_fnptr(mode, first, count);
            [UnmanagedCallersOnly]
            private static void DrawArraysEXT_Lazy(PrimitiveType mode, int first, int count)
            {
                _DrawArraysEXT_fnptr = (delegate* unmanaged<PrimitiveType, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawArraysEXT");
                _DrawArraysEXT_fnptr(mode, first, count);
            }
            
            private static delegate* unmanaged<int, int, byte*, void> _EdgeFlagPointerEXT_fnptr = &EdgeFlagPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EdgeFlagPointerEXT(int stride, int count, byte* pointer) => _EdgeFlagPointerEXT_fnptr(stride, count, pointer);
            [UnmanagedCallersOnly]
            private static void EdgeFlagPointerEXT_Lazy(int stride, int count, byte* pointer)
            {
                _EdgeFlagPointerEXT_fnptr = (delegate* unmanaged<int, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glEdgeFlagPointerEXT");
                _EdgeFlagPointerEXT_fnptr(stride, count, pointer);
            }
            
            private static delegate* unmanaged<GetPointervPName, void**, void> _GetPointervEXT_fnptr = &GetPointervEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPointervEXT(GetPointervPName pname, void** parameters) => _GetPointervEXT_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetPointervEXT_Lazy(GetPointervPName pname, void** parameters)
            {
                _GetPointervEXT_fnptr = (delegate* unmanaged<GetPointervPName, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetPointervEXT");
                _GetPointervEXT_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<IndexPointerType, int, int, void*, void> _IndexPointerEXT_fnptr = &IndexPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexPointerEXT(IndexPointerType type, int stride, int count, void* pointer) => _IndexPointerEXT_fnptr(type, stride, count, pointer);
            [UnmanagedCallersOnly]
            private static void IndexPointerEXT_Lazy(IndexPointerType type, int stride, int count, void* pointer)
            {
                _IndexPointerEXT_fnptr = (delegate* unmanaged<IndexPointerType, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glIndexPointerEXT");
                _IndexPointerEXT_fnptr(type, stride, count, pointer);
            }
            
            private static delegate* unmanaged<NormalPointerType, int, int, void*, void> _NormalPointerEXT_fnptr = &NormalPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalPointerEXT(NormalPointerType type, int stride, int count, void* pointer) => _NormalPointerEXT_fnptr(type, stride, count, pointer);
            [UnmanagedCallersOnly]
            private static void NormalPointerEXT_Lazy(NormalPointerType type, int stride, int count, void* pointer)
            {
                _NormalPointerEXT_fnptr = (delegate* unmanaged<NormalPointerType, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glNormalPointerEXT");
                _NormalPointerEXT_fnptr(type, stride, count, pointer);
            }
            
            private static delegate* unmanaged<int, TexCoordPointerType, int, int, void*, void> _TexCoordPointerEXT_fnptr = &TexCoordPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordPointerEXT(int size, TexCoordPointerType type, int stride, int count, void* pointer) => _TexCoordPointerEXT_fnptr(size, type, stride, count, pointer);
            [UnmanagedCallersOnly]
            private static void TexCoordPointerEXT_Lazy(int size, TexCoordPointerType type, int stride, int count, void* pointer)
            {
                _TexCoordPointerEXT_fnptr = (delegate* unmanaged<int, TexCoordPointerType, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordPointerEXT");
                _TexCoordPointerEXT_fnptr(size, type, stride, count, pointer);
            }
            
            private static delegate* unmanaged<int, VertexPointerType, int, int, void*, void> _VertexPointerEXT_fnptr = &VertexPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexPointerEXT(int size, VertexPointerType type, int stride, int count, void* pointer) => _VertexPointerEXT_fnptr(size, type, stride, count, pointer);
            [UnmanagedCallersOnly]
            private static void VertexPointerEXT_Lazy(int size, VertexPointerType type, int stride, int count, void* pointer)
            {
                _VertexPointerEXT_fnptr = (delegate* unmanaged<int, VertexPointerType, int, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexPointerEXT");
                _VertexPointerEXT_fnptr(size, type, stride, count, pointer);
            }
            
            private static delegate* unmanaged<uint, double, void> _VertexAttribL1dEXT_fnptr = &VertexAttribL1dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1dEXT(uint index, double x) => _VertexAttribL1dEXT_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1dEXT_Lazy(uint index, double x)
            {
                _VertexAttribL1dEXT_fnptr = (delegate* unmanaged<uint, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1dEXT");
                _VertexAttribL1dEXT_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, double, double, void> _VertexAttribL2dEXT_fnptr = &VertexAttribL2dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2dEXT(uint index, double x, double y) => _VertexAttribL2dEXT_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttribL2dEXT_Lazy(uint index, double x, double y)
            {
                _VertexAttribL2dEXT_fnptr = (delegate* unmanaged<uint, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2dEXT");
                _VertexAttribL2dEXT_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, double, double, double, void> _VertexAttribL3dEXT_fnptr = &VertexAttribL3dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3dEXT(uint index, double x, double y, double z) => _VertexAttribL3dEXT_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttribL3dEXT_Lazy(uint index, double x, double y, double z)
            {
                _VertexAttribL3dEXT_fnptr = (delegate* unmanaged<uint, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3dEXT");
                _VertexAttribL3dEXT_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, double, double, double, double, void> _VertexAttribL4dEXT_fnptr = &VertexAttribL4dEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4dEXT(uint index, double x, double y, double z, double w) => _VertexAttribL4dEXT_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttribL4dEXT_Lazy(uint index, double x, double y, double z, double w)
            {
                _VertexAttribL4dEXT_fnptr = (delegate* unmanaged<uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4dEXT");
                _VertexAttribL4dEXT_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttribL1dvEXT_fnptr = &VertexAttribL1dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1dvEXT(uint index, double* v) => _VertexAttribL1dvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1dvEXT_Lazy(uint index, double* v)
            {
                _VertexAttribL1dvEXT_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1dvEXT");
                _VertexAttribL1dvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttribL2dvEXT_fnptr = &VertexAttribL2dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2dvEXT(uint index, double* v) => _VertexAttribL2dvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL2dvEXT_Lazy(uint index, double* v)
            {
                _VertexAttribL2dvEXT_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2dvEXT");
                _VertexAttribL2dvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttribL3dvEXT_fnptr = &VertexAttribL3dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3dvEXT(uint index, double* v) => _VertexAttribL3dvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL3dvEXT_Lazy(uint index, double* v)
            {
                _VertexAttribL3dvEXT_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3dvEXT");
                _VertexAttribL3dvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttribL4dvEXT_fnptr = &VertexAttribL4dvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4dvEXT(uint index, double* v) => _VertexAttribL4dvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL4dvEXT_Lazy(uint index, double* v)
            {
                _VertexAttribL4dvEXT_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4dvEXT");
                _VertexAttribL4dvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribLType, int, void*, void> _VertexAttribLPointerEXT_fnptr = &VertexAttribLPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribLPointerEXT(uint index, int size, VertexAttribLType type, int stride, void* pointer) => _VertexAttribLPointerEXT_fnptr(index, size, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void VertexAttribLPointerEXT_Lazy(uint index, int size, VertexAttribLType type, int stride, void* pointer)
            {
                _VertexAttribLPointerEXT_fnptr = (delegate* unmanaged<uint, int, VertexAttribLType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribLPointerEXT");
                _VertexAttribLPointerEXT_fnptr(index, size, type, stride, pointer);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnum, double*, void> _GetVertexAttribLdvEXT_fnptr = &GetVertexAttribLdvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, double* parameters) => _GetVertexAttribLdvEXT_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribLdvEXT_Lazy(uint index, VertexAttribEnum pname, double* parameters)
            {
                _GetVertexAttribLdvEXT_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribLdvEXT");
                _GetVertexAttribLdvEXT_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<void> _BeginVertexShaderEXT_fnptr = &BeginVertexShaderEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginVertexShaderEXT() => _BeginVertexShaderEXT_fnptr();
            [UnmanagedCallersOnly]
            private static void BeginVertexShaderEXT_Lazy()
            {
                _BeginVertexShaderEXT_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glBeginVertexShaderEXT");
                _BeginVertexShaderEXT_fnptr();
            }
            
            private static delegate* unmanaged<void> _EndVertexShaderEXT_fnptr = &EndVertexShaderEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndVertexShaderEXT() => _EndVertexShaderEXT_fnptr();
            [UnmanagedCallersOnly]
            private static void EndVertexShaderEXT_Lazy()
            {
                _EndVertexShaderEXT_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndVertexShaderEXT");
                _EndVertexShaderEXT_fnptr();
            }
            
            private static delegate* unmanaged<uint, void> _BindVertexShaderEXT_fnptr = &BindVertexShaderEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindVertexShaderEXT(uint id) => _BindVertexShaderEXT_fnptr(id);
            [UnmanagedCallersOnly]
            private static void BindVertexShaderEXT_Lazy(uint id)
            {
                _BindVertexShaderEXT_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glBindVertexShaderEXT");
                _BindVertexShaderEXT_fnptr(id);
            }
            
            private static delegate* unmanaged<uint, uint> _GenVertexShadersEXT_fnptr = &GenVertexShadersEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenVertexShadersEXT(uint range) => _GenVertexShadersEXT_fnptr(range);
            [UnmanagedCallersOnly]
            private static uint GenVertexShadersEXT_Lazy(uint range)
            {
                _GenVertexShadersEXT_fnptr = (delegate* unmanaged<uint, uint>)GLLoader.BindingsContext.GetProcAddress("glGenVertexShadersEXT");
                return _GenVertexShadersEXT_fnptr(range);
            }
            
            private static delegate* unmanaged<uint, void> _DeleteVertexShaderEXT_fnptr = &DeleteVertexShaderEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteVertexShaderEXT(uint id) => _DeleteVertexShaderEXT_fnptr(id);
            [UnmanagedCallersOnly]
            private static void DeleteVertexShaderEXT_Lazy(uint id)
            {
                _DeleteVertexShaderEXT_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteVertexShaderEXT");
                _DeleteVertexShaderEXT_fnptr(id);
            }
            
            private static delegate* unmanaged<VertexShaderOpEXT, uint, uint, void> _ShaderOp1EXT_fnptr = &ShaderOp1EXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShaderOp1EXT(VertexShaderOpEXT op, uint res, uint arg1) => _ShaderOp1EXT_fnptr(op, res, arg1);
            [UnmanagedCallersOnly]
            private static void ShaderOp1EXT_Lazy(VertexShaderOpEXT op, uint res, uint arg1)
            {
                _ShaderOp1EXT_fnptr = (delegate* unmanaged<VertexShaderOpEXT, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glShaderOp1EXT");
                _ShaderOp1EXT_fnptr(op, res, arg1);
            }
            
            private static delegate* unmanaged<VertexShaderOpEXT, uint, uint, uint, void> _ShaderOp2EXT_fnptr = &ShaderOp2EXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShaderOp2EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2) => _ShaderOp2EXT_fnptr(op, res, arg1, arg2);
            [UnmanagedCallersOnly]
            private static void ShaderOp2EXT_Lazy(VertexShaderOpEXT op, uint res, uint arg1, uint arg2)
            {
                _ShaderOp2EXT_fnptr = (delegate* unmanaged<VertexShaderOpEXT, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glShaderOp2EXT");
                _ShaderOp2EXT_fnptr(op, res, arg1, arg2);
            }
            
            private static delegate* unmanaged<VertexShaderOpEXT, uint, uint, uint, uint, void> _ShaderOp3EXT_fnptr = &ShaderOp3EXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShaderOp3EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2, uint arg3) => _ShaderOp3EXT_fnptr(op, res, arg1, arg2, arg3);
            [UnmanagedCallersOnly]
            private static void ShaderOp3EXT_Lazy(VertexShaderOpEXT op, uint res, uint arg1, uint arg2, uint arg3)
            {
                _ShaderOp3EXT_fnptr = (delegate* unmanaged<VertexShaderOpEXT, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glShaderOp3EXT");
                _ShaderOp3EXT_fnptr(op, res, arg1, arg2, arg3);
            }
            
            private static delegate* unmanaged<uint, uint, VertexShaderCoordOutEXT, VertexShaderCoordOutEXT, VertexShaderCoordOutEXT, VertexShaderCoordOutEXT, void> _SwizzleEXT_fnptr = &SwizzleEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SwizzleEXT(uint res, uint input, VertexShaderCoordOutEXT outX, VertexShaderCoordOutEXT outY, VertexShaderCoordOutEXT outZ, VertexShaderCoordOutEXT outW) => _SwizzleEXT_fnptr(res, input, outX, outY, outZ, outW);
            [UnmanagedCallersOnly]
            private static void SwizzleEXT_Lazy(uint res, uint input, VertexShaderCoordOutEXT outX, VertexShaderCoordOutEXT outY, VertexShaderCoordOutEXT outZ, VertexShaderCoordOutEXT outW)
            {
                _SwizzleEXT_fnptr = (delegate* unmanaged<uint, uint, VertexShaderCoordOutEXT, VertexShaderCoordOutEXT, VertexShaderCoordOutEXT, VertexShaderCoordOutEXT, void>)GLLoader.BindingsContext.GetProcAddress("glSwizzleEXT");
                _SwizzleEXT_fnptr(res, input, outX, outY, outZ, outW);
            }
            
            private static delegate* unmanaged<uint, uint, VertexShaderWriteMaskEXT, VertexShaderWriteMaskEXT, VertexShaderWriteMaskEXT, VertexShaderWriteMaskEXT, void> _WriteMaskEXT_fnptr = &WriteMaskEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WriteMaskEXT(uint res, uint input, VertexShaderWriteMaskEXT outX, VertexShaderWriteMaskEXT outY, VertexShaderWriteMaskEXT outZ, VertexShaderWriteMaskEXT outW) => _WriteMaskEXT_fnptr(res, input, outX, outY, outZ, outW);
            [UnmanagedCallersOnly]
            private static void WriteMaskEXT_Lazy(uint res, uint input, VertexShaderWriteMaskEXT outX, VertexShaderWriteMaskEXT outY, VertexShaderWriteMaskEXT outZ, VertexShaderWriteMaskEXT outW)
            {
                _WriteMaskEXT_fnptr = (delegate* unmanaged<uint, uint, VertexShaderWriteMaskEXT, VertexShaderWriteMaskEXT, VertexShaderWriteMaskEXT, VertexShaderWriteMaskEXT, void>)GLLoader.BindingsContext.GetProcAddress("glWriteMaskEXT");
                _WriteMaskEXT_fnptr(res, input, outX, outY, outZ, outW);
            }
            
            private static delegate* unmanaged<uint, uint, uint, void> _InsertComponentEXT_fnptr = &InsertComponentEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void InsertComponentEXT(uint res, uint src, uint num) => _InsertComponentEXT_fnptr(res, src, num);
            [UnmanagedCallersOnly]
            private static void InsertComponentEXT_Lazy(uint res, uint src, uint num)
            {
                _InsertComponentEXT_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glInsertComponentEXT");
                _InsertComponentEXT_fnptr(res, src, num);
            }
            
            private static delegate* unmanaged<uint, uint, uint, void> _ExtractComponentEXT_fnptr = &ExtractComponentEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ExtractComponentEXT(uint res, uint src, uint num) => _ExtractComponentEXT_fnptr(res, src, num);
            [UnmanagedCallersOnly]
            private static void ExtractComponentEXT_Lazy(uint res, uint src, uint num)
            {
                _ExtractComponentEXT_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glExtractComponentEXT");
                _ExtractComponentEXT_fnptr(res, src, num);
            }
            
            private static delegate* unmanaged<DataTypeEXT, VertexShaderStorageTypeEXT, ParameterRangeEXT, uint, uint> _GenSymbolsEXT_fnptr = &GenSymbolsEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenSymbolsEXT(DataTypeEXT datatype, VertexShaderStorageTypeEXT storagetype, ParameterRangeEXT range, uint components) => _GenSymbolsEXT_fnptr(datatype, storagetype, range, components);
            [UnmanagedCallersOnly]
            private static uint GenSymbolsEXT_Lazy(DataTypeEXT datatype, VertexShaderStorageTypeEXT storagetype, ParameterRangeEXT range, uint components)
            {
                _GenSymbolsEXT_fnptr = (delegate* unmanaged<DataTypeEXT, VertexShaderStorageTypeEXT, ParameterRangeEXT, uint, uint>)GLLoader.BindingsContext.GetProcAddress("glGenSymbolsEXT");
                return _GenSymbolsEXT_fnptr(datatype, storagetype, range, components);
            }
            
            private static delegate* unmanaged<uint, ScalarType, void*, void> _SetInvariantEXT_fnptr = &SetInvariantEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetInvariantEXT(uint id, ScalarType type, void* addr) => _SetInvariantEXT_fnptr(id, type, addr);
            [UnmanagedCallersOnly]
            private static void SetInvariantEXT_Lazy(uint id, ScalarType type, void* addr)
            {
                _SetInvariantEXT_fnptr = (delegate* unmanaged<uint, ScalarType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glSetInvariantEXT");
                _SetInvariantEXT_fnptr(id, type, addr);
            }
            
            private static delegate* unmanaged<uint, ScalarType, void*, void> _SetLocalConstantEXT_fnptr = &SetLocalConstantEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetLocalConstantEXT(uint id, ScalarType type, void* addr) => _SetLocalConstantEXT_fnptr(id, type, addr);
            [UnmanagedCallersOnly]
            private static void SetLocalConstantEXT_Lazy(uint id, ScalarType type, void* addr)
            {
                _SetLocalConstantEXT_fnptr = (delegate* unmanaged<uint, ScalarType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glSetLocalConstantEXT");
                _SetLocalConstantEXT_fnptr(id, type, addr);
            }
            
            private static delegate* unmanaged<uint, sbyte*, void> _VariantbvEXT_fnptr = &VariantbvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantbvEXT(uint id, sbyte* addr) => _VariantbvEXT_fnptr(id, addr);
            [UnmanagedCallersOnly]
            private static void VariantbvEXT_Lazy(uint id, sbyte* addr)
            {
                _VariantbvEXT_fnptr = (delegate* unmanaged<uint, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVariantbvEXT");
                _VariantbvEXT_fnptr(id, addr);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VariantsvEXT_fnptr = &VariantsvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantsvEXT(uint id, short* addr) => _VariantsvEXT_fnptr(id, addr);
            [UnmanagedCallersOnly]
            private static void VariantsvEXT_Lazy(uint id, short* addr)
            {
                _VariantsvEXT_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVariantsvEXT");
                _VariantsvEXT_fnptr(id, addr);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VariantivEXT_fnptr = &VariantivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantivEXT(uint id, int* addr) => _VariantivEXT_fnptr(id, addr);
            [UnmanagedCallersOnly]
            private static void VariantivEXT_Lazy(uint id, int* addr)
            {
                _VariantivEXT_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVariantivEXT");
                _VariantivEXT_fnptr(id, addr);
            }
            
            private static delegate* unmanaged<uint, float*, void> _VariantfvEXT_fnptr = &VariantfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantfvEXT(uint id, float* addr) => _VariantfvEXT_fnptr(id, addr);
            [UnmanagedCallersOnly]
            private static void VariantfvEXT_Lazy(uint id, float* addr)
            {
                _VariantfvEXT_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVariantfvEXT");
                _VariantfvEXT_fnptr(id, addr);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VariantdvEXT_fnptr = &VariantdvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantdvEXT(uint id, double* addr) => _VariantdvEXT_fnptr(id, addr);
            [UnmanagedCallersOnly]
            private static void VariantdvEXT_Lazy(uint id, double* addr)
            {
                _VariantdvEXT_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVariantdvEXT");
                _VariantdvEXT_fnptr(id, addr);
            }
            
            private static delegate* unmanaged<uint, byte*, void> _VariantubvEXT_fnptr = &VariantubvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantubvEXT(uint id, byte* addr) => _VariantubvEXT_fnptr(id, addr);
            [UnmanagedCallersOnly]
            private static void VariantubvEXT_Lazy(uint id, byte* addr)
            {
                _VariantubvEXT_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVariantubvEXT");
                _VariantubvEXT_fnptr(id, addr);
            }
            
            private static delegate* unmanaged<uint, ushort*, void> _VariantusvEXT_fnptr = &VariantusvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantusvEXT(uint id, ushort* addr) => _VariantusvEXT_fnptr(id, addr);
            [UnmanagedCallersOnly]
            private static void VariantusvEXT_Lazy(uint id, ushort* addr)
            {
                _VariantusvEXT_fnptr = (delegate* unmanaged<uint, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glVariantusvEXT");
                _VariantusvEXT_fnptr(id, addr);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VariantuivEXT_fnptr = &VariantuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantuivEXT(uint id, uint* addr) => _VariantuivEXT_fnptr(id, addr);
            [UnmanagedCallersOnly]
            private static void VariantuivEXT_Lazy(uint id, uint* addr)
            {
                _VariantuivEXT_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVariantuivEXT");
                _VariantuivEXT_fnptr(id, addr);
            }
            
            private static delegate* unmanaged<uint, ScalarType, uint, void*, void> _VariantPointerEXT_fnptr = &VariantPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantPointerEXT(uint id, ScalarType type, uint stride, void* addr) => _VariantPointerEXT_fnptr(id, type, stride, addr);
            [UnmanagedCallersOnly]
            private static void VariantPointerEXT_Lazy(uint id, ScalarType type, uint stride, void* addr)
            {
                _VariantPointerEXT_fnptr = (delegate* unmanaged<uint, ScalarType, uint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVariantPointerEXT");
                _VariantPointerEXT_fnptr(id, type, stride, addr);
            }
            
            private static delegate* unmanaged<uint, void> _EnableVariantClientStateEXT_fnptr = &EnableVariantClientStateEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVariantClientStateEXT(uint id) => _EnableVariantClientStateEXT_fnptr(id);
            [UnmanagedCallersOnly]
            private static void EnableVariantClientStateEXT_Lazy(uint id)
            {
                _EnableVariantClientStateEXT_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glEnableVariantClientStateEXT");
                _EnableVariantClientStateEXT_fnptr(id);
            }
            
            private static delegate* unmanaged<uint, void> _DisableVariantClientStateEXT_fnptr = &DisableVariantClientStateEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVariantClientStateEXT(uint id) => _DisableVariantClientStateEXT_fnptr(id);
            [UnmanagedCallersOnly]
            private static void DisableVariantClientStateEXT_Lazy(uint id)
            {
                _DisableVariantClientStateEXT_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glDisableVariantClientStateEXT");
                _DisableVariantClientStateEXT_fnptr(id);
            }
            
            private static delegate* unmanaged<LightName, LightParameter, uint> _BindLightParameterEXT_fnptr = &BindLightParameterEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindLightParameterEXT(LightName light, LightParameter value) => _BindLightParameterEXT_fnptr(light, value);
            [UnmanagedCallersOnly]
            private static uint BindLightParameterEXT_Lazy(LightName light, LightParameter value)
            {
                _BindLightParameterEXT_fnptr = (delegate* unmanaged<LightName, LightParameter, uint>)GLLoader.BindingsContext.GetProcAddress("glBindLightParameterEXT");
                return _BindLightParameterEXT_fnptr(light, value);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, uint> _BindMaterialParameterEXT_fnptr = &BindMaterialParameterEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindMaterialParameterEXT(MaterialFace face, MaterialParameter value) => _BindMaterialParameterEXT_fnptr(face, value);
            [UnmanagedCallersOnly]
            private static uint BindMaterialParameterEXT_Lazy(MaterialFace face, MaterialParameter value)
            {
                _BindMaterialParameterEXT_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, uint>)GLLoader.BindingsContext.GetProcAddress("glBindMaterialParameterEXT");
                return _BindMaterialParameterEXT_fnptr(face, value);
            }
            
            private static delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, uint> _BindTexGenParameterEXT_fnptr = &BindTexGenParameterEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindTexGenParameterEXT(TextureUnit unit, TextureCoordName coord, TextureGenParameter value) => _BindTexGenParameterEXT_fnptr(unit, coord, value);
            [UnmanagedCallersOnly]
            private static uint BindTexGenParameterEXT_Lazy(TextureUnit unit, TextureCoordName coord, TextureGenParameter value)
            {
                _BindTexGenParameterEXT_fnptr = (delegate* unmanaged<TextureUnit, TextureCoordName, TextureGenParameter, uint>)GLLoader.BindingsContext.GetProcAddress("glBindTexGenParameterEXT");
                return _BindTexGenParameterEXT_fnptr(unit, coord, value);
            }
            
            private static delegate* unmanaged<TextureUnit, VertexShaderTextureUnitParameter, uint> _BindTextureUnitParameterEXT_fnptr = &BindTextureUnitParameterEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindTextureUnitParameterEXT(TextureUnit unit, VertexShaderTextureUnitParameter value) => _BindTextureUnitParameterEXT_fnptr(unit, value);
            [UnmanagedCallersOnly]
            private static uint BindTextureUnitParameterEXT_Lazy(TextureUnit unit, VertexShaderTextureUnitParameter value)
            {
                _BindTextureUnitParameterEXT_fnptr = (delegate* unmanaged<TextureUnit, VertexShaderTextureUnitParameter, uint>)GLLoader.BindingsContext.GetProcAddress("glBindTextureUnitParameterEXT");
                return _BindTextureUnitParameterEXT_fnptr(unit, value);
            }
            
            private static delegate* unmanaged<VertexShaderParameterEXT, uint> _BindParameterEXT_fnptr = &BindParameterEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindParameterEXT(VertexShaderParameterEXT value) => _BindParameterEXT_fnptr(value);
            [UnmanagedCallersOnly]
            private static uint BindParameterEXT_Lazy(VertexShaderParameterEXT value)
            {
                _BindParameterEXT_fnptr = (delegate* unmanaged<VertexShaderParameterEXT, uint>)GLLoader.BindingsContext.GetProcAddress("glBindParameterEXT");
                return _BindParameterEXT_fnptr(value);
            }
            
            private static delegate* unmanaged<uint, VariantCapEXT, byte> _IsVariantEnabledEXT_fnptr = &IsVariantEnabledEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsVariantEnabledEXT(uint id, VariantCapEXT cap) => _IsVariantEnabledEXT_fnptr(id, cap);
            [UnmanagedCallersOnly]
            private static byte IsVariantEnabledEXT_Lazy(uint id, VariantCapEXT cap)
            {
                _IsVariantEnabledEXT_fnptr = (delegate* unmanaged<uint, VariantCapEXT, byte>)GLLoader.BindingsContext.GetProcAddress("glIsVariantEnabledEXT");
                return _IsVariantEnabledEXT_fnptr(id, cap);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, byte*, void> _GetVariantBooleanvEXT_fnptr = &GetVariantBooleanvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, byte* data) => _GetVariantBooleanvEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetVariantBooleanvEXT_Lazy(uint id, GetVariantValueEXT value, byte* data)
            {
                _GetVariantBooleanvEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVariantBooleanvEXT");
                _GetVariantBooleanvEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, int*, void> _GetVariantIntegervEXT_fnptr = &GetVariantIntegervEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => _GetVariantIntegervEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetVariantIntegervEXT_Lazy(uint id, GetVariantValueEXT value, int* data)
            {
                _GetVariantIntegervEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVariantIntegervEXT");
                _GetVariantIntegervEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, float*, void> _GetVariantFloatvEXT_fnptr = &GetVariantFloatvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => _GetVariantFloatvEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetVariantFloatvEXT_Lazy(uint id, GetVariantValueEXT value, float* data)
            {
                _GetVariantFloatvEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVariantFloatvEXT");
                _GetVariantFloatvEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, void**, void> _GetVariantPointervEXT_fnptr = &GetVariantPointervEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantPointervEXT(uint id, GetVariantValueEXT value, void** data) => _GetVariantPointervEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetVariantPointervEXT_Lazy(uint id, GetVariantValueEXT value, void** data)
            {
                _GetVariantPointervEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetVariantPointervEXT");
                _GetVariantPointervEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, byte*, void> _GetInvariantBooleanvEXT_fnptr = &GetInvariantBooleanvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, byte* data) => _GetInvariantBooleanvEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetInvariantBooleanvEXT_Lazy(uint id, GetVariantValueEXT value, byte* data)
            {
                _GetInvariantBooleanvEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInvariantBooleanvEXT");
                _GetInvariantBooleanvEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, int*, void> _GetInvariantIntegervEXT_fnptr = &GetInvariantIntegervEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => _GetInvariantIntegervEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetInvariantIntegervEXT_Lazy(uint id, GetVariantValueEXT value, int* data)
            {
                _GetInvariantIntegervEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInvariantIntegervEXT");
                _GetInvariantIntegervEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, float*, void> _GetInvariantFloatvEXT_fnptr = &GetInvariantFloatvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => _GetInvariantFloatvEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetInvariantFloatvEXT_Lazy(uint id, GetVariantValueEXT value, float* data)
            {
                _GetInvariantFloatvEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInvariantFloatvEXT");
                _GetInvariantFloatvEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, byte*, void> _GetLocalConstantBooleanvEXT_fnptr = &GetLocalConstantBooleanvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, byte* data) => _GetLocalConstantBooleanvEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetLocalConstantBooleanvEXT_Lazy(uint id, GetVariantValueEXT value, byte* data)
            {
                _GetLocalConstantBooleanvEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetLocalConstantBooleanvEXT");
                _GetLocalConstantBooleanvEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, int*, void> _GetLocalConstantIntegervEXT_fnptr = &GetLocalConstantIntegervEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => _GetLocalConstantIntegervEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetLocalConstantIntegervEXT_Lazy(uint id, GetVariantValueEXT value, int* data)
            {
                _GetLocalConstantIntegervEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetLocalConstantIntegervEXT");
                _GetLocalConstantIntegervEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<uint, GetVariantValueEXT, float*, void> _GetLocalConstantFloatvEXT_fnptr = &GetLocalConstantFloatvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => _GetLocalConstantFloatvEXT_fnptr(id, value, data);
            [UnmanagedCallersOnly]
            private static void GetLocalConstantFloatvEXT_Lazy(uint id, GetVariantValueEXT value, float* data)
            {
                _GetLocalConstantFloatvEXT_fnptr = (delegate* unmanaged<uint, GetVariantValueEXT, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetLocalConstantFloatvEXT");
                _GetLocalConstantFloatvEXT_fnptr(id, value, data);
            }
            
            private static delegate* unmanaged<float, void> _VertexWeightfEXT_fnptr = &VertexWeightfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeightfEXT(float weight) => _VertexWeightfEXT_fnptr(weight);
            [UnmanagedCallersOnly]
            private static void VertexWeightfEXT_Lazy(float weight)
            {
                _VertexWeightfEXT_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexWeightfEXT");
                _VertexWeightfEXT_fnptr(weight);
            }
            
            private static delegate* unmanaged<float*, void> _VertexWeightfvEXT_fnptr = &VertexWeightfvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeightfvEXT(float* weight) => _VertexWeightfvEXT_fnptr(weight);
            [UnmanagedCallersOnly]
            private static void VertexWeightfvEXT_Lazy(float* weight)
            {
                _VertexWeightfvEXT_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexWeightfvEXT");
                _VertexWeightfvEXT_fnptr(weight);
            }
            
            private static delegate* unmanaged<int, VertexWeightPointerTypeEXT, int, void*, void> _VertexWeightPointerEXT_fnptr = &VertexWeightPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeightPointerEXT(int size, VertexWeightPointerTypeEXT type, int stride, void* pointer) => _VertexWeightPointerEXT_fnptr(size, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void VertexWeightPointerEXT_Lazy(int size, VertexWeightPointerTypeEXT type, int stride, void* pointer)
            {
                _VertexWeightPointerEXT_fnptr = (delegate* unmanaged<int, VertexWeightPointerTypeEXT, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexWeightPointerEXT");
                _VertexWeightPointerEXT_fnptr(size, type, stride, pointer);
            }
            
            private static delegate* unmanaged<uint, ulong, uint, byte> _AcquireKeyedMutexWin32EXT_fnptr = &AcquireKeyedMutexWin32EXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte AcquireKeyedMutexWin32EXT(uint memory, ulong key, uint timeout) => _AcquireKeyedMutexWin32EXT_fnptr(memory, key, timeout);
            [UnmanagedCallersOnly]
            private static byte AcquireKeyedMutexWin32EXT_Lazy(uint memory, ulong key, uint timeout)
            {
                _AcquireKeyedMutexWin32EXT_fnptr = (delegate* unmanaged<uint, ulong, uint, byte>)GLLoader.BindingsContext.GetProcAddress("glAcquireKeyedMutexWin32EXT");
                return _AcquireKeyedMutexWin32EXT_fnptr(memory, key, timeout);
            }
            
            private static delegate* unmanaged<uint, ulong, byte> _ReleaseKeyedMutexWin32EXT_fnptr = &ReleaseKeyedMutexWin32EXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte ReleaseKeyedMutexWin32EXT(uint memory, ulong key) => _ReleaseKeyedMutexWin32EXT_fnptr(memory, key);
            [UnmanagedCallersOnly]
            private static byte ReleaseKeyedMutexWin32EXT_Lazy(uint memory, ulong key)
            {
                _ReleaseKeyedMutexWin32EXT_fnptr = (delegate* unmanaged<uint, ulong, byte>)GLLoader.BindingsContext.GetProcAddress("glReleaseKeyedMutexWin32EXT");
                return _ReleaseKeyedMutexWin32EXT_fnptr(memory, key);
            }
            
            private static delegate* unmanaged<All, int, int*, void> _WindowRectanglesEXT_fnptr = &WindowRectanglesEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_window_rectangles]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowRectanglesEXT(All mode, int count, int* box) => _WindowRectanglesEXT_fnptr(mode, count, box);
            [UnmanagedCallersOnly]
            private static void WindowRectanglesEXT_Lazy(All mode, int count, int* box)
            {
                _WindowRectanglesEXT_fnptr = (delegate* unmanaged<All, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowRectanglesEXT");
                _WindowRectanglesEXT_fnptr(mode, count, box);
            }
            
            private static delegate* unmanaged<All, IntPtr, All, IntPtr> _ImportSyncEXT_fnptr = &ImportSyncEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_x11_sync_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLSync ImportSyncEXT(All external_sync_type, IntPtr external_sync, All flags) => (GLSync) _ImportSyncEXT_fnptr(external_sync_type, external_sync, flags);
            [UnmanagedCallersOnly]
            private static IntPtr ImportSyncEXT_Lazy(All external_sync_type, IntPtr external_sync, All flags)
            {
                _ImportSyncEXT_fnptr = (delegate* unmanaged<All, IntPtr, All, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glImportSyncEXT");
                return _ImportSyncEXT_fnptr(external_sync_type, external_sync, flags);
            }
            
        }
        public static unsafe partial class NV
        {
            private static delegate* unmanaged<int, uint*, void> _CreateSemaphoresNV_fnptr = &CreateSemaphoresNV_Lazy;
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreateSemaphoresNV(int n, uint* semaphores) => _CreateSemaphoresNV_fnptr(n, semaphores);
            [UnmanagedCallersOnly]
            private static void CreateSemaphoresNV_Lazy(int n, uint* semaphores)
            {
                _CreateSemaphoresNV_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateSemaphoresNV");
                _CreateSemaphoresNV_fnptr(n, semaphores);
            }
            
            private static delegate* unmanaged<uint, SemaphoreParameterName, int*, void> _SemaphoreParameterivNV_fnptr = &SemaphoreParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, int* parameters) => _SemaphoreParameterivNV_fnptr(semaphore, pname, parameters);
            [UnmanagedCallersOnly]
            private static void SemaphoreParameterivNV_Lazy(uint semaphore, SemaphoreParameterName pname, int* parameters)
            {
                _SemaphoreParameterivNV_fnptr = (delegate* unmanaged<uint, SemaphoreParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glSemaphoreParameterivNV");
                _SemaphoreParameterivNV_fnptr(semaphore, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, SemaphoreParameterName, int*, void> _GetSemaphoreParameterivNV_fnptr = &GetSemaphoreParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetSemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, int* parameters) => _GetSemaphoreParameterivNV_fnptr(semaphore, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetSemaphoreParameterivNV_Lazy(uint semaphore, SemaphoreParameterName pname, int* parameters)
            {
                _GetSemaphoreParameterivNV_fnptr = (delegate* unmanaged<uint, SemaphoreParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSemaphoreParameterivNV");
                _GetSemaphoreParameterivNV_fnptr(semaphore, pname, parameters);
            }
            
            private static delegate* unmanaged<All, void> _AlphaToCoverageDitherControlNV_fnptr = &AlphaToCoverageDitherControlNV_Lazy;
            /// <summary> <b>[requires: GL_NV_alpha_to_coverage_dither_control]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaToCoverageDitherControlNV(All mode) => _AlphaToCoverageDitherControlNV_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void AlphaToCoverageDitherControlNV_Lazy(All mode)
            {
                _AlphaToCoverageDitherControlNV_fnptr = (delegate* unmanaged<All, void>)GLLoader.BindingsContext.GetProcAddress("glAlphaToCoverageDitherControlNV");
                _AlphaToCoverageDitherControlNV_fnptr(mode);
            }
            
            private static delegate* unmanaged<PrimitiveType, void*, int, int, int, void> _MultiDrawArraysIndirectBindlessNV_fnptr = &MultiDrawArraysIndirectBindlessNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysIndirectBindlessNV(PrimitiveType mode, void* indirect, int drawCount, int stride, int vertexBufferCount) => _MultiDrawArraysIndirectBindlessNV_fnptr(mode, indirect, drawCount, stride, vertexBufferCount);
            [UnmanagedCallersOnly]
            private static void MultiDrawArraysIndirectBindlessNV_Lazy(PrimitiveType mode, void* indirect, int drawCount, int stride, int vertexBufferCount)
            {
                _MultiDrawArraysIndirectBindlessNV_fnptr = (delegate* unmanaged<PrimitiveType, void*, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawArraysIndirectBindlessNV");
                _MultiDrawArraysIndirectBindlessNV_fnptr(mode, indirect, drawCount, stride, vertexBufferCount);
            }
            
            private static delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, int, void> _MultiDrawElementsIndirectBindlessNV_fnptr = &MultiDrawElementsIndirectBindlessNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsIndirectBindlessNV(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int stride, int vertexBufferCount) => _MultiDrawElementsIndirectBindlessNV_fnptr(mode, type, indirect, drawCount, stride, vertexBufferCount);
            [UnmanagedCallersOnly]
            private static void MultiDrawElementsIndirectBindlessNV_Lazy(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int stride, int vertexBufferCount)
            {
                _MultiDrawElementsIndirectBindlessNV_fnptr = (delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsIndirectBindlessNV");
                _MultiDrawElementsIndirectBindlessNV_fnptr(mode, type, indirect, drawCount, stride, vertexBufferCount);
            }
            
            private static delegate* unmanaged<PrimitiveType, void*, int, int, int, int, void> _MultiDrawArraysIndirectBindlessCountNV_fnptr = &MultiDrawArraysIndirectBindlessCountNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysIndirectBindlessCountNV(PrimitiveType mode, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => _MultiDrawArraysIndirectBindlessCountNV_fnptr(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            [UnmanagedCallersOnly]
            private static void MultiDrawArraysIndirectBindlessCountNV_Lazy(PrimitiveType mode, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
            {
                _MultiDrawArraysIndirectBindlessCountNV_fnptr = (delegate* unmanaged<PrimitiveType, void*, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawArraysIndirectBindlessCountNV");
                _MultiDrawArraysIndirectBindlessCountNV_fnptr(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            }
            
            private static delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, int, int, void> _MultiDrawElementsIndirectBindlessCountNV_fnptr = &MultiDrawElementsIndirectBindlessCountNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsIndirectBindlessCountNV(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => _MultiDrawElementsIndirectBindlessCountNV_fnptr(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            [UnmanagedCallersOnly]
            private static void MultiDrawElementsIndirectBindlessCountNV_Lazy(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
            {
                _MultiDrawElementsIndirectBindlessCountNV_fnptr = (delegate* unmanaged<PrimitiveType, DrawElementsType, void*, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawElementsIndirectBindlessCountNV");
                _MultiDrawElementsIndirectBindlessCountNV_fnptr(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            }
            
            private static delegate* unmanaged<TextureHandle, ulong> _GetTextureHandleNV_fnptr = &GetTextureHandleNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetTextureHandleNV(TextureHandle texture) => _GetTextureHandleNV_fnptr(texture);
            [UnmanagedCallersOnly]
            private static ulong GetTextureHandleNV_Lazy(TextureHandle texture)
            {
                _GetTextureHandleNV_fnptr = (delegate* unmanaged<TextureHandle, ulong>)GLLoader.BindingsContext.GetProcAddress("glGetTextureHandleNV");
                return _GetTextureHandleNV_fnptr(texture);
            }
            
            private static delegate* unmanaged<TextureHandle, SamplerHandle, ulong> _GetTextureSamplerHandleNV_fnptr = &GetTextureSamplerHandleNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetTextureSamplerHandleNV(TextureHandle texture, SamplerHandle sampler) => _GetTextureSamplerHandleNV_fnptr(texture, sampler);
            [UnmanagedCallersOnly]
            private static ulong GetTextureSamplerHandleNV_Lazy(TextureHandle texture, SamplerHandle sampler)
            {
                _GetTextureSamplerHandleNV_fnptr = (delegate* unmanaged<TextureHandle, SamplerHandle, ulong>)GLLoader.BindingsContext.GetProcAddress("glGetTextureSamplerHandleNV");
                return _GetTextureSamplerHandleNV_fnptr(texture, sampler);
            }
            
            private static delegate* unmanaged<ulong, void> _MakeTextureHandleResidentNV_fnptr = &MakeTextureHandleResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeTextureHandleResidentNV(ulong handle) => _MakeTextureHandleResidentNV_fnptr(handle);
            [UnmanagedCallersOnly]
            private static void MakeTextureHandleResidentNV_Lazy(ulong handle)
            {
                _MakeTextureHandleResidentNV_fnptr = (delegate* unmanaged<ulong, void>)GLLoader.BindingsContext.GetProcAddress("glMakeTextureHandleResidentNV");
                _MakeTextureHandleResidentNV_fnptr(handle);
            }
            
            private static delegate* unmanaged<ulong, void> _MakeTextureHandleNonResidentNV_fnptr = &MakeTextureHandleNonResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeTextureHandleNonResidentNV(ulong handle) => _MakeTextureHandleNonResidentNV_fnptr(handle);
            [UnmanagedCallersOnly]
            private static void MakeTextureHandleNonResidentNV_Lazy(ulong handle)
            {
                _MakeTextureHandleNonResidentNV_fnptr = (delegate* unmanaged<ulong, void>)GLLoader.BindingsContext.GetProcAddress("glMakeTextureHandleNonResidentNV");
                _MakeTextureHandleNonResidentNV_fnptr(handle);
            }
            
            private static delegate* unmanaged<TextureHandle, int, byte, int, PixelFormat, ulong> _GetImageHandleNV_fnptr = &GetImageHandleNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetImageHandleNV(TextureHandle texture, int level, byte layered, int layer, PixelFormat format) => _GetImageHandleNV_fnptr(texture, level, layered, layer, format);
            [UnmanagedCallersOnly]
            private static ulong GetImageHandleNV_Lazy(TextureHandle texture, int level, byte layered, int layer, PixelFormat format)
            {
                _GetImageHandleNV_fnptr = (delegate* unmanaged<TextureHandle, int, byte, int, PixelFormat, ulong>)GLLoader.BindingsContext.GetProcAddress("glGetImageHandleNV");
                return _GetImageHandleNV_fnptr(texture, level, layered, layer, format);
            }
            
            private static delegate* unmanaged<ulong, All, void> _MakeImageHandleResidentNV_fnptr = &MakeImageHandleResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeImageHandleResidentNV(ulong handle, All access) => _MakeImageHandleResidentNV_fnptr(handle, access);
            [UnmanagedCallersOnly]
            private static void MakeImageHandleResidentNV_Lazy(ulong handle, All access)
            {
                _MakeImageHandleResidentNV_fnptr = (delegate* unmanaged<ulong, All, void>)GLLoader.BindingsContext.GetProcAddress("glMakeImageHandleResidentNV");
                _MakeImageHandleResidentNV_fnptr(handle, access);
            }
            
            private static delegate* unmanaged<ulong, void> _MakeImageHandleNonResidentNV_fnptr = &MakeImageHandleNonResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeImageHandleNonResidentNV(ulong handle) => _MakeImageHandleNonResidentNV_fnptr(handle);
            [UnmanagedCallersOnly]
            private static void MakeImageHandleNonResidentNV_Lazy(ulong handle)
            {
                _MakeImageHandleNonResidentNV_fnptr = (delegate* unmanaged<ulong, void>)GLLoader.BindingsContext.GetProcAddress("glMakeImageHandleNonResidentNV");
                _MakeImageHandleNonResidentNV_fnptr(handle);
            }
            
            private static delegate* unmanaged<int, ulong, void> _UniformHandleui64NV_fnptr = &UniformHandleui64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformHandleui64NV(int location, ulong value) => _UniformHandleui64NV_fnptr(location, value);
            [UnmanagedCallersOnly]
            private static void UniformHandleui64NV_Lazy(int location, ulong value)
            {
                _UniformHandleui64NV_fnptr = (delegate* unmanaged<int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniformHandleui64NV");
                _UniformHandleui64NV_fnptr(location, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _UniformHandleui64vNV_fnptr = &UniformHandleui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformHandleui64vNV(int location, int count, ulong* value) => _UniformHandleui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void UniformHandleui64vNV_Lazy(int location, int count, ulong* value)
            {
                _UniformHandleui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformHandleui64vNV");
                _UniformHandleui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, void> _ProgramUniformHandleui64NV_fnptr = &ProgramUniformHandleui64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformHandleui64NV(ProgramHandle program, int location, ulong value) => _ProgramUniformHandleui64NV_fnptr(program, location, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformHandleui64NV_Lazy(ProgramHandle program, int location, ulong value)
            {
                _ProgramUniformHandleui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformHandleui64NV");
                _ProgramUniformHandleui64NV_fnptr(program, location, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniformHandleui64vNV_fnptr = &ProgramUniformHandleui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformHandleui64vNV(ProgramHandle program, int location, int count, ulong* values) => _ProgramUniformHandleui64vNV_fnptr(program, location, count, values);
            [UnmanagedCallersOnly]
            private static void ProgramUniformHandleui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* values)
            {
                _ProgramUniformHandleui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformHandleui64vNV");
                _ProgramUniformHandleui64vNV_fnptr(program, location, count, values);
            }
            
            private static delegate* unmanaged<ulong, byte> _IsTextureHandleResidentNV_fnptr = &IsTextureHandleResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsTextureHandleResidentNV(ulong handle) => _IsTextureHandleResidentNV_fnptr(handle);
            [UnmanagedCallersOnly]
            private static byte IsTextureHandleResidentNV_Lazy(ulong handle)
            {
                _IsTextureHandleResidentNV_fnptr = (delegate* unmanaged<ulong, byte>)GLLoader.BindingsContext.GetProcAddress("glIsTextureHandleResidentNV");
                return _IsTextureHandleResidentNV_fnptr(handle);
            }
            
            private static delegate* unmanaged<ulong, byte> _IsImageHandleResidentNV_fnptr = &IsImageHandleResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsImageHandleResidentNV(ulong handle) => _IsImageHandleResidentNV_fnptr(handle);
            [UnmanagedCallersOnly]
            private static byte IsImageHandleResidentNV_Lazy(ulong handle)
            {
                _IsImageHandleResidentNV_fnptr = (delegate* unmanaged<ulong, byte>)GLLoader.BindingsContext.GetProcAddress("glIsImageHandleResidentNV");
                return _IsImageHandleResidentNV_fnptr(handle);
            }
            
            private static delegate* unmanaged<All, int, void> _BlendParameteriNV_fnptr = &BlendParameteriNV_Lazy;
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendParameteriNV(All pname, int value) => _BlendParameteriNV_fnptr(pname, value);
            [UnmanagedCallersOnly]
            private static void BlendParameteriNV_Lazy(All pname, int value)
            {
                _BlendParameteriNV_fnptr = (delegate* unmanaged<All, int, void>)GLLoader.BindingsContext.GetProcAddress("glBlendParameteriNV");
                _BlendParameteriNV_fnptr(pname, value);
            }
            
            private static delegate* unmanaged<void> _BlendBarrierNV_fnptr = &BlendBarrierNV_Lazy;
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendBarrierNV() => _BlendBarrierNV_fnptr();
            [UnmanagedCallersOnly]
            private static void BlendBarrierNV_Lazy()
            {
                _BlendBarrierNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glBlendBarrierNV");
                _BlendBarrierNV_fnptr();
            }
            
            private static delegate* unmanaged<uint, float, float, void> _ViewportPositionWScaleNV_fnptr = &ViewportPositionWScaleNV_Lazy;
            /// <summary> <b>[requires: GL_NV_clip_space_w_scaling]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ViewportPositionWScaleNV(uint index, float xcoeff, float ycoeff) => _ViewportPositionWScaleNV_fnptr(index, xcoeff, ycoeff);
            [UnmanagedCallersOnly]
            private static void ViewportPositionWScaleNV_Lazy(uint index, float xcoeff, float ycoeff)
            {
                _ViewportPositionWScaleNV_fnptr = (delegate* unmanaged<uint, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glViewportPositionWScaleNV");
                _ViewportPositionWScaleNV_fnptr(index, xcoeff, ycoeff);
            }
            
            private static delegate* unmanaged<int, uint*, void> _CreateStatesNV_fnptr = &CreateStatesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreateStatesNV(int n, uint* states) => _CreateStatesNV_fnptr(n, states);
            [UnmanagedCallersOnly]
            private static void CreateStatesNV_Lazy(int n, uint* states)
            {
                _CreateStatesNV_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateStatesNV");
                _CreateStatesNV_fnptr(n, states);
            }
            
            private static delegate* unmanaged<int, uint*, void> _DeleteStatesNV_fnptr = &DeleteStatesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteStatesNV(int n, uint* states) => _DeleteStatesNV_fnptr(n, states);
            [UnmanagedCallersOnly]
            private static void DeleteStatesNV_Lazy(int n, uint* states)
            {
                _DeleteStatesNV_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteStatesNV");
                _DeleteStatesNV_fnptr(n, states);
            }
            
            private static delegate* unmanaged<uint, byte> _IsStateNV_fnptr = &IsStateNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsStateNV(uint state) => _IsStateNV_fnptr(state);
            [UnmanagedCallersOnly]
            private static byte IsStateNV_Lazy(uint state)
            {
                _IsStateNV_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsStateNV");
                return _IsStateNV_fnptr(state);
            }
            
            private static delegate* unmanaged<uint, All, void> _StateCaptureNV_fnptr = &StateCaptureNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StateCaptureNV(uint state, All mode) => _StateCaptureNV_fnptr(state, mode);
            [UnmanagedCallersOnly]
            private static void StateCaptureNV_Lazy(uint state, All mode)
            {
                _StateCaptureNV_fnptr = (delegate* unmanaged<uint, All, void>)GLLoader.BindingsContext.GetProcAddress("glStateCaptureNV");
                _StateCaptureNV_fnptr(state, mode);
            }
            
            private static delegate* unmanaged<All, uint, uint> _GetCommandHeaderNV_fnptr = &GetCommandHeaderNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GetCommandHeaderNV(All tokenID, uint size) => _GetCommandHeaderNV_fnptr(tokenID, size);
            [UnmanagedCallersOnly]
            private static uint GetCommandHeaderNV_Lazy(All tokenID, uint size)
            {
                _GetCommandHeaderNV_fnptr = (delegate* unmanaged<All, uint, uint>)GLLoader.BindingsContext.GetProcAddress("glGetCommandHeaderNV");
                return _GetCommandHeaderNV_fnptr(tokenID, size);
            }
            
            private static delegate* unmanaged<ShaderType, ushort> _GetStageIndexNV_fnptr = &GetStageIndexNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ushort GetStageIndexNV(ShaderType shadertype) => _GetStageIndexNV_fnptr(shadertype);
            [UnmanagedCallersOnly]
            private static ushort GetStageIndexNV_Lazy(ShaderType shadertype)
            {
                _GetStageIndexNV_fnptr = (delegate* unmanaged<ShaderType, ushort>)GLLoader.BindingsContext.GetProcAddress("glGetStageIndexNV");
                return _GetStageIndexNV_fnptr(shadertype);
            }
            
            private static delegate* unmanaged<All, uint, IntPtr*, int*, uint, void> _DrawCommandsNV_fnptr = &DrawCommandsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawCommandsNV(All primitiveMode, uint buffer, IntPtr* indirects, int* sizes, uint count) => _DrawCommandsNV_fnptr(primitiveMode, buffer, indirects, sizes, count);
            [UnmanagedCallersOnly]
            private static void DrawCommandsNV_Lazy(All primitiveMode, uint buffer, IntPtr* indirects, int* sizes, uint count)
            {
                _DrawCommandsNV_fnptr = (delegate* unmanaged<All, uint, IntPtr*, int*, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawCommandsNV");
                _DrawCommandsNV_fnptr(primitiveMode, buffer, indirects, sizes, count);
            }
            
            private static delegate* unmanaged<All, ulong*, int*, uint, void> _DrawCommandsAddressNV_fnptr = &DrawCommandsAddressNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawCommandsAddressNV(All primitiveMode, ulong* indirects, int* sizes, uint count) => _DrawCommandsAddressNV_fnptr(primitiveMode, indirects, sizes, count);
            [UnmanagedCallersOnly]
            private static void DrawCommandsAddressNV_Lazy(All primitiveMode, ulong* indirects, int* sizes, uint count)
            {
                _DrawCommandsAddressNV_fnptr = (delegate* unmanaged<All, ulong*, int*, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawCommandsAddressNV");
                _DrawCommandsAddressNV_fnptr(primitiveMode, indirects, sizes, count);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr*, int*, uint*, uint*, uint, void> _DrawCommandsStatesNV_fnptr = &DrawCommandsStatesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawCommandsStatesNV(BufferHandle buffer, IntPtr* indirects, int* sizes, uint* states, uint* fbos, uint count) => _DrawCommandsStatesNV_fnptr(buffer, indirects, sizes, states, fbos, count);
            [UnmanagedCallersOnly]
            private static void DrawCommandsStatesNV_Lazy(BufferHandle buffer, IntPtr* indirects, int* sizes, uint* states, uint* fbos, uint count)
            {
                _DrawCommandsStatesNV_fnptr = (delegate* unmanaged<BufferHandle, IntPtr*, int*, uint*, uint*, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawCommandsStatesNV");
                _DrawCommandsStatesNV_fnptr(buffer, indirects, sizes, states, fbos, count);
            }
            
            private static delegate* unmanaged<ulong*, int*, uint*, uint*, uint, void> _DrawCommandsStatesAddressNV_fnptr = &DrawCommandsStatesAddressNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count) => _DrawCommandsStatesAddressNV_fnptr(indirects, sizes, states, fbos, count);
            [UnmanagedCallersOnly]
            private static void DrawCommandsStatesAddressNV_Lazy(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count)
            {
                _DrawCommandsStatesAddressNV_fnptr = (delegate* unmanaged<ulong*, int*, uint*, uint*, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawCommandsStatesAddressNV");
                _DrawCommandsStatesAddressNV_fnptr(indirects, sizes, states, fbos, count);
            }
            
            private static delegate* unmanaged<int, uint*, void> _CreateCommandListsNV_fnptr = &CreateCommandListsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreateCommandListsNV(int n, uint* lists) => _CreateCommandListsNV_fnptr(n, lists);
            [UnmanagedCallersOnly]
            private static void CreateCommandListsNV_Lazy(int n, uint* lists)
            {
                _CreateCommandListsNV_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glCreateCommandListsNV");
                _CreateCommandListsNV_fnptr(n, lists);
            }
            
            private static delegate* unmanaged<int, uint*, void> _DeleteCommandListsNV_fnptr = &DeleteCommandListsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteCommandListsNV(int n, uint* lists) => _DeleteCommandListsNV_fnptr(n, lists);
            [UnmanagedCallersOnly]
            private static void DeleteCommandListsNV_Lazy(int n, uint* lists)
            {
                _DeleteCommandListsNV_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteCommandListsNV");
                _DeleteCommandListsNV_fnptr(n, lists);
            }
            
            private static delegate* unmanaged<uint, byte> _IsCommandListNV_fnptr = &IsCommandListNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsCommandListNV(uint list) => _IsCommandListNV_fnptr(list);
            [UnmanagedCallersOnly]
            private static byte IsCommandListNV_Lazy(uint list)
            {
                _IsCommandListNV_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsCommandListNV");
                return _IsCommandListNV_fnptr(list);
            }
            
            private static delegate* unmanaged<uint, uint, void**, int*, uint*, uint*, uint, void> _ListDrawCommandsStatesClientNV_fnptr = &ListDrawCommandsStatesClientNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count) => _ListDrawCommandsStatesClientNV_fnptr(list, segment, indirects, sizes, states, fbos, count);
            [UnmanagedCallersOnly]
            private static void ListDrawCommandsStatesClientNV_Lazy(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count)
            {
                _ListDrawCommandsStatesClientNV_fnptr = (delegate* unmanaged<uint, uint, void**, int*, uint*, uint*, uint, void>)GLLoader.BindingsContext.GetProcAddress("glListDrawCommandsStatesClientNV");
                _ListDrawCommandsStatesClientNV_fnptr(list, segment, indirects, sizes, states, fbos, count);
            }
            
            private static delegate* unmanaged<uint, uint, void> _CommandListSegmentsNV_fnptr = &CommandListSegmentsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CommandListSegmentsNV(uint list, uint segments) => _CommandListSegmentsNV_fnptr(list, segments);
            [UnmanagedCallersOnly]
            private static void CommandListSegmentsNV_Lazy(uint list, uint segments)
            {
                _CommandListSegmentsNV_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glCommandListSegmentsNV");
                _CommandListSegmentsNV_fnptr(list, segments);
            }
            
            private static delegate* unmanaged<uint, void> _CompileCommandListNV_fnptr = &CompileCommandListNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompileCommandListNV(uint list) => _CompileCommandListNV_fnptr(list);
            [UnmanagedCallersOnly]
            private static void CompileCommandListNV_Lazy(uint list)
            {
                _CompileCommandListNV_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glCompileCommandListNV");
                _CompileCommandListNV_fnptr(list);
            }
            
            private static delegate* unmanaged<uint, void> _CallCommandListNV_fnptr = &CallCommandListNV_Lazy;
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CallCommandListNV(uint list) => _CallCommandListNV_fnptr(list);
            [UnmanagedCallersOnly]
            private static void CallCommandListNV_Lazy(uint list)
            {
                _CallCommandListNV_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glCallCommandListNV");
                _CallCommandListNV_fnptr(list);
            }
            
            private static delegate* unmanaged<uint, ConditionalRenderMode, void> _BeginConditionalRenderNV_fnptr = &BeginConditionalRenderNV_Lazy;
            /// <summary> <b>[requires: GL_NV_conditional_render]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginConditionalRenderNV(uint id, ConditionalRenderMode mode) => _BeginConditionalRenderNV_fnptr(id, mode);
            [UnmanagedCallersOnly]
            private static void BeginConditionalRenderNV_Lazy(uint id, ConditionalRenderMode mode)
            {
                _BeginConditionalRenderNV_fnptr = (delegate* unmanaged<uint, ConditionalRenderMode, void>)GLLoader.BindingsContext.GetProcAddress("glBeginConditionalRenderNV");
                _BeginConditionalRenderNV_fnptr(id, mode);
            }
            
            private static delegate* unmanaged<void> _EndConditionalRenderNV_fnptr = &EndConditionalRenderNV_Lazy;
            /// <summary> <b>[requires: GL_NV_conditional_render]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndConditionalRenderNV() => _EndConditionalRenderNV_fnptr();
            [UnmanagedCallersOnly]
            private static void EndConditionalRenderNV_Lazy()
            {
                _EndConditionalRenderNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndConditionalRenderNV");
                _EndConditionalRenderNV_fnptr();
            }
            
            private static delegate* unmanaged<uint, uint, void> _SubpixelPrecisionBiasNV_fnptr = &SubpixelPrecisionBiasNV_Lazy;
            /// <summary> <b>[requires: GL_NV_conservative_raster]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SubpixelPrecisionBiasNV(uint xbits, uint ybits) => _SubpixelPrecisionBiasNV_fnptr(xbits, ybits);
            [UnmanagedCallersOnly]
            private static void SubpixelPrecisionBiasNV_Lazy(uint xbits, uint ybits)
            {
                _SubpixelPrecisionBiasNV_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glSubpixelPrecisionBiasNV");
                _SubpixelPrecisionBiasNV_fnptr(xbits, ybits);
            }
            
            private static delegate* unmanaged<All, float, void> _ConservativeRasterParameterfNV_fnptr = &ConservativeRasterParameterfNV_Lazy;
            /// <summary> <b>[requires: GL_NV_conservative_raster_dilate]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConservativeRasterParameterfNV(All pname, float value) => _ConservativeRasterParameterfNV_fnptr(pname, value);
            [UnmanagedCallersOnly]
            private static void ConservativeRasterParameterfNV_Lazy(All pname, float value)
            {
                _ConservativeRasterParameterfNV_fnptr = (delegate* unmanaged<All, float, void>)GLLoader.BindingsContext.GetProcAddress("glConservativeRasterParameterfNV");
                _ConservativeRasterParameterfNV_fnptr(pname, value);
            }
            
            private static delegate* unmanaged<All, int, void> _ConservativeRasterParameteriNV_fnptr = &ConservativeRasterParameteriNV_Lazy;
            /// <summary> <b>[requires: GL_NV_conservative_raster_pre_snap_triangles]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConservativeRasterParameteriNV(All pname, int param) => _ConservativeRasterParameteriNV_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void ConservativeRasterParameteriNV_Lazy(All pname, int param)
            {
                _ConservativeRasterParameteriNV_fnptr = (delegate* unmanaged<All, int, void>)GLLoader.BindingsContext.GetProcAddress("glConservativeRasterParameteriNV");
                _ConservativeRasterParameteriNV_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<uint, CopyBufferSubDataTarget, int, int, int, int, uint, CopyBufferSubDataTarget, int, int, int, int, int, int, int, void> _CopyImageSubDataNV_fnptr = &CopyImageSubDataNV_Lazy;
            /// <summary> <b>[requires: GL_NV_copy_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyImageSubDataNV(uint srcName, CopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => _CopyImageSubDataNV_fnptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            [UnmanagedCallersOnly]
            private static void CopyImageSubDataNV_Lazy(uint srcName, CopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)
            {
                _CopyImageSubDataNV_fnptr = (delegate* unmanaged<uint, CopyBufferSubDataTarget, int, int, int, int, uint, CopyBufferSubDataTarget, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyImageSubDataNV");
                _CopyImageSubDataNV_fnptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            }
            
            private static delegate* unmanaged<double, double, void> _DepthRangedNV_fnptr = &DepthRangedNV_Lazy;
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangedNV(double zNear, double zFar) => _DepthRangedNV_fnptr(zNear, zFar);
            [UnmanagedCallersOnly]
            private static void DepthRangedNV_Lazy(double zNear, double zFar)
            {
                _DepthRangedNV_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangedNV");
                _DepthRangedNV_fnptr(zNear, zFar);
            }
            
            private static delegate* unmanaged<double, void> _ClearDepthdNV_fnptr = &ClearDepthdNV_Lazy;
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearDepthdNV(double depth) => _ClearDepthdNV_fnptr(depth);
            [UnmanagedCallersOnly]
            private static void ClearDepthdNV_Lazy(double depth)
            {
                _ClearDepthdNV_fnptr = (delegate* unmanaged<double, void>)GLLoader.BindingsContext.GetProcAddress("glClearDepthdNV");
                _ClearDepthdNV_fnptr(depth);
            }
            
            private static delegate* unmanaged<double, double, void> _DepthBoundsdNV_fnptr = &DepthBoundsdNV_Lazy;
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthBoundsdNV(double zmin, double zmax) => _DepthBoundsdNV_fnptr(zmin, zmax);
            [UnmanagedCallersOnly]
            private static void DepthBoundsdNV_Lazy(double zmin, double zmax)
            {
                _DepthBoundsdNV_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glDepthBoundsdNV");
                _DepthBoundsdNV_fnptr(zmin, zmax);
            }
            
            private static delegate* unmanaged<TextureHandle, SamplerHandle, float, float, float, float, float, float, float, float, float, void> _DrawTextureNV_fnptr = &DrawTextureNV_Lazy;
            /// <summary> <b>[requires: GL_NV_draw_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawTextureNV(TextureHandle texture, SamplerHandle sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => _DrawTextureNV_fnptr(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            [UnmanagedCallersOnly]
            private static void DrawTextureNV_Lazy(TextureHandle texture, SamplerHandle sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1)
            {
                _DrawTextureNV_fnptr = (delegate* unmanaged<TextureHandle, SamplerHandle, float, float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTextureNV");
                _DrawTextureNV_fnptr(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            }
            
            private static delegate* unmanaged<ulong, SamplerHandle, float, float, float, float, float, float, float, float, float, void> _DrawVkImageNV_fnptr = &DrawVkImageNV_Lazy;
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawVkImageNV(ulong vkImage, SamplerHandle sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => _DrawVkImageNV_fnptr(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            [UnmanagedCallersOnly]
            private static void DrawVkImageNV_Lazy(ulong vkImage, SamplerHandle sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1)
            {
                _DrawVkImageNV_fnptr = (delegate* unmanaged<ulong, SamplerHandle, float, float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glDrawVkImageNV");
                _DrawVkImageNV_fnptr(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            }
            
            private static delegate* unmanaged<byte*, IntPtr> _GetVkProcAddrNV_fnptr = &GetVkProcAddrNV_Lazy;
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr GetVkProcAddrNV(byte* name) => _GetVkProcAddrNV_fnptr(name);
            [UnmanagedCallersOnly]
            private static IntPtr GetVkProcAddrNV_Lazy(byte* name)
            {
                _GetVkProcAddrNV_fnptr = (delegate* unmanaged<byte*, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glGetVkProcAddrNV");
                return _GetVkProcAddrNV_fnptr(name);
            }
            
            private static delegate* unmanaged<ulong, void> _WaitVkSemaphoreNV_fnptr = &WaitVkSemaphoreNV_Lazy;
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WaitVkSemaphoreNV(ulong vkSemaphore) => _WaitVkSemaphoreNV_fnptr(vkSemaphore);
            [UnmanagedCallersOnly]
            private static void WaitVkSemaphoreNV_Lazy(ulong vkSemaphore)
            {
                _WaitVkSemaphoreNV_fnptr = (delegate* unmanaged<ulong, void>)GLLoader.BindingsContext.GetProcAddress("glWaitVkSemaphoreNV");
                _WaitVkSemaphoreNV_fnptr(vkSemaphore);
            }
            
            private static delegate* unmanaged<ulong, void> _SignalVkSemaphoreNV_fnptr = &SignalVkSemaphoreNV_Lazy;
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SignalVkSemaphoreNV(ulong vkSemaphore) => _SignalVkSemaphoreNV_fnptr(vkSemaphore);
            [UnmanagedCallersOnly]
            private static void SignalVkSemaphoreNV_Lazy(ulong vkSemaphore)
            {
                _SignalVkSemaphoreNV_fnptr = (delegate* unmanaged<ulong, void>)GLLoader.BindingsContext.GetProcAddress("glSignalVkSemaphoreNV");
                _SignalVkSemaphoreNV_fnptr(vkSemaphore);
            }
            
            private static delegate* unmanaged<ulong, void> _SignalVkFenceNV_fnptr = &SignalVkFenceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SignalVkFenceNV(ulong vkFence) => _SignalVkFenceNV_fnptr(vkFence);
            [UnmanagedCallersOnly]
            private static void SignalVkFenceNV_Lazy(ulong vkFence)
            {
                _SignalVkFenceNV_fnptr = (delegate* unmanaged<ulong, void>)GLLoader.BindingsContext.GetProcAddress("glSignalVkFenceNV");
                _SignalVkFenceNV_fnptr(vkFence);
            }
            
            private static delegate* unmanaged<EvalTargetNV, uint, MapTypeNV, int, int, int, int, byte, void*, void> _MapControlPointsNV_fnptr = &MapControlPointsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, byte packed, void* points) => _MapControlPointsNV_fnptr(target, index, type, ustride, vstride, uorder, vorder, packed, points);
            [UnmanagedCallersOnly]
            private static void MapControlPointsNV_Lazy(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, byte packed, void* points)
            {
                _MapControlPointsNV_fnptr = (delegate* unmanaged<EvalTargetNV, uint, MapTypeNV, int, int, int, int, byte, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMapControlPointsNV");
                _MapControlPointsNV_fnptr(target, index, type, ustride, vstride, uorder, vorder, packed, points);
            }
            
            private static delegate* unmanaged<EvalTargetNV, MapParameterNV, int*, void> _MapParameterivNV_fnptr = &MapParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, int* parameters) => _MapParameterivNV_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MapParameterivNV_Lazy(EvalTargetNV target, MapParameterNV pname, int* parameters)
            {
                _MapParameterivNV_fnptr = (delegate* unmanaged<EvalTargetNV, MapParameterNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMapParameterivNV");
                _MapParameterivNV_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<EvalTargetNV, MapParameterNV, float*, void> _MapParameterfvNV_fnptr = &MapParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float* parameters) => _MapParameterfvNV_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MapParameterfvNV_Lazy(EvalTargetNV target, MapParameterNV pname, float* parameters)
            {
                _MapParameterfvNV_fnptr = (delegate* unmanaged<EvalTargetNV, MapParameterNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMapParameterfvNV");
                _MapParameterfvNV_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<EvalTargetNV, uint, MapTypeNV, int, int, byte, void*, void> _GetMapControlPointsNV_fnptr = &GetMapControlPointsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, byte packed, void* points) => _GetMapControlPointsNV_fnptr(target, index, type, ustride, vstride, packed, points);
            [UnmanagedCallersOnly]
            private static void GetMapControlPointsNV_Lazy(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, byte packed, void* points)
            {
                _GetMapControlPointsNV_fnptr = (delegate* unmanaged<EvalTargetNV, uint, MapTypeNV, int, int, byte, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMapControlPointsNV");
                _GetMapControlPointsNV_fnptr(target, index, type, ustride, vstride, packed, points);
            }
            
            private static delegate* unmanaged<EvalTargetNV, MapParameterNV, int*, void> _GetMapParameterivNV_fnptr = &GetMapParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, int* parameters) => _GetMapParameterivNV_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMapParameterivNV_Lazy(EvalTargetNV target, MapParameterNV pname, int* parameters)
            {
                _GetMapParameterivNV_fnptr = (delegate* unmanaged<EvalTargetNV, MapParameterNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMapParameterivNV");
                _GetMapParameterivNV_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<EvalTargetNV, MapParameterNV, float*, void> _GetMapParameterfvNV_fnptr = &GetMapParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float* parameters) => _GetMapParameterfvNV_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMapParameterfvNV_Lazy(EvalTargetNV target, MapParameterNV pname, float* parameters)
            {
                _GetMapParameterfvNV_fnptr = (delegate* unmanaged<EvalTargetNV, MapParameterNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMapParameterfvNV");
                _GetMapParameterfvNV_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<EvalTargetNV, uint, MapAttribParameterNV, int*, void> _GetMapAttribParameterivNV_fnptr = &GetMapAttribParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, int* parameters) => _GetMapAttribParameterivNV_fnptr(target, index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMapAttribParameterivNV_Lazy(EvalTargetNV target, uint index, MapAttribParameterNV pname, int* parameters)
            {
                _GetMapAttribParameterivNV_fnptr = (delegate* unmanaged<EvalTargetNV, uint, MapAttribParameterNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMapAttribParameterivNV");
                _GetMapAttribParameterivNV_fnptr(target, index, pname, parameters);
            }
            
            private static delegate* unmanaged<EvalTargetNV, uint, MapAttribParameterNV, float*, void> _GetMapAttribParameterfvNV_fnptr = &GetMapAttribParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, float* parameters) => _GetMapAttribParameterfvNV_fnptr(target, index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMapAttribParameterfvNV_Lazy(EvalTargetNV target, uint index, MapAttribParameterNV pname, float* parameters)
            {
                _GetMapAttribParameterfvNV_fnptr = (delegate* unmanaged<EvalTargetNV, uint, MapAttribParameterNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMapAttribParameterfvNV");
                _GetMapAttribParameterfvNV_fnptr(target, index, pname, parameters);
            }
            
            private static delegate* unmanaged<EvalTargetNV, EvalMapsModeNV, void> _EvalMapsNV_fnptr = &EvalMapsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalMapsNV(EvalTargetNV target, EvalMapsModeNV mode) => _EvalMapsNV_fnptr(target, mode);
            [UnmanagedCallersOnly]
            private static void EvalMapsNV_Lazy(EvalTargetNV target, EvalMapsModeNV mode)
            {
                _EvalMapsNV_fnptr = (delegate* unmanaged<EvalTargetNV, EvalMapsModeNV, void>)GLLoader.BindingsContext.GetProcAddress("glEvalMapsNV");
                _EvalMapsNV_fnptr(target, mode);
            }
            
            private static delegate* unmanaged<GetMultisamplePNameNV, uint, float*, void> _GetMultisamplefvNV_fnptr = &GetMultisamplefvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, float* val) => _GetMultisamplefvNV_fnptr(pname, index, val);
            [UnmanagedCallersOnly]
            private static void GetMultisamplefvNV_Lazy(GetMultisamplePNameNV pname, uint index, float* val)
            {
                _GetMultisamplefvNV_fnptr = (delegate* unmanaged<GetMultisamplePNameNV, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMultisamplefvNV");
                _GetMultisamplefvNV_fnptr(pname, index, val);
            }
            
            private static delegate* unmanaged<uint, SampleMaskNV, void> _SampleMaskIndexedNV_fnptr = &SampleMaskIndexedNV_Lazy;
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleMaskIndexedNV(uint index, SampleMaskNV mask) => _SampleMaskIndexedNV_fnptr(index, mask);
            [UnmanagedCallersOnly]
            private static void SampleMaskIndexedNV_Lazy(uint index, SampleMaskNV mask)
            {
                _SampleMaskIndexedNV_fnptr = (delegate* unmanaged<uint, SampleMaskNV, void>)GLLoader.BindingsContext.GetProcAddress("glSampleMaskIndexedNV");
                _SampleMaskIndexedNV_fnptr(index, mask);
            }
            
            private static delegate* unmanaged<TextureTarget, RenderbufferHandle, void> _TexRenderbufferNV_fnptr = &TexRenderbufferNV_Lazy;
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexRenderbufferNV(TextureTarget target, RenderbufferHandle renderbuffer) => _TexRenderbufferNV_fnptr(target, renderbuffer);
            [UnmanagedCallersOnly]
            private static void TexRenderbufferNV_Lazy(TextureTarget target, RenderbufferHandle renderbuffer)
            {
                _TexRenderbufferNV_fnptr = (delegate* unmanaged<TextureTarget, RenderbufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glTexRenderbufferNV");
                _TexRenderbufferNV_fnptr(target, renderbuffer);
            }
            
            private static delegate* unmanaged<int, uint*, void> _DeleteFencesNV_fnptr = &DeleteFencesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteFencesNV(int n, uint* fences) => _DeleteFencesNV_fnptr(n, fences);
            [UnmanagedCallersOnly]
            private static void DeleteFencesNV_Lazy(int n, uint* fences)
            {
                _DeleteFencesNV_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteFencesNV");
                _DeleteFencesNV_fnptr(n, fences);
            }
            
            private static delegate* unmanaged<int, uint*, void> _GenFencesNV_fnptr = &GenFencesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenFencesNV(int n, uint* fences) => _GenFencesNV_fnptr(n, fences);
            [UnmanagedCallersOnly]
            private static void GenFencesNV_Lazy(int n, uint* fences)
            {
                _GenFencesNV_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGenFencesNV");
                _GenFencesNV_fnptr(n, fences);
            }
            
            private static delegate* unmanaged<uint, byte> _IsFenceNV_fnptr = &IsFenceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsFenceNV(uint fence) => _IsFenceNV_fnptr(fence);
            [UnmanagedCallersOnly]
            private static byte IsFenceNV_Lazy(uint fence)
            {
                _IsFenceNV_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsFenceNV");
                return _IsFenceNV_fnptr(fence);
            }
            
            private static delegate* unmanaged<uint, byte> _TestFenceNV_fnptr = &TestFenceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte TestFenceNV(uint fence) => _TestFenceNV_fnptr(fence);
            [UnmanagedCallersOnly]
            private static byte TestFenceNV_Lazy(uint fence)
            {
                _TestFenceNV_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glTestFenceNV");
                return _TestFenceNV_fnptr(fence);
            }
            
            private static delegate* unmanaged<uint, FenceParameterNameNV, int*, void> _GetFenceivNV_fnptr = &GetFenceivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFenceivNV(uint fence, FenceParameterNameNV pname, int* parameters) => _GetFenceivNV_fnptr(fence, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFenceivNV_Lazy(uint fence, FenceParameterNameNV pname, int* parameters)
            {
                _GetFenceivNV_fnptr = (delegate* unmanaged<uint, FenceParameterNameNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFenceivNV");
                _GetFenceivNV_fnptr(fence, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, void> _FinishFenceNV_fnptr = &FinishFenceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinishFenceNV(uint fence) => _FinishFenceNV_fnptr(fence);
            [UnmanagedCallersOnly]
            private static void FinishFenceNV_Lazy(uint fence)
            {
                _FinishFenceNV_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glFinishFenceNV");
                _FinishFenceNV_fnptr(fence);
            }
            
            private static delegate* unmanaged<uint, FenceConditionNV, void> _SetFenceNV_fnptr = &SetFenceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetFenceNV(uint fence, FenceConditionNV condition) => _SetFenceNV_fnptr(fence, condition);
            [UnmanagedCallersOnly]
            private static void SetFenceNV_Lazy(uint fence, FenceConditionNV condition)
            {
                _SetFenceNV_fnptr = (delegate* unmanaged<uint, FenceConditionNV, void>)GLLoader.BindingsContext.GetProcAddress("glSetFenceNV");
                _SetFenceNV_fnptr(fence, condition);
            }
            
            private static delegate* unmanaged<uint, void> _FragmentCoverageColorNV_fnptr = &FragmentCoverageColorNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fragment_coverage_to_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentCoverageColorNV(uint color) => _FragmentCoverageColorNV_fnptr(color);
            [UnmanagedCallersOnly]
            private static void FragmentCoverageColorNV_Lazy(uint color)
            {
                _FragmentCoverageColorNV_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentCoverageColorNV");
                _FragmentCoverageColorNV_fnptr(color);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, byte*, float, float, float, float, void> _ProgramNamedParameter4fNV_fnptr = &ProgramNamedParameter4fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramNamedParameter4fNV(ProgramHandle id, int len, byte* name, float x, float y, float z, float w) => _ProgramNamedParameter4fNV_fnptr(id, len, name, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramNamedParameter4fNV_Lazy(ProgramHandle id, int len, byte* name, float x, float y, float z, float w)
            {
                _ProgramNamedParameter4fNV_fnptr = (delegate* unmanaged<ProgramHandle, int, byte*, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramNamedParameter4fNV");
                _ProgramNamedParameter4fNV_fnptr(id, len, name, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, byte*, float*, void> _ProgramNamedParameter4fvNV_fnptr = &ProgramNamedParameter4fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramNamedParameter4fvNV(ProgramHandle id, int len, byte* name, float* v) => _ProgramNamedParameter4fvNV_fnptr(id, len, name, v);
            [UnmanagedCallersOnly]
            private static void ProgramNamedParameter4fvNV_Lazy(ProgramHandle id, int len, byte* name, float* v)
            {
                _ProgramNamedParameter4fvNV_fnptr = (delegate* unmanaged<ProgramHandle, int, byte*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramNamedParameter4fvNV");
                _ProgramNamedParameter4fvNV_fnptr(id, len, name, v);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, byte*, double, double, double, double, void> _ProgramNamedParameter4dNV_fnptr = &ProgramNamedParameter4dNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramNamedParameter4dNV(ProgramHandle id, int len, byte* name, double x, double y, double z, double w) => _ProgramNamedParameter4dNV_fnptr(id, len, name, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramNamedParameter4dNV_Lazy(ProgramHandle id, int len, byte* name, double x, double y, double z, double w)
            {
                _ProgramNamedParameter4dNV_fnptr = (delegate* unmanaged<ProgramHandle, int, byte*, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramNamedParameter4dNV");
                _ProgramNamedParameter4dNV_fnptr(id, len, name, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, byte*, double*, void> _ProgramNamedParameter4dvNV_fnptr = &ProgramNamedParameter4dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramNamedParameter4dvNV(ProgramHandle id, int len, byte* name, double* v) => _ProgramNamedParameter4dvNV_fnptr(id, len, name, v);
            [UnmanagedCallersOnly]
            private static void ProgramNamedParameter4dvNV_Lazy(ProgramHandle id, int len, byte* name, double* v)
            {
                _ProgramNamedParameter4dvNV_fnptr = (delegate* unmanaged<ProgramHandle, int, byte*, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramNamedParameter4dvNV");
                _ProgramNamedParameter4dvNV_fnptr(id, len, name, v);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, byte*, float*, void> _GetProgramNamedParameterfvNV_fnptr = &GetProgramNamedParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramNamedParameterfvNV(ProgramHandle id, int len, byte* name, float* parameters) => _GetProgramNamedParameterfvNV_fnptr(id, len, name, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramNamedParameterfvNV_Lazy(ProgramHandle id, int len, byte* name, float* parameters)
            {
                _GetProgramNamedParameterfvNV_fnptr = (delegate* unmanaged<ProgramHandle, int, byte*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramNamedParameterfvNV");
                _GetProgramNamedParameterfvNV_fnptr(id, len, name, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, byte*, double*, void> _GetProgramNamedParameterdvNV_fnptr = &GetProgramNamedParameterdvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramNamedParameterdvNV(ProgramHandle id, int len, byte* name, double* parameters) => _GetProgramNamedParameterdvNV_fnptr(id, len, name, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramNamedParameterdvNV_Lazy(ProgramHandle id, int len, byte* name, double* parameters)
            {
                _GetProgramNamedParameterdvNV_fnptr = (delegate* unmanaged<ProgramHandle, int, byte*, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramNamedParameterdvNV");
                _GetProgramNamedParameterdvNV_fnptr(id, len, name, parameters);
            }
            
            private static delegate* unmanaged<uint, byte, void> _RasterSamplesEXT_fnptr = &RasterSamplesEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterSamplesEXT(uint samples, byte fixedsamplelocations) => _RasterSamplesEXT_fnptr(samples, fixedsamplelocations);
            [UnmanagedCallersOnly]
            private static void RasterSamplesEXT_Lazy(uint samples, byte fixedsamplelocations)
            {
                _RasterSamplesEXT_fnptr = (delegate* unmanaged<uint, byte, void>)GLLoader.BindingsContext.GetProcAddress("glRasterSamplesEXT");
                _RasterSamplesEXT_fnptr(samples, fixedsamplelocations);
            }
            
            private static delegate* unmanaged<int, float*, void> _CoverageModulationTableNV_fnptr = &CoverageModulationTableNV_Lazy;
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverageModulationTableNV(int n, float* v) => _CoverageModulationTableNV_fnptr(n, v);
            [UnmanagedCallersOnly]
            private static void CoverageModulationTableNV_Lazy(int n, float* v)
            {
                _CoverageModulationTableNV_fnptr = (delegate* unmanaged<int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glCoverageModulationTableNV");
                _CoverageModulationTableNV_fnptr(n, v);
            }
            
            private static delegate* unmanaged<int, float*, void> _GetCoverageModulationTableNV_fnptr = &GetCoverageModulationTableNV_Lazy;
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCoverageModulationTableNV(int bufSize, float* v) => _GetCoverageModulationTableNV_fnptr(bufSize, v);
            [UnmanagedCallersOnly]
            private static void GetCoverageModulationTableNV_Lazy(int bufSize, float* v)
            {
                _GetCoverageModulationTableNV_fnptr = (delegate* unmanaged<int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCoverageModulationTableNV");
                _GetCoverageModulationTableNV_fnptr(bufSize, v);
            }
            
            private static delegate* unmanaged<All, void> _CoverageModulationNV_fnptr = &CoverageModulationNV_Lazy;
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverageModulationNV(All components) => _CoverageModulationNV_fnptr(components);
            [UnmanagedCallersOnly]
            private static void CoverageModulationNV_Lazy(All components)
            {
                _CoverageModulationNV_fnptr = (delegate* unmanaged<All, void>)GLLoader.BindingsContext.GetProcAddress("glCoverageModulationNV");
                _CoverageModulationNV_fnptr(components);
            }
            
            private static delegate* unmanaged<RenderbufferTarget, int, int, InternalFormat, int, int, void> _RenderbufferStorageMultisampleCoverageNV_fnptr = &RenderbufferStorageMultisampleCoverageNV_Lazy;
            /// <summary> <b>[requires: GL_NV_framebuffer_multisample_coverage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderbufferStorageMultisampleCoverageNV(RenderbufferTarget target, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleCoverageNV_fnptr(target, coverageSamples, colorSamples, internalformat, width, height);
            [UnmanagedCallersOnly]
            private static void RenderbufferStorageMultisampleCoverageNV_Lazy(RenderbufferTarget target, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height)
            {
                _RenderbufferStorageMultisampleCoverageNV_fnptr = (delegate* unmanaged<RenderbufferTarget, int, int, InternalFormat, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRenderbufferStorageMultisampleCoverageNV");
                _RenderbufferStorageMultisampleCoverageNV_fnptr(target, coverageSamples, colorSamples, internalformat, width, height);
            }
            
            private static delegate* unmanaged<ProgramTarget, int, void> _ProgramVertexLimitNV_fnptr = &ProgramVertexLimitNV_Lazy;
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramVertexLimitNV(ProgramTarget target, int limit) => _ProgramVertexLimitNV_fnptr(target, limit);
            [UnmanagedCallersOnly]
            private static void ProgramVertexLimitNV_Lazy(ProgramTarget target, int limit)
            {
                _ProgramVertexLimitNV_fnptr = (delegate* unmanaged<ProgramTarget, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramVertexLimitNV");
                _ProgramVertexLimitNV_fnptr(target, limit);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, void> _FramebufferTextureEXT_fnptr = &FramebufferTextureEXT_Lazy;
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level) => _FramebufferTextureEXT_fnptr(target, attachment, texture, level);
            [UnmanagedCallersOnly]
            private static void FramebufferTextureEXT_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level)
            {
                _FramebufferTextureEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureEXT");
                _FramebufferTextureEXT_fnptr(target, attachment, texture, level);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void> _FramebufferTextureLayerEXT_fnptr = &FramebufferTextureLayerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => _FramebufferTextureLayerEXT_fnptr(target, attachment, texture, level, layer);
            [UnmanagedCallersOnly]
            private static void FramebufferTextureLayerEXT_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer)
            {
                _FramebufferTextureLayerEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureLayerEXT");
                _FramebufferTextureLayerEXT_fnptr(target, attachment, texture, level, layer);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, TextureTarget, void> _FramebufferTextureFaceEXT_fnptr = &FramebufferTextureFaceEXT_Lazy;
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureFaceEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, TextureTarget face) => _FramebufferTextureFaceEXT_fnptr(target, attachment, texture, level, face);
            [UnmanagedCallersOnly]
            private static void FramebufferTextureFaceEXT_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, TextureTarget face)
            {
                _FramebufferTextureFaceEXT_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, TextureTarget, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureFaceEXT");
                _FramebufferTextureFaceEXT_fnptr(target, attachment, texture, level, face);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int, int, int, int, void> _ProgramLocalParameterI4iNV_fnptr = &ProgramLocalParameterI4iNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => _ProgramLocalParameterI4iNV_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParameterI4iNV_Lazy(ProgramTarget target, uint index, int x, int y, int z, int w)
            {
                _ProgramLocalParameterI4iNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParameterI4iNV");
                _ProgramLocalParameterI4iNV_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int*, void> _ProgramLocalParameterI4ivNV_fnptr = &ProgramLocalParameterI4ivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, int* parameters) => _ProgramLocalParameterI4ivNV_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParameterI4ivNV_Lazy(ProgramTarget target, uint index, int* parameters)
            {
                _ProgramLocalParameterI4ivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParameterI4ivNV");
                _ProgramLocalParameterI4ivNV_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int, int*, void> _ProgramLocalParametersI4ivNV_fnptr = &ProgramLocalParametersI4ivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, int count, int* parameters) => _ProgramLocalParametersI4ivNV_fnptr(target, index, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParametersI4ivNV_Lazy(ProgramTarget target, uint index, int count, int* parameters)
            {
                _ProgramLocalParametersI4ivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParametersI4ivNV");
                _ProgramLocalParametersI4ivNV_fnptr(target, index, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, uint, uint, uint, uint, void> _ProgramLocalParameterI4uiNV_fnptr = &ProgramLocalParameterI4uiNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => _ProgramLocalParameterI4uiNV_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParameterI4uiNV_Lazy(ProgramTarget target, uint index, uint x, uint y, uint z, uint w)
            {
                _ProgramLocalParameterI4uiNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParameterI4uiNV");
                _ProgramLocalParameterI4uiNV_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, uint*, void> _ProgramLocalParameterI4uivNV_fnptr = &ProgramLocalParameterI4uivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, uint* parameters) => _ProgramLocalParameterI4uivNV_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParameterI4uivNV_Lazy(ProgramTarget target, uint index, uint* parameters)
            {
                _ProgramLocalParameterI4uivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParameterI4uivNV");
                _ProgramLocalParameterI4uivNV_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int, uint*, void> _ProgramLocalParametersI4uivNV_fnptr = &ProgramLocalParametersI4uivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, int count, uint* parameters) => _ProgramLocalParametersI4uivNV_fnptr(target, index, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramLocalParametersI4uivNV_Lazy(ProgramTarget target, uint index, int count, uint* parameters)
            {
                _ProgramLocalParametersI4uivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramLocalParametersI4uivNV");
                _ProgramLocalParametersI4uivNV_fnptr(target, index, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int, int, int, int, void> _ProgramEnvParameterI4iNV_fnptr = &ProgramEnvParameterI4iNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => _ProgramEnvParameterI4iNV_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParameterI4iNV_Lazy(ProgramTarget target, uint index, int x, int y, int z, int w)
            {
                _ProgramEnvParameterI4iNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParameterI4iNV");
                _ProgramEnvParameterI4iNV_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int*, void> _ProgramEnvParameterI4ivNV_fnptr = &ProgramEnvParameterI4ivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, int* parameters) => _ProgramEnvParameterI4ivNV_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParameterI4ivNV_Lazy(ProgramTarget target, uint index, int* parameters)
            {
                _ProgramEnvParameterI4ivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParameterI4ivNV");
                _ProgramEnvParameterI4ivNV_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int, int*, void> _ProgramEnvParametersI4ivNV_fnptr = &ProgramEnvParametersI4ivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, int count, int* parameters) => _ProgramEnvParametersI4ivNV_fnptr(target, index, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParametersI4ivNV_Lazy(ProgramTarget target, uint index, int count, int* parameters)
            {
                _ProgramEnvParametersI4ivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParametersI4ivNV");
                _ProgramEnvParametersI4ivNV_fnptr(target, index, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, uint, uint, uint, uint, void> _ProgramEnvParameterI4uiNV_fnptr = &ProgramEnvParameterI4uiNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => _ProgramEnvParameterI4uiNV_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParameterI4uiNV_Lazy(ProgramTarget target, uint index, uint x, uint y, uint z, uint w)
            {
                _ProgramEnvParameterI4uiNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParameterI4uiNV");
                _ProgramEnvParameterI4uiNV_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, uint*, void> _ProgramEnvParameterI4uivNV_fnptr = &ProgramEnvParameterI4uivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, uint* parameters) => _ProgramEnvParameterI4uivNV_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParameterI4uivNV_Lazy(ProgramTarget target, uint index, uint* parameters)
            {
                _ProgramEnvParameterI4uivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParameterI4uivNV");
                _ProgramEnvParameterI4uivNV_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int, uint*, void> _ProgramEnvParametersI4uivNV_fnptr = &ProgramEnvParametersI4uivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, int count, uint* parameters) => _ProgramEnvParametersI4uivNV_fnptr(target, index, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramEnvParametersI4uivNV_Lazy(ProgramTarget target, uint index, int count, uint* parameters)
            {
                _ProgramEnvParametersI4uivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramEnvParametersI4uivNV");
                _ProgramEnvParametersI4uivNV_fnptr(target, index, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int*, void> _GetProgramLocalParameterIivNV_fnptr = &GetProgramLocalParameterIivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, int* parameters) => _GetProgramLocalParameterIivNV_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramLocalParameterIivNV_Lazy(ProgramTarget target, uint index, int* parameters)
            {
                _GetProgramLocalParameterIivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramLocalParameterIivNV");
                _GetProgramLocalParameterIivNV_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, uint*, void> _GetProgramLocalParameterIuivNV_fnptr = &GetProgramLocalParameterIuivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, uint* parameters) => _GetProgramLocalParameterIuivNV_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramLocalParameterIuivNV_Lazy(ProgramTarget target, uint index, uint* parameters)
            {
                _GetProgramLocalParameterIuivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramLocalParameterIuivNV");
                _GetProgramLocalParameterIuivNV_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, int*, void> _GetProgramEnvParameterIivNV_fnptr = &GetProgramEnvParameterIivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, int* parameters) => _GetProgramEnvParameterIivNV_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramEnvParameterIivNV_Lazy(ProgramTarget target, uint index, int* parameters)
            {
                _GetProgramEnvParameterIivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramEnvParameterIivNV");
                _GetProgramEnvParameterIivNV_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, uint*, void> _GetProgramEnvParameterIuivNV_fnptr = &GetProgramEnvParameterIuivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, uint* parameters) => _GetProgramEnvParameterIuivNV_fnptr(target, index, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramEnvParameterIuivNV_Lazy(ProgramTarget target, uint index, uint* parameters)
            {
                _GetProgramEnvParameterIuivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramEnvParameterIuivNV");
                _GetProgramEnvParameterIuivNV_fnptr(target, index, parameters);
            }
            
            private static delegate* unmanaged<All, int, uint*, void> _ProgramSubroutineParametersuivNV_fnptr = &ProgramSubroutineParametersuivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramSubroutineParametersuivNV(All target, int count, uint* parameters) => _ProgramSubroutineParametersuivNV_fnptr(target, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramSubroutineParametersuivNV_Lazy(All target, int count, uint* parameters)
            {
                _ProgramSubroutineParametersuivNV_fnptr = (delegate* unmanaged<All, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramSubroutineParametersuivNV");
                _ProgramSubroutineParametersuivNV_fnptr(target, count, parameters);
            }
            
            private static delegate* unmanaged<All, uint, uint*, void> _GetProgramSubroutineParameteruivNV_fnptr = &GetProgramSubroutineParameteruivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_program5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramSubroutineParameteruivNV(All target, uint index, uint* param) => _GetProgramSubroutineParameteruivNV_fnptr(target, index, param);
            [UnmanagedCallersOnly]
            private static void GetProgramSubroutineParameteruivNV_Lazy(All target, uint index, uint* param)
            {
                _GetProgramSubroutineParameteruivNV_fnptr = (delegate* unmanaged<All, uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramSubroutineParameteruivNV");
                _GetProgramSubroutineParameteruivNV_fnptr(target, index, param);
            }
            
            private static delegate* unmanaged<int, long, void> _Uniform1i64NV_fnptr = &Uniform1i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64NV(int location, long x) => _Uniform1i64NV_fnptr(location, x);
            [UnmanagedCallersOnly]
            private static void Uniform1i64NV_Lazy(int location, long x)
            {
                _Uniform1i64NV_fnptr = (delegate* unmanaged<int, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1i64NV");
                _Uniform1i64NV_fnptr(location, x);
            }
            
            private static delegate* unmanaged<int, long, long, void> _Uniform2i64NV_fnptr = &Uniform2i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64NV(int location, long x, long y) => _Uniform2i64NV_fnptr(location, x, y);
            [UnmanagedCallersOnly]
            private static void Uniform2i64NV_Lazy(int location, long x, long y)
            {
                _Uniform2i64NV_fnptr = (delegate* unmanaged<int, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2i64NV");
                _Uniform2i64NV_fnptr(location, x, y);
            }
            
            private static delegate* unmanaged<int, long, long, long, void> _Uniform3i64NV_fnptr = &Uniform3i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64NV(int location, long x, long y, long z) => _Uniform3i64NV_fnptr(location, x, y, z);
            [UnmanagedCallersOnly]
            private static void Uniform3i64NV_Lazy(int location, long x, long y, long z)
            {
                _Uniform3i64NV_fnptr = (delegate* unmanaged<int, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3i64NV");
                _Uniform3i64NV_fnptr(location, x, y, z);
            }
            
            private static delegate* unmanaged<int, long, long, long, long, void> _Uniform4i64NV_fnptr = &Uniform4i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64NV(int location, long x, long y, long z, long w) => _Uniform4i64NV_fnptr(location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void Uniform4i64NV_Lazy(int location, long x, long y, long z, long w)
            {
                _Uniform4i64NV_fnptr = (delegate* unmanaged<int, long, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4i64NV");
                _Uniform4i64NV_fnptr(location, x, y, z, w);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform1i64vNV_fnptr = &Uniform1i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64vNV(int location, int count, long* value) => _Uniform1i64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1i64vNV_Lazy(int location, int count, long* value)
            {
                _Uniform1i64vNV_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1i64vNV");
                _Uniform1i64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform2i64vNV_fnptr = &Uniform2i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64vNV(int location, int count, long* value) => _Uniform2i64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2i64vNV_Lazy(int location, int count, long* value)
            {
                _Uniform2i64vNV_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2i64vNV");
                _Uniform2i64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform3i64vNV_fnptr = &Uniform3i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64vNV(int location, int count, long* value) => _Uniform3i64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3i64vNV_Lazy(int location, int count, long* value)
            {
                _Uniform3i64vNV_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3i64vNV");
                _Uniform3i64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, long*, void> _Uniform4i64vNV_fnptr = &Uniform4i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64vNV(int location, int count, long* value) => _Uniform4i64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4i64vNV_Lazy(int location, int count, long* value)
            {
                _Uniform4i64vNV_fnptr = (delegate* unmanaged<int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4i64vNV");
                _Uniform4i64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, ulong, void> _Uniform1ui64NV_fnptr = &Uniform1ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64NV(int location, ulong x) => _Uniform1ui64NV_fnptr(location, x);
            [UnmanagedCallersOnly]
            private static void Uniform1ui64NV_Lazy(int location, ulong x)
            {
                _Uniform1ui64NV_fnptr = (delegate* unmanaged<int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1ui64NV");
                _Uniform1ui64NV_fnptr(location, x);
            }
            
            private static delegate* unmanaged<int, ulong, ulong, void> _Uniform2ui64NV_fnptr = &Uniform2ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64NV(int location, ulong x, ulong y) => _Uniform2ui64NV_fnptr(location, x, y);
            [UnmanagedCallersOnly]
            private static void Uniform2ui64NV_Lazy(int location, ulong x, ulong y)
            {
                _Uniform2ui64NV_fnptr = (delegate* unmanaged<int, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2ui64NV");
                _Uniform2ui64NV_fnptr(location, x, y);
            }
            
            private static delegate* unmanaged<int, ulong, ulong, ulong, void> _Uniform3ui64NV_fnptr = &Uniform3ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z) => _Uniform3ui64NV_fnptr(location, x, y, z);
            [UnmanagedCallersOnly]
            private static void Uniform3ui64NV_Lazy(int location, ulong x, ulong y, ulong z)
            {
                _Uniform3ui64NV_fnptr = (delegate* unmanaged<int, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3ui64NV");
                _Uniform3ui64NV_fnptr(location, x, y, z);
            }
            
            private static delegate* unmanaged<int, ulong, ulong, ulong, ulong, void> _Uniform4ui64NV_fnptr = &Uniform4ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) => _Uniform4ui64NV_fnptr(location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void Uniform4ui64NV_Lazy(int location, ulong x, ulong y, ulong z, ulong w)
            {
                _Uniform4ui64NV_fnptr = (delegate* unmanaged<int, ulong, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4ui64NV");
                _Uniform4ui64NV_fnptr(location, x, y, z, w);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform1ui64vNV_fnptr = &Uniform1ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64vNV(int location, int count, ulong* value) => _Uniform1ui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform1ui64vNV_Lazy(int location, int count, ulong* value)
            {
                _Uniform1ui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform1ui64vNV");
                _Uniform1ui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform2ui64vNV_fnptr = &Uniform2ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64vNV(int location, int count, ulong* value) => _Uniform2ui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform2ui64vNV_Lazy(int location, int count, ulong* value)
            {
                _Uniform2ui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform2ui64vNV");
                _Uniform2ui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform3ui64vNV_fnptr = &Uniform3ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64vNV(int location, int count, ulong* value) => _Uniform3ui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform3ui64vNV_Lazy(int location, int count, ulong* value)
            {
                _Uniform3ui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform3ui64vNV");
                _Uniform3ui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniform4ui64vNV_fnptr = &Uniform4ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64vNV(int location, int count, ulong* value) => _Uniform4ui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniform4ui64vNV_Lazy(int location, int count, ulong* value)
            {
                _Uniform4ui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniform4ui64vNV");
                _Uniform4ui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long*, void> _GetUniformi64vNV_fnptr = &GetUniformi64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformi64vNV(ProgramHandle program, int location, long* parameters) => _GetUniformi64vNV_fnptr(program, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformi64vNV_Lazy(ProgramHandle program, int location, long* parameters)
            {
                _GetUniformi64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformi64vNV");
                _GetUniformi64vNV_fnptr(program, location, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, void> _ProgramUniform1i64NV_fnptr = &ProgramUniform1i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64NV(ProgramHandle program, int location, long x) => _ProgramUniform1i64NV_fnptr(program, location, x);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1i64NV_Lazy(ProgramHandle program, int location, long x)
            {
                _ProgramUniform1i64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1i64NV");
                _ProgramUniform1i64NV_fnptr(program, location, x);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, long, void> _ProgramUniform2i64NV_fnptr = &ProgramUniform2i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64NV(ProgramHandle program, int location, long x, long y) => _ProgramUniform2i64NV_fnptr(program, location, x, y);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2i64NV_Lazy(ProgramHandle program, int location, long x, long y)
            {
                _ProgramUniform2i64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2i64NV");
                _ProgramUniform2i64NV_fnptr(program, location, x, y);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, long, long, void> _ProgramUniform3i64NV_fnptr = &ProgramUniform3i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64NV(ProgramHandle program, int location, long x, long y, long z) => _ProgramUniform3i64NV_fnptr(program, location, x, y, z);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3i64NV_Lazy(ProgramHandle program, int location, long x, long y, long z)
            {
                _ProgramUniform3i64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3i64NV");
                _ProgramUniform3i64NV_fnptr(program, location, x, y, z);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, long, long, long, long, void> _ProgramUniform4i64NV_fnptr = &ProgramUniform4i64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64NV(ProgramHandle program, int location, long x, long y, long z, long w) => _ProgramUniform4i64NV_fnptr(program, location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4i64NV_Lazy(ProgramHandle program, int location, long x, long y, long z, long w)
            {
                _ProgramUniform4i64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, long, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4i64NV");
                _ProgramUniform4i64NV_fnptr(program, location, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform1i64vNV_fnptr = &ProgramUniform1i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64vNV(ProgramHandle program, int location, int count, long* value) => _ProgramUniform1i64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1i64vNV_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform1i64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1i64vNV");
                _ProgramUniform1i64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform2i64vNV_fnptr = &ProgramUniform2i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64vNV(ProgramHandle program, int location, int count, long* value) => _ProgramUniform2i64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2i64vNV_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform2i64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2i64vNV");
                _ProgramUniform2i64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform3i64vNV_fnptr = &ProgramUniform3i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64vNV(ProgramHandle program, int location, int count, long* value) => _ProgramUniform3i64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3i64vNV_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform3i64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3i64vNV");
                _ProgramUniform3i64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, long*, void> _ProgramUniform4i64vNV_fnptr = &ProgramUniform4i64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64vNV(ProgramHandle program, int location, int count, long* value) => _ProgramUniform4i64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4i64vNV_Lazy(ProgramHandle program, int location, int count, long* value)
            {
                _ProgramUniform4i64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, long*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4i64vNV");
                _ProgramUniform4i64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, void> _ProgramUniform1ui64NV_fnptr = &ProgramUniform1ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64NV(ProgramHandle program, int location, ulong x) => _ProgramUniform1ui64NV_fnptr(program, location, x);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1ui64NV_Lazy(ProgramHandle program, int location, ulong x)
            {
                _ProgramUniform1ui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1ui64NV");
                _ProgramUniform1ui64NV_fnptr(program, location, x);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, ulong, void> _ProgramUniform2ui64NV_fnptr = &ProgramUniform2ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64NV(ProgramHandle program, int location, ulong x, ulong y) => _ProgramUniform2ui64NV_fnptr(program, location, x, y);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2ui64NV_Lazy(ProgramHandle program, int location, ulong x, ulong y)
            {
                _ProgramUniform2ui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2ui64NV");
                _ProgramUniform2ui64NV_fnptr(program, location, x, y);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, void> _ProgramUniform3ui64NV_fnptr = &ProgramUniform3ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64NV(ProgramHandle program, int location, ulong x, ulong y, ulong z) => _ProgramUniform3ui64NV_fnptr(program, location, x, y, z);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3ui64NV_Lazy(ProgramHandle program, int location, ulong x, ulong y, ulong z)
            {
                _ProgramUniform3ui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3ui64NV");
                _ProgramUniform3ui64NV_fnptr(program, location, x, y, z);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, ulong, void> _ProgramUniform4ui64NV_fnptr = &ProgramUniform4ui64NV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64NV(ProgramHandle program, int location, ulong x, ulong y, ulong z, ulong w) => _ProgramUniform4ui64NV_fnptr(program, location, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4ui64NV_Lazy(ProgramHandle program, int location, ulong x, ulong y, ulong z, ulong w)
            {
                _ProgramUniform4ui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4ui64NV");
                _ProgramUniform4ui64NV_fnptr(program, location, x, y, z, w);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform1ui64vNV_fnptr = &ProgramUniform1ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64vNV(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform1ui64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform1ui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform1ui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform1ui64vNV");
                _ProgramUniform1ui64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform2ui64vNV_fnptr = &ProgramUniform2ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64vNV(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform2ui64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform2ui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform2ui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform2ui64vNV");
                _ProgramUniform2ui64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform3ui64vNV_fnptr = &ProgramUniform3ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64vNV(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform3ui64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform3ui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform3ui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform3ui64vNV");
                _ProgramUniform3ui64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniform4ui64vNV_fnptr = &ProgramUniform4ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64vNV(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniform4ui64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniform4ui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniform4ui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniform4ui64vNV");
                _ProgramUniform4ui64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<Half, Half, void> _Vertex2hNV_fnptr = &Vertex2hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2hNV(Half x, Half y) => _Vertex2hNV_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void Vertex2hNV_Lazy(Half x, Half y)
            {
                _Vertex2hNV_fnptr = (delegate* unmanaged<Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2hNV");
                _Vertex2hNV_fnptr(x, y);
            }
            
            private static delegate* unmanaged<Half*, void> _Vertex2hvNV_fnptr = &Vertex2hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2hvNV(Half* v) => _Vertex2hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Vertex2hvNV_Lazy(Half* v)
            {
                _Vertex2hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2hvNV");
                _Vertex2hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, Half, Half, void> _Vertex3hNV_fnptr = &Vertex3hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3hNV(Half x, Half y, Half z) => _Vertex3hNV_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void Vertex3hNV_Lazy(Half x, Half y, Half z)
            {
                _Vertex3hNV_fnptr = (delegate* unmanaged<Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3hNV");
                _Vertex3hNV_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<Half*, void> _Vertex3hvNV_fnptr = &Vertex3hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3hvNV(Half* v) => _Vertex3hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Vertex3hvNV_Lazy(Half* v)
            {
                _Vertex3hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3hvNV");
                _Vertex3hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, Half, Half, Half, void> _Vertex4hNV_fnptr = &Vertex4hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4hNV(Half x, Half y, Half z, Half w) => _Vertex4hNV_fnptr(x, y, z, w);
            [UnmanagedCallersOnly]
            private static void Vertex4hNV_Lazy(Half x, Half y, Half z, Half w)
            {
                _Vertex4hNV_fnptr = (delegate* unmanaged<Half, Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4hNV");
                _Vertex4hNV_fnptr(x, y, z, w);
            }
            
            private static delegate* unmanaged<Half*, void> _Vertex4hvNV_fnptr = &Vertex4hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4hvNV(Half* v) => _Vertex4hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Vertex4hvNV_Lazy(Half* v)
            {
                _Vertex4hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4hvNV");
                _Vertex4hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, Half, Half, void> _Normal3hNV_fnptr = &Normal3hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3hNV(Half nx, Half ny, Half nz) => _Normal3hNV_fnptr(nx, ny, nz);
            [UnmanagedCallersOnly]
            private static void Normal3hNV_Lazy(Half nx, Half ny, Half nz)
            {
                _Normal3hNV_fnptr = (delegate* unmanaged<Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3hNV");
                _Normal3hNV_fnptr(nx, ny, nz);
            }
            
            private static delegate* unmanaged<Half*, void> _Normal3hvNV_fnptr = &Normal3hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3hvNV(Half* v) => _Normal3hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Normal3hvNV_Lazy(Half* v)
            {
                _Normal3hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3hvNV");
                _Normal3hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, Half, Half, void> _Color3hNV_fnptr = &Color3hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3hNV(Half red, Half green, Half blue) => _Color3hNV_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void Color3hNV_Lazy(Half red, Half green, Half blue)
            {
                _Color3hNV_fnptr = (delegate* unmanaged<Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glColor3hNV");
                _Color3hNV_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<Half*, void> _Color3hvNV_fnptr = &Color3hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3hvNV(Half* v) => _Color3hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Color3hvNV_Lazy(Half* v)
            {
                _Color3hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3hvNV");
                _Color3hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, Half, Half, Half, void> _Color4hNV_fnptr = &Color4hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4hNV(Half red, Half green, Half blue, Half alpha) => _Color4hNV_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void Color4hNV_Lazy(Half red, Half green, Half blue, Half alpha)
            {
                _Color4hNV_fnptr = (delegate* unmanaged<Half, Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glColor4hNV");
                _Color4hNV_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<Half*, void> _Color4hvNV_fnptr = &Color4hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4hvNV(Half* v) => _Color4hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void Color4hvNV_Lazy(Half* v)
            {
                _Color4hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4hvNV");
                _Color4hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, void> _TexCoord1hNV_fnptr = &TexCoord1hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1hNV(Half s) => _TexCoord1hNV_fnptr(s);
            [UnmanagedCallersOnly]
            private static void TexCoord1hNV_Lazy(Half s)
            {
                _TexCoord1hNV_fnptr = (delegate* unmanaged<Half, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1hNV");
                _TexCoord1hNV_fnptr(s);
            }
            
            private static delegate* unmanaged<Half*, void> _TexCoord1hvNV_fnptr = &TexCoord1hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1hvNV(Half* v) => _TexCoord1hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void TexCoord1hvNV_Lazy(Half* v)
            {
                _TexCoord1hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1hvNV");
                _TexCoord1hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, Half, void> _TexCoord2hNV_fnptr = &TexCoord2hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2hNV(Half s, Half t) => _TexCoord2hNV_fnptr(s, t);
            [UnmanagedCallersOnly]
            private static void TexCoord2hNV_Lazy(Half s, Half t)
            {
                _TexCoord2hNV_fnptr = (delegate* unmanaged<Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2hNV");
                _TexCoord2hNV_fnptr(s, t);
            }
            
            private static delegate* unmanaged<Half*, void> _TexCoord2hvNV_fnptr = &TexCoord2hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2hvNV(Half* v) => _TexCoord2hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void TexCoord2hvNV_Lazy(Half* v)
            {
                _TexCoord2hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2hvNV");
                _TexCoord2hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, Half, Half, void> _TexCoord3hNV_fnptr = &TexCoord3hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3hNV(Half s, Half t, Half r) => _TexCoord3hNV_fnptr(s, t, r);
            [UnmanagedCallersOnly]
            private static void TexCoord3hNV_Lazy(Half s, Half t, Half r)
            {
                _TexCoord3hNV_fnptr = (delegate* unmanaged<Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3hNV");
                _TexCoord3hNV_fnptr(s, t, r);
            }
            
            private static delegate* unmanaged<Half*, void> _TexCoord3hvNV_fnptr = &TexCoord3hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3hvNV(Half* v) => _TexCoord3hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void TexCoord3hvNV_Lazy(Half* v)
            {
                _TexCoord3hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3hvNV");
                _TexCoord3hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, Half, Half, Half, void> _TexCoord4hNV_fnptr = &TexCoord4hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4hNV(Half s, Half t, Half r, Half q) => _TexCoord4hNV_fnptr(s, t, r, q);
            [UnmanagedCallersOnly]
            private static void TexCoord4hNV_Lazy(Half s, Half t, Half r, Half q)
            {
                _TexCoord4hNV_fnptr = (delegate* unmanaged<Half, Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4hNV");
                _TexCoord4hNV_fnptr(s, t, r, q);
            }
            
            private static delegate* unmanaged<Half*, void> _TexCoord4hvNV_fnptr = &TexCoord4hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4hvNV(Half* v) => _TexCoord4hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void TexCoord4hvNV_Lazy(Half* v)
            {
                _TexCoord4hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4hvNV");
                _TexCoord4hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<TextureUnit, Half, void> _MultiTexCoord1hNV_fnptr = &MultiTexCoord1hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1hNV(TextureUnit target, Half s) => _MultiTexCoord1hNV_fnptr(target, s);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1hNV_Lazy(TextureUnit target, Half s)
            {
                _MultiTexCoord1hNV_fnptr = (delegate* unmanaged<TextureUnit, Half, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1hNV");
                _MultiTexCoord1hNV_fnptr(target, s);
            }
            
            private static delegate* unmanaged<TextureUnit, Half*, void> _MultiTexCoord1hvNV_fnptr = &MultiTexCoord1hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1hvNV(TextureUnit target, Half* v) => _MultiTexCoord1hvNV_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1hvNV_Lazy(TextureUnit target, Half* v)
            {
                _MultiTexCoord1hvNV_fnptr = (delegate* unmanaged<TextureUnit, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1hvNV");
                _MultiTexCoord1hvNV_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, Half, Half, void> _MultiTexCoord2hNV_fnptr = &MultiTexCoord2hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2hNV(TextureUnit target, Half s, Half t) => _MultiTexCoord2hNV_fnptr(target, s, t);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2hNV_Lazy(TextureUnit target, Half s, Half t)
            {
                _MultiTexCoord2hNV_fnptr = (delegate* unmanaged<TextureUnit, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2hNV");
                _MultiTexCoord2hNV_fnptr(target, s, t);
            }
            
            private static delegate* unmanaged<TextureUnit, Half*, void> _MultiTexCoord2hvNV_fnptr = &MultiTexCoord2hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2hvNV(TextureUnit target, Half* v) => _MultiTexCoord2hvNV_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2hvNV_Lazy(TextureUnit target, Half* v)
            {
                _MultiTexCoord2hvNV_fnptr = (delegate* unmanaged<TextureUnit, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2hvNV");
                _MultiTexCoord2hvNV_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, Half, Half, Half, void> _MultiTexCoord3hNV_fnptr = &MultiTexCoord3hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3hNV(TextureUnit target, Half s, Half t, Half r) => _MultiTexCoord3hNV_fnptr(target, s, t, r);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3hNV_Lazy(TextureUnit target, Half s, Half t, Half r)
            {
                _MultiTexCoord3hNV_fnptr = (delegate* unmanaged<TextureUnit, Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3hNV");
                _MultiTexCoord3hNV_fnptr(target, s, t, r);
            }
            
            private static delegate* unmanaged<TextureUnit, Half*, void> _MultiTexCoord3hvNV_fnptr = &MultiTexCoord3hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3hvNV(TextureUnit target, Half* v) => _MultiTexCoord3hvNV_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3hvNV_Lazy(TextureUnit target, Half* v)
            {
                _MultiTexCoord3hvNV_fnptr = (delegate* unmanaged<TextureUnit, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3hvNV");
                _MultiTexCoord3hvNV_fnptr(target, v);
            }
            
            private static delegate* unmanaged<TextureUnit, Half, Half, Half, Half, void> _MultiTexCoord4hNV_fnptr = &MultiTexCoord4hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4hNV(TextureUnit target, Half s, Half t, Half r, Half q) => _MultiTexCoord4hNV_fnptr(target, s, t, r, q);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4hNV_Lazy(TextureUnit target, Half s, Half t, Half r, Half q)
            {
                _MultiTexCoord4hNV_fnptr = (delegate* unmanaged<TextureUnit, Half, Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4hNV");
                _MultiTexCoord4hNV_fnptr(target, s, t, r, q);
            }
            
            private static delegate* unmanaged<TextureUnit, Half*, void> _MultiTexCoord4hvNV_fnptr = &MultiTexCoord4hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4hvNV(TextureUnit target, Half* v) => _MultiTexCoord4hvNV_fnptr(target, v);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4hvNV_Lazy(TextureUnit target, Half* v)
            {
                _MultiTexCoord4hvNV_fnptr = (delegate* unmanaged<TextureUnit, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4hvNV");
                _MultiTexCoord4hvNV_fnptr(target, v);
            }
            
            private static delegate* unmanaged<Half, void> _FogCoordhNV_fnptr = &FogCoordhNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordhNV(Half fog) => _FogCoordhNV_fnptr(fog);
            [UnmanagedCallersOnly]
            private static void FogCoordhNV_Lazy(Half fog)
            {
                _FogCoordhNV_fnptr = (delegate* unmanaged<Half, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordhNV");
                _FogCoordhNV_fnptr(fog);
            }
            
            private static delegate* unmanaged<Half*, void> _FogCoordhvNV_fnptr = &FogCoordhvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordhvNV(Half* fog) => _FogCoordhvNV_fnptr(fog);
            [UnmanagedCallersOnly]
            private static void FogCoordhvNV_Lazy(Half* fog)
            {
                _FogCoordhvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordhvNV");
                _FogCoordhvNV_fnptr(fog);
            }
            
            private static delegate* unmanaged<Half, Half, Half, void> _SecondaryColor3hNV_fnptr = &SecondaryColor3hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3hNV(Half red, Half green, Half blue) => _SecondaryColor3hNV_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3hNV_Lazy(Half red, Half green, Half blue)
            {
                _SecondaryColor3hNV_fnptr = (delegate* unmanaged<Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3hNV");
                _SecondaryColor3hNV_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<Half*, void> _SecondaryColor3hvNV_fnptr = &SecondaryColor3hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3hvNV(Half* v) => _SecondaryColor3hvNV_fnptr(v);
            [UnmanagedCallersOnly]
            private static void SecondaryColor3hvNV_Lazy(Half* v)
            {
                _SecondaryColor3hvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColor3hvNV");
                _SecondaryColor3hvNV_fnptr(v);
            }
            
            private static delegate* unmanaged<Half, void> _VertexWeighthNV_fnptr = &VertexWeighthNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeighthNV(Half weight) => _VertexWeighthNV_fnptr(weight);
            [UnmanagedCallersOnly]
            private static void VertexWeighthNV_Lazy(Half weight)
            {
                _VertexWeighthNV_fnptr = (delegate* unmanaged<Half, void>)GLLoader.BindingsContext.GetProcAddress("glVertexWeighthNV");
                _VertexWeighthNV_fnptr(weight);
            }
            
            private static delegate* unmanaged<Half*, void> _VertexWeighthvNV_fnptr = &VertexWeighthvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeighthvNV(Half* weight) => _VertexWeighthvNV_fnptr(weight);
            [UnmanagedCallersOnly]
            private static void VertexWeighthvNV_Lazy(Half* weight)
            {
                _VertexWeighthvNV_fnptr = (delegate* unmanaged<Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexWeighthvNV");
                _VertexWeighthvNV_fnptr(weight);
            }
            
            private static delegate* unmanaged<uint, Half, void> _VertexAttrib1hNV_fnptr = &VertexAttrib1hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1hNV(uint index, Half x) => _VertexAttrib1hNV_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1hNV_Lazy(uint index, Half x)
            {
                _VertexAttrib1hNV_fnptr = (delegate* unmanaged<uint, Half, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1hNV");
                _VertexAttrib1hNV_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, Half*, void> _VertexAttrib1hvNV_fnptr = &VertexAttrib1hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1hvNV(uint index, Half* v) => _VertexAttrib1hvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1hvNV_Lazy(uint index, Half* v)
            {
                _VertexAttrib1hvNV_fnptr = (delegate* unmanaged<uint, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1hvNV");
                _VertexAttrib1hvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, Half, Half, void> _VertexAttrib2hNV_fnptr = &VertexAttrib2hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2hNV(uint index, Half x, Half y) => _VertexAttrib2hNV_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2hNV_Lazy(uint index, Half x, Half y)
            {
                _VertexAttrib2hNV_fnptr = (delegate* unmanaged<uint, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2hNV");
                _VertexAttrib2hNV_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, Half*, void> _VertexAttrib2hvNV_fnptr = &VertexAttrib2hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2hvNV(uint index, Half* v) => _VertexAttrib2hvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2hvNV_Lazy(uint index, Half* v)
            {
                _VertexAttrib2hvNV_fnptr = (delegate* unmanaged<uint, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2hvNV");
                _VertexAttrib2hvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, Half, Half, Half, void> _VertexAttrib3hNV_fnptr = &VertexAttrib3hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3hNV(uint index, Half x, Half y, Half z) => _VertexAttrib3hNV_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3hNV_Lazy(uint index, Half x, Half y, Half z)
            {
                _VertexAttrib3hNV_fnptr = (delegate* unmanaged<uint, Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3hNV");
                _VertexAttrib3hNV_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, Half*, void> _VertexAttrib3hvNV_fnptr = &VertexAttrib3hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3hvNV(uint index, Half* v) => _VertexAttrib3hvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3hvNV_Lazy(uint index, Half* v)
            {
                _VertexAttrib3hvNV_fnptr = (delegate* unmanaged<uint, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3hvNV");
                _VertexAttrib3hvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, Half, Half, Half, Half, void> _VertexAttrib4hNV_fnptr = &VertexAttrib4hNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4hNV(uint index, Half x, Half y, Half z, Half w) => _VertexAttrib4hNV_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4hNV_Lazy(uint index, Half x, Half y, Half z, Half w)
            {
                _VertexAttrib4hNV_fnptr = (delegate* unmanaged<uint, Half, Half, Half, Half, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4hNV");
                _VertexAttrib4hNV_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, Half*, void> _VertexAttrib4hvNV_fnptr = &VertexAttrib4hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4hvNV(uint index, Half* v) => _VertexAttrib4hvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4hvNV_Lazy(uint index, Half* v)
            {
                _VertexAttrib4hvNV_fnptr = (delegate* unmanaged<uint, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4hvNV");
                _VertexAttrib4hvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int, Half*, void> _VertexAttribs1hvNV_fnptr = &VertexAttribs1hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs1hvNV(uint index, int n, Half* v) => _VertexAttribs1hvNV_fnptr(index, n, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs1hvNV_Lazy(uint index, int n, Half* v)
            {
                _VertexAttribs1hvNV_fnptr = (delegate* unmanaged<uint, int, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs1hvNV");
                _VertexAttribs1hvNV_fnptr(index, n, v);
            }
            
            private static delegate* unmanaged<uint, int, Half*, void> _VertexAttribs2hvNV_fnptr = &VertexAttribs2hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs2hvNV(uint index, int n, Half* v) => _VertexAttribs2hvNV_fnptr(index, n, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs2hvNV_Lazy(uint index, int n, Half* v)
            {
                _VertexAttribs2hvNV_fnptr = (delegate* unmanaged<uint, int, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs2hvNV");
                _VertexAttribs2hvNV_fnptr(index, n, v);
            }
            
            private static delegate* unmanaged<uint, int, Half*, void> _VertexAttribs3hvNV_fnptr = &VertexAttribs3hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs3hvNV(uint index, int n, Half* v) => _VertexAttribs3hvNV_fnptr(index, n, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs3hvNV_Lazy(uint index, int n, Half* v)
            {
                _VertexAttribs3hvNV_fnptr = (delegate* unmanaged<uint, int, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs3hvNV");
                _VertexAttribs3hvNV_fnptr(index, n, v);
            }
            
            private static delegate* unmanaged<uint, int, Half*, void> _VertexAttribs4hvNV_fnptr = &VertexAttribs4hvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4hvNV(uint index, int n, Half* v) => _VertexAttribs4hvNV_fnptr(index, n, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs4hvNV_Lazy(uint index, int n, Half* v)
            {
                _VertexAttribs4hvNV_fnptr = (delegate* unmanaged<uint, int, Half*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs4hvNV");
                _VertexAttribs4hvNV_fnptr(index, n, v);
            }
            
            private static delegate* unmanaged<TextureTarget, InternalFormat, int, InternalFormatPName, int, int*, void> _GetInternalformatSampleivNV_fnptr = &GetInternalformatSampleivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_internalformat_sample_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, int* parameters) => _GetInternalformatSampleivNV_fnptr(target, internalformat, samples, pname, count, parameters);
            [UnmanagedCallersOnly]
            private static void GetInternalformatSampleivNV_Lazy(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, int* parameters)
            {
                _GetInternalformatSampleivNV_fnptr = (delegate* unmanaged<TextureTarget, InternalFormat, int, InternalFormatPName, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetInternalformatSampleivNV");
                _GetInternalformatSampleivNV_fnptr(target, internalformat, samples, pname, count, parameters);
            }
            
            private static delegate* unmanaged<All, void> _RenderGpuMaskNV_fnptr = &RenderGpuMaskNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderGpuMaskNV(All mask) => _RenderGpuMaskNV_fnptr(mask);
            [UnmanagedCallersOnly]
            private static void RenderGpuMaskNV_Lazy(All mask)
            {
                _RenderGpuMaskNV_fnptr = (delegate* unmanaged<All, void>)GLLoader.BindingsContext.GetProcAddress("glRenderGpuMaskNV");
                _RenderGpuMaskNV_fnptr(mask);
            }
            
            private static delegate* unmanaged<All, BufferHandle, IntPtr, nint, void*, void> _MulticastBufferSubDataNV_fnptr = &MulticastBufferSubDataNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastBufferSubDataNV(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, void* data) => _MulticastBufferSubDataNV_fnptr(gpuMask, buffer, offset, size, data);
            [UnmanagedCallersOnly]
            private static void MulticastBufferSubDataNV_Lazy(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, void* data)
            {
                _MulticastBufferSubDataNV_fnptr = (delegate* unmanaged<All, BufferHandle, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastBufferSubDataNV");
                _MulticastBufferSubDataNV_fnptr(gpuMask, buffer, offset, size, data);
            }
            
            private static delegate* unmanaged<uint, All, BufferHandle, BufferHandle, IntPtr, IntPtr, nint, void> _MulticastCopyBufferSubDataNV_fnptr = &MulticastCopyBufferSubDataNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastCopyBufferSubDataNV(uint readGpu, All writeGpuMask, BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => _MulticastCopyBufferSubDataNV_fnptr(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
            [UnmanagedCallersOnly]
            private static void MulticastCopyBufferSubDataNV_Lazy(uint readGpu, All writeGpuMask, BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size)
            {
                _MulticastCopyBufferSubDataNV_fnptr = (delegate* unmanaged<uint, All, BufferHandle, BufferHandle, IntPtr, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastCopyBufferSubDataNV");
                _MulticastCopyBufferSubDataNV_fnptr(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
            }
            
            private static delegate* unmanaged<uint, All, uint, All, int, int, int, int, uint, All, int, int, int, int, int, int, int, void> _MulticastCopyImageSubDataNV_fnptr = &MulticastCopyImageSubDataNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastCopyImageSubDataNV(uint srcGpu, All dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => _MulticastCopyImageSubDataNV_fnptr(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            [UnmanagedCallersOnly]
            private static void MulticastCopyImageSubDataNV_Lazy(uint srcGpu, All dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
            {
                _MulticastCopyImageSubDataNV_fnptr = (delegate* unmanaged<uint, All, uint, All, int, int, int, int, uint, All, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastCopyImageSubDataNV");
                _MulticastCopyImageSubDataNV_fnptr(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            }
            
            private static delegate* unmanaged<uint, uint, int, int, int, int, int, int, int, int, ClearBufferMask, All, void> _MulticastBlitFramebufferNV_fnptr = &MulticastBlitFramebufferNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, All filter) => _MulticastBlitFramebufferNV_fnptr(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            [UnmanagedCallersOnly]
            private static void MulticastBlitFramebufferNV_Lazy(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, All filter)
            {
                _MulticastBlitFramebufferNV_fnptr = (delegate* unmanaged<uint, uint, int, int, int, int, int, int, int, int, ClearBufferMask, All, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastBlitFramebufferNV");
                _MulticastBlitFramebufferNV_fnptr(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            }
            
            private static delegate* unmanaged<uint, FramebufferHandle, uint, int, float*, void> _MulticastFramebufferSampleLocationsfvNV_fnptr = &MulticastFramebufferSampleLocationsfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastFramebufferSampleLocationsfvNV(uint gpu, FramebufferHandle framebuffer, uint start, int count, float* v) => _MulticastFramebufferSampleLocationsfvNV_fnptr(gpu, framebuffer, start, count, v);
            [UnmanagedCallersOnly]
            private static void MulticastFramebufferSampleLocationsfvNV_Lazy(uint gpu, FramebufferHandle framebuffer, uint start, int count, float* v)
            {
                _MulticastFramebufferSampleLocationsfvNV_fnptr = (delegate* unmanaged<uint, FramebufferHandle, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastFramebufferSampleLocationsfvNV");
                _MulticastFramebufferSampleLocationsfvNV_fnptr(gpu, framebuffer, start, count, v);
            }
            
            private static delegate* unmanaged<void> _MulticastBarrierNV_fnptr = &MulticastBarrierNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastBarrierNV() => _MulticastBarrierNV_fnptr();
            [UnmanagedCallersOnly]
            private static void MulticastBarrierNV_Lazy()
            {
                _MulticastBarrierNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glMulticastBarrierNV");
                _MulticastBarrierNV_fnptr();
            }
            
            private static delegate* unmanaged<uint, All, void> _MulticastWaitSyncNV_fnptr = &MulticastWaitSyncNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastWaitSyncNV(uint signalGpu, All waitGpuMask) => _MulticastWaitSyncNV_fnptr(signalGpu, waitGpuMask);
            [UnmanagedCallersOnly]
            private static void MulticastWaitSyncNV_Lazy(uint signalGpu, All waitGpuMask)
            {
                _MulticastWaitSyncNV_fnptr = (delegate* unmanaged<uint, All, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastWaitSyncNV");
                _MulticastWaitSyncNV_fnptr(signalGpu, waitGpuMask);
            }
            
            private static delegate* unmanaged<uint, uint, All, int*, void> _MulticastGetQueryObjectivNV_fnptr = &MulticastGetQueryObjectivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastGetQueryObjectivNV(uint gpu, uint id, All pname, int* parameters) => _MulticastGetQueryObjectivNV_fnptr(gpu, id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MulticastGetQueryObjectivNV_Lazy(uint gpu, uint id, All pname, int* parameters)
            {
                _MulticastGetQueryObjectivNV_fnptr = (delegate* unmanaged<uint, uint, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastGetQueryObjectivNV");
                _MulticastGetQueryObjectivNV_fnptr(gpu, id, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint, All, uint*, void> _MulticastGetQueryObjectuivNV_fnptr = &MulticastGetQueryObjectuivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastGetQueryObjectuivNV(uint gpu, uint id, All pname, uint* parameters) => _MulticastGetQueryObjectuivNV_fnptr(gpu, id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MulticastGetQueryObjectuivNV_Lazy(uint gpu, uint id, All pname, uint* parameters)
            {
                _MulticastGetQueryObjectuivNV_fnptr = (delegate* unmanaged<uint, uint, All, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastGetQueryObjectuivNV");
                _MulticastGetQueryObjectuivNV_fnptr(gpu, id, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint, All, long*, void> _MulticastGetQueryObjecti64vNV_fnptr = &MulticastGetQueryObjecti64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastGetQueryObjecti64vNV(uint gpu, uint id, All pname, long* parameters) => _MulticastGetQueryObjecti64vNV_fnptr(gpu, id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MulticastGetQueryObjecti64vNV_Lazy(uint gpu, uint id, All pname, long* parameters)
            {
                _MulticastGetQueryObjecti64vNV_fnptr = (delegate* unmanaged<uint, uint, All, long*, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastGetQueryObjecti64vNV");
                _MulticastGetQueryObjecti64vNV_fnptr(gpu, id, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint, All, ulong*, void> _MulticastGetQueryObjectui64vNV_fnptr = &MulticastGetQueryObjectui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastGetQueryObjectui64vNV(uint gpu, uint id, All pname, ulong* parameters) => _MulticastGetQueryObjectui64vNV_fnptr(gpu, id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void MulticastGetQueryObjectui64vNV_Lazy(uint gpu, uint id, All pname, ulong* parameters)
            {
                _MulticastGetQueryObjectui64vNV_fnptr = (delegate* unmanaged<uint, uint, All, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastGetQueryObjectui64vNV");
                _MulticastGetQueryObjectui64vNV_fnptr(gpu, id, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, All, int, int, uint*, void> _GetMemoryObjectDetachedResourcesuivNV_fnptr = &GetMemoryObjectDetachedResourcesuivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMemoryObjectDetachedResourcesuivNV(uint memory, All pname, int first, int count, uint* parameters) => _GetMemoryObjectDetachedResourcesuivNV_fnptr(memory, pname, first, count, parameters);
            [UnmanagedCallersOnly]
            private static void GetMemoryObjectDetachedResourcesuivNV_Lazy(uint memory, All pname, int first, int count, uint* parameters)
            {
                _GetMemoryObjectDetachedResourcesuivNV_fnptr = (delegate* unmanaged<uint, All, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMemoryObjectDetachedResourcesuivNV");
                _GetMemoryObjectDetachedResourcesuivNV_fnptr(memory, pname, first, count, parameters);
            }
            
            private static delegate* unmanaged<uint, All, void> _ResetMemoryObjectParameterNV_fnptr = &ResetMemoryObjectParameterNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResetMemoryObjectParameterNV(uint memory, All pname) => _ResetMemoryObjectParameterNV_fnptr(memory, pname);
            [UnmanagedCallersOnly]
            private static void ResetMemoryObjectParameterNV_Lazy(uint memory, All pname)
            {
                _ResetMemoryObjectParameterNV_fnptr = (delegate* unmanaged<uint, All, void>)GLLoader.BindingsContext.GetProcAddress("glResetMemoryObjectParameterNV");
                _ResetMemoryObjectParameterNV_fnptr(memory, pname);
            }
            
            private static delegate* unmanaged<TextureTarget, uint, ulong, void> _TexAttachMemoryNV_fnptr = &TexAttachMemoryNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexAttachMemoryNV(TextureTarget target, uint memory, ulong offset) => _TexAttachMemoryNV_fnptr(target, memory, offset);
            [UnmanagedCallersOnly]
            private static void TexAttachMemoryNV_Lazy(TextureTarget target, uint memory, ulong offset)
            {
                _TexAttachMemoryNV_fnptr = (delegate* unmanaged<TextureTarget, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTexAttachMemoryNV");
                _TexAttachMemoryNV_fnptr(target, memory, offset);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, ulong, void> _BufferAttachMemoryNV_fnptr = &BufferAttachMemoryNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferAttachMemoryNV(BufferTargetARB target, uint memory, ulong offset) => _BufferAttachMemoryNV_fnptr(target, memory, offset);
            [UnmanagedCallersOnly]
            private static void BufferAttachMemoryNV_Lazy(BufferTargetARB target, uint memory, ulong offset)
            {
                _BufferAttachMemoryNV_fnptr = (delegate* unmanaged<BufferTargetARB, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glBufferAttachMemoryNV");
                _BufferAttachMemoryNV_fnptr(target, memory, offset);
            }
            
            private static delegate* unmanaged<TextureHandle, uint, ulong, void> _TextureAttachMemoryNV_fnptr = &TextureAttachMemoryNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureAttachMemoryNV(TextureHandle texture, uint memory, ulong offset) => _TextureAttachMemoryNV_fnptr(texture, memory, offset);
            [UnmanagedCallersOnly]
            private static void TextureAttachMemoryNV_Lazy(TextureHandle texture, uint memory, ulong offset)
            {
                _TextureAttachMemoryNV_fnptr = (delegate* unmanaged<TextureHandle, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glTextureAttachMemoryNV");
                _TextureAttachMemoryNV_fnptr(texture, memory, offset);
            }
            
            private static delegate* unmanaged<BufferHandle, uint, ulong, void> _NamedBufferAttachMemoryNV_fnptr = &NamedBufferAttachMemoryNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferAttachMemoryNV(BufferHandle buffer, uint memory, ulong offset) => _NamedBufferAttachMemoryNV_fnptr(buffer, memory, offset);
            [UnmanagedCallersOnly]
            private static void NamedBufferAttachMemoryNV_Lazy(BufferHandle buffer, uint memory, ulong offset)
            {
                _NamedBufferAttachMemoryNV_fnptr = (delegate* unmanaged<BufferHandle, uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferAttachMemoryNV");
                _NamedBufferAttachMemoryNV_fnptr(buffer, memory, offset);
            }
            
            private static delegate* unmanaged<BufferStorageTarget, IntPtr, nint, uint, ulong, byte, void> _BufferPageCommitmentMemNV_fnptr = &BufferPageCommitmentMemNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferPageCommitmentMemNV(BufferStorageTarget target, IntPtr offset, nint size, uint memory, ulong memOffset, byte commit) => _BufferPageCommitmentMemNV_fnptr(target, offset, size, memory, memOffset, commit);
            [UnmanagedCallersOnly]
            private static void BufferPageCommitmentMemNV_Lazy(BufferStorageTarget target, IntPtr offset, nint size, uint memory, ulong memOffset, byte commit)
            {
                _BufferPageCommitmentMemNV_fnptr = (delegate* unmanaged<BufferStorageTarget, IntPtr, nint, uint, ulong, byte, void>)GLLoader.BindingsContext.GetProcAddress("glBufferPageCommitmentMemNV");
                _BufferPageCommitmentMemNV_fnptr(target, offset, size, memory, memOffset, commit);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, int, uint, ulong, byte, void> _TexPageCommitmentMemNV_fnptr = &TexPageCommitmentMemNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexPageCommitmentMemNV(TextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit) => _TexPageCommitmentMemNV_fnptr(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
            [UnmanagedCallersOnly]
            private static void TexPageCommitmentMemNV_Lazy(TextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
            {
                _TexPageCommitmentMemNV_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexPageCommitmentMemNV");
                _TexPageCommitmentMemNV_fnptr(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
            }
            
            private static delegate* unmanaged<BufferHandle, IntPtr, nint, uint, ulong, byte, void> _NamedBufferPageCommitmentMemNV_fnptr = &NamedBufferPageCommitmentMemNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferPageCommitmentMemNV(BufferHandle buffer, IntPtr offset, nint size, uint memory, ulong memOffset, byte commit) => _NamedBufferPageCommitmentMemNV_fnptr(buffer, offset, size, memory, memOffset, commit);
            [UnmanagedCallersOnly]
            private static void NamedBufferPageCommitmentMemNV_Lazy(BufferHandle buffer, IntPtr offset, nint size, uint memory, ulong memOffset, byte commit)
            {
                _NamedBufferPageCommitmentMemNV_fnptr = (delegate* unmanaged<BufferHandle, IntPtr, nint, uint, ulong, byte, void>)GLLoader.BindingsContext.GetProcAddress("glNamedBufferPageCommitmentMemNV");
                _NamedBufferPageCommitmentMemNV_fnptr(buffer, offset, size, memory, memOffset, commit);
            }
            
            private static delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, uint, ulong, byte, void> _TexturePageCommitmentMemNV_fnptr = &TexturePageCommitmentMemNV_Lazy;
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexturePageCommitmentMemNV(TextureHandle texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit) => _TexturePageCommitmentMemNV_fnptr(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
            [UnmanagedCallersOnly]
            private static void TexturePageCommitmentMemNV_Lazy(TextureHandle texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
            {
                _TexturePageCommitmentMemNV_fnptr = (delegate* unmanaged<TextureHandle, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexturePageCommitmentMemNV");
                _TexturePageCommitmentMemNV_fnptr(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
            }
            
            private static delegate* unmanaged<uint, uint, void> _DrawMeshTasksNV_fnptr = &DrawMeshTasksNV_Lazy;
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawMeshTasksNV(uint first, uint count) => _DrawMeshTasksNV_fnptr(first, count);
            [UnmanagedCallersOnly]
            private static void DrawMeshTasksNV_Lazy(uint first, uint count)
            {
                _DrawMeshTasksNV_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glDrawMeshTasksNV");
                _DrawMeshTasksNV_fnptr(first, count);
            }
            
            private static delegate* unmanaged<IntPtr, void> _DrawMeshTasksIndirectNV_fnptr = &DrawMeshTasksIndirectNV_Lazy;
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawMeshTasksIndirectNV(IntPtr indirect) => _DrawMeshTasksIndirectNV_fnptr(indirect);
            [UnmanagedCallersOnly]
            private static void DrawMeshTasksIndirectNV_Lazy(IntPtr indirect)
            {
                _DrawMeshTasksIndirectNV_fnptr = (delegate* unmanaged<IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glDrawMeshTasksIndirectNV");
                _DrawMeshTasksIndirectNV_fnptr(indirect);
            }
            
            private static delegate* unmanaged<IntPtr, int, int, void> _MultiDrawMeshTasksIndirectNV_fnptr = &MultiDrawMeshTasksIndirectNV_Lazy;
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawMeshTasksIndirectNV(IntPtr indirect, int drawcount, int stride) => _MultiDrawMeshTasksIndirectNV_fnptr(indirect, drawcount, stride);
            [UnmanagedCallersOnly]
            private static void MultiDrawMeshTasksIndirectNV_Lazy(IntPtr indirect, int drawcount, int stride)
            {
                _MultiDrawMeshTasksIndirectNV_fnptr = (delegate* unmanaged<IntPtr, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawMeshTasksIndirectNV");
                _MultiDrawMeshTasksIndirectNV_fnptr(indirect, drawcount, stride);
            }
            
            private static delegate* unmanaged<IntPtr, IntPtr, int, int, void> _MultiDrawMeshTasksIndirectCountNV_fnptr = &MultiDrawMeshTasksIndirectCountNV_Lazy;
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawMeshTasksIndirectCountNV(IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawMeshTasksIndirectCountNV_fnptr(indirect, drawcount, maxdrawcount, stride);
            [UnmanagedCallersOnly]
            private static void MultiDrawMeshTasksIndirectCountNV_Lazy(IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride)
            {
                _MultiDrawMeshTasksIndirectCountNV_fnptr = (delegate* unmanaged<IntPtr, IntPtr, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiDrawMeshTasksIndirectCountNV");
                _MultiDrawMeshTasksIndirectCountNV_fnptr(indirect, drawcount, maxdrawcount, stride);
            }
            
            private static delegate* unmanaged<int, uint*, void> _GenOcclusionQueriesNV_fnptr = &GenOcclusionQueriesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenOcclusionQueriesNV(int n, uint* ids) => _GenOcclusionQueriesNV_fnptr(n, ids);
            [UnmanagedCallersOnly]
            private static void GenOcclusionQueriesNV_Lazy(int n, uint* ids)
            {
                _GenOcclusionQueriesNV_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGenOcclusionQueriesNV");
                _GenOcclusionQueriesNV_fnptr(n, ids);
            }
            
            private static delegate* unmanaged<int, uint*, void> _DeleteOcclusionQueriesNV_fnptr = &DeleteOcclusionQueriesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteOcclusionQueriesNV(int n, uint* ids) => _DeleteOcclusionQueriesNV_fnptr(n, ids);
            [UnmanagedCallersOnly]
            private static void DeleteOcclusionQueriesNV_Lazy(int n, uint* ids)
            {
                _DeleteOcclusionQueriesNV_fnptr = (delegate* unmanaged<int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteOcclusionQueriesNV");
                _DeleteOcclusionQueriesNV_fnptr(n, ids);
            }
            
            private static delegate* unmanaged<uint, byte> _IsOcclusionQueryNV_fnptr = &IsOcclusionQueryNV_Lazy;
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsOcclusionQueryNV(uint id) => _IsOcclusionQueryNV_fnptr(id);
            [UnmanagedCallersOnly]
            private static byte IsOcclusionQueryNV_Lazy(uint id)
            {
                _IsOcclusionQueryNV_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsOcclusionQueryNV");
                return _IsOcclusionQueryNV_fnptr(id);
            }
            
            private static delegate* unmanaged<uint, void> _BeginOcclusionQueryNV_fnptr = &BeginOcclusionQueryNV_Lazy;
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginOcclusionQueryNV(uint id) => _BeginOcclusionQueryNV_fnptr(id);
            [UnmanagedCallersOnly]
            private static void BeginOcclusionQueryNV_Lazy(uint id)
            {
                _BeginOcclusionQueryNV_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glBeginOcclusionQueryNV");
                _BeginOcclusionQueryNV_fnptr(id);
            }
            
            private static delegate* unmanaged<void> _EndOcclusionQueryNV_fnptr = &EndOcclusionQueryNV_Lazy;
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndOcclusionQueryNV() => _EndOcclusionQueryNV_fnptr();
            [UnmanagedCallersOnly]
            private static void EndOcclusionQueryNV_Lazy()
            {
                _EndOcclusionQueryNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndOcclusionQueryNV");
                _EndOcclusionQueryNV_fnptr();
            }
            
            private static delegate* unmanaged<uint, OcclusionQueryParameterNameNV, int*, void> _GetOcclusionQueryivNV_fnptr = &GetOcclusionQueryivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, int* parameters) => _GetOcclusionQueryivNV_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetOcclusionQueryivNV_Lazy(uint id, OcclusionQueryParameterNameNV pname, int* parameters)
            {
                _GetOcclusionQueryivNV_fnptr = (delegate* unmanaged<uint, OcclusionQueryParameterNameNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetOcclusionQueryivNV");
                _GetOcclusionQueryivNV_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, OcclusionQueryParameterNameNV, uint*, void> _GetOcclusionQueryuivNV_fnptr = &GetOcclusionQueryuivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, uint* parameters) => _GetOcclusionQueryuivNV_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetOcclusionQueryuivNV_Lazy(uint id, OcclusionQueryParameterNameNV pname, uint* parameters)
            {
                _GetOcclusionQueryuivNV_fnptr = (delegate* unmanaged<uint, OcclusionQueryParameterNameNV, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetOcclusionQueryuivNV");
                _GetOcclusionQueryuivNV_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, uint, int, float*, void> _ProgramBufferParametersfvNV_fnptr = &ProgramBufferParametersfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, float* parameters) => _ProgramBufferParametersfvNV_fnptr(target, bindingIndex, wordIndex, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramBufferParametersfvNV_Lazy(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, float* parameters)
            {
                _ProgramBufferParametersfvNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramBufferParametersfvNV");
                _ProgramBufferParametersfvNV_fnptr(target, bindingIndex, wordIndex, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, uint, int, int*, void> _ProgramBufferParametersIivNV_fnptr = &ProgramBufferParametersIivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, int* parameters) => _ProgramBufferParametersIivNV_fnptr(target, bindingIndex, wordIndex, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramBufferParametersIivNV_Lazy(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, int* parameters)
            {
                _ProgramBufferParametersIivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, uint, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramBufferParametersIivNV");
                _ProgramBufferParametersIivNV_fnptr(target, bindingIndex, wordIndex, count, parameters);
            }
            
            private static delegate* unmanaged<ProgramTarget, uint, uint, int, uint*, void> _ProgramBufferParametersIuivNV_fnptr = &ProgramBufferParametersIuivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, uint* parameters) => _ProgramBufferParametersIuivNV_fnptr(target, bindingIndex, wordIndex, count, parameters);
            [UnmanagedCallersOnly]
            private static void ProgramBufferParametersIuivNV_Lazy(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, uint* parameters)
            {
                _ProgramBufferParametersIuivNV_fnptr = (delegate* unmanaged<ProgramTarget, uint, uint, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramBufferParametersIuivNV");
                _ProgramBufferParametersIuivNV_fnptr(target, bindingIndex, wordIndex, count, parameters);
            }
            
            private static delegate* unmanaged<int, uint> _GenPathsNV_fnptr = &GenPathsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenPathsNV(int range) => _GenPathsNV_fnptr(range);
            [UnmanagedCallersOnly]
            private static uint GenPathsNV_Lazy(int range)
            {
                _GenPathsNV_fnptr = (delegate* unmanaged<int, uint>)GLLoader.BindingsContext.GetProcAddress("glGenPathsNV");
                return _GenPathsNV_fnptr(range);
            }
            
            private static delegate* unmanaged<uint, int, void> _DeletePathsNV_fnptr = &DeletePathsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeletePathsNV(uint path, int range) => _DeletePathsNV_fnptr(path, range);
            [UnmanagedCallersOnly]
            private static void DeletePathsNV_Lazy(uint path, int range)
            {
                _DeletePathsNV_fnptr = (delegate* unmanaged<uint, int, void>)GLLoader.BindingsContext.GetProcAddress("glDeletePathsNV");
                _DeletePathsNV_fnptr(path, range);
            }
            
            private static delegate* unmanaged<uint, byte> _IsPathNV_fnptr = &IsPathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsPathNV(uint path) => _IsPathNV_fnptr(path);
            [UnmanagedCallersOnly]
            private static byte IsPathNV_Lazy(uint path)
            {
                _IsPathNV_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsPathNV");
                return _IsPathNV_fnptr(path);
            }
            
            private static delegate* unmanaged<uint, int, byte*, int, PathCoordType, void*, void> _PathCommandsNV_fnptr = &PathCommandsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathCommandsNV(uint path, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => _PathCommandsNV_fnptr(path, numCommands, commands, numCoords, coordType, coords);
            [UnmanagedCallersOnly]
            private static void PathCommandsNV_Lazy(uint path, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords)
            {
                _PathCommandsNV_fnptr = (delegate* unmanaged<uint, int, byte*, int, PathCoordType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glPathCommandsNV");
                _PathCommandsNV_fnptr(path, numCommands, commands, numCoords, coordType, coords);
            }
            
            private static delegate* unmanaged<uint, int, PathCoordType, void*, void> _PathCoordsNV_fnptr = &PathCoordsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathCoordsNV(uint path, int numCoords, PathCoordType coordType, void* coords) => _PathCoordsNV_fnptr(path, numCoords, coordType, coords);
            [UnmanagedCallersOnly]
            private static void PathCoordsNV_Lazy(uint path, int numCoords, PathCoordType coordType, void* coords)
            {
                _PathCoordsNV_fnptr = (delegate* unmanaged<uint, int, PathCoordType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glPathCoordsNV");
                _PathCoordsNV_fnptr(path, numCoords, coordType, coords);
            }
            
            private static delegate* unmanaged<uint, int, int, int, byte*, int, PathCoordType, void*, void> _PathSubCommandsNV_fnptr = &PathSubCommandsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => _PathSubCommandsNV_fnptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
            [UnmanagedCallersOnly]
            private static void PathSubCommandsNV_Lazy(uint path, int commandStart, int commandsToDelete, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords)
            {
                _PathSubCommandsNV_fnptr = (delegate* unmanaged<uint, int, int, int, byte*, int, PathCoordType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glPathSubCommandsNV");
                _PathSubCommandsNV_fnptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
            }
            
            private static delegate* unmanaged<uint, int, int, PathCoordType, void*, void> _PathSubCoordsNV_fnptr = &PathSubCoordsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathSubCoordsNV(uint path, int coordStart, int numCoords, PathCoordType coordType, void* coords) => _PathSubCoordsNV_fnptr(path, coordStart, numCoords, coordType, coords);
            [UnmanagedCallersOnly]
            private static void PathSubCoordsNV_Lazy(uint path, int coordStart, int numCoords, PathCoordType coordType, void* coords)
            {
                _PathSubCoordsNV_fnptr = (delegate* unmanaged<uint, int, int, PathCoordType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glPathSubCoordsNV");
                _PathSubCoordsNV_fnptr(path, coordStart, numCoords, coordType, coords);
            }
            
            private static delegate* unmanaged<uint, PathStringFormat, int, void*, void> _PathStringNV_fnptr = &PathStringNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathStringNV(uint path, PathStringFormat format, int length, void* pathString) => _PathStringNV_fnptr(path, format, length, pathString);
            [UnmanagedCallersOnly]
            private static void PathStringNV_Lazy(uint path, PathStringFormat format, int length, void* pathString)
            {
                _PathStringNV_fnptr = (delegate* unmanaged<uint, PathStringFormat, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glPathStringNV");
                _PathStringNV_fnptr(path, format, length, pathString);
            }
            
            private static delegate* unmanaged<uint, PathFontTarget, void*, PathFontStyle, int, PathElementType, void*, PathHandleMissingGlyphs, uint, float, void> _PathGlyphsNV_fnptr = &PathGlyphsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathGlyphsNV(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, void* charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => _PathGlyphsNV_fnptr(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
            [UnmanagedCallersOnly]
            private static void PathGlyphsNV_Lazy(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, void* charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            {
                _PathGlyphsNV_fnptr = (delegate* unmanaged<uint, PathFontTarget, void*, PathFontStyle, int, PathElementType, void*, PathHandleMissingGlyphs, uint, float, void>)GLLoader.BindingsContext.GetProcAddress("glPathGlyphsNV");
                _PathGlyphsNV_fnptr(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
            }
            
            private static delegate* unmanaged<uint, PathFontTarget, void*, PathFontStyle, uint, int, PathHandleMissingGlyphs, uint, float, void> _PathGlyphRangeNV_fnptr = &PathGlyphRangeNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathGlyphRangeNV(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => _PathGlyphRangeNV_fnptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
            [UnmanagedCallersOnly]
            private static void PathGlyphRangeNV_Lazy(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            {
                _PathGlyphRangeNV_fnptr = (delegate* unmanaged<uint, PathFontTarget, void*, PathFontStyle, uint, int, PathHandleMissingGlyphs, uint, float, void>)GLLoader.BindingsContext.GetProcAddress("glPathGlyphRangeNV");
                _PathGlyphRangeNV_fnptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
            }
            
            private static delegate* unmanaged<uint, int, uint*, float*, void> _WeightPathsNV_fnptr = &WeightPathsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightPathsNV(uint resultPath, int numPaths, uint* paths, float* weights) => _WeightPathsNV_fnptr(resultPath, numPaths, paths, weights);
            [UnmanagedCallersOnly]
            private static void WeightPathsNV_Lazy(uint resultPath, int numPaths, uint* paths, float* weights)
            {
                _WeightPathsNV_fnptr = (delegate* unmanaged<uint, int, uint*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glWeightPathsNV");
                _WeightPathsNV_fnptr(resultPath, numPaths, paths, weights);
            }
            
            private static delegate* unmanaged<uint, uint, void> _CopyPathNV_fnptr = &CopyPathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyPathNV(uint resultPath, uint srcPath) => _CopyPathNV_fnptr(resultPath, srcPath);
            [UnmanagedCallersOnly]
            private static void CopyPathNV_Lazy(uint resultPath, uint srcPath)
            {
                _CopyPathNV_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glCopyPathNV");
                _CopyPathNV_fnptr(resultPath, srcPath);
            }
            
            private static delegate* unmanaged<uint, uint, uint, float, void> _InterpolatePathsNV_fnptr = &InterpolatePathsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void InterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight) => _InterpolatePathsNV_fnptr(resultPath, pathA, pathB, weight);
            [UnmanagedCallersOnly]
            private static void InterpolatePathsNV_Lazy(uint resultPath, uint pathA, uint pathB, float weight)
            {
                _InterpolatePathsNV_fnptr = (delegate* unmanaged<uint, uint, uint, float, void>)GLLoader.BindingsContext.GetProcAddress("glInterpolatePathsNV");
                _InterpolatePathsNV_fnptr(resultPath, pathA, pathB, weight);
            }
            
            private static delegate* unmanaged<uint, uint, PathTransformType, float*, void> _TransformPathNV_fnptr = &TransformPathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, float* transformValues) => _TransformPathNV_fnptr(resultPath, srcPath, transformType, transformValues);
            [UnmanagedCallersOnly]
            private static void TransformPathNV_Lazy(uint resultPath, uint srcPath, PathTransformType transformType, float* transformValues)
            {
                _TransformPathNV_fnptr = (delegate* unmanaged<uint, uint, PathTransformType, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTransformPathNV");
                _TransformPathNV_fnptr(resultPath, srcPath, transformType, transformValues);
            }
            
            private static delegate* unmanaged<uint, PathParameter, int*, void> _PathParameterivNV_fnptr = &PathParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathParameterivNV(uint path, PathParameter pname, int* value) => _PathParameterivNV_fnptr(path, pname, value);
            [UnmanagedCallersOnly]
            private static void PathParameterivNV_Lazy(uint path, PathParameter pname, int* value)
            {
                _PathParameterivNV_fnptr = (delegate* unmanaged<uint, PathParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glPathParameterivNV");
                _PathParameterivNV_fnptr(path, pname, value);
            }
            
            private static delegate* unmanaged<uint, PathParameter, int, void> _PathParameteriNV_fnptr = &PathParameteriNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathParameteriNV(uint path, PathParameter pname, int value) => _PathParameteriNV_fnptr(path, pname, value);
            [UnmanagedCallersOnly]
            private static void PathParameteriNV_Lazy(uint path, PathParameter pname, int value)
            {
                _PathParameteriNV_fnptr = (delegate* unmanaged<uint, PathParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glPathParameteriNV");
                _PathParameteriNV_fnptr(path, pname, value);
            }
            
            private static delegate* unmanaged<uint, PathParameter, float*, void> _PathParameterfvNV_fnptr = &PathParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathParameterfvNV(uint path, PathParameter pname, float* value) => _PathParameterfvNV_fnptr(path, pname, value);
            [UnmanagedCallersOnly]
            private static void PathParameterfvNV_Lazy(uint path, PathParameter pname, float* value)
            {
                _PathParameterfvNV_fnptr = (delegate* unmanaged<uint, PathParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPathParameterfvNV");
                _PathParameterfvNV_fnptr(path, pname, value);
            }
            
            private static delegate* unmanaged<uint, PathParameter, float, void> _PathParameterfNV_fnptr = &PathParameterfNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathParameterfNV(uint path, PathParameter pname, float value) => _PathParameterfNV_fnptr(path, pname, value);
            [UnmanagedCallersOnly]
            private static void PathParameterfNV_Lazy(uint path, PathParameter pname, float value)
            {
                _PathParameterfNV_fnptr = (delegate* unmanaged<uint, PathParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glPathParameterfNV");
                _PathParameterfNV_fnptr(path, pname, value);
            }
            
            private static delegate* unmanaged<uint, int, float*, void> _PathDashArrayNV_fnptr = &PathDashArrayNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathDashArrayNV(uint path, int dashCount, float* dashArray) => _PathDashArrayNV_fnptr(path, dashCount, dashArray);
            [UnmanagedCallersOnly]
            private static void PathDashArrayNV_Lazy(uint path, int dashCount, float* dashArray)
            {
                _PathDashArrayNV_fnptr = (delegate* unmanaged<uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPathDashArrayNV");
                _PathDashArrayNV_fnptr(path, dashCount, dashArray);
            }
            
            private static delegate* unmanaged<StencilFunction, int, uint, void> _PathStencilFuncNV_fnptr = &PathStencilFuncNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathStencilFuncNV(StencilFunction func, int reference, uint mask) => _PathStencilFuncNV_fnptr(func, reference, mask);
            [UnmanagedCallersOnly]
            private static void PathStencilFuncNV_Lazy(StencilFunction func, int reference, uint mask)
            {
                _PathStencilFuncNV_fnptr = (delegate* unmanaged<StencilFunction, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glPathStencilFuncNV");
                _PathStencilFuncNV_fnptr(func, reference, mask);
            }
            
            private static delegate* unmanaged<float, float, void> _PathStencilDepthOffsetNV_fnptr = &PathStencilDepthOffsetNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathStencilDepthOffsetNV(float factor, float units) => _PathStencilDepthOffsetNV_fnptr(factor, units);
            [UnmanagedCallersOnly]
            private static void PathStencilDepthOffsetNV_Lazy(float factor, float units)
            {
                _PathStencilDepthOffsetNV_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glPathStencilDepthOffsetNV");
                _PathStencilDepthOffsetNV_fnptr(factor, units);
            }
            
            private static delegate* unmanaged<uint, PathFillMode, uint, void> _StencilFillPathNV_fnptr = &StencilFillPathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilFillPathNV(uint path, PathFillMode fillMode, uint mask) => _StencilFillPathNV_fnptr(path, fillMode, mask);
            [UnmanagedCallersOnly]
            private static void StencilFillPathNV_Lazy(uint path, PathFillMode fillMode, uint mask)
            {
                _StencilFillPathNV_fnptr = (delegate* unmanaged<uint, PathFillMode, uint, void>)GLLoader.BindingsContext.GetProcAddress("glStencilFillPathNV");
                _StencilFillPathNV_fnptr(path, fillMode, mask);
            }
            
            private static delegate* unmanaged<uint, int, uint, void> _StencilStrokePathNV_fnptr = &StencilStrokePathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilStrokePathNV(uint path, int reference, uint mask) => _StencilStrokePathNV_fnptr(path, reference, mask);
            [UnmanagedCallersOnly]
            private static void StencilStrokePathNV_Lazy(uint path, int reference, uint mask)
            {
                _StencilStrokePathNV_fnptr = (delegate* unmanaged<uint, int, uint, void>)GLLoader.BindingsContext.GetProcAddress("glStencilStrokePathNV");
                _StencilStrokePathNV_fnptr(path, reference, mask);
            }
            
            private static delegate* unmanaged<int, PathElementType, void*, uint, PathFillMode, uint, PathTransformType, float*, void> _StencilFillPathInstancedNV_fnptr = &StencilFillPathInstancedNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float* transformValues) => _StencilFillPathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
            [UnmanagedCallersOnly]
            private static void StencilFillPathInstancedNV_Lazy(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float* transformValues)
            {
                _StencilFillPathInstancedNV_fnptr = (delegate* unmanaged<int, PathElementType, void*, uint, PathFillMode, uint, PathTransformType, float*, void>)GLLoader.BindingsContext.GetProcAddress("glStencilFillPathInstancedNV");
                _StencilFillPathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
            }
            
            private static delegate* unmanaged<int, PathElementType, void*, uint, int, uint, PathTransformType, float*, void> _StencilStrokePathInstancedNV_fnptr = &StencilStrokePathInstancedNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float* transformValues) => _StencilStrokePathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
            [UnmanagedCallersOnly]
            private static void StencilStrokePathInstancedNV_Lazy(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float* transformValues)
            {
                _StencilStrokePathInstancedNV_fnptr = (delegate* unmanaged<int, PathElementType, void*, uint, int, uint, PathTransformType, float*, void>)GLLoader.BindingsContext.GetProcAddress("glStencilStrokePathInstancedNV");
                _StencilStrokePathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
            }
            
            private static delegate* unmanaged<DepthFunction, void> _PathCoverDepthFuncNV_fnptr = &PathCoverDepthFuncNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathCoverDepthFuncNV(DepthFunction func) => _PathCoverDepthFuncNV_fnptr(func);
            [UnmanagedCallersOnly]
            private static void PathCoverDepthFuncNV_Lazy(DepthFunction func)
            {
                _PathCoverDepthFuncNV_fnptr = (delegate* unmanaged<DepthFunction, void>)GLLoader.BindingsContext.GetProcAddress("glPathCoverDepthFuncNV");
                _PathCoverDepthFuncNV_fnptr(func);
            }
            
            private static delegate* unmanaged<uint, PathCoverMode, void> _CoverFillPathNV_fnptr = &CoverFillPathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverFillPathNV(uint path, PathCoverMode coverMode) => _CoverFillPathNV_fnptr(path, coverMode);
            [UnmanagedCallersOnly]
            private static void CoverFillPathNV_Lazy(uint path, PathCoverMode coverMode)
            {
                _CoverFillPathNV_fnptr = (delegate* unmanaged<uint, PathCoverMode, void>)GLLoader.BindingsContext.GetProcAddress("glCoverFillPathNV");
                _CoverFillPathNV_fnptr(path, coverMode);
            }
            
            private static delegate* unmanaged<uint, PathCoverMode, void> _CoverStrokePathNV_fnptr = &CoverStrokePathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverStrokePathNV(uint path, PathCoverMode coverMode) => _CoverStrokePathNV_fnptr(path, coverMode);
            [UnmanagedCallersOnly]
            private static void CoverStrokePathNV_Lazy(uint path, PathCoverMode coverMode)
            {
                _CoverStrokePathNV_fnptr = (delegate* unmanaged<uint, PathCoverMode, void>)GLLoader.BindingsContext.GetProcAddress("glCoverStrokePathNV");
                _CoverStrokePathNV_fnptr(path, coverMode);
            }
            
            private static delegate* unmanaged<int, PathElementType, void*, uint, PathCoverMode, PathTransformType, float*, void> _CoverFillPathInstancedNV_fnptr = &CoverFillPathInstancedNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float* transformValues) => _CoverFillPathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
            [UnmanagedCallersOnly]
            private static void CoverFillPathInstancedNV_Lazy(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float* transformValues)
            {
                _CoverFillPathInstancedNV_fnptr = (delegate* unmanaged<int, PathElementType, void*, uint, PathCoverMode, PathTransformType, float*, void>)GLLoader.BindingsContext.GetProcAddress("glCoverFillPathInstancedNV");
                _CoverFillPathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
            }
            
            private static delegate* unmanaged<int, PathElementType, void*, uint, PathCoverMode, PathTransformType, float*, void> _CoverStrokePathInstancedNV_fnptr = &CoverStrokePathInstancedNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float* transformValues) => _CoverStrokePathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
            [UnmanagedCallersOnly]
            private static void CoverStrokePathInstancedNV_Lazy(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float* transformValues)
            {
                _CoverStrokePathInstancedNV_fnptr = (delegate* unmanaged<int, PathElementType, void*, uint, PathCoverMode, PathTransformType, float*, void>)GLLoader.BindingsContext.GetProcAddress("glCoverStrokePathInstancedNV");
                _CoverStrokePathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
            }
            
            private static delegate* unmanaged<uint, PathParameter, int*, void> _GetPathParameterivNV_fnptr = &GetPathParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathParameterivNV(uint path, PathParameter pname, int* value) => _GetPathParameterivNV_fnptr(path, pname, value);
            [UnmanagedCallersOnly]
            private static void GetPathParameterivNV_Lazy(uint path, PathParameter pname, int* value)
            {
                _GetPathParameterivNV_fnptr = (delegate* unmanaged<uint, PathParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathParameterivNV");
                _GetPathParameterivNV_fnptr(path, pname, value);
            }
            
            private static delegate* unmanaged<uint, PathParameter, float*, void> _GetPathParameterfvNV_fnptr = &GetPathParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathParameterfvNV(uint path, PathParameter pname, float* value) => _GetPathParameterfvNV_fnptr(path, pname, value);
            [UnmanagedCallersOnly]
            private static void GetPathParameterfvNV_Lazy(uint path, PathParameter pname, float* value)
            {
                _GetPathParameterfvNV_fnptr = (delegate* unmanaged<uint, PathParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathParameterfvNV");
                _GetPathParameterfvNV_fnptr(path, pname, value);
            }
            
            private static delegate* unmanaged<uint, byte*, void> _GetPathCommandsNV_fnptr = &GetPathCommandsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathCommandsNV(uint path, byte* commands) => _GetPathCommandsNV_fnptr(path, commands);
            [UnmanagedCallersOnly]
            private static void GetPathCommandsNV_Lazy(uint path, byte* commands)
            {
                _GetPathCommandsNV_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathCommandsNV");
                _GetPathCommandsNV_fnptr(path, commands);
            }
            
            private static delegate* unmanaged<uint, float*, void> _GetPathCoordsNV_fnptr = &GetPathCoordsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathCoordsNV(uint path, float* coords) => _GetPathCoordsNV_fnptr(path, coords);
            [UnmanagedCallersOnly]
            private static void GetPathCoordsNV_Lazy(uint path, float* coords)
            {
                _GetPathCoordsNV_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathCoordsNV");
                _GetPathCoordsNV_fnptr(path, coords);
            }
            
            private static delegate* unmanaged<uint, float*, void> _GetPathDashArrayNV_fnptr = &GetPathDashArrayNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathDashArrayNV(uint path, float* dashArray) => _GetPathDashArrayNV_fnptr(path, dashArray);
            [UnmanagedCallersOnly]
            private static void GetPathDashArrayNV_Lazy(uint path, float* dashArray)
            {
                _GetPathDashArrayNV_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathDashArrayNV");
                _GetPathDashArrayNV_fnptr(path, dashArray);
            }
            
            private static delegate* unmanaged<PathMetricMask, int, PathElementType, void*, uint, int, float*, void> _GetPathMetricsNV_fnptr = &GetPathMetricsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathMetricsNV(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics) => _GetPathMetricsNV_fnptr(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
            [UnmanagedCallersOnly]
            private static void GetPathMetricsNV_Lazy(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics)
            {
                _GetPathMetricsNV_fnptr = (delegate* unmanaged<PathMetricMask, int, PathElementType, void*, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathMetricsNV");
                _GetPathMetricsNV_fnptr(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
            }
            
            private static delegate* unmanaged<PathMetricMask, uint, int, int, float*, void> _GetPathMetricRangeNV_fnptr = &GetPathMetricRangeNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathMetricRangeNV(PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics) => _GetPathMetricRangeNV_fnptr(metricQueryMask, firstPathName, numPaths, stride, metrics);
            [UnmanagedCallersOnly]
            private static void GetPathMetricRangeNV_Lazy(PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics)
            {
                _GetPathMetricRangeNV_fnptr = (delegate* unmanaged<PathMetricMask, uint, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathMetricRangeNV");
                _GetPathMetricRangeNV_fnptr(metricQueryMask, firstPathName, numPaths, stride, metrics);
            }
            
            private static delegate* unmanaged<PathListMode, int, PathElementType, void*, uint, float, float, PathTransformType, float*, void> _GetPathSpacingNV_fnptr = &GetPathSpacingNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float* returnedSpacing) => _GetPathSpacingNV_fnptr(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
            [UnmanagedCallersOnly]
            private static void GetPathSpacingNV_Lazy(PathListMode pathListMode, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float* returnedSpacing)
            {
                _GetPathSpacingNV_fnptr = (delegate* unmanaged<PathListMode, int, PathElementType, void*, uint, float, float, PathTransformType, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathSpacingNV");
                _GetPathSpacingNV_fnptr(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
            }
            
            private static delegate* unmanaged<uint, uint, float, float, byte> _IsPointInFillPathNV_fnptr = &IsPointInFillPathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsPointInFillPathNV(uint path, uint mask, float x, float y) => _IsPointInFillPathNV_fnptr(path, mask, x, y);
            [UnmanagedCallersOnly]
            private static byte IsPointInFillPathNV_Lazy(uint path, uint mask, float x, float y)
            {
                _IsPointInFillPathNV_fnptr = (delegate* unmanaged<uint, uint, float, float, byte>)GLLoader.BindingsContext.GetProcAddress("glIsPointInFillPathNV");
                return _IsPointInFillPathNV_fnptr(path, mask, x, y);
            }
            
            private static delegate* unmanaged<uint, float, float, byte> _IsPointInStrokePathNV_fnptr = &IsPointInStrokePathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsPointInStrokePathNV(uint path, float x, float y) => _IsPointInStrokePathNV_fnptr(path, x, y);
            [UnmanagedCallersOnly]
            private static byte IsPointInStrokePathNV_Lazy(uint path, float x, float y)
            {
                _IsPointInStrokePathNV_fnptr = (delegate* unmanaged<uint, float, float, byte>)GLLoader.BindingsContext.GetProcAddress("glIsPointInStrokePathNV");
                return _IsPointInStrokePathNV_fnptr(path, x, y);
            }
            
            private static delegate* unmanaged<uint, int, int, float> _GetPathLengthNV_fnptr = &GetPathLengthNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static float GetPathLengthNV(uint path, int startSegment, int numSegments) => _GetPathLengthNV_fnptr(path, startSegment, numSegments);
            [UnmanagedCallersOnly]
            private static float GetPathLengthNV_Lazy(uint path, int startSegment, int numSegments)
            {
                _GetPathLengthNV_fnptr = (delegate* unmanaged<uint, int, int, float>)GLLoader.BindingsContext.GetProcAddress("glGetPathLengthNV");
                return _GetPathLengthNV_fnptr(path, startSegment, numSegments);
            }
            
            private static delegate* unmanaged<uint, int, int, float, float*, float*, float*, float*, byte> _PointAlongPathNV_fnptr = &PointAlongPathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY) => _PointAlongPathNV_fnptr(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
            [UnmanagedCallersOnly]
            private static byte PointAlongPathNV_Lazy(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY)
            {
                _PointAlongPathNV_fnptr = (delegate* unmanaged<uint, int, int, float, float*, float*, float*, float*, byte>)GLLoader.BindingsContext.GetProcAddress("glPointAlongPathNV");
                return _PointAlongPathNV_fnptr(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
            }
            
            private static delegate* unmanaged<All, float*, void> _MatrixLoad3x2fNV_fnptr = &MatrixLoad3x2fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoad3x2fNV(All matrixMode, float* m) => _MatrixLoad3x2fNV_fnptr(matrixMode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoad3x2fNV_Lazy(All matrixMode, float* m)
            {
                _MatrixLoad3x2fNV_fnptr = (delegate* unmanaged<All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoad3x2fNV");
                _MatrixLoad3x2fNV_fnptr(matrixMode, m);
            }
            
            private static delegate* unmanaged<All, float*, void> _MatrixLoad3x3fNV_fnptr = &MatrixLoad3x3fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoad3x3fNV(All matrixMode, float* m) => _MatrixLoad3x3fNV_fnptr(matrixMode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoad3x3fNV_Lazy(All matrixMode, float* m)
            {
                _MatrixLoad3x3fNV_fnptr = (delegate* unmanaged<All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoad3x3fNV");
                _MatrixLoad3x3fNV_fnptr(matrixMode, m);
            }
            
            private static delegate* unmanaged<All, float*, void> _MatrixLoadTranspose3x3fNV_fnptr = &MatrixLoadTranspose3x3fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTranspose3x3fNV(All matrixMode, float* m) => _MatrixLoadTranspose3x3fNV_fnptr(matrixMode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoadTranspose3x3fNV_Lazy(All matrixMode, float* m)
            {
                _MatrixLoadTranspose3x3fNV_fnptr = (delegate* unmanaged<All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoadTranspose3x3fNV");
                _MatrixLoadTranspose3x3fNV_fnptr(matrixMode, m);
            }
            
            private static delegate* unmanaged<All, float*, void> _MatrixMult3x2fNV_fnptr = &MatrixMult3x2fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMult3x2fNV(All matrixMode, float* m) => _MatrixMult3x2fNV_fnptr(matrixMode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMult3x2fNV_Lazy(All matrixMode, float* m)
            {
                _MatrixMult3x2fNV_fnptr = (delegate* unmanaged<All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMult3x2fNV");
                _MatrixMult3x2fNV_fnptr(matrixMode, m);
            }
            
            private static delegate* unmanaged<All, float*, void> _MatrixMult3x3fNV_fnptr = &MatrixMult3x3fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMult3x3fNV(All matrixMode, float* m) => _MatrixMult3x3fNV_fnptr(matrixMode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMult3x3fNV_Lazy(All matrixMode, float* m)
            {
                _MatrixMult3x3fNV_fnptr = (delegate* unmanaged<All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMult3x3fNV");
                _MatrixMult3x3fNV_fnptr(matrixMode, m);
            }
            
            private static delegate* unmanaged<All, float*, void> _MatrixMultTranspose3x3fNV_fnptr = &MatrixMultTranspose3x3fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTranspose3x3fNV(All matrixMode, float* m) => _MatrixMultTranspose3x3fNV_fnptr(matrixMode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMultTranspose3x3fNV_Lazy(All matrixMode, float* m)
            {
                _MatrixMultTranspose3x3fNV_fnptr = (delegate* unmanaged<All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMultTranspose3x3fNV");
                _MatrixMultTranspose3x3fNV_fnptr(matrixMode, m);
            }
            
            private static delegate* unmanaged<uint, All, uint, All, void> _StencilThenCoverFillPathNV_fnptr = &StencilThenCoverFillPathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilThenCoverFillPathNV(uint path, All fillMode, uint mask, All coverMode) => _StencilThenCoverFillPathNV_fnptr(path, fillMode, mask, coverMode);
            [UnmanagedCallersOnly]
            private static void StencilThenCoverFillPathNV_Lazy(uint path, All fillMode, uint mask, All coverMode)
            {
                _StencilThenCoverFillPathNV_fnptr = (delegate* unmanaged<uint, All, uint, All, void>)GLLoader.BindingsContext.GetProcAddress("glStencilThenCoverFillPathNV");
                _StencilThenCoverFillPathNV_fnptr(path, fillMode, mask, coverMode);
            }
            
            private static delegate* unmanaged<uint, int, uint, All, void> _StencilThenCoverStrokePathNV_fnptr = &StencilThenCoverStrokePathNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilThenCoverStrokePathNV(uint path, int reference, uint mask, All coverMode) => _StencilThenCoverStrokePathNV_fnptr(path, reference, mask, coverMode);
            [UnmanagedCallersOnly]
            private static void StencilThenCoverStrokePathNV_Lazy(uint path, int reference, uint mask, All coverMode)
            {
                _StencilThenCoverStrokePathNV_fnptr = (delegate* unmanaged<uint, int, uint, All, void>)GLLoader.BindingsContext.GetProcAddress("glStencilThenCoverStrokePathNV");
                _StencilThenCoverStrokePathNV_fnptr(path, reference, mask, coverMode);
            }
            
            private static delegate* unmanaged<int, All, void*, uint, All, uint, All, All, float*, void> _StencilThenCoverFillPathInstancedNV_fnptr = &StencilThenCoverFillPathInstancedNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilThenCoverFillPathInstancedNV(int numPaths, All pathNameType, void* paths, uint pathBase, All fillMode, uint mask, All coverMode, All transformType, float* transformValues) => _StencilThenCoverFillPathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
            [UnmanagedCallersOnly]
            private static void StencilThenCoverFillPathInstancedNV_Lazy(int numPaths, All pathNameType, void* paths, uint pathBase, All fillMode, uint mask, All coverMode, All transformType, float* transformValues)
            {
                _StencilThenCoverFillPathInstancedNV_fnptr = (delegate* unmanaged<int, All, void*, uint, All, uint, All, All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glStencilThenCoverFillPathInstancedNV");
                _StencilThenCoverFillPathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
            }
            
            private static delegate* unmanaged<int, All, void*, uint, int, uint, All, All, float*, void> _StencilThenCoverStrokePathInstancedNV_fnptr = &StencilThenCoverStrokePathInstancedNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilThenCoverStrokePathInstancedNV(int numPaths, All pathNameType, void* paths, uint pathBase, int reference, uint mask, All coverMode, All transformType, float* transformValues) => _StencilThenCoverStrokePathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
            [UnmanagedCallersOnly]
            private static void StencilThenCoverStrokePathInstancedNV_Lazy(int numPaths, All pathNameType, void* paths, uint pathBase, int reference, uint mask, All coverMode, All transformType, float* transformValues)
            {
                _StencilThenCoverStrokePathInstancedNV_fnptr = (delegate* unmanaged<int, All, void*, uint, int, uint, All, All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glStencilThenCoverStrokePathInstancedNV");
                _StencilThenCoverStrokePathInstancedNV_fnptr(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
            }
            
            private static delegate* unmanaged<All, void*, PathFontStyle, uint, float, uint*, All> _PathGlyphIndexRangeNV_fnptr = &PathGlyphIndexRangeNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All PathGlyphIndexRangeNV(All fontTarget, void* fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount) => _PathGlyphIndexRangeNV_fnptr(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
            [UnmanagedCallersOnly]
            private static All PathGlyphIndexRangeNV_Lazy(All fontTarget, void* fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount)
            {
                _PathGlyphIndexRangeNV_fnptr = (delegate* unmanaged<All, void*, PathFontStyle, uint, float, uint*, All>)GLLoader.BindingsContext.GetProcAddress("glPathGlyphIndexRangeNV");
                return _PathGlyphIndexRangeNV_fnptr(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
            }
            
            private static delegate* unmanaged<uint, All, void*, PathFontStyle, uint, int, uint, float, All> _PathGlyphIndexArrayNV_fnptr = &PathGlyphIndexArrayNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All PathGlyphIndexArrayNV(uint firstPathName, All fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => _PathGlyphIndexArrayNV_fnptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            [UnmanagedCallersOnly]
            private static All PathGlyphIndexArrayNV_Lazy(uint firstPathName, All fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
            {
                _PathGlyphIndexArrayNV_fnptr = (delegate* unmanaged<uint, All, void*, PathFontStyle, uint, int, uint, float, All>)GLLoader.BindingsContext.GetProcAddress("glPathGlyphIndexArrayNV");
                return _PathGlyphIndexArrayNV_fnptr(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            }
            
            private static delegate* unmanaged<uint, All, nint, void*, int, uint, int, uint, float, All> _PathMemoryGlyphIndexArrayNV_fnptr = &PathMemoryGlyphIndexArrayNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All PathMemoryGlyphIndexArrayNV(uint firstPathName, All fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => _PathMemoryGlyphIndexArrayNV_fnptr(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            [UnmanagedCallersOnly]
            private static All PathMemoryGlyphIndexArrayNV_Lazy(uint firstPathName, All fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
            {
                _PathMemoryGlyphIndexArrayNV_fnptr = (delegate* unmanaged<uint, All, nint, void*, int, uint, int, uint, float, All>)GLLoader.BindingsContext.GetProcAddress("glPathMemoryGlyphIndexArrayNV");
                return _PathMemoryGlyphIndexArrayNV_fnptr(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, All, int, float*, void> _ProgramPathFragmentInputGenNV_fnptr = &ProgramPathFragmentInputGenNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramPathFragmentInputGenNV(ProgramHandle program, int location, All genMode, int components, float* coeffs) => _ProgramPathFragmentInputGenNV_fnptr(program, location, genMode, components, coeffs);
            [UnmanagedCallersOnly]
            private static void ProgramPathFragmentInputGenNV_Lazy(ProgramHandle program, int location, All genMode, int components, float* coeffs)
            {
                _ProgramPathFragmentInputGenNV_fnptr = (delegate* unmanaged<ProgramHandle, int, All, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramPathFragmentInputGenNV");
                _ProgramPathFragmentInputGenNV_fnptr(program, location, genMode, components, coeffs);
            }
            
            private static delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, All*, int, int*, float*, void> _GetProgramResourcefvNV_fnptr = &GetProgramResourcefvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramResourcefvNV(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, All* props, int count, int* length, float* parameters) => _GetProgramResourcefvNV_fnptr(program, programInterface, index, propCount, props, count, length, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramResourcefvNV_Lazy(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, All* props, int count, int* length, float* parameters)
            {
                _GetProgramResourcefvNV_fnptr = (delegate* unmanaged<ProgramHandle, ProgramInterface, uint, int, All*, int, int*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramResourcefvNV");
                _GetProgramResourcefvNV_fnptr(program, programInterface, index, propCount, props, count, length, parameters);
            }
            
            private static delegate* unmanaged<PathColor, PathGenMode, PathColorFormat, float*, void> _PathColorGenNV_fnptr = &PathColorGenNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathColorGenNV(PathColor color, PathGenMode genMode, PathColorFormat colorFormat, float* coeffs) => _PathColorGenNV_fnptr(color, genMode, colorFormat, coeffs);
            [UnmanagedCallersOnly]
            private static void PathColorGenNV_Lazy(PathColor color, PathGenMode genMode, PathColorFormat colorFormat, float* coeffs)
            {
                _PathColorGenNV_fnptr = (delegate* unmanaged<PathColor, PathGenMode, PathColorFormat, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPathColorGenNV");
                _PathColorGenNV_fnptr(color, genMode, colorFormat, coeffs);
            }
            
            private static delegate* unmanaged<PathColor, PathGenMode, int, float*, void> _PathTexGenNV_fnptr = &PathTexGenNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathTexGenNV(PathColor texCoordSet, PathGenMode genMode, int components, float* coeffs) => _PathTexGenNV_fnptr(texCoordSet, genMode, components, coeffs);
            [UnmanagedCallersOnly]
            private static void PathTexGenNV_Lazy(PathColor texCoordSet, PathGenMode genMode, int components, float* coeffs)
            {
                _PathTexGenNV_fnptr = (delegate* unmanaged<PathColor, PathGenMode, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPathTexGenNV");
                _PathTexGenNV_fnptr(texCoordSet, genMode, components, coeffs);
            }
            
            private static delegate* unmanaged<PathGenMode, void> _PathFogGenNV_fnptr = &PathFogGenNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathFogGenNV(PathGenMode genMode) => _PathFogGenNV_fnptr(genMode);
            [UnmanagedCallersOnly]
            private static void PathFogGenNV_Lazy(PathGenMode genMode)
            {
                _PathFogGenNV_fnptr = (delegate* unmanaged<PathGenMode, void>)GLLoader.BindingsContext.GetProcAddress("glPathFogGenNV");
                _PathFogGenNV_fnptr(genMode);
            }
            
            private static delegate* unmanaged<PathColor, PathGenMode, int*, void> _GetPathColorGenivNV_fnptr = &GetPathColorGenivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathColorGenivNV(PathColor color, PathGenMode pname, int* value) => _GetPathColorGenivNV_fnptr(color, pname, value);
            [UnmanagedCallersOnly]
            private static void GetPathColorGenivNV_Lazy(PathColor color, PathGenMode pname, int* value)
            {
                _GetPathColorGenivNV_fnptr = (delegate* unmanaged<PathColor, PathGenMode, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathColorGenivNV");
                _GetPathColorGenivNV_fnptr(color, pname, value);
            }
            
            private static delegate* unmanaged<PathColor, PathGenMode, float*, void> _GetPathColorGenfvNV_fnptr = &GetPathColorGenfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathColorGenfvNV(PathColor color, PathGenMode pname, float* value) => _GetPathColorGenfvNV_fnptr(color, pname, value);
            [UnmanagedCallersOnly]
            private static void GetPathColorGenfvNV_Lazy(PathColor color, PathGenMode pname, float* value)
            {
                _GetPathColorGenfvNV_fnptr = (delegate* unmanaged<PathColor, PathGenMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathColorGenfvNV");
                _GetPathColorGenfvNV_fnptr(color, pname, value);
            }
            
            private static delegate* unmanaged<TextureUnit, PathGenMode, int*, void> _GetPathTexGenivNV_fnptr = &GetPathTexGenivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathTexGenivNV(TextureUnit texCoordSet, PathGenMode pname, int* value) => _GetPathTexGenivNV_fnptr(texCoordSet, pname, value);
            [UnmanagedCallersOnly]
            private static void GetPathTexGenivNV_Lazy(TextureUnit texCoordSet, PathGenMode pname, int* value)
            {
                _GetPathTexGenivNV_fnptr = (delegate* unmanaged<TextureUnit, PathGenMode, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathTexGenivNV");
                _GetPathTexGenivNV_fnptr(texCoordSet, pname, value);
            }
            
            private static delegate* unmanaged<TextureUnit, PathGenMode, float*, void> _GetPathTexGenfvNV_fnptr = &GetPathTexGenfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathTexGenfvNV(TextureUnit texCoordSet, PathGenMode pname, float* value) => _GetPathTexGenfvNV_fnptr(texCoordSet, pname, value);
            [UnmanagedCallersOnly]
            private static void GetPathTexGenfvNV_Lazy(TextureUnit texCoordSet, PathGenMode pname, float* value)
            {
                _GetPathTexGenfvNV_fnptr = (delegate* unmanaged<TextureUnit, PathGenMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPathTexGenfvNV");
                _GetPathTexGenfvNV_fnptr(texCoordSet, pname, value);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, double, double, double, void> _MatrixFrustumEXT_fnptr = &MatrixFrustumEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => _MatrixFrustumEXT_fnptr(mode, left, right, bottom, top, zNear, zFar);
            [UnmanagedCallersOnly]
            private static void MatrixFrustumEXT_Lazy(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
            {
                _MatrixFrustumEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixFrustumEXT");
                _MatrixFrustumEXT_fnptr(mode, left, right, bottom, top, zNear, zFar);
            }
            
            private static delegate* unmanaged<MatrixMode, void> _MatrixLoadIdentityEXT_fnptr = &MatrixLoadIdentityEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadIdentityEXT(MatrixMode mode) => _MatrixLoadIdentityEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void MatrixLoadIdentityEXT_Lazy(MatrixMode mode)
            {
                _MatrixLoadIdentityEXT_fnptr = (delegate* unmanaged<MatrixMode, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoadIdentityEXT");
                _MatrixLoadIdentityEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<MatrixMode, float*, void> _MatrixLoadTransposefEXT_fnptr = &MatrixLoadTransposefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTransposefEXT(MatrixMode mode, float* m) => _MatrixLoadTransposefEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoadTransposefEXT_Lazy(MatrixMode mode, float* m)
            {
                _MatrixLoadTransposefEXT_fnptr = (delegate* unmanaged<MatrixMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoadTransposefEXT");
                _MatrixLoadTransposefEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, double*, void> _MatrixLoadTransposedEXT_fnptr = &MatrixLoadTransposedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTransposedEXT(MatrixMode mode, double* m) => _MatrixLoadTransposedEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoadTransposedEXT_Lazy(MatrixMode mode, double* m)
            {
                _MatrixLoadTransposedEXT_fnptr = (delegate* unmanaged<MatrixMode, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoadTransposedEXT");
                _MatrixLoadTransposedEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, float*, void> _MatrixLoadfEXT_fnptr = &MatrixLoadfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadfEXT(MatrixMode mode, float* m) => _MatrixLoadfEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoadfEXT_Lazy(MatrixMode mode, float* m)
            {
                _MatrixLoadfEXT_fnptr = (delegate* unmanaged<MatrixMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoadfEXT");
                _MatrixLoadfEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, double*, void> _MatrixLoaddEXT_fnptr = &MatrixLoaddEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoaddEXT(MatrixMode mode, double* m) => _MatrixLoaddEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixLoaddEXT_Lazy(MatrixMode mode, double* m)
            {
                _MatrixLoaddEXT_fnptr = (delegate* unmanaged<MatrixMode, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixLoaddEXT");
                _MatrixLoaddEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, float*, void> _MatrixMultTransposefEXT_fnptr = &MatrixMultTransposefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTransposefEXT(MatrixMode mode, float* m) => _MatrixMultTransposefEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMultTransposefEXT_Lazy(MatrixMode mode, float* m)
            {
                _MatrixMultTransposefEXT_fnptr = (delegate* unmanaged<MatrixMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMultTransposefEXT");
                _MatrixMultTransposefEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, double*, void> _MatrixMultTransposedEXT_fnptr = &MatrixMultTransposedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTransposedEXT(MatrixMode mode, double* m) => _MatrixMultTransposedEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMultTransposedEXT_Lazy(MatrixMode mode, double* m)
            {
                _MatrixMultTransposedEXT_fnptr = (delegate* unmanaged<MatrixMode, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMultTransposedEXT");
                _MatrixMultTransposedEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, float*, void> _MatrixMultfEXT_fnptr = &MatrixMultfEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultfEXT(MatrixMode mode, float* m) => _MatrixMultfEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMultfEXT_Lazy(MatrixMode mode, float* m)
            {
                _MatrixMultfEXT_fnptr = (delegate* unmanaged<MatrixMode, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMultfEXT");
                _MatrixMultfEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, double*, void> _MatrixMultdEXT_fnptr = &MatrixMultdEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultdEXT(MatrixMode mode, double* m) => _MatrixMultdEXT_fnptr(mode, m);
            [UnmanagedCallersOnly]
            private static void MatrixMultdEXT_Lazy(MatrixMode mode, double* m)
            {
                _MatrixMultdEXT_fnptr = (delegate* unmanaged<MatrixMode, double*, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixMultdEXT");
                _MatrixMultdEXT_fnptr(mode, m);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, double, double, double, void> _MatrixOrthoEXT_fnptr = &MatrixOrthoEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => _MatrixOrthoEXT_fnptr(mode, left, right, bottom, top, zNear, zFar);
            [UnmanagedCallersOnly]
            private static void MatrixOrthoEXT_Lazy(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
            {
                _MatrixOrthoEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixOrthoEXT");
                _MatrixOrthoEXT_fnptr(mode, left, right, bottom, top, zNear, zFar);
            }
            
            private static delegate* unmanaged<MatrixMode, void> _MatrixPopEXT_fnptr = &MatrixPopEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixPopEXT(MatrixMode mode) => _MatrixPopEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void MatrixPopEXT_Lazy(MatrixMode mode)
            {
                _MatrixPopEXT_fnptr = (delegate* unmanaged<MatrixMode, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixPopEXT");
                _MatrixPopEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<MatrixMode, void> _MatrixPushEXT_fnptr = &MatrixPushEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixPushEXT(MatrixMode mode) => _MatrixPushEXT_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void MatrixPushEXT_Lazy(MatrixMode mode)
            {
                _MatrixPushEXT_fnptr = (delegate* unmanaged<MatrixMode, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixPushEXT");
                _MatrixPushEXT_fnptr(mode);
            }
            
            private static delegate* unmanaged<MatrixMode, float, float, float, float, void> _MatrixRotatefEXT_fnptr = &MatrixRotatefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => _MatrixRotatefEXT_fnptr(mode, angle, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixRotatefEXT_Lazy(MatrixMode mode, float angle, float x, float y, float z)
            {
                _MatrixRotatefEXT_fnptr = (delegate* unmanaged<MatrixMode, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixRotatefEXT");
                _MatrixRotatefEXT_fnptr(mode, angle, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, double, void> _MatrixRotatedEXT_fnptr = &MatrixRotatedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => _MatrixRotatedEXT_fnptr(mode, angle, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixRotatedEXT_Lazy(MatrixMode mode, double angle, double x, double y, double z)
            {
                _MatrixRotatedEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixRotatedEXT");
                _MatrixRotatedEXT_fnptr(mode, angle, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, float, float, float, void> _MatrixScalefEXT_fnptr = &MatrixScalefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => _MatrixScalefEXT_fnptr(mode, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixScalefEXT_Lazy(MatrixMode mode, float x, float y, float z)
            {
                _MatrixScalefEXT_fnptr = (delegate* unmanaged<MatrixMode, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixScalefEXT");
                _MatrixScalefEXT_fnptr(mode, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, void> _MatrixScaledEXT_fnptr = &MatrixScaledEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => _MatrixScaledEXT_fnptr(mode, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixScaledEXT_Lazy(MatrixMode mode, double x, double y, double z)
            {
                _MatrixScaledEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixScaledEXT");
                _MatrixScaledEXT_fnptr(mode, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, float, float, float, void> _MatrixTranslatefEXT_fnptr = &MatrixTranslatefEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => _MatrixTranslatefEXT_fnptr(mode, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixTranslatefEXT_Lazy(MatrixMode mode, float x, float y, float z)
            {
                _MatrixTranslatefEXT_fnptr = (delegate* unmanaged<MatrixMode, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixTranslatefEXT");
                _MatrixTranslatefEXT_fnptr(mode, x, y, z);
            }
            
            private static delegate* unmanaged<MatrixMode, double, double, double, void> _MatrixTranslatedEXT_fnptr = &MatrixTranslatedEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => _MatrixTranslatedEXT_fnptr(mode, x, y, z);
            [UnmanagedCallersOnly]
            private static void MatrixTranslatedEXT_Lazy(MatrixMode mode, double x, double y, double z)
            {
                _MatrixTranslatedEXT_fnptr = (delegate* unmanaged<MatrixMode, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glMatrixTranslatedEXT");
                _MatrixTranslatedEXT_fnptr(mode, x, y, z);
            }
            
            private static delegate* unmanaged<PixelDataRangeTargetNV, int, void*, void> _PixelDataRangeNV_fnptr = &PixelDataRangeNV_Lazy;
            /// <summary> <b>[requires: GL_NV_pixel_data_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelDataRangeNV(PixelDataRangeTargetNV target, int length, void* pointer) => _PixelDataRangeNV_fnptr(target, length, pointer);
            [UnmanagedCallersOnly]
            private static void PixelDataRangeNV_Lazy(PixelDataRangeTargetNV target, int length, void* pointer)
            {
                _PixelDataRangeNV_fnptr = (delegate* unmanaged<PixelDataRangeTargetNV, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glPixelDataRangeNV");
                _PixelDataRangeNV_fnptr(target, length, pointer);
            }
            
            private static delegate* unmanaged<PixelDataRangeTargetNV, void> _FlushPixelDataRangeNV_fnptr = &FlushPixelDataRangeNV_Lazy;
            /// <summary> <b>[requires: GL_NV_pixel_data_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushPixelDataRangeNV(PixelDataRangeTargetNV target) => _FlushPixelDataRangeNV_fnptr(target);
            [UnmanagedCallersOnly]
            private static void FlushPixelDataRangeNV_Lazy(PixelDataRangeTargetNV target)
            {
                _FlushPixelDataRangeNV_fnptr = (delegate* unmanaged<PixelDataRangeTargetNV, void>)GLLoader.BindingsContext.GetProcAddress("glFlushPixelDataRangeNV");
                _FlushPixelDataRangeNV_fnptr(target);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, int, void> _PointParameteriNV_fnptr = &PointParameteriNV_Lazy;
            /// <summary> <b>[requires: GL_NV_point_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameteriNV(PointParameterNameARB pname, int param) => _PointParameteriNV_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PointParameteriNV_Lazy(PointParameterNameARB pname, int param)
            {
                _PointParameteriNV_fnptr = (delegate* unmanaged<PointParameterNameARB, int, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameteriNV");
                _PointParameteriNV_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, int*, void> _PointParameterivNV_fnptr = &PointParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_point_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterivNV(PointParameterNameARB pname, int* parameters) => _PointParameterivNV_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void PointParameterivNV_Lazy(PointParameterNameARB pname, int* parameters)
            {
                _PointParameterivNV_fnptr = (delegate* unmanaged<PointParameterNameARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterivNV");
                _PointParameterivNV_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<uint, ulong, uint, uint, All, All, uint, uint, All, uint, uint, void> _PresentFrameKeyedNV_fnptr = &PresentFrameKeyedNV_Lazy;
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PresentFrameKeyedNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, uint key0, All target1, uint fill1, uint key1) => _PresentFrameKeyedNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
            [UnmanagedCallersOnly]
            private static void PresentFrameKeyedNV_Lazy(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, uint key0, All target1, uint fill1, uint key1)
            {
                _PresentFrameKeyedNV_fnptr = (delegate* unmanaged<uint, ulong, uint, uint, All, All, uint, uint, All, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glPresentFrameKeyedNV");
                _PresentFrameKeyedNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
            }
            
            private static delegate* unmanaged<uint, ulong, uint, uint, All, All, uint, All, uint, All, uint, All, uint, void> _PresentFrameDualFillNV_fnptr = &PresentFrameDualFillNV_Lazy;
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PresentFrameDualFillNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, All target1, uint fill1, All target2, uint fill2, All target3, uint fill3) => _PresentFrameDualFillNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
            [UnmanagedCallersOnly]
            private static void PresentFrameDualFillNV_Lazy(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, All target1, uint fill1, All target2, uint fill2, All target3, uint fill3)
            {
                _PresentFrameDualFillNV_fnptr = (delegate* unmanaged<uint, ulong, uint, uint, All, All, uint, All, uint, All, uint, All, uint, void>)GLLoader.BindingsContext.GetProcAddress("glPresentFrameDualFillNV");
                _PresentFrameDualFillNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
            }
            
            private static delegate* unmanaged<uint, All, int*, void> _GetVideoivNV_fnptr = &GetVideoivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoivNV(uint video_slot, All pname, int* parameters) => _GetVideoivNV_fnptr(video_slot, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVideoivNV_Lazy(uint video_slot, All pname, int* parameters)
            {
                _GetVideoivNV_fnptr = (delegate* unmanaged<uint, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVideoivNV");
                _GetVideoivNV_fnptr(video_slot, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, All, uint*, void> _GetVideouivNV_fnptr = &GetVideouivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideouivNV(uint video_slot, All pname, uint* parameters) => _GetVideouivNV_fnptr(video_slot, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVideouivNV_Lazy(uint video_slot, All pname, uint* parameters)
            {
                _GetVideouivNV_fnptr = (delegate* unmanaged<uint, All, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVideouivNV");
                _GetVideouivNV_fnptr(video_slot, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, All, long*, void> _GetVideoi64vNV_fnptr = &GetVideoi64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoi64vNV(uint video_slot, All pname, long* parameters) => _GetVideoi64vNV_fnptr(video_slot, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVideoi64vNV_Lazy(uint video_slot, All pname, long* parameters)
            {
                _GetVideoi64vNV_fnptr = (delegate* unmanaged<uint, All, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVideoi64vNV");
                _GetVideoi64vNV_fnptr(video_slot, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, All, ulong*, void> _GetVideoui64vNV_fnptr = &GetVideoui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoui64vNV(uint video_slot, All pname, ulong* parameters) => _GetVideoui64vNV_fnptr(video_slot, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVideoui64vNV_Lazy(uint video_slot, All pname, ulong* parameters)
            {
                _GetVideoui64vNV_fnptr = (delegate* unmanaged<uint, All, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVideoui64vNV");
                _GetVideoui64vNV_fnptr(video_slot, pname, parameters);
            }
            
            private static delegate* unmanaged<void> _PrimitiveRestartNV_fnptr = &PrimitiveRestartNV_Lazy;
            /// <summary> <b>[requires: GL_NV_primitive_restart]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrimitiveRestartNV() => _PrimitiveRestartNV_fnptr();
            [UnmanagedCallersOnly]
            private static void PrimitiveRestartNV_Lazy()
            {
                _PrimitiveRestartNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPrimitiveRestartNV");
                _PrimitiveRestartNV_fnptr();
            }
            
            private static delegate* unmanaged<uint, void> _PrimitiveRestartIndexNV_fnptr = &PrimitiveRestartIndexNV_Lazy;
            /// <summary> <b>[requires: GL_NV_primitive_restart]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrimitiveRestartIndexNV(uint index) => _PrimitiveRestartIndexNV_fnptr(index);
            [UnmanagedCallersOnly]
            private static void PrimitiveRestartIndexNV_Lazy(uint index)
            {
                _PrimitiveRestartIndexNV_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glPrimitiveRestartIndexNV");
                _PrimitiveRestartIndexNV_fnptr(index);
            }
            
            private static delegate* unmanaged<All, int, uint, int*, int> _QueryResourceNV_fnptr = &QueryResourceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_query_resource]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int QueryResourceNV(All queryType, int tagId, uint count, int* buffer) => _QueryResourceNV_fnptr(queryType, tagId, count, buffer);
            [UnmanagedCallersOnly]
            private static int QueryResourceNV_Lazy(All queryType, int tagId, uint count, int* buffer)
            {
                _QueryResourceNV_fnptr = (delegate* unmanaged<All, int, uint, int*, int>)GLLoader.BindingsContext.GetProcAddress("glQueryResourceNV");
                return _QueryResourceNV_fnptr(queryType, tagId, count, buffer);
            }
            
            private static delegate* unmanaged<int, int*, void> _GenQueryResourceTagNV_fnptr = &GenQueryResourceTagNV_Lazy;
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenQueryResourceTagNV(int n, int* tagIds) => _GenQueryResourceTagNV_fnptr(n, tagIds);
            [UnmanagedCallersOnly]
            private static void GenQueryResourceTagNV_Lazy(int n, int* tagIds)
            {
                _GenQueryResourceTagNV_fnptr = (delegate* unmanaged<int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGenQueryResourceTagNV");
                _GenQueryResourceTagNV_fnptr(n, tagIds);
            }
            
            private static delegate* unmanaged<int, int*, void> _DeleteQueryResourceTagNV_fnptr = &DeleteQueryResourceTagNV_Lazy;
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteQueryResourceTagNV(int n, int* tagIds) => _DeleteQueryResourceTagNV_fnptr(n, tagIds);
            [UnmanagedCallersOnly]
            private static void DeleteQueryResourceTagNV_Lazy(int n, int* tagIds)
            {
                _DeleteQueryResourceTagNV_fnptr = (delegate* unmanaged<int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteQueryResourceTagNV");
                _DeleteQueryResourceTagNV_fnptr(n, tagIds);
            }
            
            private static delegate* unmanaged<int, byte*, void> _QueryResourceTagNV_fnptr = &QueryResourceTagNV_Lazy;
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void QueryResourceTagNV(int tagId, byte* tagString) => _QueryResourceTagNV_fnptr(tagId, tagString);
            [UnmanagedCallersOnly]
            private static void QueryResourceTagNV_Lazy(int tagId, byte* tagString)
            {
                _QueryResourceTagNV_fnptr = (delegate* unmanaged<int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glQueryResourceTagNV");
                _QueryResourceTagNV_fnptr(tagId, tagString);
            }
            
            private static delegate* unmanaged<CombinerParameterNV, float*, void> _CombinerParameterfvNV_fnptr = &CombinerParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerParameterfvNV(CombinerParameterNV pname, float* parameters) => _CombinerParameterfvNV_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void CombinerParameterfvNV_Lazy(CombinerParameterNV pname, float* parameters)
            {
                _CombinerParameterfvNV_fnptr = (delegate* unmanaged<CombinerParameterNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glCombinerParameterfvNV");
                _CombinerParameterfvNV_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<CombinerParameterNV, float, void> _CombinerParameterfNV_fnptr = &CombinerParameterfNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerParameterfNV(CombinerParameterNV pname, float param) => _CombinerParameterfNV_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void CombinerParameterfNV_Lazy(CombinerParameterNV pname, float param)
            {
                _CombinerParameterfNV_fnptr = (delegate* unmanaged<CombinerParameterNV, float, void>)GLLoader.BindingsContext.GetProcAddress("glCombinerParameterfNV");
                _CombinerParameterfNV_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<CombinerParameterNV, int*, void> _CombinerParameterivNV_fnptr = &CombinerParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerParameterivNV(CombinerParameterNV pname, int* parameters) => _CombinerParameterivNV_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void CombinerParameterivNV_Lazy(CombinerParameterNV pname, int* parameters)
            {
                _CombinerParameterivNV_fnptr = (delegate* unmanaged<CombinerParameterNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glCombinerParameterivNV");
                _CombinerParameterivNV_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<CombinerParameterNV, int, void> _CombinerParameteriNV_fnptr = &CombinerParameteriNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerParameteriNV(CombinerParameterNV pname, int param) => _CombinerParameteriNV_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void CombinerParameteriNV_Lazy(CombinerParameterNV pname, int param)
            {
                _CombinerParameteriNV_fnptr = (delegate* unmanaged<CombinerParameterNV, int, void>)GLLoader.BindingsContext.GetProcAddress("glCombinerParameteriNV");
                _CombinerParameteriNV_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerVariableNV, CombinerRegisterNV, CombinerMappingNV, CombinerComponentUsageNV, void> _CombinerInputNV_fnptr = &CombinerInputNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerInputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => _CombinerInputNV_fnptr(stage, portion, variable, input, mapping, componentUsage);
            [UnmanagedCallersOnly]
            private static void CombinerInputNV_Lazy(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage)
            {
                _CombinerInputNV_fnptr = (delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerVariableNV, CombinerRegisterNV, CombinerMappingNV, CombinerComponentUsageNV, void>)GLLoader.BindingsContext.GetProcAddress("glCombinerInputNV");
                _CombinerInputNV_fnptr(stage, portion, variable, input, mapping, componentUsage);
            }
            
            private static delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerRegisterNV, CombinerRegisterNV, CombinerRegisterNV, CombinerScaleNV, CombinerBiasNV, byte, byte, byte, void> _CombinerOutputNV_fnptr = &CombinerOutputNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerOutputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerRegisterNV abOutput, CombinerRegisterNV cdOutput, CombinerRegisterNV sumOutput, CombinerScaleNV scale, CombinerBiasNV bias, byte abDotProduct, byte cdDotProduct, byte muxSum) => _CombinerOutputNV_fnptr(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
            [UnmanagedCallersOnly]
            private static void CombinerOutputNV_Lazy(CombinerStageNV stage, CombinerPortionNV portion, CombinerRegisterNV abOutput, CombinerRegisterNV cdOutput, CombinerRegisterNV sumOutput, CombinerScaleNV scale, CombinerBiasNV bias, byte abDotProduct, byte cdDotProduct, byte muxSum)
            {
                _CombinerOutputNV_fnptr = (delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerRegisterNV, CombinerRegisterNV, CombinerRegisterNV, CombinerScaleNV, CombinerBiasNV, byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glCombinerOutputNV");
                _CombinerOutputNV_fnptr(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
            }
            
            private static delegate* unmanaged<CombinerVariableNV, CombinerRegisterNV, CombinerMappingNV, CombinerComponentUsageNV, void> _FinalCombinerInputNV_fnptr = &FinalCombinerInputNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinalCombinerInputNV(CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => _FinalCombinerInputNV_fnptr(variable, input, mapping, componentUsage);
            [UnmanagedCallersOnly]
            private static void FinalCombinerInputNV_Lazy(CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage)
            {
                _FinalCombinerInputNV_fnptr = (delegate* unmanaged<CombinerVariableNV, CombinerRegisterNV, CombinerMappingNV, CombinerComponentUsageNV, void>)GLLoader.BindingsContext.GetProcAddress("glFinalCombinerInputNV");
                _FinalCombinerInputNV_fnptr(variable, input, mapping, componentUsage);
            }
            
            private static delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerVariableNV, CombinerParameterNV, float*, void> _GetCombinerInputParameterfvNV_fnptr = &GetCombinerInputParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => _GetCombinerInputParameterfvNV_fnptr(stage, portion, variable, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetCombinerInputParameterfvNV_Lazy(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, float* parameters)
            {
                _GetCombinerInputParameterfvNV_fnptr = (delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerVariableNV, CombinerParameterNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCombinerInputParameterfvNV");
                _GetCombinerInputParameterfvNV_fnptr(stage, portion, variable, pname, parameters);
            }
            
            private static delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerVariableNV, CombinerParameterNV, int*, void> _GetCombinerInputParameterivNV_fnptr = &GetCombinerInputParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => _GetCombinerInputParameterivNV_fnptr(stage, portion, variable, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetCombinerInputParameterivNV_Lazy(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, int* parameters)
            {
                _GetCombinerInputParameterivNV_fnptr = (delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerVariableNV, CombinerParameterNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCombinerInputParameterivNV");
                _GetCombinerInputParameterivNV_fnptr(stage, portion, variable, pname, parameters);
            }
            
            private static delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerParameterNV, float*, void> _GetCombinerOutputParameterfvNV_fnptr = &GetCombinerOutputParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, float* parameters) => _GetCombinerOutputParameterfvNV_fnptr(stage, portion, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetCombinerOutputParameterfvNV_Lazy(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, float* parameters)
            {
                _GetCombinerOutputParameterfvNV_fnptr = (delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerParameterNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCombinerOutputParameterfvNV");
                _GetCombinerOutputParameterfvNV_fnptr(stage, portion, pname, parameters);
            }
            
            private static delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerParameterNV, int*, void> _GetCombinerOutputParameterivNV_fnptr = &GetCombinerOutputParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, int* parameters) => _GetCombinerOutputParameterivNV_fnptr(stage, portion, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetCombinerOutputParameterivNV_Lazy(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, int* parameters)
            {
                _GetCombinerOutputParameterivNV_fnptr = (delegate* unmanaged<CombinerStageNV, CombinerPortionNV, CombinerParameterNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCombinerOutputParameterivNV");
                _GetCombinerOutputParameterivNV_fnptr(stage, portion, pname, parameters);
            }
            
            private static delegate* unmanaged<CombinerVariableNV, CombinerParameterNV, float*, void> _GetFinalCombinerInputParameterfvNV_fnptr = &GetFinalCombinerInputParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => _GetFinalCombinerInputParameterfvNV_fnptr(variable, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFinalCombinerInputParameterfvNV_Lazy(CombinerVariableNV variable, CombinerParameterNV pname, float* parameters)
            {
                _GetFinalCombinerInputParameterfvNV_fnptr = (delegate* unmanaged<CombinerVariableNV, CombinerParameterNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFinalCombinerInputParameterfvNV");
                _GetFinalCombinerInputParameterfvNV_fnptr(variable, pname, parameters);
            }
            
            private static delegate* unmanaged<CombinerVariableNV, CombinerParameterNV, int*, void> _GetFinalCombinerInputParameterivNV_fnptr = &GetFinalCombinerInputParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => _GetFinalCombinerInputParameterivNV_fnptr(variable, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFinalCombinerInputParameterivNV_Lazy(CombinerVariableNV variable, CombinerParameterNV pname, int* parameters)
            {
                _GetFinalCombinerInputParameterivNV_fnptr = (delegate* unmanaged<CombinerVariableNV, CombinerParameterNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFinalCombinerInputParameterivNV");
                _GetFinalCombinerInputParameterivNV_fnptr(variable, pname, parameters);
            }
            
            private static delegate* unmanaged<CombinerStageNV, CombinerParameterNV, float*, void> _CombinerStageParameterfvNV_fnptr = &CombinerStageParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => _CombinerStageParameterfvNV_fnptr(stage, pname, parameters);
            [UnmanagedCallersOnly]
            private static void CombinerStageParameterfvNV_Lazy(CombinerStageNV stage, CombinerParameterNV pname, float* parameters)
            {
                _CombinerStageParameterfvNV_fnptr = (delegate* unmanaged<CombinerStageNV, CombinerParameterNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glCombinerStageParameterfvNV");
                _CombinerStageParameterfvNV_fnptr(stage, pname, parameters);
            }
            
            private static delegate* unmanaged<CombinerStageNV, CombinerParameterNV, float*, void> _GetCombinerStageParameterfvNV_fnptr = &GetCombinerStageParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_register_combiners2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => _GetCombinerStageParameterfvNV_fnptr(stage, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetCombinerStageParameterfvNV_Lazy(CombinerStageNV stage, CombinerParameterNV pname, float* parameters)
            {
                _GetCombinerStageParameterfvNV_fnptr = (delegate* unmanaged<CombinerStageNV, CombinerParameterNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetCombinerStageParameterfvNV");
                _GetCombinerStageParameterfvNV_fnptr(stage, pname, parameters);
            }
            
            private static delegate* unmanaged<FramebufferTarget, uint, int, float*, void> _FramebufferSampleLocationsfvNV_fnptr = &FramebufferSampleLocationsfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferSampleLocationsfvNV(FramebufferTarget target, uint start, int count, float* v) => _FramebufferSampleLocationsfvNV_fnptr(target, start, count, v);
            [UnmanagedCallersOnly]
            private static void FramebufferSampleLocationsfvNV_Lazy(FramebufferTarget target, uint start, int count, float* v)
            {
                _FramebufferSampleLocationsfvNV_fnptr = (delegate* unmanaged<FramebufferTarget, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferSampleLocationsfvNV");
                _FramebufferSampleLocationsfvNV_fnptr(target, start, count, v);
            }
            
            private static delegate* unmanaged<FramebufferHandle, uint, int, float*, void> _NamedFramebufferSampleLocationsfvNV_fnptr = &NamedFramebufferSampleLocationsfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferSampleLocationsfvNV(FramebufferHandle framebuffer, uint start, int count, float* v) => _NamedFramebufferSampleLocationsfvNV_fnptr(framebuffer, start, count, v);
            [UnmanagedCallersOnly]
            private static void NamedFramebufferSampleLocationsfvNV_Lazy(FramebufferHandle framebuffer, uint start, int count, float* v)
            {
                _NamedFramebufferSampleLocationsfvNV_fnptr = (delegate* unmanaged<FramebufferHandle, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glNamedFramebufferSampleLocationsfvNV");
                _NamedFramebufferSampleLocationsfvNV_fnptr(framebuffer, start, count, v);
            }
            
            private static delegate* unmanaged<void> _ResolveDepthValuesNV_fnptr = &ResolveDepthValuesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResolveDepthValuesNV() => _ResolveDepthValuesNV_fnptr();
            [UnmanagedCallersOnly]
            private static void ResolveDepthValuesNV_Lazy()
            {
                _ResolveDepthValuesNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glResolveDepthValuesNV");
                _ResolveDepthValuesNV_fnptr();
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _ScissorExclusiveNV_fnptr = &ScissorExclusiveNV_Lazy;
            /// <summary> <b>[requires: GL_NV_scissor_exclusive]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ScissorExclusiveNV(int x, int y, int width, int height) => _ScissorExclusiveNV_fnptr(x, y, width, height);
            [UnmanagedCallersOnly]
            private static void ScissorExclusiveNV_Lazy(int x, int y, int width, int height)
            {
                _ScissorExclusiveNV_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glScissorExclusiveNV");
                _ScissorExclusiveNV_fnptr(x, y, width, height);
            }
            
            private static delegate* unmanaged<uint, int, int*, void> _ScissorExclusiveArrayvNV_fnptr = &ScissorExclusiveArrayvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_scissor_exclusive]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ScissorExclusiveArrayvNV(uint first, int count, int* v) => _ScissorExclusiveArrayvNV_fnptr(first, count, v);
            [UnmanagedCallersOnly]
            private static void ScissorExclusiveArrayvNV_Lazy(uint first, int count, int* v)
            {
                _ScissorExclusiveArrayvNV_fnptr = (delegate* unmanaged<uint, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glScissorExclusiveArrayvNV");
                _ScissorExclusiveArrayvNV_fnptr(first, count, v);
            }
            
            private static delegate* unmanaged<All, All, void> _MakeBufferResidentNV_fnptr = &MakeBufferResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeBufferResidentNV(All target, All access) => _MakeBufferResidentNV_fnptr(target, access);
            [UnmanagedCallersOnly]
            private static void MakeBufferResidentNV_Lazy(All target, All access)
            {
                _MakeBufferResidentNV_fnptr = (delegate* unmanaged<All, All, void>)GLLoader.BindingsContext.GetProcAddress("glMakeBufferResidentNV");
                _MakeBufferResidentNV_fnptr(target, access);
            }
            
            private static delegate* unmanaged<All, void> _MakeBufferNonResidentNV_fnptr = &MakeBufferNonResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeBufferNonResidentNV(All target) => _MakeBufferNonResidentNV_fnptr(target);
            [UnmanagedCallersOnly]
            private static void MakeBufferNonResidentNV_Lazy(All target)
            {
                _MakeBufferNonResidentNV_fnptr = (delegate* unmanaged<All, void>)GLLoader.BindingsContext.GetProcAddress("glMakeBufferNonResidentNV");
                _MakeBufferNonResidentNV_fnptr(target);
            }
            
            private static delegate* unmanaged<All, byte> _IsBufferResidentNV_fnptr = &IsBufferResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsBufferResidentNV(All target) => _IsBufferResidentNV_fnptr(target);
            [UnmanagedCallersOnly]
            private static byte IsBufferResidentNV_Lazy(All target)
            {
                _IsBufferResidentNV_fnptr = (delegate* unmanaged<All, byte>)GLLoader.BindingsContext.GetProcAddress("glIsBufferResidentNV");
                return _IsBufferResidentNV_fnptr(target);
            }
            
            private static delegate* unmanaged<BufferHandle, All, void> _MakeNamedBufferResidentNV_fnptr = &MakeNamedBufferResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeNamedBufferResidentNV(BufferHandle buffer, All access) => _MakeNamedBufferResidentNV_fnptr(buffer, access);
            [UnmanagedCallersOnly]
            private static void MakeNamedBufferResidentNV_Lazy(BufferHandle buffer, All access)
            {
                _MakeNamedBufferResidentNV_fnptr = (delegate* unmanaged<BufferHandle, All, void>)GLLoader.BindingsContext.GetProcAddress("glMakeNamedBufferResidentNV");
                _MakeNamedBufferResidentNV_fnptr(buffer, access);
            }
            
            private static delegate* unmanaged<BufferHandle, void> _MakeNamedBufferNonResidentNV_fnptr = &MakeNamedBufferNonResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeNamedBufferNonResidentNV(BufferHandle buffer) => _MakeNamedBufferNonResidentNV_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static void MakeNamedBufferNonResidentNV_Lazy(BufferHandle buffer)
            {
                _MakeNamedBufferNonResidentNV_fnptr = (delegate* unmanaged<BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glMakeNamedBufferNonResidentNV");
                _MakeNamedBufferNonResidentNV_fnptr(buffer);
            }
            
            private static delegate* unmanaged<BufferHandle, byte> _IsNamedBufferResidentNV_fnptr = &IsNamedBufferResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsNamedBufferResidentNV(BufferHandle buffer) => _IsNamedBufferResidentNV_fnptr(buffer);
            [UnmanagedCallersOnly]
            private static byte IsNamedBufferResidentNV_Lazy(BufferHandle buffer)
            {
                _IsNamedBufferResidentNV_fnptr = (delegate* unmanaged<BufferHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsNamedBufferResidentNV");
                return _IsNamedBufferResidentNV_fnptr(buffer);
            }
            
            private static delegate* unmanaged<BufferTargetARB, All, ulong*, void> _GetBufferParameterui64vNV_fnptr = &GetBufferParameterui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBufferParameterui64vNV(BufferTargetARB target, All pname, ulong* parameters) => _GetBufferParameterui64vNV_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetBufferParameterui64vNV_Lazy(BufferTargetARB target, All pname, ulong* parameters)
            {
                _GetBufferParameterui64vNV_fnptr = (delegate* unmanaged<BufferTargetARB, All, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetBufferParameterui64vNV");
                _GetBufferParameterui64vNV_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<BufferHandle, BufferPNameARB, ulong*, void> _GetNamedBufferParameterui64vNV_fnptr = &GetNamedBufferParameterui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedBufferParameterui64vNV(BufferHandle buffer, BufferPNameARB pname, ulong* parameters) => _GetNamedBufferParameterui64vNV_fnptr(buffer, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetNamedBufferParameterui64vNV_Lazy(BufferHandle buffer, BufferPNameARB pname, ulong* parameters)
            {
                _GetNamedBufferParameterui64vNV_fnptr = (delegate* unmanaged<BufferHandle, BufferPNameARB, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNamedBufferParameterui64vNV");
                _GetNamedBufferParameterui64vNV_fnptr(buffer, pname, parameters);
            }
            
            private static delegate* unmanaged<All, ulong*, void> _GetIntegerui64vNV_fnptr = &GetIntegerui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetIntegerui64vNV(All value, ulong* result) => _GetIntegerui64vNV_fnptr(value, result);
            [UnmanagedCallersOnly]
            private static void GetIntegerui64vNV_Lazy(All value, ulong* result)
            {
                _GetIntegerui64vNV_fnptr = (delegate* unmanaged<All, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetIntegerui64vNV");
                _GetIntegerui64vNV_fnptr(value, result);
            }
            
            private static delegate* unmanaged<int, ulong, void> _Uniformui64NV_fnptr = &Uniformui64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniformui64NV(int location, ulong value) => _Uniformui64NV_fnptr(location, value);
            [UnmanagedCallersOnly]
            private static void Uniformui64NV_Lazy(int location, ulong value)
            {
                _Uniformui64NV_fnptr = (delegate* unmanaged<int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glUniformui64NV");
                _Uniformui64NV_fnptr(location, value);
            }
            
            private static delegate* unmanaged<int, int, ulong*, void> _Uniformui64vNV_fnptr = &Uniformui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniformui64vNV(int location, int count, ulong* value) => _Uniformui64vNV_fnptr(location, count, value);
            [UnmanagedCallersOnly]
            private static void Uniformui64vNV_Lazy(int location, int count, ulong* value)
            {
                _Uniformui64vNV_fnptr = (delegate* unmanaged<int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glUniformui64vNV");
                _Uniformui64vNV_fnptr(location, count, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong*, void> _GetUniformui64vNV_fnptr = &GetUniformui64vNV_Lazy;
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformui64vNV(ProgramHandle program, int location, ulong* parameters) => _GetUniformui64vNV_fnptr(program, location, parameters);
            [UnmanagedCallersOnly]
            private static void GetUniformui64vNV_Lazy(ProgramHandle program, int location, ulong* parameters)
            {
                _GetUniformui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetUniformui64vNV");
                _GetUniformui64vNV_fnptr(program, location, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, ulong, void> _ProgramUniformui64NV_fnptr = &ProgramUniformui64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformui64NV(ProgramHandle program, int location, ulong value) => _ProgramUniformui64NV_fnptr(program, location, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformui64NV_Lazy(ProgramHandle program, int location, ulong value)
            {
                _ProgramUniformui64NV_fnptr = (delegate* unmanaged<ProgramHandle, int, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformui64NV");
                _ProgramUniformui64NV_fnptr(program, location, value);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, ulong*, void> _ProgramUniformui64vNV_fnptr = &ProgramUniformui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformui64vNV(ProgramHandle program, int location, int count, ulong* value) => _ProgramUniformui64vNV_fnptr(program, location, count, value);
            [UnmanagedCallersOnly]
            private static void ProgramUniformui64vNV_Lazy(ProgramHandle program, int location, int count, ulong* value)
            {
                _ProgramUniformui64vNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramUniformui64vNV");
                _ProgramUniformui64vNV_fnptr(program, location, count, value);
            }
            
            private static delegate* unmanaged<TextureHandle, void> _BindShadingRateImageNV_fnptr = &BindShadingRateImageNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindShadingRateImageNV(TextureHandle texture) => _BindShadingRateImageNV_fnptr(texture);
            [UnmanagedCallersOnly]
            private static void BindShadingRateImageNV_Lazy(TextureHandle texture)
            {
                _BindShadingRateImageNV_fnptr = (delegate* unmanaged<TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindShadingRateImageNV");
                _BindShadingRateImageNV_fnptr(texture);
            }
            
            private static delegate* unmanaged<uint, uint, All*, void> _GetShadingRateImagePaletteNV_fnptr = &GetShadingRateImagePaletteNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, All* rate) => _GetShadingRateImagePaletteNV_fnptr(viewport, entry, rate);
            [UnmanagedCallersOnly]
            private static void GetShadingRateImagePaletteNV_Lazy(uint viewport, uint entry, All* rate)
            {
                _GetShadingRateImagePaletteNV_fnptr = (delegate* unmanaged<uint, uint, All*, void>)GLLoader.BindingsContext.GetProcAddress("glGetShadingRateImagePaletteNV");
                _GetShadingRateImagePaletteNV_fnptr(viewport, entry, rate);
            }
            
            private static delegate* unmanaged<All, uint, uint, int*, void> _GetShadingRateSampleLocationivNV_fnptr = &GetShadingRateSampleLocationivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetShadingRateSampleLocationivNV(All rate, uint samples, uint index, int* location) => _GetShadingRateSampleLocationivNV_fnptr(rate, samples, index, location);
            [UnmanagedCallersOnly]
            private static void GetShadingRateSampleLocationivNV_Lazy(All rate, uint samples, uint index, int* location)
            {
                _GetShadingRateSampleLocationivNV_fnptr = (delegate* unmanaged<All, uint, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetShadingRateSampleLocationivNV");
                _GetShadingRateSampleLocationivNV_fnptr(rate, samples, index, location);
            }
            
            private static delegate* unmanaged<byte, void> _ShadingRateImageBarrierNV_fnptr = &ShadingRateImageBarrierNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShadingRateImageBarrierNV(byte synchronize) => _ShadingRateImageBarrierNV_fnptr(synchronize);
            [UnmanagedCallersOnly]
            private static void ShadingRateImageBarrierNV_Lazy(byte synchronize)
            {
                _ShadingRateImageBarrierNV_fnptr = (delegate* unmanaged<byte, void>)GLLoader.BindingsContext.GetProcAddress("glShadingRateImageBarrierNV");
                _ShadingRateImageBarrierNV_fnptr(synchronize);
            }
            
            private static delegate* unmanaged<uint, uint, int, All*, void> _ShadingRateImagePaletteNV_fnptr = &ShadingRateImagePaletteNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, All* rates) => _ShadingRateImagePaletteNV_fnptr(viewport, first, count, rates);
            [UnmanagedCallersOnly]
            private static void ShadingRateImagePaletteNV_Lazy(uint viewport, uint first, int count, All* rates)
            {
                _ShadingRateImagePaletteNV_fnptr = (delegate* unmanaged<uint, uint, int, All*, void>)GLLoader.BindingsContext.GetProcAddress("glShadingRateImagePaletteNV");
                _ShadingRateImagePaletteNV_fnptr(viewport, first, count, rates);
            }
            
            private static delegate* unmanaged<All, void> _ShadingRateSampleOrderNV_fnptr = &ShadingRateSampleOrderNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShadingRateSampleOrderNV(All order) => _ShadingRateSampleOrderNV_fnptr(order);
            [UnmanagedCallersOnly]
            private static void ShadingRateSampleOrderNV_Lazy(All order)
            {
                _ShadingRateSampleOrderNV_fnptr = (delegate* unmanaged<All, void>)GLLoader.BindingsContext.GetProcAddress("glShadingRateSampleOrderNV");
                _ShadingRateSampleOrderNV_fnptr(order);
            }
            
            private static delegate* unmanaged<All, uint, int*, void> _ShadingRateSampleOrderCustomNV_fnptr = &ShadingRateSampleOrderCustomNV_Lazy;
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShadingRateSampleOrderCustomNV(All rate, uint samples, int* locations) => _ShadingRateSampleOrderCustomNV_fnptr(rate, samples, locations);
            [UnmanagedCallersOnly]
            private static void ShadingRateSampleOrderCustomNV_Lazy(All rate, uint samples, int* locations)
            {
                _ShadingRateSampleOrderCustomNV_fnptr = (delegate* unmanaged<All, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glShadingRateSampleOrderCustomNV");
                _ShadingRateSampleOrderCustomNV_fnptr(rate, samples, locations);
            }
            
            private static delegate* unmanaged<void> _TextureBarrierNV_fnptr = &TextureBarrierNV_Lazy;
            /// <summary> <b>[requires: GL_NV_texture_barrier]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureBarrierNV() => _TextureBarrierNV_fnptr();
            [UnmanagedCallersOnly]
            private static void TextureBarrierNV_Lazy()
            {
                _TextureBarrierNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glTextureBarrierNV");
                _TextureBarrierNV_fnptr();
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, byte, void> _TexImage2DMultisampleCoverageNV_fnptr = &TexImage2DMultisampleCoverageNV_Lazy;
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexImage2DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, byte fixedSampleLocations) => _TexImage2DMultisampleCoverageNV_fnptr(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
            [UnmanagedCallersOnly]
            private static void TexImage2DMultisampleCoverageNV_Lazy(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, byte fixedSampleLocations)
            {
                _TexImage2DMultisampleCoverageNV_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage2DMultisampleCoverageNV");
                _TexImage2DMultisampleCoverageNV_fnptr(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, byte, void> _TexImage3DMultisampleCoverageNV_fnptr = &TexImage3DMultisampleCoverageNV_Lazy;
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexImage3DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, byte fixedSampleLocations) => _TexImage3DMultisampleCoverageNV_fnptr(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
            [UnmanagedCallersOnly]
            private static void TexImage3DMultisampleCoverageNV_Lazy(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, byte fixedSampleLocations)
            {
                _TexImage3DMultisampleCoverageNV_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage3DMultisampleCoverageNV");
                _TexImage3DMultisampleCoverageNV_fnptr(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, byte, void> _TextureImage2DMultisampleNV_fnptr = &TextureImage2DMultisampleNV_Lazy;
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage2DMultisampleNV(TextureHandle texture, TextureTarget target, int samples, int internalFormat, int width, int height, byte fixedSampleLocations) => _TextureImage2DMultisampleNV_fnptr(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
            [UnmanagedCallersOnly]
            private static void TextureImage2DMultisampleNV_Lazy(TextureHandle texture, TextureTarget target, int samples, int internalFormat, int width, int height, byte fixedSampleLocations)
            {
                _TextureImage2DMultisampleNV_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureImage2DMultisampleNV");
                _TextureImage2DMultisampleNV_fnptr(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, byte, void> _TextureImage3DMultisampleNV_fnptr = &TextureImage3DMultisampleNV_Lazy;
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage3DMultisampleNV(TextureHandle texture, TextureTarget target, int samples, int internalFormat, int width, int height, int depth, byte fixedSampleLocations) => _TextureImage3DMultisampleNV_fnptr(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
            [UnmanagedCallersOnly]
            private static void TextureImage3DMultisampleNV_Lazy(TextureHandle texture, TextureTarget target, int samples, int internalFormat, int width, int height, int depth, byte fixedSampleLocations)
            {
                _TextureImage3DMultisampleNV_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureImage3DMultisampleNV");
                _TextureImage3DMultisampleNV_fnptr(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, byte, void> _TextureImage2DMultisampleCoverageNV_fnptr = &TextureImage2DMultisampleCoverageNV_Lazy;
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage2DMultisampleCoverageNV(TextureHandle texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, byte fixedSampleLocations) => _TextureImage2DMultisampleCoverageNV_fnptr(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
            [UnmanagedCallersOnly]
            private static void TextureImage2DMultisampleCoverageNV_Lazy(TextureHandle texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, byte fixedSampleLocations)
            {
                _TextureImage2DMultisampleCoverageNV_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureImage2DMultisampleCoverageNV");
                _TextureImage2DMultisampleCoverageNV_fnptr(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
            }
            
            private static delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, byte, void> _TextureImage3DMultisampleCoverageNV_fnptr = &TextureImage3DMultisampleCoverageNV_Lazy;
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage3DMultisampleCoverageNV(TextureHandle texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, byte fixedSampleLocations) => _TextureImage3DMultisampleCoverageNV_fnptr(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
            [UnmanagedCallersOnly]
            private static void TextureImage3DMultisampleCoverageNV_Lazy(TextureHandle texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, byte fixedSampleLocations)
            {
                _TextureImage3DMultisampleCoverageNV_fnptr = (delegate* unmanaged<TextureHandle, TextureTarget, int, int, int, int, int, int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureImage3DMultisampleCoverageNV");
                _TextureImage3DMultisampleCoverageNV_fnptr(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
            }
            
            private static delegate* unmanaged<PrimitiveType, void> _BeginTransformFeedbackNV_fnptr = &BeginTransformFeedbackNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginTransformFeedbackNV(PrimitiveType primitiveMode) => _BeginTransformFeedbackNV_fnptr(primitiveMode);
            [UnmanagedCallersOnly]
            private static void BeginTransformFeedbackNV_Lazy(PrimitiveType primitiveMode)
            {
                _BeginTransformFeedbackNV_fnptr = (delegate* unmanaged<PrimitiveType, void>)GLLoader.BindingsContext.GetProcAddress("glBeginTransformFeedbackNV");
                _BeginTransformFeedbackNV_fnptr(primitiveMode);
            }
            
            private static delegate* unmanaged<void> _EndTransformFeedbackNV_fnptr = &EndTransformFeedbackNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndTransformFeedbackNV() => _EndTransformFeedbackNV_fnptr();
            [UnmanagedCallersOnly]
            private static void EndTransformFeedbackNV_Lazy()
            {
                _EndTransformFeedbackNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndTransformFeedbackNV");
                _EndTransformFeedbackNV_fnptr();
            }
            
            private static delegate* unmanaged<int, int*, All, void> _TransformFeedbackAttribsNV_fnptr = &TransformFeedbackAttribsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformFeedbackAttribsNV(int count, int* attribs, All bufferMode) => _TransformFeedbackAttribsNV_fnptr(count, attribs, bufferMode);
            [UnmanagedCallersOnly]
            private static void TransformFeedbackAttribsNV_Lazy(int count, int* attribs, All bufferMode)
            {
                _TransformFeedbackAttribsNV_fnptr = (delegate* unmanaged<int, int*, All, void>)GLLoader.BindingsContext.GetProcAddress("glTransformFeedbackAttribsNV");
                _TransformFeedbackAttribsNV_fnptr(count, attribs, bufferMode);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, nint, void> _BindBufferRangeNV_fnptr = &BindBufferRangeNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferRangeNV(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size) => _BindBufferRangeNV_fnptr(target, index, buffer, offset, size);
            [UnmanagedCallersOnly]
            private static void BindBufferRangeNV_Lazy(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size)
            {
                _BindBufferRangeNV_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, nint, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferRangeNV");
                _BindBufferRangeNV_fnptr(target, index, buffer, offset, size);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, void> _BindBufferOffsetNV_fnptr = &BindBufferOffsetNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferOffsetNV(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset) => _BindBufferOffsetNV_fnptr(target, index, buffer, offset);
            [UnmanagedCallersOnly]
            private static void BindBufferOffsetNV_Lazy(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset)
            {
                _BindBufferOffsetNV_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferOffsetNV");
                _BindBufferOffsetNV_fnptr(target, index, buffer, offset);
            }
            
            private static delegate* unmanaged<BufferTargetARB, uint, BufferHandle, void> _BindBufferBaseNV_fnptr = &BindBufferBaseNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferBaseNV(BufferTargetARB target, uint index, BufferHandle buffer) => _BindBufferBaseNV_fnptr(target, index, buffer);
            [UnmanagedCallersOnly]
            private static void BindBufferBaseNV_Lazy(BufferTargetARB target, uint index, BufferHandle buffer)
            {
                _BindBufferBaseNV_fnptr = (delegate* unmanaged<BufferTargetARB, uint, BufferHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindBufferBaseNV");
                _BindBufferBaseNV_fnptr(target, index, buffer);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int*, All, void> _TransformFeedbackVaryingsNV_fnptr = &TransformFeedbackVaryingsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformFeedbackVaryingsNV(ProgramHandle program, int count, int* locations, All bufferMode) => _TransformFeedbackVaryingsNV_fnptr(program, count, locations, bufferMode);
            [UnmanagedCallersOnly]
            private static void TransformFeedbackVaryingsNV_Lazy(ProgramHandle program, int count, int* locations, All bufferMode)
            {
                _TransformFeedbackVaryingsNV_fnptr = (delegate* unmanaged<ProgramHandle, int, int*, All, void>)GLLoader.BindingsContext.GetProcAddress("glTransformFeedbackVaryingsNV");
                _TransformFeedbackVaryingsNV_fnptr(program, count, locations, bufferMode);
            }
            
            private static delegate* unmanaged<ProgramHandle, byte*, void> _ActiveVaryingNV_fnptr = &ActiveVaryingNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveVaryingNV(ProgramHandle program, byte* name) => _ActiveVaryingNV_fnptr(program, name);
            [UnmanagedCallersOnly]
            private static void ActiveVaryingNV_Lazy(ProgramHandle program, byte* name)
            {
                _ActiveVaryingNV_fnptr = (delegate* unmanaged<ProgramHandle, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glActiveVaryingNV");
                _ActiveVaryingNV_fnptr(program, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, byte*, int> _GetVaryingLocationNV_fnptr = &GetVaryingLocationNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetVaryingLocationNV(ProgramHandle program, byte* name) => _GetVaryingLocationNV_fnptr(program, name);
            [UnmanagedCallersOnly]
            private static int GetVaryingLocationNV_Lazy(ProgramHandle program, byte* name)
            {
                _GetVaryingLocationNV_fnptr = (delegate* unmanaged<ProgramHandle, byte*, int>)GLLoader.BindingsContext.GetProcAddress("glGetVaryingLocationNV");
                return _GetVaryingLocationNV_fnptr(program, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, int, int*, int*, All*, byte*, void> _GetActiveVaryingNV_fnptr = &GetActiveVaryingNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetActiveVaryingNV(ProgramHandle program, uint index, int bufSize, int* length, int* size, All* type, byte* name) => _GetActiveVaryingNV_fnptr(program, index, bufSize, length, size, type, name);
            [UnmanagedCallersOnly]
            private static void GetActiveVaryingNV_Lazy(ProgramHandle program, uint index, int bufSize, int* length, int* size, All* type, byte* name)
            {
                _GetActiveVaryingNV_fnptr = (delegate* unmanaged<ProgramHandle, uint, int, int*, int*, All*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetActiveVaryingNV");
                _GetActiveVaryingNV_fnptr(program, index, bufSize, length, size, type, name);
            }
            
            private static delegate* unmanaged<ProgramHandle, uint, int*, void> _GetTransformFeedbackVaryingNV_fnptr = &GetTransformFeedbackVaryingNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTransformFeedbackVaryingNV(ProgramHandle program, uint index, int* location) => _GetTransformFeedbackVaryingNV_fnptr(program, index, location);
            [UnmanagedCallersOnly]
            private static void GetTransformFeedbackVaryingNV_Lazy(ProgramHandle program, uint index, int* location)
            {
                _GetTransformFeedbackVaryingNV_fnptr = (delegate* unmanaged<ProgramHandle, uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTransformFeedbackVaryingNV");
                _GetTransformFeedbackVaryingNV_fnptr(program, index, location);
            }
            
            private static delegate* unmanaged<int, int*, int, int*, All, void> _TransformFeedbackStreamAttribsNV_fnptr = &TransformFeedbackStreamAttribsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformFeedbackStreamAttribsNV(int count, int* attribs, int nbuffers, int* bufstreams, All bufferMode) => _TransformFeedbackStreamAttribsNV_fnptr(count, attribs, nbuffers, bufstreams, bufferMode);
            [UnmanagedCallersOnly]
            private static void TransformFeedbackStreamAttribsNV_Lazy(int count, int* attribs, int nbuffers, int* bufstreams, All bufferMode)
            {
                _TransformFeedbackStreamAttribsNV_fnptr = (delegate* unmanaged<int, int*, int, int*, All, void>)GLLoader.BindingsContext.GetProcAddress("glTransformFeedbackStreamAttribsNV");
                _TransformFeedbackStreamAttribsNV_fnptr(count, attribs, nbuffers, bufstreams, bufferMode);
            }
            
            private static delegate* unmanaged<BufferTargetARB, TransformFeedbackHandle, void> _BindTransformFeedbackNV_fnptr = &BindTransformFeedbackNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindTransformFeedbackNV(BufferTargetARB target, TransformFeedbackHandle id) => _BindTransformFeedbackNV_fnptr(target, id);
            [UnmanagedCallersOnly]
            private static void BindTransformFeedbackNV_Lazy(BufferTargetARB target, TransformFeedbackHandle id)
            {
                _BindTransformFeedbackNV_fnptr = (delegate* unmanaged<BufferTargetARB, TransformFeedbackHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindTransformFeedbackNV");
                _BindTransformFeedbackNV_fnptr(target, id);
            }
            
            private static delegate* unmanaged<int, TransformFeedbackHandle*, void> _DeleteTransformFeedbacksNV_fnptr = &DeleteTransformFeedbacksNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteTransformFeedbacksNV(int n, TransformFeedbackHandle* ids) => _DeleteTransformFeedbacksNV_fnptr(n, ids);
            [UnmanagedCallersOnly]
            private static void DeleteTransformFeedbacksNV_Lazy(int n, TransformFeedbackHandle* ids)
            {
                _DeleteTransformFeedbacksNV_fnptr = (delegate* unmanaged<int, TransformFeedbackHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteTransformFeedbacksNV");
                _DeleteTransformFeedbacksNV_fnptr(n, ids);
            }
            
            private static delegate* unmanaged<int, TransformFeedbackHandle*, void> _GenTransformFeedbacksNV_fnptr = &GenTransformFeedbacksNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenTransformFeedbacksNV(int n, TransformFeedbackHandle* ids) => _GenTransformFeedbacksNV_fnptr(n, ids);
            [UnmanagedCallersOnly]
            private static void GenTransformFeedbacksNV_Lazy(int n, TransformFeedbackHandle* ids)
            {
                _GenTransformFeedbacksNV_fnptr = (delegate* unmanaged<int, TransformFeedbackHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenTransformFeedbacksNV");
                _GenTransformFeedbacksNV_fnptr(n, ids);
            }
            
            private static delegate* unmanaged<TransformFeedbackHandle, byte> _IsTransformFeedbackNV_fnptr = &IsTransformFeedbackNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsTransformFeedbackNV(TransformFeedbackHandle id) => _IsTransformFeedbackNV_fnptr(id);
            [UnmanagedCallersOnly]
            private static byte IsTransformFeedbackNV_Lazy(TransformFeedbackHandle id)
            {
                _IsTransformFeedbackNV_fnptr = (delegate* unmanaged<TransformFeedbackHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsTransformFeedbackNV");
                return _IsTransformFeedbackNV_fnptr(id);
            }
            
            private static delegate* unmanaged<void> _PauseTransformFeedbackNV_fnptr = &PauseTransformFeedbackNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PauseTransformFeedbackNV() => _PauseTransformFeedbackNV_fnptr();
            [UnmanagedCallersOnly]
            private static void PauseTransformFeedbackNV_Lazy()
            {
                _PauseTransformFeedbackNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPauseTransformFeedbackNV");
                _PauseTransformFeedbackNV_fnptr();
            }
            
            private static delegate* unmanaged<void> _ResumeTransformFeedbackNV_fnptr = &ResumeTransformFeedbackNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResumeTransformFeedbackNV() => _ResumeTransformFeedbackNV_fnptr();
            [UnmanagedCallersOnly]
            private static void ResumeTransformFeedbackNV_Lazy()
            {
                _ResumeTransformFeedbackNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glResumeTransformFeedbackNV");
                _ResumeTransformFeedbackNV_fnptr();
            }
            
            private static delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, void> _DrawTransformFeedbackNV_fnptr = &DrawTransformFeedbackNV_Lazy;
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawTransformFeedbackNV(PrimitiveType mode, TransformFeedbackHandle id) => _DrawTransformFeedbackNV_fnptr(mode, id);
            [UnmanagedCallersOnly]
            private static void DrawTransformFeedbackNV_Lazy(PrimitiveType mode, TransformFeedbackHandle id)
            {
                _DrawTransformFeedbackNV_fnptr = (delegate* unmanaged<PrimitiveType, TransformFeedbackHandle, void>)GLLoader.BindingsContext.GetProcAddress("glDrawTransformFeedbackNV");
                _DrawTransformFeedbackNV_fnptr(mode, id);
            }
            
            private static delegate* unmanaged<void*, void*, void> _VDPAUInitNV_fnptr = &VDPAUInitNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUInitNV(void* vdpDevice, void* getProcAddress) => _VDPAUInitNV_fnptr(vdpDevice, getProcAddress);
            [UnmanagedCallersOnly]
            private static void VDPAUInitNV_Lazy(void* vdpDevice, void* getProcAddress)
            {
                _VDPAUInitNV_fnptr = (delegate* unmanaged<void*, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVDPAUInitNV");
                _VDPAUInitNV_fnptr(vdpDevice, getProcAddress);
            }
            
            private static delegate* unmanaged<void> _VDPAUFiniNV_fnptr = &VDPAUFiniNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUFiniNV() => _VDPAUFiniNV_fnptr();
            [UnmanagedCallersOnly]
            private static void VDPAUFiniNV_Lazy()
            {
                _VDPAUFiniNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glVDPAUFiniNV");
                _VDPAUFiniNV_fnptr();
            }
            
            private static delegate* unmanaged<void*, All, int, uint*, IntPtr> _VDPAURegisterVideoSurfaceNV_fnptr = &VDPAURegisterVideoSurfaceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr VDPAURegisterVideoSurfaceNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => _VDPAURegisterVideoSurfaceNV_fnptr(vdpSurface, target, numTextureNames, textureNames);
            [UnmanagedCallersOnly]
            private static IntPtr VDPAURegisterVideoSurfaceNV_Lazy(void* vdpSurface, All target, int numTextureNames, uint* textureNames)
            {
                _VDPAURegisterVideoSurfaceNV_fnptr = (delegate* unmanaged<void*, All, int, uint*, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glVDPAURegisterVideoSurfaceNV");
                return _VDPAURegisterVideoSurfaceNV_fnptr(vdpSurface, target, numTextureNames, textureNames);
            }
            
            private static delegate* unmanaged<void*, All, int, uint*, IntPtr> _VDPAURegisterOutputSurfaceNV_fnptr = &VDPAURegisterOutputSurfaceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr VDPAURegisterOutputSurfaceNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => _VDPAURegisterOutputSurfaceNV_fnptr(vdpSurface, target, numTextureNames, textureNames);
            [UnmanagedCallersOnly]
            private static IntPtr VDPAURegisterOutputSurfaceNV_Lazy(void* vdpSurface, All target, int numTextureNames, uint* textureNames)
            {
                _VDPAURegisterOutputSurfaceNV_fnptr = (delegate* unmanaged<void*, All, int, uint*, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glVDPAURegisterOutputSurfaceNV");
                return _VDPAURegisterOutputSurfaceNV_fnptr(vdpSurface, target, numTextureNames, textureNames);
            }
            
            private static delegate* unmanaged<IntPtr, byte> _VDPAUIsSurfaceNV_fnptr = &VDPAUIsSurfaceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte VDPAUIsSurfaceNV(IntPtr surface) => _VDPAUIsSurfaceNV_fnptr(surface);
            [UnmanagedCallersOnly]
            private static byte VDPAUIsSurfaceNV_Lazy(IntPtr surface)
            {
                _VDPAUIsSurfaceNV_fnptr = (delegate* unmanaged<IntPtr, byte>)GLLoader.BindingsContext.GetProcAddress("glVDPAUIsSurfaceNV");
                return _VDPAUIsSurfaceNV_fnptr(surface);
            }
            
            private static delegate* unmanaged<IntPtr, void> _VDPAUUnregisterSurfaceNV_fnptr = &VDPAUUnregisterSurfaceNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUUnregisterSurfaceNV(IntPtr surface) => _VDPAUUnregisterSurfaceNV_fnptr(surface);
            [UnmanagedCallersOnly]
            private static void VDPAUUnregisterSurfaceNV_Lazy(IntPtr surface)
            {
                _VDPAUUnregisterSurfaceNV_fnptr = (delegate* unmanaged<IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glVDPAUUnregisterSurfaceNV");
                _VDPAUUnregisterSurfaceNV_fnptr(surface);
            }
            
            private static delegate* unmanaged<IntPtr, All, int, int*, int*, void> _VDPAUGetSurfaceivNV_fnptr = &VDPAUGetSurfaceivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUGetSurfaceivNV(IntPtr surface, All pname, int count, int* length, int* values) => _VDPAUGetSurfaceivNV_fnptr(surface, pname, count, length, values);
            [UnmanagedCallersOnly]
            private static void VDPAUGetSurfaceivNV_Lazy(IntPtr surface, All pname, int count, int* length, int* values)
            {
                _VDPAUGetSurfaceivNV_fnptr = (delegate* unmanaged<IntPtr, All, int, int*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVDPAUGetSurfaceivNV");
                _VDPAUGetSurfaceivNV_fnptr(surface, pname, count, length, values);
            }
            
            private static delegate* unmanaged<IntPtr, All, void> _VDPAUSurfaceAccessNV_fnptr = &VDPAUSurfaceAccessNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUSurfaceAccessNV(IntPtr surface, All access) => _VDPAUSurfaceAccessNV_fnptr(surface, access);
            [UnmanagedCallersOnly]
            private static void VDPAUSurfaceAccessNV_Lazy(IntPtr surface, All access)
            {
                _VDPAUSurfaceAccessNV_fnptr = (delegate* unmanaged<IntPtr, All, void>)GLLoader.BindingsContext.GetProcAddress("glVDPAUSurfaceAccessNV");
                _VDPAUSurfaceAccessNV_fnptr(surface, access);
            }
            
            private static delegate* unmanaged<int, IntPtr*, void> _VDPAUMapSurfacesNV_fnptr = &VDPAUMapSurfacesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUMapSurfacesNV(int numSurfaces, IntPtr* surfaces) => _VDPAUMapSurfacesNV_fnptr(numSurfaces, surfaces);
            [UnmanagedCallersOnly]
            private static void VDPAUMapSurfacesNV_Lazy(int numSurfaces, IntPtr* surfaces)
            {
                _VDPAUMapSurfacesNV_fnptr = (delegate* unmanaged<int, IntPtr*, void>)GLLoader.BindingsContext.GetProcAddress("glVDPAUMapSurfacesNV");
                _VDPAUMapSurfacesNV_fnptr(numSurfaces, surfaces);
            }
            
            private static delegate* unmanaged<int, IntPtr*, void> _VDPAUUnmapSurfacesNV_fnptr = &VDPAUUnmapSurfacesNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUUnmapSurfacesNV(int numSurface, IntPtr* surfaces) => _VDPAUUnmapSurfacesNV_fnptr(numSurface, surfaces);
            [UnmanagedCallersOnly]
            private static void VDPAUUnmapSurfacesNV_Lazy(int numSurface, IntPtr* surfaces)
            {
                _VDPAUUnmapSurfacesNV_fnptr = (delegate* unmanaged<int, IntPtr*, void>)GLLoader.BindingsContext.GetProcAddress("glVDPAUUnmapSurfacesNV");
                _VDPAUUnmapSurfacesNV_fnptr(numSurface, surfaces);
            }
            
            private static delegate* unmanaged<void*, All, int, uint*, byte, IntPtr> _VDPAURegisterVideoSurfaceWithPictureStructureNV_fnptr = &VDPAURegisterVideoSurfaceWithPictureStructureNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vdpau_interop2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames, byte isFrameStructure) => _VDPAURegisterVideoSurfaceWithPictureStructureNV_fnptr(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
            [UnmanagedCallersOnly]
            private static IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV_Lazy(void* vdpSurface, All target, int numTextureNames, uint* textureNames, byte isFrameStructure)
            {
                _VDPAURegisterVideoSurfaceWithPictureStructureNV_fnptr = (delegate* unmanaged<void*, All, int, uint*, byte, IntPtr>)GLLoader.BindingsContext.GetProcAddress("glVDPAURegisterVideoSurfaceWithPictureStructureNV");
                return _VDPAURegisterVideoSurfaceWithPictureStructureNV_fnptr(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
            }
            
            private static delegate* unmanaged<void> _FlushVertexArrayRangeNV_fnptr = &FlushVertexArrayRangeNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushVertexArrayRangeNV() => _FlushVertexArrayRangeNV_fnptr();
            [UnmanagedCallersOnly]
            private static void FlushVertexArrayRangeNV_Lazy()
            {
                _FlushVertexArrayRangeNV_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glFlushVertexArrayRangeNV");
                _FlushVertexArrayRangeNV_fnptr();
            }
            
            private static delegate* unmanaged<int, void*, void> _VertexArrayRangeNV_fnptr = &VertexArrayRangeNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayRangeNV(int length, void* pointer) => _VertexArrayRangeNV_fnptr(length, pointer);
            [UnmanagedCallersOnly]
            private static void VertexArrayRangeNV_Lazy(int length, void* pointer)
            {
                _VertexArrayRangeNV_fnptr = (delegate* unmanaged<int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexArrayRangeNV");
                _VertexArrayRangeNV_fnptr(length, pointer);
            }
            
            private static delegate* unmanaged<uint, long, void> _VertexAttribL1i64NV_fnptr = &VertexAttribL1i64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1i64NV(uint index, long x) => _VertexAttribL1i64NV_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1i64NV_Lazy(uint index, long x)
            {
                _VertexAttribL1i64NV_fnptr = (delegate* unmanaged<uint, long, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1i64NV");
                _VertexAttribL1i64NV_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, long, long, void> _VertexAttribL2i64NV_fnptr = &VertexAttribL2i64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2i64NV(uint index, long x, long y) => _VertexAttribL2i64NV_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttribL2i64NV_Lazy(uint index, long x, long y)
            {
                _VertexAttribL2i64NV_fnptr = (delegate* unmanaged<uint, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2i64NV");
                _VertexAttribL2i64NV_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, long, long, long, void> _VertexAttribL3i64NV_fnptr = &VertexAttribL3i64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3i64NV(uint index, long x, long y, long z) => _VertexAttribL3i64NV_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttribL3i64NV_Lazy(uint index, long x, long y, long z)
            {
                _VertexAttribL3i64NV_fnptr = (delegate* unmanaged<uint, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3i64NV");
                _VertexAttribL3i64NV_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, long, long, long, long, void> _VertexAttribL4i64NV_fnptr = &VertexAttribL4i64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4i64NV(uint index, long x, long y, long z, long w) => _VertexAttribL4i64NV_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttribL4i64NV_Lazy(uint index, long x, long y, long z, long w)
            {
                _VertexAttribL4i64NV_fnptr = (delegate* unmanaged<uint, long, long, long, long, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4i64NV");
                _VertexAttribL4i64NV_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, long*, void> _VertexAttribL1i64vNV_fnptr = &VertexAttribL1i64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1i64vNV(uint index, long* v) => _VertexAttribL1i64vNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1i64vNV_Lazy(uint index, long* v)
            {
                _VertexAttribL1i64vNV_fnptr = (delegate* unmanaged<uint, long*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1i64vNV");
                _VertexAttribL1i64vNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, long*, void> _VertexAttribL2i64vNV_fnptr = &VertexAttribL2i64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2i64vNV(uint index, long* v) => _VertexAttribL2i64vNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL2i64vNV_Lazy(uint index, long* v)
            {
                _VertexAttribL2i64vNV_fnptr = (delegate* unmanaged<uint, long*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2i64vNV");
                _VertexAttribL2i64vNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, long*, void> _VertexAttribL3i64vNV_fnptr = &VertexAttribL3i64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3i64vNV(uint index, long* v) => _VertexAttribL3i64vNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL3i64vNV_Lazy(uint index, long* v)
            {
                _VertexAttribL3i64vNV_fnptr = (delegate* unmanaged<uint, long*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3i64vNV");
                _VertexAttribL3i64vNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, long*, void> _VertexAttribL4i64vNV_fnptr = &VertexAttribL4i64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4i64vNV(uint index, long* v) => _VertexAttribL4i64vNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL4i64vNV_Lazy(uint index, long* v)
            {
                _VertexAttribL4i64vNV_fnptr = (delegate* unmanaged<uint, long*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4i64vNV");
                _VertexAttribL4i64vNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, ulong, void> _VertexAttribL1ui64NV_fnptr = &VertexAttribL1ui64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1ui64NV(uint index, ulong x) => _VertexAttribL1ui64NV_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1ui64NV_Lazy(uint index, ulong x)
            {
                _VertexAttribL1ui64NV_fnptr = (delegate* unmanaged<uint, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1ui64NV");
                _VertexAttribL1ui64NV_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, ulong, ulong, void> _VertexAttribL2ui64NV_fnptr = &VertexAttribL2ui64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2ui64NV(uint index, ulong x, ulong y) => _VertexAttribL2ui64NV_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttribL2ui64NV_Lazy(uint index, ulong x, ulong y)
            {
                _VertexAttribL2ui64NV_fnptr = (delegate* unmanaged<uint, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2ui64NV");
                _VertexAttribL2ui64NV_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, ulong, ulong, ulong, void> _VertexAttribL3ui64NV_fnptr = &VertexAttribL3ui64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3ui64NV(uint index, ulong x, ulong y, ulong z) => _VertexAttribL3ui64NV_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttribL3ui64NV_Lazy(uint index, ulong x, ulong y, ulong z)
            {
                _VertexAttribL3ui64NV_fnptr = (delegate* unmanaged<uint, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3ui64NV");
                _VertexAttribL3ui64NV_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, ulong, ulong, ulong, ulong, void> _VertexAttribL4ui64NV_fnptr = &VertexAttribL4ui64NV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4ui64NV(uint index, ulong x, ulong y, ulong z, ulong w) => _VertexAttribL4ui64NV_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttribL4ui64NV_Lazy(uint index, ulong x, ulong y, ulong z, ulong w)
            {
                _VertexAttribL4ui64NV_fnptr = (delegate* unmanaged<uint, ulong, ulong, ulong, ulong, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4ui64NV");
                _VertexAttribL4ui64NV_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, ulong*, void> _VertexAttribL1ui64vNV_fnptr = &VertexAttribL1ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1ui64vNV(uint index, ulong* v) => _VertexAttribL1ui64vNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL1ui64vNV_Lazy(uint index, ulong* v)
            {
                _VertexAttribL1ui64vNV_fnptr = (delegate* unmanaged<uint, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL1ui64vNV");
                _VertexAttribL1ui64vNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, ulong*, void> _VertexAttribL2ui64vNV_fnptr = &VertexAttribL2ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2ui64vNV(uint index, ulong* v) => _VertexAttribL2ui64vNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL2ui64vNV_Lazy(uint index, ulong* v)
            {
                _VertexAttribL2ui64vNV_fnptr = (delegate* unmanaged<uint, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL2ui64vNV");
                _VertexAttribL2ui64vNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, ulong*, void> _VertexAttribL3ui64vNV_fnptr = &VertexAttribL3ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3ui64vNV(uint index, ulong* v) => _VertexAttribL3ui64vNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL3ui64vNV_Lazy(uint index, ulong* v)
            {
                _VertexAttribL3ui64vNV_fnptr = (delegate* unmanaged<uint, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL3ui64vNV");
                _VertexAttribL3ui64vNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, ulong*, void> _VertexAttribL4ui64vNV_fnptr = &VertexAttribL4ui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4ui64vNV(uint index, ulong* v) => _VertexAttribL4ui64vNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribL4ui64vNV_Lazy(uint index, ulong* v)
            {
                _VertexAttribL4ui64vNV_fnptr = (delegate* unmanaged<uint, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribL4ui64vNV");
                _VertexAttribL4ui64vNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnum, long*, void> _GetVertexAttribLi64vNV_fnptr = &GetVertexAttribLi64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, long* parameters) => _GetVertexAttribLi64vNV_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribLi64vNV_Lazy(uint index, VertexAttribEnum pname, long* parameters)
            {
                _GetVertexAttribLi64vNV_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, long*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribLi64vNV");
                _GetVertexAttribLi64vNV_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnum, ulong*, void> _GetVertexAttribLui64vNV_fnptr = &GetVertexAttribLui64vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, ulong* parameters) => _GetVertexAttribLui64vNV_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribLui64vNV_Lazy(uint index, VertexAttribEnum pname, ulong* parameters)
            {
                _GetVertexAttribLui64vNV_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribLui64vNV");
                _GetVertexAttribLui64vNV_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribLType, int, void> _VertexAttribLFormatNV_fnptr = &VertexAttribLFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribLFormatNV(uint index, int size, VertexAttribLType type, int stride) => _VertexAttribLFormatNV_fnptr(index, size, type, stride);
            [UnmanagedCallersOnly]
            private static void VertexAttribLFormatNV_Lazy(uint index, int size, VertexAttribLType type, int stride)
            {
                _VertexAttribLFormatNV_fnptr = (delegate* unmanaged<uint, int, VertexAttribLType, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribLFormatNV");
                _VertexAttribLFormatNV_fnptr(index, size, type, stride);
            }
            
            private static delegate* unmanaged<All, uint, ulong, nint, void> _BufferAddressRangeNV_fnptr = &BufferAddressRangeNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferAddressRangeNV(All pname, uint index, ulong address, nint length) => _BufferAddressRangeNV_fnptr(pname, index, address, length);
            [UnmanagedCallersOnly]
            private static void BufferAddressRangeNV_Lazy(All pname, uint index, ulong address, nint length)
            {
                _BufferAddressRangeNV_fnptr = (delegate* unmanaged<All, uint, ulong, nint, void>)GLLoader.BindingsContext.GetProcAddress("glBufferAddressRangeNV");
                _BufferAddressRangeNV_fnptr(pname, index, address, length);
            }
            
            private static delegate* unmanaged<int, VertexPointerType, int, void> _VertexFormatNV_fnptr = &VertexFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexFormatNV(int size, VertexPointerType type, int stride) => _VertexFormatNV_fnptr(size, type, stride);
            [UnmanagedCallersOnly]
            private static void VertexFormatNV_Lazy(int size, VertexPointerType type, int stride)
            {
                _VertexFormatNV_fnptr = (delegate* unmanaged<int, VertexPointerType, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexFormatNV");
                _VertexFormatNV_fnptr(size, type, stride);
            }
            
            private static delegate* unmanaged<All, int, void> _NormalFormatNV_fnptr = &NormalFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalFormatNV(All type, int stride) => _NormalFormatNV_fnptr(type, stride);
            [UnmanagedCallersOnly]
            private static void NormalFormatNV_Lazy(All type, int stride)
            {
                _NormalFormatNV_fnptr = (delegate* unmanaged<All, int, void>)GLLoader.BindingsContext.GetProcAddress("glNormalFormatNV");
                _NormalFormatNV_fnptr(type, stride);
            }
            
            private static delegate* unmanaged<int, All, int, void> _ColorFormatNV_fnptr = &ColorFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorFormatNV(int size, All type, int stride) => _ColorFormatNV_fnptr(size, type, stride);
            [UnmanagedCallersOnly]
            private static void ColorFormatNV_Lazy(int size, All type, int stride)
            {
                _ColorFormatNV_fnptr = (delegate* unmanaged<int, All, int, void>)GLLoader.BindingsContext.GetProcAddress("glColorFormatNV");
                _ColorFormatNV_fnptr(size, type, stride);
            }
            
            private static delegate* unmanaged<All, int, void> _IndexFormatNV_fnptr = &IndexFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexFormatNV(All type, int stride) => _IndexFormatNV_fnptr(type, stride);
            [UnmanagedCallersOnly]
            private static void IndexFormatNV_Lazy(All type, int stride)
            {
                _IndexFormatNV_fnptr = (delegate* unmanaged<All, int, void>)GLLoader.BindingsContext.GetProcAddress("glIndexFormatNV");
                _IndexFormatNV_fnptr(type, stride);
            }
            
            private static delegate* unmanaged<int, All, int, void> _TexCoordFormatNV_fnptr = &TexCoordFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordFormatNV(int size, All type, int stride) => _TexCoordFormatNV_fnptr(size, type, stride);
            [UnmanagedCallersOnly]
            private static void TexCoordFormatNV_Lazy(int size, All type, int stride)
            {
                _TexCoordFormatNV_fnptr = (delegate* unmanaged<int, All, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordFormatNV");
                _TexCoordFormatNV_fnptr(size, type, stride);
            }
            
            private static delegate* unmanaged<int, void> _EdgeFlagFormatNV_fnptr = &EdgeFlagFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EdgeFlagFormatNV(int stride) => _EdgeFlagFormatNV_fnptr(stride);
            [UnmanagedCallersOnly]
            private static void EdgeFlagFormatNV_Lazy(int stride)
            {
                _EdgeFlagFormatNV_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glEdgeFlagFormatNV");
                _EdgeFlagFormatNV_fnptr(stride);
            }
            
            private static delegate* unmanaged<int, ColorPointerType, int, void> _SecondaryColorFormatNV_fnptr = &SecondaryColorFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColorFormatNV(int size, ColorPointerType type, int stride) => _SecondaryColorFormatNV_fnptr(size, type, stride);
            [UnmanagedCallersOnly]
            private static void SecondaryColorFormatNV_Lazy(int size, ColorPointerType type, int stride)
            {
                _SecondaryColorFormatNV_fnptr = (delegate* unmanaged<int, ColorPointerType, int, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColorFormatNV");
                _SecondaryColorFormatNV_fnptr(size, type, stride);
            }
            
            private static delegate* unmanaged<All, int, void> _FogCoordFormatNV_fnptr = &FogCoordFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordFormatNV(All type, int stride) => _FogCoordFormatNV_fnptr(type, stride);
            [UnmanagedCallersOnly]
            private static void FogCoordFormatNV_Lazy(All type, int stride)
            {
                _FogCoordFormatNV_fnptr = (delegate* unmanaged<All, int, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordFormatNV");
                _FogCoordFormatNV_fnptr(type, stride);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribType, byte, int, void> _VertexAttribFormatNV_fnptr = &VertexAttribFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribFormatNV(uint index, int size, VertexAttribType type, byte normalized, int stride) => _VertexAttribFormatNV_fnptr(index, size, type, normalized, stride);
            [UnmanagedCallersOnly]
            private static void VertexAttribFormatNV_Lazy(uint index, int size, VertexAttribType type, byte normalized, int stride)
            {
                _VertexAttribFormatNV_fnptr = (delegate* unmanaged<uint, int, VertexAttribType, byte, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribFormatNV");
                _VertexAttribFormatNV_fnptr(index, size, type, normalized, stride);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribIType, int, void> _VertexAttribIFormatNV_fnptr = &VertexAttribIFormatNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribIFormatNV(uint index, int size, VertexAttribIType type, int stride) => _VertexAttribIFormatNV_fnptr(index, size, type, stride);
            [UnmanagedCallersOnly]
            private static void VertexAttribIFormatNV_Lazy(uint index, int size, VertexAttribIType type, int stride)
            {
                _VertexAttribIFormatNV_fnptr = (delegate* unmanaged<uint, int, VertexAttribIType, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribIFormatNV");
                _VertexAttribIFormatNV_fnptr(index, size, type, stride);
            }
            
            private static delegate* unmanaged<All, uint, ulong*, void> _GetIntegerui64i_vNV_fnptr = &GetIntegerui64i_vNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetIntegerui64i_vNV(All value, uint index, ulong* result) => _GetIntegerui64i_vNV_fnptr(value, index, result);
            [UnmanagedCallersOnly]
            private static void GetIntegerui64i_vNV_Lazy(All value, uint index, ulong* result)
            {
                _GetIntegerui64i_vNV_fnptr = (delegate* unmanaged<All, uint, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetIntegerui64i_vNV");
                _GetIntegerui64i_vNV_fnptr(value, index, result);
            }
            
            private static delegate* unmanaged<int, ProgramHandle*, byte*, byte> _AreProgramsResidentNV_fnptr = &AreProgramsResidentNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte AreProgramsResidentNV(int n, ProgramHandle* programs, byte* residences) => _AreProgramsResidentNV_fnptr(n, programs, residences);
            [UnmanagedCallersOnly]
            private static byte AreProgramsResidentNV_Lazy(int n, ProgramHandle* programs, byte* residences)
            {
                _AreProgramsResidentNV_fnptr = (delegate* unmanaged<int, ProgramHandle*, byte*, byte>)GLLoader.BindingsContext.GetProcAddress("glAreProgramsResidentNV");
                return _AreProgramsResidentNV_fnptr(n, programs, residences);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, ProgramHandle, void> _BindProgramNV_fnptr = &BindProgramNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindProgramNV(VertexAttribEnumNV target, ProgramHandle id) => _BindProgramNV_fnptr(target, id);
            [UnmanagedCallersOnly]
            private static void BindProgramNV_Lazy(VertexAttribEnumNV target, ProgramHandle id)
            {
                _BindProgramNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, ProgramHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindProgramNV");
                _BindProgramNV_fnptr(target, id);
            }
            
            private static delegate* unmanaged<int, ProgramHandle*, void> _DeleteProgramsNV_fnptr = &DeleteProgramsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteProgramsNV(int n, ProgramHandle* programs) => _DeleteProgramsNV_fnptr(n, programs);
            [UnmanagedCallersOnly]
            private static void DeleteProgramsNV_Lazy(int n, ProgramHandle* programs)
            {
                _DeleteProgramsNV_fnptr = (delegate* unmanaged<int, ProgramHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteProgramsNV");
                _DeleteProgramsNV_fnptr(n, programs);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, float*, void> _ExecuteProgramNV_fnptr = &ExecuteProgramNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ExecuteProgramNV(VertexAttribEnumNV target, uint id, float* parameters) => _ExecuteProgramNV_fnptr(target, id, parameters);
            [UnmanagedCallersOnly]
            private static void ExecuteProgramNV_Lazy(VertexAttribEnumNV target, uint id, float* parameters)
            {
                _ExecuteProgramNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glExecuteProgramNV");
                _ExecuteProgramNV_fnptr(target, id, parameters);
            }
            
            private static delegate* unmanaged<int, ProgramHandle*, void> _GenProgramsNV_fnptr = &GenProgramsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenProgramsNV(int n, ProgramHandle* programs) => _GenProgramsNV_fnptr(n, programs);
            [UnmanagedCallersOnly]
            private static void GenProgramsNV_Lazy(int n, ProgramHandle* programs)
            {
                _GenProgramsNV_fnptr = (delegate* unmanaged<int, ProgramHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glGenProgramsNV");
                _GenProgramsNV_fnptr(n, programs);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, VertexAttribEnumNV, double*, void> _GetProgramParameterdvNV_fnptr = &GetProgramParameterdvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, double* parameters) => _GetProgramParameterdvNV_fnptr(target, index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramParameterdvNV_Lazy(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, double* parameters)
            {
                _GetProgramParameterdvNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, VertexAttribEnumNV, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramParameterdvNV");
                _GetProgramParameterdvNV_fnptr(target, index, pname, parameters);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, VertexAttribEnumNV, float*, void> _GetProgramParameterfvNV_fnptr = &GetProgramParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, float* parameters) => _GetProgramParameterfvNV_fnptr(target, index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramParameterfvNV_Lazy(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, float* parameters)
            {
                _GetProgramParameterfvNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, VertexAttribEnumNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramParameterfvNV");
                _GetProgramParameterfvNV_fnptr(target, index, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, VertexAttribEnumNV, int*, void> _GetProgramivNV_fnptr = &GetProgramivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramivNV(ProgramHandle id, VertexAttribEnumNV pname, int* parameters) => _GetProgramivNV_fnptr(id, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetProgramivNV_Lazy(ProgramHandle id, VertexAttribEnumNV pname, int* parameters)
            {
                _GetProgramivNV_fnptr = (delegate* unmanaged<ProgramHandle, VertexAttribEnumNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramivNV");
                _GetProgramivNV_fnptr(id, pname, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, VertexAttribEnumNV, byte*, void> _GetProgramStringNV_fnptr = &GetProgramStringNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramStringNV(ProgramHandle id, VertexAttribEnumNV pname, byte* program) => _GetProgramStringNV_fnptr(id, pname, program);
            [UnmanagedCallersOnly]
            private static void GetProgramStringNV_Lazy(ProgramHandle id, VertexAttribEnumNV pname, byte* program)
            {
                _GetProgramStringNV_fnptr = (delegate* unmanaged<ProgramHandle, VertexAttribEnumNV, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetProgramStringNV");
                _GetProgramStringNV_fnptr(id, pname, program);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, VertexAttribEnumNV, int*, void> _GetTrackMatrixivNV_fnptr = &GetTrackMatrixivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTrackMatrixivNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, int* parameters) => _GetTrackMatrixivNV_fnptr(target, address, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTrackMatrixivNV_Lazy(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, int* parameters)
            {
                _GetTrackMatrixivNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, VertexAttribEnumNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTrackMatrixivNV");
                _GetTrackMatrixivNV_fnptr(target, address, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnumNV, double*, void> _GetVertexAttribdvNV_fnptr = &GetVertexAttribdvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribdvNV(uint index, VertexAttribEnumNV pname, double* parameters) => _GetVertexAttribdvNV_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribdvNV_Lazy(uint index, VertexAttribEnumNV pname, double* parameters)
            {
                _GetVertexAttribdvNV_fnptr = (delegate* unmanaged<uint, VertexAttribEnumNV, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribdvNV");
                _GetVertexAttribdvNV_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnumNV, float*, void> _GetVertexAttribfvNV_fnptr = &GetVertexAttribfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribfvNV(uint index, VertexAttribEnumNV pname, float* parameters) => _GetVertexAttribfvNV_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribfvNV_Lazy(uint index, VertexAttribEnumNV pname, float* parameters)
            {
                _GetVertexAttribfvNV_fnptr = (delegate* unmanaged<uint, VertexAttribEnumNV, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribfvNV");
                _GetVertexAttribfvNV_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnumNV, int*, void> _GetVertexAttribivNV_fnptr = &GetVertexAttribivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribivNV(uint index, VertexAttribEnumNV pname, int* parameters) => _GetVertexAttribivNV_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribivNV_Lazy(uint index, VertexAttribEnumNV pname, int* parameters)
            {
                _GetVertexAttribivNV_fnptr = (delegate* unmanaged<uint, VertexAttribEnumNV, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribivNV");
                _GetVertexAttribivNV_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnumNV, void**, void> _GetVertexAttribPointervNV_fnptr = &GetVertexAttribPointervNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribPointervNV(uint index, VertexAttribEnumNV pname, void** pointer) => _GetVertexAttribPointervNV_fnptr(index, pname, pointer);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribPointervNV_Lazy(uint index, VertexAttribEnumNV pname, void** pointer)
            {
                _GetVertexAttribPointervNV_fnptr = (delegate* unmanaged<uint, VertexAttribEnumNV, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribPointervNV");
                _GetVertexAttribPointervNV_fnptr(index, pname, pointer);
            }
            
            private static delegate* unmanaged<ProgramHandle, byte> _IsProgramNV_fnptr = &IsProgramNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsProgramNV(ProgramHandle id) => _IsProgramNV_fnptr(id);
            [UnmanagedCallersOnly]
            private static byte IsProgramNV_Lazy(ProgramHandle id)
            {
                _IsProgramNV_fnptr = (delegate* unmanaged<ProgramHandle, byte>)GLLoader.BindingsContext.GetProcAddress("glIsProgramNV");
                return _IsProgramNV_fnptr(id);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, int, byte*, void> _LoadProgramNV_fnptr = &LoadProgramNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadProgramNV(VertexAttribEnumNV target, uint id, int len, byte* program) => _LoadProgramNV_fnptr(target, id, len, program);
            [UnmanagedCallersOnly]
            private static void LoadProgramNV_Lazy(VertexAttribEnumNV target, uint id, int len, byte* program)
            {
                _LoadProgramNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glLoadProgramNV");
                _LoadProgramNV_fnptr(target, id, len, program);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, double, double, double, double, void> _ProgramParameter4dNV_fnptr = &ProgramParameter4dNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameter4dNV(VertexAttribEnumNV target, uint index, double x, double y, double z, double w) => _ProgramParameter4dNV_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramParameter4dNV_Lazy(VertexAttribEnumNV target, uint index, double x, double y, double z, double w)
            {
                _ProgramParameter4dNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameter4dNV");
                _ProgramParameter4dNV_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, double*, void> _ProgramParameter4dvNV_fnptr = &ProgramParameter4dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, double* v) => _ProgramParameter4dvNV_fnptr(target, index, v);
            [UnmanagedCallersOnly]
            private static void ProgramParameter4dvNV_Lazy(VertexAttribEnumNV target, uint index, double* v)
            {
                _ProgramParameter4dvNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameter4dvNV");
                _ProgramParameter4dvNV_fnptr(target, index, v);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, float, float, float, float, void> _ProgramParameter4fNV_fnptr = &ProgramParameter4fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameter4fNV(VertexAttribEnumNV target, uint index, float x, float y, float z, float w) => _ProgramParameter4fNV_fnptr(target, index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void ProgramParameter4fNV_Lazy(VertexAttribEnumNV target, uint index, float x, float y, float z, float w)
            {
                _ProgramParameter4fNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameter4fNV");
                _ProgramParameter4fNV_fnptr(target, index, x, y, z, w);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, float*, void> _ProgramParameter4fvNV_fnptr = &ProgramParameter4fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, float* v) => _ProgramParameter4fvNV_fnptr(target, index, v);
            [UnmanagedCallersOnly]
            private static void ProgramParameter4fvNV_Lazy(VertexAttribEnumNV target, uint index, float* v)
            {
                _ProgramParameter4fvNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameter4fvNV");
                _ProgramParameter4fvNV_fnptr(target, index, v);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, int, double*, void> _ProgramParameters4dvNV_fnptr = &ProgramParameters4dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, int count, double* v) => _ProgramParameters4dvNV_fnptr(target, index, count, v);
            [UnmanagedCallersOnly]
            private static void ProgramParameters4dvNV_Lazy(VertexAttribEnumNV target, uint index, int count, double* v)
            {
                _ProgramParameters4dvNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameters4dvNV");
                _ProgramParameters4dvNV_fnptr(target, index, count, v);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, int, float*, void> _ProgramParameters4fvNV_fnptr = &ProgramParameters4fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, int count, float* v) => _ProgramParameters4fvNV_fnptr(target, index, count, v);
            [UnmanagedCallersOnly]
            private static void ProgramParameters4fvNV_Lazy(VertexAttribEnumNV target, uint index, int count, float* v)
            {
                _ProgramParameters4fvNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glProgramParameters4fvNV");
                _ProgramParameters4fvNV_fnptr(target, index, count, v);
            }
            
            private static delegate* unmanaged<int, ProgramHandle*, void> _RequestResidentProgramsNV_fnptr = &RequestResidentProgramsNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RequestResidentProgramsNV(int n, ProgramHandle* programs) => _RequestResidentProgramsNV_fnptr(n, programs);
            [UnmanagedCallersOnly]
            private static void RequestResidentProgramsNV_Lazy(int n, ProgramHandle* programs)
            {
                _RequestResidentProgramsNV_fnptr = (delegate* unmanaged<int, ProgramHandle*, void>)GLLoader.BindingsContext.GetProcAddress("glRequestResidentProgramsNV");
                _RequestResidentProgramsNV_fnptr(n, programs);
            }
            
            private static delegate* unmanaged<VertexAttribEnumNV, uint, VertexAttribEnumNV, VertexAttribEnumNV, void> _TrackMatrixNV_fnptr = &TrackMatrixNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TrackMatrixNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV matrix, VertexAttribEnumNV transform) => _TrackMatrixNV_fnptr(target, address, matrix, transform);
            [UnmanagedCallersOnly]
            private static void TrackMatrixNV_Lazy(VertexAttribEnumNV target, uint address, VertexAttribEnumNV matrix, VertexAttribEnumNV transform)
            {
                _TrackMatrixNV_fnptr = (delegate* unmanaged<VertexAttribEnumNV, uint, VertexAttribEnumNV, VertexAttribEnumNV, void>)GLLoader.BindingsContext.GetProcAddress("glTrackMatrixNV");
                _TrackMatrixNV_fnptr(target, address, matrix, transform);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribEnumNV, int, void*, void> _VertexAttribPointerNV_fnptr = &VertexAttribPointerNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribPointerNV(uint index, int fsize, VertexAttribEnumNV type, int stride, void* pointer) => _VertexAttribPointerNV_fnptr(index, fsize, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void VertexAttribPointerNV_Lazy(uint index, int fsize, VertexAttribEnumNV type, int stride, void* pointer)
            {
                _VertexAttribPointerNV_fnptr = (delegate* unmanaged<uint, int, VertexAttribEnumNV, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribPointerNV");
                _VertexAttribPointerNV_fnptr(index, fsize, type, stride, pointer);
            }
            
            private static delegate* unmanaged<uint, double, void> _VertexAttrib1dNV_fnptr = &VertexAttrib1dNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1dNV(uint index, double x) => _VertexAttrib1dNV_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1dNV_Lazy(uint index, double x)
            {
                _VertexAttrib1dNV_fnptr = (delegate* unmanaged<uint, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1dNV");
                _VertexAttrib1dNV_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttrib1dvNV_fnptr = &VertexAttrib1dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1dvNV(uint index, double* v) => _VertexAttrib1dvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1dvNV_Lazy(uint index, double* v)
            {
                _VertexAttrib1dvNV_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1dvNV");
                _VertexAttrib1dvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, float, void> _VertexAttrib1fNV_fnptr = &VertexAttrib1fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1fNV(uint index, float x) => _VertexAttrib1fNV_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1fNV_Lazy(uint index, float x)
            {
                _VertexAttrib1fNV_fnptr = (delegate* unmanaged<uint, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1fNV");
                _VertexAttrib1fNV_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, float*, void> _VertexAttrib1fvNV_fnptr = &VertexAttrib1fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1fvNV(uint index, float* v) => _VertexAttrib1fvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1fvNV_Lazy(uint index, float* v)
            {
                _VertexAttrib1fvNV_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1fvNV");
                _VertexAttrib1fvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short, void> _VertexAttrib1sNV_fnptr = &VertexAttrib1sNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1sNV(uint index, short x) => _VertexAttrib1sNV_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1sNV_Lazy(uint index, short x)
            {
                _VertexAttrib1sNV_fnptr = (delegate* unmanaged<uint, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1sNV");
                _VertexAttrib1sNV_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttrib1svNV_fnptr = &VertexAttrib1svNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1svNV(uint index, short* v) => _VertexAttrib1svNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib1svNV_Lazy(uint index, short* v)
            {
                _VertexAttrib1svNV_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib1svNV");
                _VertexAttrib1svNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double, double, void> _VertexAttrib2dNV_fnptr = &VertexAttrib2dNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2dNV(uint index, double x, double y) => _VertexAttrib2dNV_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2dNV_Lazy(uint index, double x, double y)
            {
                _VertexAttrib2dNV_fnptr = (delegate* unmanaged<uint, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2dNV");
                _VertexAttrib2dNV_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttrib2dvNV_fnptr = &VertexAttrib2dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2dvNV(uint index, double* v) => _VertexAttrib2dvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2dvNV_Lazy(uint index, double* v)
            {
                _VertexAttrib2dvNV_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2dvNV");
                _VertexAttrib2dvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, float, float, void> _VertexAttrib2fNV_fnptr = &VertexAttrib2fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2fNV(uint index, float x, float y) => _VertexAttrib2fNV_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2fNV_Lazy(uint index, float x, float y)
            {
                _VertexAttrib2fNV_fnptr = (delegate* unmanaged<uint, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2fNV");
                _VertexAttrib2fNV_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, float*, void> _VertexAttrib2fvNV_fnptr = &VertexAttrib2fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2fvNV(uint index, float* v) => _VertexAttrib2fvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2fvNV_Lazy(uint index, float* v)
            {
                _VertexAttrib2fvNV_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2fvNV");
                _VertexAttrib2fvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short, short, void> _VertexAttrib2sNV_fnptr = &VertexAttrib2sNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2sNV(uint index, short x, short y) => _VertexAttrib2sNV_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2sNV_Lazy(uint index, short x, short y)
            {
                _VertexAttrib2sNV_fnptr = (delegate* unmanaged<uint, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2sNV");
                _VertexAttrib2sNV_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttrib2svNV_fnptr = &VertexAttrib2svNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2svNV(uint index, short* v) => _VertexAttrib2svNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib2svNV_Lazy(uint index, short* v)
            {
                _VertexAttrib2svNV_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib2svNV");
                _VertexAttrib2svNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double, double, double, void> _VertexAttrib3dNV_fnptr = &VertexAttrib3dNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3dNV(uint index, double x, double y, double z) => _VertexAttrib3dNV_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3dNV_Lazy(uint index, double x, double y, double z)
            {
                _VertexAttrib3dNV_fnptr = (delegate* unmanaged<uint, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3dNV");
                _VertexAttrib3dNV_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttrib3dvNV_fnptr = &VertexAttrib3dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3dvNV(uint index, double* v) => _VertexAttrib3dvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3dvNV_Lazy(uint index, double* v)
            {
                _VertexAttrib3dvNV_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3dvNV");
                _VertexAttrib3dvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, void> _VertexAttrib3fNV_fnptr = &VertexAttrib3fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3fNV(uint index, float x, float y, float z) => _VertexAttrib3fNV_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3fNV_Lazy(uint index, float x, float y, float z)
            {
                _VertexAttrib3fNV_fnptr = (delegate* unmanaged<uint, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3fNV");
                _VertexAttrib3fNV_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, float*, void> _VertexAttrib3fvNV_fnptr = &VertexAttrib3fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3fvNV(uint index, float* v) => _VertexAttrib3fvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3fvNV_Lazy(uint index, float* v)
            {
                _VertexAttrib3fvNV_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3fvNV");
                _VertexAttrib3fvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short, short, short, void> _VertexAttrib3sNV_fnptr = &VertexAttrib3sNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3sNV(uint index, short x, short y, short z) => _VertexAttrib3sNV_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3sNV_Lazy(uint index, short x, short y, short z)
            {
                _VertexAttrib3sNV_fnptr = (delegate* unmanaged<uint, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3sNV");
                _VertexAttrib3sNV_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttrib3svNV_fnptr = &VertexAttrib3svNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3svNV(uint index, short* v) => _VertexAttrib3svNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib3svNV_Lazy(uint index, short* v)
            {
                _VertexAttrib3svNV_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib3svNV");
                _VertexAttrib3svNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, double, double, double, double, void> _VertexAttrib4dNV_fnptr = &VertexAttrib4dNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4dNV(uint index, double x, double y, double z, double w) => _VertexAttrib4dNV_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4dNV_Lazy(uint index, double x, double y, double z, double w)
            {
                _VertexAttrib4dNV_fnptr = (delegate* unmanaged<uint, double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4dNV");
                _VertexAttrib4dNV_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, double*, void> _VertexAttrib4dvNV_fnptr = &VertexAttrib4dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4dvNV(uint index, double* v) => _VertexAttrib4dvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4dvNV_Lazy(uint index, double* v)
            {
                _VertexAttrib4dvNV_fnptr = (delegate* unmanaged<uint, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4dvNV");
                _VertexAttrib4dvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, float, void> _VertexAttrib4fNV_fnptr = &VertexAttrib4fNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4fNV(uint index, float x, float y, float z, float w) => _VertexAttrib4fNV_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4fNV_Lazy(uint index, float x, float y, float z, float w)
            {
                _VertexAttrib4fNV_fnptr = (delegate* unmanaged<uint, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4fNV");
                _VertexAttrib4fNV_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, float*, void> _VertexAttrib4fvNV_fnptr = &VertexAttrib4fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4fvNV(uint index, float* v) => _VertexAttrib4fvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4fvNV_Lazy(uint index, float* v)
            {
                _VertexAttrib4fvNV_fnptr = (delegate* unmanaged<uint, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4fvNV");
                _VertexAttrib4fvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short, short, short, short, void> _VertexAttrib4sNV_fnptr = &VertexAttrib4sNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4sNV(uint index, short x, short y, short z, short w) => _VertexAttrib4sNV_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4sNV_Lazy(uint index, short x, short y, short z, short w)
            {
                _VertexAttrib4sNV_fnptr = (delegate* unmanaged<uint, short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4sNV");
                _VertexAttrib4sNV_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttrib4svNV_fnptr = &VertexAttrib4svNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4svNV(uint index, short* v) => _VertexAttrib4svNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4svNV_Lazy(uint index, short* v)
            {
                _VertexAttrib4svNV_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4svNV");
                _VertexAttrib4svNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, byte, byte, byte, byte, void> _VertexAttrib4ubNV_fnptr = &VertexAttrib4ubNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4ubNV(uint index, byte x, byte y, byte z, byte w) => _VertexAttrib4ubNV_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4ubNV_Lazy(uint index, byte x, byte y, byte z, byte w)
            {
                _VertexAttrib4ubNV_fnptr = (delegate* unmanaged<uint, byte, byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4ubNV");
                _VertexAttrib4ubNV_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, byte*, void> _VertexAttrib4ubvNV_fnptr = &VertexAttrib4ubvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4ubvNV(uint index, byte* v) => _VertexAttrib4ubvNV_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttrib4ubvNV_Lazy(uint index, byte* v)
            {
                _VertexAttrib4ubvNV_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttrib4ubvNV");
                _VertexAttrib4ubvNV_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int, double*, void> _VertexAttribs1dvNV_fnptr = &VertexAttribs1dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs1dvNV(uint index, int count, double* v) => _VertexAttribs1dvNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs1dvNV_Lazy(uint index, int count, double* v)
            {
                _VertexAttribs1dvNV_fnptr = (delegate* unmanaged<uint, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs1dvNV");
                _VertexAttribs1dvNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, float*, void> _VertexAttribs1fvNV_fnptr = &VertexAttribs1fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs1fvNV(uint index, int count, float* v) => _VertexAttribs1fvNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs1fvNV_Lazy(uint index, int count, float* v)
            {
                _VertexAttribs1fvNV_fnptr = (delegate* unmanaged<uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs1fvNV");
                _VertexAttribs1fvNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, short*, void> _VertexAttribs1svNV_fnptr = &VertexAttribs1svNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs1svNV(uint index, int count, short* v) => _VertexAttribs1svNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs1svNV_Lazy(uint index, int count, short* v)
            {
                _VertexAttribs1svNV_fnptr = (delegate* unmanaged<uint, int, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs1svNV");
                _VertexAttribs1svNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, double*, void> _VertexAttribs2dvNV_fnptr = &VertexAttribs2dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs2dvNV(uint index, int count, double* v) => _VertexAttribs2dvNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs2dvNV_Lazy(uint index, int count, double* v)
            {
                _VertexAttribs2dvNV_fnptr = (delegate* unmanaged<uint, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs2dvNV");
                _VertexAttribs2dvNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, float*, void> _VertexAttribs2fvNV_fnptr = &VertexAttribs2fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs2fvNV(uint index, int count, float* v) => _VertexAttribs2fvNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs2fvNV_Lazy(uint index, int count, float* v)
            {
                _VertexAttribs2fvNV_fnptr = (delegate* unmanaged<uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs2fvNV");
                _VertexAttribs2fvNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, short*, void> _VertexAttribs2svNV_fnptr = &VertexAttribs2svNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs2svNV(uint index, int count, short* v) => _VertexAttribs2svNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs2svNV_Lazy(uint index, int count, short* v)
            {
                _VertexAttribs2svNV_fnptr = (delegate* unmanaged<uint, int, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs2svNV");
                _VertexAttribs2svNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, double*, void> _VertexAttribs3dvNV_fnptr = &VertexAttribs3dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs3dvNV(uint index, int count, double* v) => _VertexAttribs3dvNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs3dvNV_Lazy(uint index, int count, double* v)
            {
                _VertexAttribs3dvNV_fnptr = (delegate* unmanaged<uint, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs3dvNV");
                _VertexAttribs3dvNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, float*, void> _VertexAttribs3fvNV_fnptr = &VertexAttribs3fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs3fvNV(uint index, int count, float* v) => _VertexAttribs3fvNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs3fvNV_Lazy(uint index, int count, float* v)
            {
                _VertexAttribs3fvNV_fnptr = (delegate* unmanaged<uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs3fvNV");
                _VertexAttribs3fvNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, short*, void> _VertexAttribs3svNV_fnptr = &VertexAttribs3svNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs3svNV(uint index, int count, short* v) => _VertexAttribs3svNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs3svNV_Lazy(uint index, int count, short* v)
            {
                _VertexAttribs3svNV_fnptr = (delegate* unmanaged<uint, int, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs3svNV");
                _VertexAttribs3svNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, double*, void> _VertexAttribs4dvNV_fnptr = &VertexAttribs4dvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4dvNV(uint index, int count, double* v) => _VertexAttribs4dvNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs4dvNV_Lazy(uint index, int count, double* v)
            {
                _VertexAttribs4dvNV_fnptr = (delegate* unmanaged<uint, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs4dvNV");
                _VertexAttribs4dvNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, float*, void> _VertexAttribs4fvNV_fnptr = &VertexAttribs4fvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4fvNV(uint index, int count, float* v) => _VertexAttribs4fvNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs4fvNV_Lazy(uint index, int count, float* v)
            {
                _VertexAttribs4fvNV_fnptr = (delegate* unmanaged<uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs4fvNV");
                _VertexAttribs4fvNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, short*, void> _VertexAttribs4svNV_fnptr = &VertexAttribs4svNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4svNV(uint index, int count, short* v) => _VertexAttribs4svNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs4svNV_Lazy(uint index, int count, short* v)
            {
                _VertexAttribs4svNV_fnptr = (delegate* unmanaged<uint, int, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs4svNV");
                _VertexAttribs4svNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, byte*, void> _VertexAttribs4ubvNV_fnptr = &VertexAttribs4ubvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4ubvNV(uint index, int count, byte* v) => _VertexAttribs4ubvNV_fnptr(index, count, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribs4ubvNV_Lazy(uint index, int count, byte* v)
            {
                _VertexAttribs4ubvNV_fnptr = (delegate* unmanaged<uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribs4ubvNV");
                _VertexAttribs4ubvNV_fnptr(index, count, v);
            }
            
            private static delegate* unmanaged<uint, int, void> _VertexAttribI1iEXT_fnptr = &VertexAttribI1iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1iEXT(uint index, int x) => _VertexAttribI1iEXT_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttribI1iEXT_Lazy(uint index, int x)
            {
                _VertexAttribI1iEXT_fnptr = (delegate* unmanaged<uint, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1iEXT");
                _VertexAttribI1iEXT_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, int, int, void> _VertexAttribI2iEXT_fnptr = &VertexAttribI2iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2iEXT(uint index, int x, int y) => _VertexAttribI2iEXT_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttribI2iEXT_Lazy(uint index, int x, int y)
            {
                _VertexAttribI2iEXT_fnptr = (delegate* unmanaged<uint, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2iEXT");
                _VertexAttribI2iEXT_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, int, int, int, void> _VertexAttribI3iEXT_fnptr = &VertexAttribI3iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3iEXT(uint index, int x, int y, int z) => _VertexAttribI3iEXT_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttribI3iEXT_Lazy(uint index, int x, int y, int z)
            {
                _VertexAttribI3iEXT_fnptr = (delegate* unmanaged<uint, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3iEXT");
                _VertexAttribI3iEXT_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, int, int, int, int, void> _VertexAttribI4iEXT_fnptr = &VertexAttribI4iEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => _VertexAttribI4iEXT_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4iEXT_Lazy(uint index, int x, int y, int z, int w)
            {
                _VertexAttribI4iEXT_fnptr = (delegate* unmanaged<uint, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4iEXT");
                _VertexAttribI4iEXT_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, uint, void> _VertexAttribI1uiEXT_fnptr = &VertexAttribI1uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1uiEXT(uint index, uint x) => _VertexAttribI1uiEXT_fnptr(index, x);
            [UnmanagedCallersOnly]
            private static void VertexAttribI1uiEXT_Lazy(uint index, uint x)
            {
                _VertexAttribI1uiEXT_fnptr = (delegate* unmanaged<uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1uiEXT");
                _VertexAttribI1uiEXT_fnptr(index, x);
            }
            
            private static delegate* unmanaged<uint, uint, uint, void> _VertexAttribI2uiEXT_fnptr = &VertexAttribI2uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2uiEXT(uint index, uint x, uint y) => _VertexAttribI2uiEXT_fnptr(index, x, y);
            [UnmanagedCallersOnly]
            private static void VertexAttribI2uiEXT_Lazy(uint index, uint x, uint y)
            {
                _VertexAttribI2uiEXT_fnptr = (delegate* unmanaged<uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2uiEXT");
                _VertexAttribI2uiEXT_fnptr(index, x, y);
            }
            
            private static delegate* unmanaged<uint, uint, uint, uint, void> _VertexAttribI3uiEXT_fnptr = &VertexAttribI3uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => _VertexAttribI3uiEXT_fnptr(index, x, y, z);
            [UnmanagedCallersOnly]
            private static void VertexAttribI3uiEXT_Lazy(uint index, uint x, uint y, uint z)
            {
                _VertexAttribI3uiEXT_fnptr = (delegate* unmanaged<uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3uiEXT");
                _VertexAttribI3uiEXT_fnptr(index, x, y, z);
            }
            
            private static delegate* unmanaged<uint, uint, uint, uint, uint, void> _VertexAttribI4uiEXT_fnptr = &VertexAttribI4uiEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => _VertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4uiEXT_Lazy(uint index, uint x, uint y, uint z, uint w)
            {
                _VertexAttribI4uiEXT_fnptr = (delegate* unmanaged<uint, uint, uint, uint, uint, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4uiEXT");
                _VertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttribI1ivEXT_fnptr = &VertexAttribI1ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1ivEXT(uint index, int* v) => _VertexAttribI1ivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI1ivEXT_Lazy(uint index, int* v)
            {
                _VertexAttribI1ivEXT_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1ivEXT");
                _VertexAttribI1ivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttribI2ivEXT_fnptr = &VertexAttribI2ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2ivEXT(uint index, int* v) => _VertexAttribI2ivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI2ivEXT_Lazy(uint index, int* v)
            {
                _VertexAttribI2ivEXT_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2ivEXT");
                _VertexAttribI2ivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttribI3ivEXT_fnptr = &VertexAttribI3ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3ivEXT(uint index, int* v) => _VertexAttribI3ivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI3ivEXT_Lazy(uint index, int* v)
            {
                _VertexAttribI3ivEXT_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3ivEXT");
                _VertexAttribI3ivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int*, void> _VertexAttribI4ivEXT_fnptr = &VertexAttribI4ivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4ivEXT(uint index, int* v) => _VertexAttribI4ivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4ivEXT_Lazy(uint index, int* v)
            {
                _VertexAttribI4ivEXT_fnptr = (delegate* unmanaged<uint, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4ivEXT");
                _VertexAttribI4ivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttribI1uivEXT_fnptr = &VertexAttribI1uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1uivEXT(uint index, uint* v) => _VertexAttribI1uivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI1uivEXT_Lazy(uint index, uint* v)
            {
                _VertexAttribI1uivEXT_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI1uivEXT");
                _VertexAttribI1uivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttribI2uivEXT_fnptr = &VertexAttribI2uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2uivEXT(uint index, uint* v) => _VertexAttribI2uivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI2uivEXT_Lazy(uint index, uint* v)
            {
                _VertexAttribI2uivEXT_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI2uivEXT");
                _VertexAttribI2uivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttribI3uivEXT_fnptr = &VertexAttribI3uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3uivEXT(uint index, uint* v) => _VertexAttribI3uivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI3uivEXT_Lazy(uint index, uint* v)
            {
                _VertexAttribI3uivEXT_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI3uivEXT");
                _VertexAttribI3uivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _VertexAttribI4uivEXT_fnptr = &VertexAttribI4uivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4uivEXT(uint index, uint* v) => _VertexAttribI4uivEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4uivEXT_Lazy(uint index, uint* v)
            {
                _VertexAttribI4uivEXT_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4uivEXT");
                _VertexAttribI4uivEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, sbyte*, void> _VertexAttribI4bvEXT_fnptr = &VertexAttribI4bvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4bvEXT(uint index, sbyte* v) => _VertexAttribI4bvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4bvEXT_Lazy(uint index, sbyte* v)
            {
                _VertexAttribI4bvEXT_fnptr = (delegate* unmanaged<uint, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4bvEXT");
                _VertexAttribI4bvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, short*, void> _VertexAttribI4svEXT_fnptr = &VertexAttribI4svEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4svEXT(uint index, short* v) => _VertexAttribI4svEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4svEXT_Lazy(uint index, short* v)
            {
                _VertexAttribI4svEXT_fnptr = (delegate* unmanaged<uint, short*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4svEXT");
                _VertexAttribI4svEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, byte*, void> _VertexAttribI4ubvEXT_fnptr = &VertexAttribI4ubvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4ubvEXT(uint index, byte* v) => _VertexAttribI4ubvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4ubvEXT_Lazy(uint index, byte* v)
            {
                _VertexAttribI4ubvEXT_fnptr = (delegate* unmanaged<uint, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4ubvEXT");
                _VertexAttribI4ubvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, ushort*, void> _VertexAttribI4usvEXT_fnptr = &VertexAttribI4usvEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4usvEXT(uint index, ushort* v) => _VertexAttribI4usvEXT_fnptr(index, v);
            [UnmanagedCallersOnly]
            private static void VertexAttribI4usvEXT_Lazy(uint index, ushort* v)
            {
                _VertexAttribI4usvEXT_fnptr = (delegate* unmanaged<uint, ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribI4usvEXT");
                _VertexAttribI4usvEXT_fnptr(index, v);
            }
            
            private static delegate* unmanaged<uint, int, VertexAttribIType, int, void*, void> _VertexAttribIPointerEXT_fnptr = &VertexAttribIPointerEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, void* pointer) => _VertexAttribIPointerEXT_fnptr(index, size, type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void VertexAttribIPointerEXT_Lazy(uint index, int size, VertexAttribIType type, int stride, void* pointer)
            {
                _VertexAttribIPointerEXT_fnptr = (delegate* unmanaged<uint, int, VertexAttribIType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glVertexAttribIPointerEXT");
                _VertexAttribIPointerEXT_fnptr(index, size, type, stride, pointer);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnum, int*, void> _GetVertexAttribIivEXT_fnptr = &GetVertexAttribIivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int* parameters) => _GetVertexAttribIivEXT_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribIivEXT_Lazy(uint index, VertexAttribEnum pname, int* parameters)
            {
                _GetVertexAttribIivEXT_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribIivEXT");
                _GetVertexAttribIivEXT_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, VertexAttribEnum, uint*, void> _GetVertexAttribIuivEXT_fnptr = &GetVertexAttribIuivEXT_Lazy;
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint* parameters) => _GetVertexAttribIuivEXT_fnptr(index, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVertexAttribIuivEXT_Lazy(uint index, VertexAttribEnum pname, uint* parameters)
            {
                _GetVertexAttribIuivEXT_fnptr = (delegate* unmanaged<uint, VertexAttribEnum, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVertexAttribIuivEXT");
                _GetVertexAttribIuivEXT_fnptr(index, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, void> _BeginVideoCaptureNV_fnptr = &BeginVideoCaptureNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginVideoCaptureNV(uint video_capture_slot) => _BeginVideoCaptureNV_fnptr(video_capture_slot);
            [UnmanagedCallersOnly]
            private static void BeginVideoCaptureNV_Lazy(uint video_capture_slot)
            {
                _BeginVideoCaptureNV_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glBeginVideoCaptureNV");
                _BeginVideoCaptureNV_fnptr(video_capture_slot);
            }
            
            private static delegate* unmanaged<uint, uint, All, IntPtr, void> _BindVideoCaptureStreamBufferNV_fnptr = &BindVideoCaptureStreamBufferNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindVideoCaptureStreamBufferNV(uint video_capture_slot, uint stream, All frame_region, IntPtr offset) => _BindVideoCaptureStreamBufferNV_fnptr(video_capture_slot, stream, frame_region, offset);
            [UnmanagedCallersOnly]
            private static void BindVideoCaptureStreamBufferNV_Lazy(uint video_capture_slot, uint stream, All frame_region, IntPtr offset)
            {
                _BindVideoCaptureStreamBufferNV_fnptr = (delegate* unmanaged<uint, uint, All, IntPtr, void>)GLLoader.BindingsContext.GetProcAddress("glBindVideoCaptureStreamBufferNV");
                _BindVideoCaptureStreamBufferNV_fnptr(video_capture_slot, stream, frame_region, offset);
            }
            
            private static delegate* unmanaged<uint, uint, All, All, TextureHandle, void> _BindVideoCaptureStreamTextureNV_fnptr = &BindVideoCaptureStreamTextureNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindVideoCaptureStreamTextureNV(uint video_capture_slot, uint stream, All frame_region, All target, TextureHandle texture) => _BindVideoCaptureStreamTextureNV_fnptr(video_capture_slot, stream, frame_region, target, texture);
            [UnmanagedCallersOnly]
            private static void BindVideoCaptureStreamTextureNV_Lazy(uint video_capture_slot, uint stream, All frame_region, All target, TextureHandle texture)
            {
                _BindVideoCaptureStreamTextureNV_fnptr = (delegate* unmanaged<uint, uint, All, All, TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glBindVideoCaptureStreamTextureNV");
                _BindVideoCaptureStreamTextureNV_fnptr(video_capture_slot, stream, frame_region, target, texture);
            }
            
            private static delegate* unmanaged<uint, void> _EndVideoCaptureNV_fnptr = &EndVideoCaptureNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndVideoCaptureNV(uint video_capture_slot) => _EndVideoCaptureNV_fnptr(video_capture_slot);
            [UnmanagedCallersOnly]
            private static void EndVideoCaptureNV_Lazy(uint video_capture_slot)
            {
                _EndVideoCaptureNV_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glEndVideoCaptureNV");
                _EndVideoCaptureNV_fnptr(video_capture_slot);
            }
            
            private static delegate* unmanaged<uint, All, int*, void> _GetVideoCaptureivNV_fnptr = &GetVideoCaptureivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoCaptureivNV(uint video_capture_slot, All pname, int* parameters) => _GetVideoCaptureivNV_fnptr(video_capture_slot, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVideoCaptureivNV_Lazy(uint video_capture_slot, All pname, int* parameters)
            {
                _GetVideoCaptureivNV_fnptr = (delegate* unmanaged<uint, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVideoCaptureivNV");
                _GetVideoCaptureivNV_fnptr(video_capture_slot, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint, All, int*, void> _GetVideoCaptureStreamivNV_fnptr = &GetVideoCaptureStreamivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, All pname, int* parameters) => _GetVideoCaptureStreamivNV_fnptr(video_capture_slot, stream, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVideoCaptureStreamivNV_Lazy(uint video_capture_slot, uint stream, All pname, int* parameters)
            {
                _GetVideoCaptureStreamivNV_fnptr = (delegate* unmanaged<uint, uint, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVideoCaptureStreamivNV");
                _GetVideoCaptureStreamivNV_fnptr(video_capture_slot, stream, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint, All, float*, void> _GetVideoCaptureStreamfvNV_fnptr = &GetVideoCaptureStreamfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, All pname, float* parameters) => _GetVideoCaptureStreamfvNV_fnptr(video_capture_slot, stream, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVideoCaptureStreamfvNV_Lazy(uint video_capture_slot, uint stream, All pname, float* parameters)
            {
                _GetVideoCaptureStreamfvNV_fnptr = (delegate* unmanaged<uint, uint, All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVideoCaptureStreamfvNV");
                _GetVideoCaptureStreamfvNV_fnptr(video_capture_slot, stream, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint, All, double*, void> _GetVideoCaptureStreamdvNV_fnptr = &GetVideoCaptureStreamdvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, All pname, double* parameters) => _GetVideoCaptureStreamdvNV_fnptr(video_capture_slot, stream, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetVideoCaptureStreamdvNV_Lazy(uint video_capture_slot, uint stream, All pname, double* parameters)
            {
                _GetVideoCaptureStreamdvNV_fnptr = (delegate* unmanaged<uint, uint, All, double*, void>)GLLoader.BindingsContext.GetProcAddress("glGetVideoCaptureStreamdvNV");
                _GetVideoCaptureStreamdvNV_fnptr(video_capture_slot, stream, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint*, ulong*, All> _VideoCaptureNV_fnptr = &VideoCaptureNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All VideoCaptureNV(uint video_capture_slot, uint* sequence_num, ulong* capture_time) => _VideoCaptureNV_fnptr(video_capture_slot, sequence_num, capture_time);
            [UnmanagedCallersOnly]
            private static All VideoCaptureNV_Lazy(uint video_capture_slot, uint* sequence_num, ulong* capture_time)
            {
                _VideoCaptureNV_fnptr = (delegate* unmanaged<uint, uint*, ulong*, All>)GLLoader.BindingsContext.GetProcAddress("glVideoCaptureNV");
                return _VideoCaptureNV_fnptr(video_capture_slot, sequence_num, capture_time);
            }
            
            private static delegate* unmanaged<uint, uint, All, int*, void> _VideoCaptureStreamParameterivNV_fnptr = &VideoCaptureStreamParameterivNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, All pname, int* parameters) => _VideoCaptureStreamParameterivNV_fnptr(video_capture_slot, stream, pname, parameters);
            [UnmanagedCallersOnly]
            private static void VideoCaptureStreamParameterivNV_Lazy(uint video_capture_slot, uint stream, All pname, int* parameters)
            {
                _VideoCaptureStreamParameterivNV_fnptr = (delegate* unmanaged<uint, uint, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glVideoCaptureStreamParameterivNV");
                _VideoCaptureStreamParameterivNV_fnptr(video_capture_slot, stream, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint, All, float*, void> _VideoCaptureStreamParameterfvNV_fnptr = &VideoCaptureStreamParameterfvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, All pname, float* parameters) => _VideoCaptureStreamParameterfvNV_fnptr(video_capture_slot, stream, pname, parameters);
            [UnmanagedCallersOnly]
            private static void VideoCaptureStreamParameterfvNV_Lazy(uint video_capture_slot, uint stream, All pname, float* parameters)
            {
                _VideoCaptureStreamParameterfvNV_fnptr = (delegate* unmanaged<uint, uint, All, float*, void>)GLLoader.BindingsContext.GetProcAddress("glVideoCaptureStreamParameterfvNV");
                _VideoCaptureStreamParameterfvNV_fnptr(video_capture_slot, stream, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, uint, All, double*, void> _VideoCaptureStreamParameterdvNV_fnptr = &VideoCaptureStreamParameterdvNV_Lazy;
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, All pname, double* parameters) => _VideoCaptureStreamParameterdvNV_fnptr(video_capture_slot, stream, pname, parameters);
            [UnmanagedCallersOnly]
            private static void VideoCaptureStreamParameterdvNV_Lazy(uint video_capture_slot, uint stream, All pname, double* parameters)
            {
                _VideoCaptureStreamParameterdvNV_fnptr = (delegate* unmanaged<uint, uint, All, double*, void>)GLLoader.BindingsContext.GetProcAddress("glVideoCaptureStreamParameterdvNV");
                _VideoCaptureStreamParameterdvNV_fnptr(video_capture_slot, stream, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, All, All, All, All, void> _ViewportSwizzleNV_fnptr = &ViewportSwizzleNV_Lazy;
            /// <summary> <b>[requires: GL_NV_viewport_swizzle]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ViewportSwizzleNV(uint index, All swizzlex, All swizzley, All swizzlez, All swizzlew) => _ViewportSwizzleNV_fnptr(index, swizzlex, swizzley, swizzlez, swizzlew);
            [UnmanagedCallersOnly]
            private static void ViewportSwizzleNV_Lazy(uint index, All swizzlex, All swizzley, All swizzlez, All swizzlew)
            {
                _ViewportSwizzleNV_fnptr = (delegate* unmanaged<uint, All, All, All, All, void>)GLLoader.BindingsContext.GetProcAddress("glViewportSwizzleNV");
                _ViewportSwizzleNV_fnptr(index, swizzlex, swizzley, swizzlez, swizzlew);
            }
            
        }
        public static unsafe partial class GREMEDY
        {
            private static delegate* unmanaged<void> _FrameTerminatorGREMEDY_fnptr = &FrameTerminatorGREMEDY_Lazy;
            /// <summary> <b>[requires: GL_GREMEDY_frame_terminator]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FrameTerminatorGREMEDY() => _FrameTerminatorGREMEDY_fnptr();
            [UnmanagedCallersOnly]
            private static void FrameTerminatorGREMEDY_Lazy()
            {
                _FrameTerminatorGREMEDY_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glFrameTerminatorGREMEDY");
                _FrameTerminatorGREMEDY_fnptr();
            }
            
            private static delegate* unmanaged<int, void*, void> _StringMarkerGREMEDY_fnptr = &StringMarkerGREMEDY_Lazy;
            /// <summary> <b>[requires: GL_GREMEDY_string_marker]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StringMarkerGREMEDY(int len, void* str) => _StringMarkerGREMEDY_fnptr(len, str);
            [UnmanagedCallersOnly]
            private static void StringMarkerGREMEDY_Lazy(int len, void* str)
            {
                _StringMarkerGREMEDY_fnptr = (delegate* unmanaged<int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glStringMarkerGREMEDY");
                _StringMarkerGREMEDY_fnptr(len, str);
            }
            
        }
        public static unsafe partial class HP
        {
            private static delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, int, void> _ImageTransformParameteriHP_fnptr = &ImageTransformParameteriHP_Lazy;
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImageTransformParameteriHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int param) => _ImageTransformParameteriHP_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void ImageTransformParameteriHP_Lazy(ImageTransformTargetHP target, ImageTransformPNameHP pname, int param)
            {
                _ImageTransformParameteriHP_fnptr = (delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, int, void>)GLLoader.BindingsContext.GetProcAddress("glImageTransformParameteriHP");
                _ImageTransformParameteriHP_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, float, void> _ImageTransformParameterfHP_fnptr = &ImageTransformParameterfHP_Lazy;
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImageTransformParameterfHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float param) => _ImageTransformParameterfHP_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void ImageTransformParameterfHP_Lazy(ImageTransformTargetHP target, ImageTransformPNameHP pname, float param)
            {
                _ImageTransformParameterfHP_fnptr = (delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, float, void>)GLLoader.BindingsContext.GetProcAddress("glImageTransformParameterfHP");
                _ImageTransformParameterfHP_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, int*, void> _ImageTransformParameterivHP_fnptr = &ImageTransformParameterivHP_Lazy;
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => _ImageTransformParameterivHP_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ImageTransformParameterivHP_Lazy(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters)
            {
                _ImageTransformParameterivHP_fnptr = (delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, int*, void>)GLLoader.BindingsContext.GetProcAddress("glImageTransformParameterivHP");
                _ImageTransformParameterivHP_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, float*, void> _ImageTransformParameterfvHP_fnptr = &ImageTransformParameterfvHP_Lazy;
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => _ImageTransformParameterfvHP_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ImageTransformParameterfvHP_Lazy(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters)
            {
                _ImageTransformParameterfvHP_fnptr = (delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, float*, void>)GLLoader.BindingsContext.GetProcAddress("glImageTransformParameterfvHP");
                _ImageTransformParameterfvHP_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, int*, void> _GetImageTransformParameterivHP_fnptr = &GetImageTransformParameterivHP_Lazy;
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => _GetImageTransformParameterivHP_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetImageTransformParameterivHP_Lazy(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters)
            {
                _GetImageTransformParameterivHP_fnptr = (delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetImageTransformParameterivHP");
                _GetImageTransformParameterivHP_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, float*, void> _GetImageTransformParameterfvHP_fnptr = &GetImageTransformParameterfvHP_Lazy;
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => _GetImageTransformParameterfvHP_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetImageTransformParameterfvHP_Lazy(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters)
            {
                _GetImageTransformParameterfvHP_fnptr = (delegate* unmanaged<ImageTransformTargetHP, ImageTransformPNameHP, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetImageTransformParameterfvHP");
                _GetImageTransformParameterfvHP_fnptr(target, pname, parameters);
            }
            
        }
        public static unsafe partial class IBM
        {
            private static delegate* unmanaged<PrimitiveType*, int*, int*, int, int, void> _MultiModeDrawArraysIBM_fnptr = &MultiModeDrawArraysIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiModeDrawArraysIBM(PrimitiveType* mode, int* first, int* count, int primcount, int modestride) => _MultiModeDrawArraysIBM_fnptr(mode, first, count, primcount, modestride);
            [UnmanagedCallersOnly]
            private static void MultiModeDrawArraysIBM_Lazy(PrimitiveType* mode, int* first, int* count, int primcount, int modestride)
            {
                _MultiModeDrawArraysIBM_fnptr = (delegate* unmanaged<PrimitiveType*, int*, int*, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiModeDrawArraysIBM");
                _MultiModeDrawArraysIBM_fnptr(mode, first, count, primcount, modestride);
            }
            
            private static delegate* unmanaged<PrimitiveType*, int*, DrawElementsType, void**, int, int, void> _MultiModeDrawElementsIBM_fnptr = &MultiModeDrawElementsIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiModeDrawElementsIBM(PrimitiveType* mode, int* count, DrawElementsType type, void** indices, int primcount, int modestride) => _MultiModeDrawElementsIBM_fnptr(mode, count, type, indices, primcount, modestride);
            [UnmanagedCallersOnly]
            private static void MultiModeDrawElementsIBM_Lazy(PrimitiveType* mode, int* count, DrawElementsType type, void** indices, int primcount, int modestride)
            {
                _MultiModeDrawElementsIBM_fnptr = (delegate* unmanaged<PrimitiveType*, int*, DrawElementsType, void**, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiModeDrawElementsIBM");
                _MultiModeDrawElementsIBM_fnptr(mode, count, type, indices, primcount, modestride);
            }
            
            private static delegate* unmanaged<All, void> _FlushStaticDataIBM_fnptr = &FlushStaticDataIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_static_data]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushStaticDataIBM(All target) => _FlushStaticDataIBM_fnptr(target);
            [UnmanagedCallersOnly]
            private static void FlushStaticDataIBM_Lazy(All target)
            {
                _FlushStaticDataIBM_fnptr = (delegate* unmanaged<All, void>)GLLoader.BindingsContext.GetProcAddress("glFlushStaticDataIBM");
                _FlushStaticDataIBM_fnptr(target);
            }
            
            private static delegate* unmanaged<int, ColorPointerType, int, void**, int, void> _ColorPointerListIBM_fnptr = &ColorPointerListIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorPointerListIBM(int size, ColorPointerType type, int stride, void** pointer, int ptrstride) => _ColorPointerListIBM_fnptr(size, type, stride, pointer, ptrstride);
            [UnmanagedCallersOnly]
            private static void ColorPointerListIBM_Lazy(int size, ColorPointerType type, int stride, void** pointer, int ptrstride)
            {
                _ColorPointerListIBM_fnptr = (delegate* unmanaged<int, ColorPointerType, int, void**, int, void>)GLLoader.BindingsContext.GetProcAddress("glColorPointerListIBM");
                _ColorPointerListIBM_fnptr(size, type, stride, pointer, ptrstride);
            }
            
            private static delegate* unmanaged<int, SecondaryColorPointerTypeIBM, int, void**, int, void> _SecondaryColorPointerListIBM_fnptr = &SecondaryColorPointerListIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColorPointerListIBM(int size, SecondaryColorPointerTypeIBM type, int stride, void** pointer, int ptrstride) => _SecondaryColorPointerListIBM_fnptr(size, type, stride, pointer, ptrstride);
            [UnmanagedCallersOnly]
            private static void SecondaryColorPointerListIBM_Lazy(int size, SecondaryColorPointerTypeIBM type, int stride, void** pointer, int ptrstride)
            {
                _SecondaryColorPointerListIBM_fnptr = (delegate* unmanaged<int, SecondaryColorPointerTypeIBM, int, void**, int, void>)GLLoader.BindingsContext.GetProcAddress("glSecondaryColorPointerListIBM");
                _SecondaryColorPointerListIBM_fnptr(size, type, stride, pointer, ptrstride);
            }
            
            private static delegate* unmanaged<int, byte**, int, void> _EdgeFlagPointerListIBM_fnptr = &EdgeFlagPointerListIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EdgeFlagPointerListIBM(int stride, byte** pointer, int ptrstride) => _EdgeFlagPointerListIBM_fnptr(stride, pointer, ptrstride);
            [UnmanagedCallersOnly]
            private static void EdgeFlagPointerListIBM_Lazy(int stride, byte** pointer, int ptrstride)
            {
                _EdgeFlagPointerListIBM_fnptr = (delegate* unmanaged<int, byte**, int, void>)GLLoader.BindingsContext.GetProcAddress("glEdgeFlagPointerListIBM");
                _EdgeFlagPointerListIBM_fnptr(stride, pointer, ptrstride);
            }
            
            private static delegate* unmanaged<FogPointerTypeIBM, int, void**, int, void> _FogCoordPointerListIBM_fnptr = &FogCoordPointerListIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordPointerListIBM(FogPointerTypeIBM type, int stride, void** pointer, int ptrstride) => _FogCoordPointerListIBM_fnptr(type, stride, pointer, ptrstride);
            [UnmanagedCallersOnly]
            private static void FogCoordPointerListIBM_Lazy(FogPointerTypeIBM type, int stride, void** pointer, int ptrstride)
            {
                _FogCoordPointerListIBM_fnptr = (delegate* unmanaged<FogPointerTypeIBM, int, void**, int, void>)GLLoader.BindingsContext.GetProcAddress("glFogCoordPointerListIBM");
                _FogCoordPointerListIBM_fnptr(type, stride, pointer, ptrstride);
            }
            
            private static delegate* unmanaged<IndexPointerType, int, void**, int, void> _IndexPointerListIBM_fnptr = &IndexPointerListIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexPointerListIBM(IndexPointerType type, int stride, void** pointer, int ptrstride) => _IndexPointerListIBM_fnptr(type, stride, pointer, ptrstride);
            [UnmanagedCallersOnly]
            private static void IndexPointerListIBM_Lazy(IndexPointerType type, int stride, void** pointer, int ptrstride)
            {
                _IndexPointerListIBM_fnptr = (delegate* unmanaged<IndexPointerType, int, void**, int, void>)GLLoader.BindingsContext.GetProcAddress("glIndexPointerListIBM");
                _IndexPointerListIBM_fnptr(type, stride, pointer, ptrstride);
            }
            
            private static delegate* unmanaged<NormalPointerType, int, void**, int, void> _NormalPointerListIBM_fnptr = &NormalPointerListIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalPointerListIBM(NormalPointerType type, int stride, void** pointer, int ptrstride) => _NormalPointerListIBM_fnptr(type, stride, pointer, ptrstride);
            [UnmanagedCallersOnly]
            private static void NormalPointerListIBM_Lazy(NormalPointerType type, int stride, void** pointer, int ptrstride)
            {
                _NormalPointerListIBM_fnptr = (delegate* unmanaged<NormalPointerType, int, void**, int, void>)GLLoader.BindingsContext.GetProcAddress("glNormalPointerListIBM");
                _NormalPointerListIBM_fnptr(type, stride, pointer, ptrstride);
            }
            
            private static delegate* unmanaged<int, TexCoordPointerType, int, void**, int, void> _TexCoordPointerListIBM_fnptr = &TexCoordPointerListIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordPointerListIBM(int size, TexCoordPointerType type, int stride, void** pointer, int ptrstride) => _TexCoordPointerListIBM_fnptr(size, type, stride, pointer, ptrstride);
            [UnmanagedCallersOnly]
            private static void TexCoordPointerListIBM_Lazy(int size, TexCoordPointerType type, int stride, void** pointer, int ptrstride)
            {
                _TexCoordPointerListIBM_fnptr = (delegate* unmanaged<int, TexCoordPointerType, int, void**, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordPointerListIBM");
                _TexCoordPointerListIBM_fnptr(size, type, stride, pointer, ptrstride);
            }
            
            private static delegate* unmanaged<int, VertexPointerType, int, void**, int, void> _VertexPointerListIBM_fnptr = &VertexPointerListIBM_Lazy;
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexPointerListIBM(int size, VertexPointerType type, int stride, void** pointer, int ptrstride) => _VertexPointerListIBM_fnptr(size, type, stride, pointer, ptrstride);
            [UnmanagedCallersOnly]
            private static void VertexPointerListIBM_Lazy(int size, VertexPointerType type, int stride, void** pointer, int ptrstride)
            {
                _VertexPointerListIBM_fnptr = (delegate* unmanaged<int, VertexPointerType, int, void**, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertexPointerListIBM");
                _VertexPointerListIBM_fnptr(size, type, stride, pointer, ptrstride);
            }
            
        }
        public static unsafe partial class INGR
        {
            private static delegate* unmanaged<BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void> _BlendFuncSeparateINGR_fnptr = &BlendFuncSeparateINGR_Lazy;
            /// <summary> <b>[requires: GL_INGR_blend_func_separate]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncSeparateINGR(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => _BlendFuncSeparateINGR_fnptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
            [UnmanagedCallersOnly]
            private static void BlendFuncSeparateINGR_Lazy(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha)
            {
                _BlendFuncSeparateINGR_fnptr = (delegate* unmanaged<BlendingFactor, BlendingFactor, BlendingFactor, BlendingFactor, void>)GLLoader.BindingsContext.GetProcAddress("glBlendFuncSeparateINGR");
                _BlendFuncSeparateINGR_fnptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
            }
            
        }
        public static unsafe partial class INTEL
        {
            private static delegate* unmanaged<void> _ApplyFramebufferAttachmentCMAAINTEL_fnptr = &ApplyFramebufferAttachmentCMAAINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_framebuffer_CMAA]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ApplyFramebufferAttachmentCMAAINTEL() => _ApplyFramebufferAttachmentCMAAINTEL_fnptr();
            [UnmanagedCallersOnly]
            private static void ApplyFramebufferAttachmentCMAAINTEL_Lazy()
            {
                _ApplyFramebufferAttachmentCMAAINTEL_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glApplyFramebufferAttachmentCMAAINTEL");
                _ApplyFramebufferAttachmentCMAAINTEL_fnptr();
            }
            
            private static delegate* unmanaged<TextureHandle, void> _SyncTextureINTEL_fnptr = &SyncTextureINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SyncTextureINTEL(TextureHandle texture) => _SyncTextureINTEL_fnptr(texture);
            [UnmanagedCallersOnly]
            private static void SyncTextureINTEL_Lazy(TextureHandle texture)
            {
                _SyncTextureINTEL_fnptr = (delegate* unmanaged<TextureHandle, void>)GLLoader.BindingsContext.GetProcAddress("glSyncTextureINTEL");
                _SyncTextureINTEL_fnptr(texture);
            }
            
            private static delegate* unmanaged<TextureHandle, int, void> _UnmapTexture2DINTEL_fnptr = &UnmapTexture2DINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UnmapTexture2DINTEL(TextureHandle texture, int level) => _UnmapTexture2DINTEL_fnptr(texture, level);
            [UnmanagedCallersOnly]
            private static void UnmapTexture2DINTEL_Lazy(TextureHandle texture, int level)
            {
                _UnmapTexture2DINTEL_fnptr = (delegate* unmanaged<TextureHandle, int, void>)GLLoader.BindingsContext.GetProcAddress("glUnmapTexture2DINTEL");
                _UnmapTexture2DINTEL_fnptr(texture, level);
            }
            
            private static delegate* unmanaged<TextureHandle, int, All, int*, All*, void*> _MapTexture2DINTEL_fnptr = &MapTexture2DINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapTexture2DINTEL(TextureHandle texture, int level, All access, int* stride, All* layout) => _MapTexture2DINTEL_fnptr(texture, level, access, stride, layout);
            [UnmanagedCallersOnly]
            private static void* MapTexture2DINTEL_Lazy(TextureHandle texture, int level, All access, int* stride, All* layout)
            {
                _MapTexture2DINTEL_fnptr = (delegate* unmanaged<TextureHandle, int, All, int*, All*, void*>)GLLoader.BindingsContext.GetProcAddress("glMapTexture2DINTEL");
                return _MapTexture2DINTEL_fnptr(texture, level, access, stride, layout);
            }
            
            private static delegate* unmanaged<int, VertexPointerType, void**, void> _VertexPointervINTEL_fnptr = &VertexPointervINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexPointervINTEL(int size, VertexPointerType type, void** pointer) => _VertexPointervINTEL_fnptr(size, type, pointer);
            [UnmanagedCallersOnly]
            private static void VertexPointervINTEL_Lazy(int size, VertexPointerType type, void** pointer)
            {
                _VertexPointervINTEL_fnptr = (delegate* unmanaged<int, VertexPointerType, void**, void>)GLLoader.BindingsContext.GetProcAddress("glVertexPointervINTEL");
                _VertexPointervINTEL_fnptr(size, type, pointer);
            }
            
            private static delegate* unmanaged<NormalPointerType, void**, void> _NormalPointervINTEL_fnptr = &NormalPointervINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalPointervINTEL(NormalPointerType type, void** pointer) => _NormalPointervINTEL_fnptr(type, pointer);
            [UnmanagedCallersOnly]
            private static void NormalPointervINTEL_Lazy(NormalPointerType type, void** pointer)
            {
                _NormalPointervINTEL_fnptr = (delegate* unmanaged<NormalPointerType, void**, void>)GLLoader.BindingsContext.GetProcAddress("glNormalPointervINTEL");
                _NormalPointervINTEL_fnptr(type, pointer);
            }
            
            private static delegate* unmanaged<int, VertexPointerType, void**, void> _ColorPointervINTEL_fnptr = &ColorPointervINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorPointervINTEL(int size, VertexPointerType type, void** pointer) => _ColorPointervINTEL_fnptr(size, type, pointer);
            [UnmanagedCallersOnly]
            private static void ColorPointervINTEL_Lazy(int size, VertexPointerType type, void** pointer)
            {
                _ColorPointervINTEL_fnptr = (delegate* unmanaged<int, VertexPointerType, void**, void>)GLLoader.BindingsContext.GetProcAddress("glColorPointervINTEL");
                _ColorPointervINTEL_fnptr(size, type, pointer);
            }
            
            private static delegate* unmanaged<int, VertexPointerType, void**, void> _TexCoordPointervINTEL_fnptr = &TexCoordPointervINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordPointervINTEL(int size, VertexPointerType type, void** pointer) => _TexCoordPointervINTEL_fnptr(size, type, pointer);
            [UnmanagedCallersOnly]
            private static void TexCoordPointervINTEL_Lazy(int size, VertexPointerType type, void** pointer)
            {
                _TexCoordPointervINTEL_fnptr = (delegate* unmanaged<int, VertexPointerType, void**, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoordPointervINTEL");
                _TexCoordPointervINTEL_fnptr(size, type, pointer);
            }
            
            private static delegate* unmanaged<uint, void> _BeginPerfQueryINTEL_fnptr = &BeginPerfQueryINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginPerfQueryINTEL(uint queryHandle) => _BeginPerfQueryINTEL_fnptr(queryHandle);
            [UnmanagedCallersOnly]
            private static void BeginPerfQueryINTEL_Lazy(uint queryHandle)
            {
                _BeginPerfQueryINTEL_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glBeginPerfQueryINTEL");
                _BeginPerfQueryINTEL_fnptr(queryHandle);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _CreatePerfQueryINTEL_fnptr = &CreatePerfQueryINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreatePerfQueryINTEL(uint queryId, uint* queryHandle) => _CreatePerfQueryINTEL_fnptr(queryId, queryHandle);
            [UnmanagedCallersOnly]
            private static void CreatePerfQueryINTEL_Lazy(uint queryId, uint* queryHandle)
            {
                _CreatePerfQueryINTEL_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glCreatePerfQueryINTEL");
                _CreatePerfQueryINTEL_fnptr(queryId, queryHandle);
            }
            
            private static delegate* unmanaged<uint, void> _DeletePerfQueryINTEL_fnptr = &DeletePerfQueryINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeletePerfQueryINTEL(uint queryHandle) => _DeletePerfQueryINTEL_fnptr(queryHandle);
            [UnmanagedCallersOnly]
            private static void DeletePerfQueryINTEL_Lazy(uint queryHandle)
            {
                _DeletePerfQueryINTEL_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glDeletePerfQueryINTEL");
                _DeletePerfQueryINTEL_fnptr(queryHandle);
            }
            
            private static delegate* unmanaged<uint, void> _EndPerfQueryINTEL_fnptr = &EndPerfQueryINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndPerfQueryINTEL(uint queryHandle) => _EndPerfQueryINTEL_fnptr(queryHandle);
            [UnmanagedCallersOnly]
            private static void EndPerfQueryINTEL_Lazy(uint queryHandle)
            {
                _EndPerfQueryINTEL_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glEndPerfQueryINTEL");
                _EndPerfQueryINTEL_fnptr(queryHandle);
            }
            
            private static delegate* unmanaged<uint*, void> _GetFirstPerfQueryIdINTEL_fnptr = &GetFirstPerfQueryIdINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFirstPerfQueryIdINTEL(uint* queryId) => _GetFirstPerfQueryIdINTEL_fnptr(queryId);
            [UnmanagedCallersOnly]
            private static void GetFirstPerfQueryIdINTEL_Lazy(uint* queryId)
            {
                _GetFirstPerfQueryIdINTEL_fnptr = (delegate* unmanaged<uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFirstPerfQueryIdINTEL");
                _GetFirstPerfQueryIdINTEL_fnptr(queryId);
            }
            
            private static delegate* unmanaged<uint, uint*, void> _GetNextPerfQueryIdINTEL_fnptr = &GetNextPerfQueryIdINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNextPerfQueryIdINTEL(uint queryId, uint* nextQueryId) => _GetNextPerfQueryIdINTEL_fnptr(queryId, nextQueryId);
            [UnmanagedCallersOnly]
            private static void GetNextPerfQueryIdINTEL_Lazy(uint queryId, uint* nextQueryId)
            {
                _GetNextPerfQueryIdINTEL_fnptr = (delegate* unmanaged<uint, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetNextPerfQueryIdINTEL");
                _GetNextPerfQueryIdINTEL_fnptr(queryId, nextQueryId);
            }
            
            private static delegate* unmanaged<uint, uint, uint, byte*, uint, byte*, uint*, uint*, uint*, uint*, ulong*, void> _GetPerfCounterInfoINTEL_fnptr = &GetPerfCounterInfoINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, byte* counterName, uint counterDescLength, byte* counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) => _GetPerfCounterInfoINTEL_fnptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
            [UnmanagedCallersOnly]
            private static void GetPerfCounterInfoINTEL_Lazy(uint queryId, uint counterId, uint counterNameLength, byte* counterName, uint counterDescLength, byte* counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue)
            {
                _GetPerfCounterInfoINTEL_fnptr = (delegate* unmanaged<uint, uint, uint, byte*, uint, byte*, uint*, uint*, uint*, uint*, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfCounterInfoINTEL");
                _GetPerfCounterInfoINTEL_fnptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
            }
            
            private static delegate* unmanaged<uint, uint, int, void*, uint*, void> _GetPerfQueryDataINTEL_fnptr = &GetPerfQueryDataINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, void* data, uint* bytesWritten) => _GetPerfQueryDataINTEL_fnptr(queryHandle, flags, dataSize, data, bytesWritten);
            [UnmanagedCallersOnly]
            private static void GetPerfQueryDataINTEL_Lazy(uint queryHandle, uint flags, int dataSize, void* data, uint* bytesWritten)
            {
                _GetPerfQueryDataINTEL_fnptr = (delegate* unmanaged<uint, uint, int, void*, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfQueryDataINTEL");
                _GetPerfQueryDataINTEL_fnptr(queryHandle, flags, dataSize, data, bytesWritten);
            }
            
            private static delegate* unmanaged<byte*, uint*, void> _GetPerfQueryIdByNameINTEL_fnptr = &GetPerfQueryIdByNameINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfQueryIdByNameINTEL(byte* queryName, uint* queryId) => _GetPerfQueryIdByNameINTEL_fnptr(queryName, queryId);
            [UnmanagedCallersOnly]
            private static void GetPerfQueryIdByNameINTEL_Lazy(byte* queryName, uint* queryId)
            {
                _GetPerfQueryIdByNameINTEL_fnptr = (delegate* unmanaged<byte*, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfQueryIdByNameINTEL");
                _GetPerfQueryIdByNameINTEL_fnptr(queryName, queryId);
            }
            
            private static delegate* unmanaged<uint, uint, byte*, uint*, uint*, uint*, uint*, void> _GetPerfQueryInfoINTEL_fnptr = &GetPerfQueryInfoINTEL_Lazy;
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, byte* queryName, uint* dataSize, uint* noCounters, uint* noInstances, uint* capsMask) => _GetPerfQueryInfoINTEL_fnptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
            [UnmanagedCallersOnly]
            private static void GetPerfQueryInfoINTEL_Lazy(uint queryId, uint queryNameLength, byte* queryName, uint* dataSize, uint* noCounters, uint* noInstances, uint* capsMask)
            {
                _GetPerfQueryInfoINTEL_fnptr = (delegate* unmanaged<uint, uint, byte*, uint*, uint*, uint*, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPerfQueryInfoINTEL");
                _GetPerfQueryInfoINTEL_fnptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
            }
            
        }
        public static unsafe partial class KHR
        {
            private static delegate* unmanaged<void> _BlendBarrierKHR_fnptr = &BlendBarrierKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_blend_equation_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendBarrierKHR() => _BlendBarrierKHR_fnptr();
            [UnmanagedCallersOnly]
            private static void BlendBarrierKHR_Lazy()
            {
                _BlendBarrierKHR_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glBlendBarrierKHR");
                _BlendBarrierKHR_fnptr();
            }
            
            private static delegate* unmanaged<DebugSource, DebugType, DebugSeverity, int, uint*, byte, void> _DebugMessageControl_fnptr = &DebugMessageControl_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Control the reporting of debug messages in a debug context. </summary>
            /// <param name="source"> The source of debug messages to enable or disable. </param>
            /// <param name="type"> The type of debug messages to enable or disable. </param>
            /// <param name="severity"> The severity of debug messages to enable or disable. </param>
            /// <param name="count"> The length of the array ids. </param>
            /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
            /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml" /></remarks>
            public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, byte enabled) => _DebugMessageControl_fnptr(source, type, severity, count, ids, enabled);
            [UnmanagedCallersOnly]
            private static void DebugMessageControl_Lazy(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, byte enabled)
            {
                _DebugMessageControl_fnptr = (delegate* unmanaged<DebugSource, DebugType, DebugSeverity, int, uint*, byte, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageControl");
                _DebugMessageControl_fnptr(source, type, severity, count, ids, enabled);
            }
            
            private static delegate* unmanaged<DebugSource, DebugType, uint, DebugSeverity, int, byte*, void> _DebugMessageInsert_fnptr = &DebugMessageInsert_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Inject an application-supplied message into the debug message queue. </summary>
            /// <param name="source"> The source of the debug message to insert. </param>
            /// <param name="type"> The type of the debug message insert. </param>
            /// <param name="id"> The user-supplied identifier of the message to insert. </param>
            /// <param name="severity"> The severity of the debug messages to insert. </param>
            /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
            /// <param name="message"> The address of a character array containing the message to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml" /></remarks>
            public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => _DebugMessageInsert_fnptr(source, type, id, severity, length, buf);
            [UnmanagedCallersOnly]
            private static void DebugMessageInsert_Lazy(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf)
            {
                _DebugMessageInsert_fnptr = (delegate* unmanaged<DebugSource, DebugType, uint, DebugSeverity, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageInsert");
                _DebugMessageInsert_fnptr(source, type, id, severity, length, buf);
            }
            
            private static delegate* unmanaged<IntPtr, void*, void> _DebugMessageCallback_fnptr = &DebugMessageCallback_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Specify a callback to receive debugging messages from the GL. </summary>
            /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
            /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml" /></remarks>
            public static void DebugMessageCallback(IntPtr callback, void* userParam) => _DebugMessageCallback_fnptr(callback, userParam);
            [UnmanagedCallersOnly]
            private static void DebugMessageCallback_Lazy(IntPtr callback, void* userParam)
            {
                _DebugMessageCallback_fnptr = (delegate* unmanaged<IntPtr, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageCallback");
                _DebugMessageCallback_fnptr(callback, userParam);
            }
            
            private static delegate* unmanaged<uint, int, DebugSource*, DebugType*, uint*, DebugSeverity*, int*, byte*, uint> _GetDebugMessageLog_fnptr = &GetDebugMessageLog_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve messages from the debug message log. </summary>
            /// <param name="count"> The number of debug messages to retrieve from the log. </param>
            /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
            /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
            /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
            /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
            /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
            /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
            /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml" /></remarks>
            public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => _GetDebugMessageLog_fnptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
            [UnmanagedCallersOnly]
            private static uint GetDebugMessageLog_Lazy(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog)
            {
                _GetDebugMessageLog_fnptr = (delegate* unmanaged<uint, int, DebugSource*, DebugType*, uint*, DebugSeverity*, int*, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetDebugMessageLog");
                return _GetDebugMessageLog_fnptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
            }
            
            private static delegate* unmanaged<DebugSource, uint, int, byte*, void> _PushDebugGroup_fnptr = &PushDebugGroup_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Push a named debug group into the command stream. </summary>
            /// <param name="source"> The source of the debug message. </param>
            /// <param name="id"> The identifier of the message. </param>
            /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
            /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml" /></remarks>
            public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => _PushDebugGroup_fnptr(source, id, length, message);
            [UnmanagedCallersOnly]
            private static void PushDebugGroup_Lazy(DebugSource source, uint id, int length, byte* message)
            {
                _PushDebugGroup_fnptr = (delegate* unmanaged<DebugSource, uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glPushDebugGroup");
                _PushDebugGroup_fnptr(source, id, length, message);
            }
            
            private static delegate* unmanaged<void> _PopDebugGroup_fnptr = &PopDebugGroup_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Pop the active debug group. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml" /></remarks>
            public static void PopDebugGroup() => _PopDebugGroup_fnptr();
            [UnmanagedCallersOnly]
            private static void PopDebugGroup_Lazy()
            {
                _PopDebugGroup_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPopDebugGroup");
                _PopDebugGroup_fnptr();
            }
            
            private static delegate* unmanaged<ObjectIdentifier, uint, int, byte*, void> _ObjectLabel_fnptr = &ObjectLabel_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Label a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object to label. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml" /></remarks>
            public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => _ObjectLabel_fnptr(identifier, name, length, label);
            [UnmanagedCallersOnly]
            private static void ObjectLabel_Lazy(ObjectIdentifier identifier, uint name, int length, byte* label)
            {
                _ObjectLabel_fnptr = (delegate* unmanaged<ObjectIdentifier, uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glObjectLabel");
                _ObjectLabel_fnptr(identifier, name, length, label);
            }
            
            private static delegate* unmanaged<ObjectIdentifier, uint, int, int*, byte*, void> _GetObjectLabel_fnptr = &GetObjectLabel_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve the label of a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml" /></remarks>
            public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => _GetObjectLabel_fnptr(identifier, name, bufSize, length, label);
            [UnmanagedCallersOnly]
            private static void GetObjectLabel_Lazy(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label)
            {
                _GetObjectLabel_fnptr = (delegate* unmanaged<ObjectIdentifier, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectLabel");
                _GetObjectLabel_fnptr(identifier, name, bufSize, length, label);
            }
            
            private static delegate* unmanaged<void*, int, byte*, void> _ObjectPtrLabel_fnptr = &ObjectPtrLabel_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Label a sync object identified by a pointer. </summary>
            /// <param name="ptr"> A pointer identifying a sync object. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml" /></remarks>
            public static void ObjectPtrLabel(void* ptr, int length, byte* label) => _ObjectPtrLabel_fnptr(ptr, length, label);
            [UnmanagedCallersOnly]
            private static void ObjectPtrLabel_Lazy(void* ptr, int length, byte* label)
            {
                _ObjectPtrLabel_fnptr = (delegate* unmanaged<void*, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glObjectPtrLabel");
                _ObjectPtrLabel_fnptr(ptr, length, label);
            }
            
            private static delegate* unmanaged<void*, int, int*, byte*, void> _GetObjectPtrLabel_fnptr = &GetObjectPtrLabel_Lazy;
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve the label of a sync object identified by a pointer. </summary>
            /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml" /></remarks>
            public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => _GetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
            [UnmanagedCallersOnly]
            private static void GetObjectPtrLabel_Lazy(void* ptr, int bufSize, int* length, byte* label)
            {
                _GetObjectPtrLabel_fnptr = (delegate* unmanaged<void*, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectPtrLabel");
                _GetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
            }
            
            private static delegate* unmanaged<GetPointervPName, void**, void> _GetPointerv_fnptr = &GetPointerv_Lazy;
            /// <summary> <b>[requires: v1.1 | v4.3 | GL_KHR_debug]</b> Return the address of the specified pointer. </summary>
            /// <param name="pname"> Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or GL_DEBUG_CALLBACK_USER_PARAM. </param>
            /// <param name="parameters"> Returns the pointer value specified by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml" /></remarks>
            public static void GetPointerv(GetPointervPName pname, void** parameters) => _GetPointerv_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetPointerv_Lazy(GetPointervPName pname, void** parameters)
            {
                _GetPointerv_fnptr = (delegate* unmanaged<GetPointervPName, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetPointerv");
                _GetPointerv_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<DebugSource, DebugType, DebugSeverity, int, uint*, byte, void> _DebugMessageControlKHR_fnptr = &DebugMessageControlKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageControlKHR(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, byte enabled) => _DebugMessageControlKHR_fnptr(source, type, severity, count, ids, enabled);
            [UnmanagedCallersOnly]
            private static void DebugMessageControlKHR_Lazy(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, byte enabled)
            {
                _DebugMessageControlKHR_fnptr = (delegate* unmanaged<DebugSource, DebugType, DebugSeverity, int, uint*, byte, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageControlKHR");
                _DebugMessageControlKHR_fnptr(source, type, severity, count, ids, enabled);
            }
            
            private static delegate* unmanaged<DebugSource, DebugType, uint, DebugSeverity, int, byte*, void> _DebugMessageInsertKHR_fnptr = &DebugMessageInsertKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageInsertKHR(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => _DebugMessageInsertKHR_fnptr(source, type, id, severity, length, buf);
            [UnmanagedCallersOnly]
            private static void DebugMessageInsertKHR_Lazy(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf)
            {
                _DebugMessageInsertKHR_fnptr = (delegate* unmanaged<DebugSource, DebugType, uint, DebugSeverity, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageInsertKHR");
                _DebugMessageInsertKHR_fnptr(source, type, id, severity, length, buf);
            }
            
            private static delegate* unmanaged<IntPtr, void*, void> _DebugMessageCallbackKHR_fnptr = &DebugMessageCallbackKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageCallbackKHR(IntPtr callback, void* userParam) => _DebugMessageCallbackKHR_fnptr(callback, userParam);
            [UnmanagedCallersOnly]
            private static void DebugMessageCallbackKHR_Lazy(IntPtr callback, void* userParam)
            {
                _DebugMessageCallbackKHR_fnptr = (delegate* unmanaged<IntPtr, void*, void>)GLLoader.BindingsContext.GetProcAddress("glDebugMessageCallbackKHR");
                _DebugMessageCallbackKHR_fnptr(callback, userParam);
            }
            
            private static delegate* unmanaged<uint, int, DebugSource*, DebugType*, uint*, DebugSeverity*, int*, byte*, uint> _GetDebugMessageLogKHR_fnptr = &GetDebugMessageLogKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GetDebugMessageLogKHR(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => _GetDebugMessageLogKHR_fnptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
            [UnmanagedCallersOnly]
            private static uint GetDebugMessageLogKHR_Lazy(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog)
            {
                _GetDebugMessageLogKHR_fnptr = (delegate* unmanaged<uint, int, DebugSource*, DebugType*, uint*, DebugSeverity*, int*, byte*, uint>)GLLoader.BindingsContext.GetProcAddress("glGetDebugMessageLogKHR");
                return _GetDebugMessageLogKHR_fnptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);
            }
            
            private static delegate* unmanaged<DebugSource, uint, int, byte*, void> _PushDebugGroupKHR_fnptr = &PushDebugGroupKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PushDebugGroupKHR(DebugSource source, uint id, int length, byte* message) => _PushDebugGroupKHR_fnptr(source, id, length, message);
            [UnmanagedCallersOnly]
            private static void PushDebugGroupKHR_Lazy(DebugSource source, uint id, int length, byte* message)
            {
                _PushDebugGroupKHR_fnptr = (delegate* unmanaged<DebugSource, uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glPushDebugGroupKHR");
                _PushDebugGroupKHR_fnptr(source, id, length, message);
            }
            
            private static delegate* unmanaged<void> _PopDebugGroupKHR_fnptr = &PopDebugGroupKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PopDebugGroupKHR() => _PopDebugGroupKHR_fnptr();
            [UnmanagedCallersOnly]
            private static void PopDebugGroupKHR_Lazy()
            {
                _PopDebugGroupKHR_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glPopDebugGroupKHR");
                _PopDebugGroupKHR_fnptr();
            }
            
            private static delegate* unmanaged<ObjectIdentifier, uint, int, byte*, void> _ObjectLabelKHR_fnptr = &ObjectLabelKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ObjectLabelKHR(ObjectIdentifier identifier, uint name, int length, byte* label) => _ObjectLabelKHR_fnptr(identifier, name, length, label);
            [UnmanagedCallersOnly]
            private static void ObjectLabelKHR_Lazy(ObjectIdentifier identifier, uint name, int length, byte* label)
            {
                _ObjectLabelKHR_fnptr = (delegate* unmanaged<ObjectIdentifier, uint, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glObjectLabelKHR");
                _ObjectLabelKHR_fnptr(identifier, name, length, label);
            }
            
            private static delegate* unmanaged<All, uint, int, int*, byte*, void> _GetObjectLabelKHR_fnptr = &GetObjectLabelKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectLabelKHR(All identifier, uint name, int bufSize, int* length, byte* label) => _GetObjectLabelKHR_fnptr(identifier, name, bufSize, length, label);
            [UnmanagedCallersOnly]
            private static void GetObjectLabelKHR_Lazy(All identifier, uint name, int bufSize, int* length, byte* label)
            {
                _GetObjectLabelKHR_fnptr = (delegate* unmanaged<All, uint, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectLabelKHR");
                _GetObjectLabelKHR_fnptr(identifier, name, bufSize, length, label);
            }
            
            private static delegate* unmanaged<void*, int, byte*, void> _ObjectPtrLabelKHR_fnptr = &ObjectPtrLabelKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ObjectPtrLabelKHR(void* ptr, int length, byte* label) => _ObjectPtrLabelKHR_fnptr(ptr, length, label);
            [UnmanagedCallersOnly]
            private static void ObjectPtrLabelKHR_Lazy(void* ptr, int length, byte* label)
            {
                _ObjectPtrLabelKHR_fnptr = (delegate* unmanaged<void*, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glObjectPtrLabelKHR");
                _ObjectPtrLabelKHR_fnptr(ptr, length, label);
            }
            
            private static delegate* unmanaged<void*, int, int*, byte*, void> _GetObjectPtrLabelKHR_fnptr = &GetObjectPtrLabelKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectPtrLabelKHR(void* ptr, int bufSize, int* length, byte* label) => _GetObjectPtrLabelKHR_fnptr(ptr, bufSize, length, label);
            [UnmanagedCallersOnly]
            private static void GetObjectPtrLabelKHR_Lazy(void* ptr, int bufSize, int* length, byte* label)
            {
                _GetObjectPtrLabelKHR_fnptr = (delegate* unmanaged<void*, int, int*, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glGetObjectPtrLabelKHR");
                _GetObjectPtrLabelKHR_fnptr(ptr, bufSize, length, label);
            }
            
            private static delegate* unmanaged<All, void**, void> _GetPointervKHR_fnptr = &GetPointervKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPointervKHR(All pname, void** parameters) => _GetPointervKHR_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetPointervKHR_Lazy(All pname, void** parameters)
            {
                _GetPointervKHR_fnptr = (delegate* unmanaged<All, void**, void>)GLLoader.BindingsContext.GetProcAddress("glGetPointervKHR");
                _GetPointervKHR_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<GraphicsResetStatus> _GetGraphicsResetStatus_fnptr = &GetGraphicsResetStatus_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Check if the rendering context has not been lost due to software or hardware issues. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml" /></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatus() => _GetGraphicsResetStatus_fnptr();
            [UnmanagedCallersOnly]
            private static GraphicsResetStatus GetGraphicsResetStatus_Lazy()
            {
                _GetGraphicsResetStatus_fnptr = (delegate* unmanaged<GraphicsResetStatus>)GLLoader.BindingsContext.GetProcAddress("glGetGraphicsResetStatus");
                return _GetGraphicsResetStatus_fnptr();
            }
            
            private static delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, int, void*, void> _ReadnPixels_fnptr = &ReadnPixels_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Read a block of pixels from the frame buffer. </summary>
            /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
            /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
            /// <param name="data">Returns the pixel data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
            public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => _ReadnPixels_fnptr(x, y, width, height, format, type, bufSize, data);
            [UnmanagedCallersOnly]
            private static void ReadnPixels_Lazy(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data)
            {
                _ReadnPixels_fnptr = (delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glReadnPixels");
                _ReadnPixels_fnptr(x, y, width, height, format, type, bufSize, data);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _GetnUniformfv_fnptr = &GetnUniformfv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformfv(ProgramHandle program, int location, int bufSize, float* parameters) => _GetnUniformfv_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformfv_Lazy(ProgramHandle program, int location, int bufSize, float* parameters)
            {
                _GetnUniformfv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformfv");
                _GetnUniformfv_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _GetnUniformiv_fnptr = &GetnUniformiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformiv(ProgramHandle program, int location, int bufSize, int* parameters) => _GetnUniformiv_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformiv_Lazy(ProgramHandle program, int location, int bufSize, int* parameters)
            {
                _GetnUniformiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformiv");
                _GetnUniformiv_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _GetnUniformuiv_fnptr = &GetnUniformuiv_Lazy;
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformuiv(ProgramHandle program, int location, int bufSize, uint* parameters) => _GetnUniformuiv_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformuiv_Lazy(ProgramHandle program, int location, int bufSize, uint* parameters)
            {
                _GetnUniformuiv_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformuiv");
                _GetnUniformuiv_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<GraphicsResetStatus> _GetGraphicsResetStatusKHR_fnptr = &GetGraphicsResetStatusKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatusKHR() => _GetGraphicsResetStatusKHR_fnptr();
            [UnmanagedCallersOnly]
            private static GraphicsResetStatus GetGraphicsResetStatusKHR_Lazy()
            {
                _GetGraphicsResetStatusKHR_fnptr = (delegate* unmanaged<GraphicsResetStatus>)GLLoader.BindingsContext.GetProcAddress("glGetGraphicsResetStatusKHR");
                return _GetGraphicsResetStatusKHR_fnptr();
            }
            
            private static delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, int, void*, void> _ReadnPixelsKHR_fnptr = &ReadnPixelsKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReadnPixelsKHR(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => _ReadnPixelsKHR_fnptr(x, y, width, height, format, type, bufSize, data);
            [UnmanagedCallersOnly]
            private static void ReadnPixelsKHR_Lazy(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data)
            {
                _ReadnPixelsKHR_fnptr = (delegate* unmanaged<int, int, int, int, PixelFormat, PixelType, int, void*, void>)GLLoader.BindingsContext.GetProcAddress("glReadnPixelsKHR");
                _ReadnPixelsKHR_fnptr(x, y, width, height, format, type, bufSize, data);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, float*, void> _GetnUniformfvKHR_fnptr = &GetnUniformfvKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformfvKHR(ProgramHandle program, int location, int bufSize, float* parameters) => _GetnUniformfvKHR_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformfvKHR_Lazy(ProgramHandle program, int location, int bufSize, float* parameters)
            {
                _GetnUniformfvKHR_fnptr = (delegate* unmanaged<ProgramHandle, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformfvKHR");
                _GetnUniformfvKHR_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, int*, void> _GetnUniformivKHR_fnptr = &GetnUniformivKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformivKHR(ProgramHandle program, int location, int bufSize, int* parameters) => _GetnUniformivKHR_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformivKHR_Lazy(ProgramHandle program, int location, int bufSize, int* parameters)
            {
                _GetnUniformivKHR_fnptr = (delegate* unmanaged<ProgramHandle, int, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformivKHR");
                _GetnUniformivKHR_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<ProgramHandle, int, int, uint*, void> _GetnUniformuivKHR_fnptr = &GetnUniformuivKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformuivKHR(ProgramHandle program, int location, int bufSize, uint* parameters) => _GetnUniformuivKHR_fnptr(program, location, bufSize, parameters);
            [UnmanagedCallersOnly]
            private static void GetnUniformuivKHR_Lazy(ProgramHandle program, int location, int bufSize, uint* parameters)
            {
                _GetnUniformuivKHR_fnptr = (delegate* unmanaged<ProgramHandle, int, int, uint*, void>)GLLoader.BindingsContext.GetProcAddress("glGetnUniformuivKHR");
                _GetnUniformuivKHR_fnptr(program, location, bufSize, parameters);
            }
            
            private static delegate* unmanaged<uint, void> _MaxShaderCompilerThreadsKHR_fnptr = &MaxShaderCompilerThreadsKHR_Lazy;
            /// <summary> <b>[requires: GL_KHR_parallel_shader_compile]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MaxShaderCompilerThreadsKHR(uint count) => _MaxShaderCompilerThreadsKHR_fnptr(count);
            [UnmanagedCallersOnly]
            private static void MaxShaderCompilerThreadsKHR_Lazy(uint count)
            {
                _MaxShaderCompilerThreadsKHR_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glMaxShaderCompilerThreadsKHR");
                _MaxShaderCompilerThreadsKHR_fnptr(count);
            }
            
        }
        public static unsafe partial class MESA
        {
            private static delegate* unmanaged<FramebufferTarget, FramebufferParameterName, int, void> _FramebufferParameteriMESA_fnptr = &FramebufferParameteriMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferParameteriMESA(FramebufferTarget target, FramebufferParameterName pname, int param) => _FramebufferParameteriMESA_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void FramebufferParameteriMESA_Lazy(FramebufferTarget target, FramebufferParameterName pname, int param)
            {
                _FramebufferParameteriMESA_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferParameteriMESA");
                _FramebufferParameteriMESA_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachmentParameterName, int*, void> _GetFramebufferParameterivMESA_fnptr = &GetFramebufferParameterivMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => _GetFramebufferParameterivMESA_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFramebufferParameterivMESA_Lazy(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters)
            {
                _GetFramebufferParameterivMESA_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachmentParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFramebufferParameterivMESA");
                _GetFramebufferParameterivMESA_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<void> _ResizeBuffersMESA_fnptr = &ResizeBuffersMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_resize_buffers]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResizeBuffersMESA() => _ResizeBuffersMESA_fnptr();
            [UnmanagedCallersOnly]
            private static void ResizeBuffersMESA_Lazy()
            {
                _ResizeBuffersMESA_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glResizeBuffersMESA");
                _ResizeBuffersMESA_fnptr();
            }
            
            private static delegate* unmanaged<double, double, void> _WindowPos2dMESA_fnptr = &WindowPos2dMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2dMESA(double x, double y) => _WindowPos2dMESA_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void WindowPos2dMESA_Lazy(double x, double y)
            {
                _WindowPos2dMESA_fnptr = (delegate* unmanaged<double, double, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2dMESA");
                _WindowPos2dMESA_fnptr(x, y);
            }
            
            private static delegate* unmanaged<double*, void> _WindowPos2dvMESA_fnptr = &WindowPos2dvMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2dvMESA(double* v) => _WindowPos2dvMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos2dvMESA_Lazy(double* v)
            {
                _WindowPos2dvMESA_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2dvMESA");
                _WindowPos2dvMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<float, float, void> _WindowPos2fMESA_fnptr = &WindowPos2fMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2fMESA(float x, float y) => _WindowPos2fMESA_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void WindowPos2fMESA_Lazy(float x, float y)
            {
                _WindowPos2fMESA_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2fMESA");
                _WindowPos2fMESA_fnptr(x, y);
            }
            
            private static delegate* unmanaged<float*, void> _WindowPos2fvMESA_fnptr = &WindowPos2fvMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2fvMESA(float* v) => _WindowPos2fvMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos2fvMESA_Lazy(float* v)
            {
                _WindowPos2fvMESA_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2fvMESA");
                _WindowPos2fvMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<int, int, void> _WindowPos2iMESA_fnptr = &WindowPos2iMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2iMESA(int x, int y) => _WindowPos2iMESA_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void WindowPos2iMESA_Lazy(int x, int y)
            {
                _WindowPos2iMESA_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2iMESA");
                _WindowPos2iMESA_fnptr(x, y);
            }
            
            private static delegate* unmanaged<int*, void> _WindowPos2ivMESA_fnptr = &WindowPos2ivMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2ivMESA(int* v) => _WindowPos2ivMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos2ivMESA_Lazy(int* v)
            {
                _WindowPos2ivMESA_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2ivMESA");
                _WindowPos2ivMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<short, short, void> _WindowPos2sMESA_fnptr = &WindowPos2sMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2sMESA(short x, short y) => _WindowPos2sMESA_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void WindowPos2sMESA_Lazy(short x, short y)
            {
                _WindowPos2sMESA_fnptr = (delegate* unmanaged<short, short, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2sMESA");
                _WindowPos2sMESA_fnptr(x, y);
            }
            
            private static delegate* unmanaged<short*, void> _WindowPos2svMESA_fnptr = &WindowPos2svMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2svMESA(short* v) => _WindowPos2svMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos2svMESA_Lazy(short* v)
            {
                _WindowPos2svMESA_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos2svMESA");
                _WindowPos2svMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<double, double, double, void> _WindowPos3dMESA_fnptr = &WindowPos3dMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3dMESA(double x, double y, double z) => _WindowPos3dMESA_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void WindowPos3dMESA_Lazy(double x, double y, double z)
            {
                _WindowPos3dMESA_fnptr = (delegate* unmanaged<double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3dMESA");
                _WindowPos3dMESA_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<double*, void> _WindowPos3dvMESA_fnptr = &WindowPos3dvMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3dvMESA(double* v) => _WindowPos3dvMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos3dvMESA_Lazy(double* v)
            {
                _WindowPos3dvMESA_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3dvMESA");
                _WindowPos3dvMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<float, float, float, void> _WindowPos3fMESA_fnptr = &WindowPos3fMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3fMESA(float x, float y, float z) => _WindowPos3fMESA_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void WindowPos3fMESA_Lazy(float x, float y, float z)
            {
                _WindowPos3fMESA_fnptr = (delegate* unmanaged<float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3fMESA");
                _WindowPos3fMESA_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<float*, void> _WindowPos3fvMESA_fnptr = &WindowPos3fvMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3fvMESA(float* v) => _WindowPos3fvMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos3fvMESA_Lazy(float* v)
            {
                _WindowPos3fvMESA_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3fvMESA");
                _WindowPos3fvMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<int, int, int, void> _WindowPos3iMESA_fnptr = &WindowPos3iMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3iMESA(int x, int y, int z) => _WindowPos3iMESA_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void WindowPos3iMESA_Lazy(int x, int y, int z)
            {
                _WindowPos3iMESA_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3iMESA");
                _WindowPos3iMESA_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<int*, void> _WindowPos3ivMESA_fnptr = &WindowPos3ivMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3ivMESA(int* v) => _WindowPos3ivMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos3ivMESA_Lazy(int* v)
            {
                _WindowPos3ivMESA_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3ivMESA");
                _WindowPos3ivMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<short, short, short, void> _WindowPos3sMESA_fnptr = &WindowPos3sMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3sMESA(short x, short y, short z) => _WindowPos3sMESA_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void WindowPos3sMESA_Lazy(short x, short y, short z)
            {
                _WindowPos3sMESA_fnptr = (delegate* unmanaged<short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3sMESA");
                _WindowPos3sMESA_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<short*, void> _WindowPos3svMESA_fnptr = &WindowPos3svMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3svMESA(short* v) => _WindowPos3svMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos3svMESA_Lazy(short* v)
            {
                _WindowPos3svMESA_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos3svMESA");
                _WindowPos3svMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<double, double, double, double, void> _WindowPos4dMESA_fnptr = &WindowPos4dMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4dMESA(double x, double y, double z, double w) => _WindowPos4dMESA_fnptr(x, y, z, w);
            [UnmanagedCallersOnly]
            private static void WindowPos4dMESA_Lazy(double x, double y, double z, double w)
            {
                _WindowPos4dMESA_fnptr = (delegate* unmanaged<double, double, double, double, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos4dMESA");
                _WindowPos4dMESA_fnptr(x, y, z, w);
            }
            
            private static delegate* unmanaged<double*, void> _WindowPos4dvMESA_fnptr = &WindowPos4dvMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4dvMESA(double* v) => _WindowPos4dvMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos4dvMESA_Lazy(double* v)
            {
                _WindowPos4dvMESA_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos4dvMESA");
                _WindowPos4dvMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<float, float, float, float, void> _WindowPos4fMESA_fnptr = &WindowPos4fMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4fMESA(float x, float y, float z, float w) => _WindowPos4fMESA_fnptr(x, y, z, w);
            [UnmanagedCallersOnly]
            private static void WindowPos4fMESA_Lazy(float x, float y, float z, float w)
            {
                _WindowPos4fMESA_fnptr = (delegate* unmanaged<float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos4fMESA");
                _WindowPos4fMESA_fnptr(x, y, z, w);
            }
            
            private static delegate* unmanaged<float*, void> _WindowPos4fvMESA_fnptr = &WindowPos4fvMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4fvMESA(float* v) => _WindowPos4fvMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos4fvMESA_Lazy(float* v)
            {
                _WindowPos4fvMESA_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos4fvMESA");
                _WindowPos4fvMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _WindowPos4iMESA_fnptr = &WindowPos4iMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4iMESA(int x, int y, int z, int w) => _WindowPos4iMESA_fnptr(x, y, z, w);
            [UnmanagedCallersOnly]
            private static void WindowPos4iMESA_Lazy(int x, int y, int z, int w)
            {
                _WindowPos4iMESA_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos4iMESA");
                _WindowPos4iMESA_fnptr(x, y, z, w);
            }
            
            private static delegate* unmanaged<int*, void> _WindowPos4ivMESA_fnptr = &WindowPos4ivMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4ivMESA(int* v) => _WindowPos4ivMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos4ivMESA_Lazy(int* v)
            {
                _WindowPos4ivMESA_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos4ivMESA");
                _WindowPos4ivMESA_fnptr(v);
            }
            
            private static delegate* unmanaged<short, short, short, short, void> _WindowPos4sMESA_fnptr = &WindowPos4sMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4sMESA(short x, short y, short z, short w) => _WindowPos4sMESA_fnptr(x, y, z, w);
            [UnmanagedCallersOnly]
            private static void WindowPos4sMESA_Lazy(short x, short y, short z, short w)
            {
                _WindowPos4sMESA_fnptr = (delegate* unmanaged<short, short, short, short, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos4sMESA");
                _WindowPos4sMESA_fnptr(x, y, z, w);
            }
            
            private static delegate* unmanaged<short*, void> _WindowPos4svMESA_fnptr = &WindowPos4svMESA_Lazy;
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4svMESA(short* v) => _WindowPos4svMESA_fnptr(v);
            [UnmanagedCallersOnly]
            private static void WindowPos4svMESA_Lazy(short* v)
            {
                _WindowPos4svMESA_fnptr = (delegate* unmanaged<short*, void>)GLLoader.BindingsContext.GetProcAddress("glWindowPos4svMESA");
                _WindowPos4svMESA_fnptr(v);
            }
            
        }
        public static unsafe partial class NVX
        {
            private static delegate* unmanaged<uint, void> _BeginConditionalRenderNVX_fnptr = &BeginConditionalRenderNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_conditional_render]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginConditionalRenderNVX(uint id) => _BeginConditionalRenderNVX_fnptr(id);
            [UnmanagedCallersOnly]
            private static void BeginConditionalRenderNVX_Lazy(uint id)
            {
                _BeginConditionalRenderNVX_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glBeginConditionalRenderNVX");
                _BeginConditionalRenderNVX_fnptr(id);
            }
            
            private static delegate* unmanaged<void> _EndConditionalRenderNVX_fnptr = &EndConditionalRenderNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_conditional_render]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndConditionalRenderNVX() => _EndConditionalRenderNVX_fnptr();
            [UnmanagedCallersOnly]
            private static void EndConditionalRenderNVX_Lazy()
            {
                _EndConditionalRenderNVX_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glEndConditionalRenderNVX");
                _EndConditionalRenderNVX_fnptr();
            }
            
            private static delegate* unmanaged<All, BufferHandle, IntPtr, nint, void*, void> _LGPUNamedBufferSubDataNVX_fnptr = &LGPUNamedBufferSubDataNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LGPUNamedBufferSubDataNVX(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, void* data) => _LGPUNamedBufferSubDataNVX_fnptr(gpuMask, buffer, offset, size, data);
            [UnmanagedCallersOnly]
            private static void LGPUNamedBufferSubDataNVX_Lazy(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, void* data)
            {
                _LGPUNamedBufferSubDataNVX_fnptr = (delegate* unmanaged<All, BufferHandle, IntPtr, nint, void*, void>)GLLoader.BindingsContext.GetProcAddress("glLGPUNamedBufferSubDataNVX");
                _LGPUNamedBufferSubDataNVX_fnptr(gpuMask, buffer, offset, size, data);
            }
            
            private static delegate* unmanaged<uint, All, uint, All, int, int, int, int, uint, All, int, int, int, int, int, int, int, void> _LGPUCopyImageSubDataNVX_fnptr = &LGPUCopyImageSubDataNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LGPUCopyImageSubDataNVX(uint sourceGpu, All destinationGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => _LGPUCopyImageSubDataNVX_fnptr(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            [UnmanagedCallersOnly]
            private static void LGPUCopyImageSubDataNVX_Lazy(uint sourceGpu, All destinationGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)
            {
                _LGPUCopyImageSubDataNVX_fnptr = (delegate* unmanaged<uint, All, uint, All, int, int, int, int, uint, All, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glLGPUCopyImageSubDataNVX");
                _LGPUCopyImageSubDataNVX_fnptr(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            }
            
            private static delegate* unmanaged<void> _LGPUInterlockNVX_fnptr = &LGPUInterlockNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LGPUInterlockNVX() => _LGPUInterlockNVX_fnptr();
            [UnmanagedCallersOnly]
            private static void LGPUInterlockNVX_Lazy()
            {
                _LGPUInterlockNVX_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glLGPUInterlockNVX");
                _LGPUInterlockNVX_fnptr();
            }
            
            private static delegate* unmanaged<All, void> _UploadGpuMaskNVX_fnptr = &UploadGpuMaskNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UploadGpuMaskNVX(All mask) => _UploadGpuMaskNVX_fnptr(mask);
            [UnmanagedCallersOnly]
            private static void UploadGpuMaskNVX_Lazy(All mask)
            {
                _UploadGpuMaskNVX_fnptr = (delegate* unmanaged<All, void>)GLLoader.BindingsContext.GetProcAddress("glUploadGpuMaskNVX");
                _UploadGpuMaskNVX_fnptr(mask);
            }
            
            private static delegate* unmanaged<uint, uint, int, float*, void> _MulticastViewportArrayvNVX_fnptr = &MulticastViewportArrayvNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastViewportArrayvNVX(uint gpu, uint first, int count, float* v) => _MulticastViewportArrayvNVX_fnptr(gpu, first, count, v);
            [UnmanagedCallersOnly]
            private static void MulticastViewportArrayvNVX_Lazy(uint gpu, uint first, int count, float* v)
            {
                _MulticastViewportArrayvNVX_fnptr = (delegate* unmanaged<uint, uint, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastViewportArrayvNVX");
                _MulticastViewportArrayvNVX_fnptr(gpu, first, count, v);
            }
            
            private static delegate* unmanaged<uint, uint, float, float, void> _MulticastViewportPositionWScaleNVX_fnptr = &MulticastViewportPositionWScaleNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastViewportPositionWScaleNVX(uint gpu, uint index, float xcoeff, float ycoeff) => _MulticastViewportPositionWScaleNVX_fnptr(gpu, index, xcoeff, ycoeff);
            [UnmanagedCallersOnly]
            private static void MulticastViewportPositionWScaleNVX_Lazy(uint gpu, uint index, float xcoeff, float ycoeff)
            {
                _MulticastViewportPositionWScaleNVX_fnptr = (delegate* unmanaged<uint, uint, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastViewportPositionWScaleNVX");
                _MulticastViewportPositionWScaleNVX_fnptr(gpu, index, xcoeff, ycoeff);
            }
            
            private static delegate* unmanaged<uint, uint, int, int*, void> _MulticastScissorArrayvNVX_fnptr = &MulticastScissorArrayvNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastScissorArrayvNVX(uint gpu, uint first, int count, int* v) => _MulticastScissorArrayvNVX_fnptr(gpu, first, count, v);
            [UnmanagedCallersOnly]
            private static void MulticastScissorArrayvNVX_Lazy(uint gpu, uint first, int count, int* v)
            {
                _MulticastScissorArrayvNVX_fnptr = (delegate* unmanaged<uint, uint, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMulticastScissorArrayvNVX");
                _MulticastScissorArrayvNVX_fnptr(gpu, first, count, v);
            }
            
            private static delegate* unmanaged<int, uint*, ulong*, uint, All, BufferHandle, BufferHandle, IntPtr, IntPtr, nint, int, uint*, ulong*, uint> _AsyncCopyBufferSubDataNVX_fnptr = &AsyncCopyBufferSubDataNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, All writeGpuMask, BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => _AsyncCopyBufferSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            [UnmanagedCallersOnly]
            private static uint AsyncCopyBufferSubDataNVX_Lazy(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, All writeGpuMask, BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
            {
                _AsyncCopyBufferSubDataNVX_fnptr = (delegate* unmanaged<int, uint*, ulong*, uint, All, BufferHandle, BufferHandle, IntPtr, IntPtr, nint, int, uint*, ulong*, uint>)GLLoader.BindingsContext.GetProcAddress("glAsyncCopyBufferSubDataNVX");
                return _AsyncCopyBufferSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            }
            
            private static delegate* unmanaged<int, uint*, ulong*, uint, All, uint, All, int, int, int, int, uint, All, int, int, int, int, int, int, int, int, uint*, ulong*, uint> _AsyncCopyImageSubDataNVX_fnptr = &AsyncCopyImageSubDataNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, All dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => _AsyncCopyImageSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            [UnmanagedCallersOnly]
            private static uint AsyncCopyImageSubDataNVX_Lazy(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, All dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
            {
                _AsyncCopyImageSubDataNVX_fnptr = (delegate* unmanaged<int, uint*, ulong*, uint, All, uint, All, int, int, int, int, uint, All, int, int, int, int, int, int, int, int, uint*, ulong*, uint>)GLLoader.BindingsContext.GetProcAddress("glAsyncCopyImageSubDataNVX");
                return _AsyncCopyImageSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            }
            
            private static delegate* unmanaged<uint> _CreateProgressFenceNVX_fnptr = &CreateProgressFenceNVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint CreateProgressFenceNVX() => _CreateProgressFenceNVX_fnptr();
            [UnmanagedCallersOnly]
            private static uint CreateProgressFenceNVX_Lazy()
            {
                _CreateProgressFenceNVX_fnptr = (delegate* unmanaged<uint>)GLLoader.BindingsContext.GetProcAddress("glCreateProgressFenceNVX");
                return _CreateProgressFenceNVX_fnptr();
            }
            
            private static delegate* unmanaged<uint, int, uint*, ulong*, void> _SignalSemaphoreui64NVX_fnptr = &SignalSemaphoreui64NVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => _SignalSemaphoreui64NVX_fnptr(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            [UnmanagedCallersOnly]
            private static void SignalSemaphoreui64NVX_Lazy(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray)
            {
                _SignalSemaphoreui64NVX_fnptr = (delegate* unmanaged<uint, int, uint*, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glSignalSemaphoreui64NVX");
                _SignalSemaphoreui64NVX_fnptr(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            }
            
            private static delegate* unmanaged<uint, int, uint*, ulong*, void> _WaitSemaphoreui64NVX_fnptr = &WaitSemaphoreui64NVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => _WaitSemaphoreui64NVX_fnptr(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            [UnmanagedCallersOnly]
            private static void WaitSemaphoreui64NVX_Lazy(uint waitGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray)
            {
                _WaitSemaphoreui64NVX_fnptr = (delegate* unmanaged<uint, int, uint*, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glWaitSemaphoreui64NVX");
                _WaitSemaphoreui64NVX_fnptr(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            }
            
            private static delegate* unmanaged<int, uint*, ulong*, void> _ClientWaitSemaphoreui64NVX_fnptr = &ClientWaitSemaphoreui64NVX_Lazy;
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClientWaitSemaphoreui64NVX(int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => _ClientWaitSemaphoreui64NVX_fnptr(fenceObjectCount, semaphoreArray, fenceValueArray);
            [UnmanagedCallersOnly]
            private static void ClientWaitSemaphoreui64NVX_Lazy(int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray)
            {
                _ClientWaitSemaphoreui64NVX_fnptr = (delegate* unmanaged<int, uint*, ulong*, void>)GLLoader.BindingsContext.GetProcAddress("glClientWaitSemaphoreui64NVX");
                _ClientWaitSemaphoreui64NVX_fnptr(fenceObjectCount, semaphoreArray, fenceValueArray);
            }
            
        }
        public static unsafe partial class OES
        {
            private static delegate* unmanaged<TextureUnit, sbyte, void> _MultiTexCoord1bOES_fnptr = &MultiTexCoord1bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1bOES(TextureUnit texture, sbyte s) => _MultiTexCoord1bOES_fnptr(texture, s);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1bOES_Lazy(TextureUnit texture, sbyte s)
            {
                _MultiTexCoord1bOES_fnptr = (delegate* unmanaged<TextureUnit, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1bOES");
                _MultiTexCoord1bOES_fnptr(texture, s);
            }
            
            private static delegate* unmanaged<TextureUnit, sbyte*, void> _MultiTexCoord1bvOES_fnptr = &MultiTexCoord1bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1bvOES(TextureUnit texture, sbyte* coords) => _MultiTexCoord1bvOES_fnptr(texture, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1bvOES_Lazy(TextureUnit texture, sbyte* coords)
            {
                _MultiTexCoord1bvOES_fnptr = (delegate* unmanaged<TextureUnit, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1bvOES");
                _MultiTexCoord1bvOES_fnptr(texture, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, sbyte, sbyte, void> _MultiTexCoord2bOES_fnptr = &MultiTexCoord2bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2bOES(TextureUnit texture, sbyte s, sbyte t) => _MultiTexCoord2bOES_fnptr(texture, s, t);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2bOES_Lazy(TextureUnit texture, sbyte s, sbyte t)
            {
                _MultiTexCoord2bOES_fnptr = (delegate* unmanaged<TextureUnit, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2bOES");
                _MultiTexCoord2bOES_fnptr(texture, s, t);
            }
            
            private static delegate* unmanaged<TextureUnit, sbyte*, void> _MultiTexCoord2bvOES_fnptr = &MultiTexCoord2bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2bvOES(TextureUnit texture, sbyte* coords) => _MultiTexCoord2bvOES_fnptr(texture, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2bvOES_Lazy(TextureUnit texture, sbyte* coords)
            {
                _MultiTexCoord2bvOES_fnptr = (delegate* unmanaged<TextureUnit, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2bvOES");
                _MultiTexCoord2bvOES_fnptr(texture, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, sbyte, sbyte, sbyte, void> _MultiTexCoord3bOES_fnptr = &MultiTexCoord3bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r) => _MultiTexCoord3bOES_fnptr(texture, s, t, r);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3bOES_Lazy(TextureUnit texture, sbyte s, sbyte t, sbyte r)
            {
                _MultiTexCoord3bOES_fnptr = (delegate* unmanaged<TextureUnit, sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3bOES");
                _MultiTexCoord3bOES_fnptr(texture, s, t, r);
            }
            
            private static delegate* unmanaged<TextureUnit, sbyte*, void> _MultiTexCoord3bvOES_fnptr = &MultiTexCoord3bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3bvOES(TextureUnit texture, sbyte* coords) => _MultiTexCoord3bvOES_fnptr(texture, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3bvOES_Lazy(TextureUnit texture, sbyte* coords)
            {
                _MultiTexCoord3bvOES_fnptr = (delegate* unmanaged<TextureUnit, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3bvOES");
                _MultiTexCoord3bvOES_fnptr(texture, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, sbyte, sbyte, sbyte, sbyte, void> _MultiTexCoord4bOES_fnptr = &MultiTexCoord4bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r, sbyte q) => _MultiTexCoord4bOES_fnptr(texture, s, t, r, q);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4bOES_Lazy(TextureUnit texture, sbyte s, sbyte t, sbyte r, sbyte q)
            {
                _MultiTexCoord4bOES_fnptr = (delegate* unmanaged<TextureUnit, sbyte, sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4bOES");
                _MultiTexCoord4bOES_fnptr(texture, s, t, r, q);
            }
            
            private static delegate* unmanaged<TextureUnit, sbyte*, void> _MultiTexCoord4bvOES_fnptr = &MultiTexCoord4bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4bvOES(TextureUnit texture, sbyte* coords) => _MultiTexCoord4bvOES_fnptr(texture, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4bvOES_Lazy(TextureUnit texture, sbyte* coords)
            {
                _MultiTexCoord4bvOES_fnptr = (delegate* unmanaged<TextureUnit, sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4bvOES");
                _MultiTexCoord4bvOES_fnptr(texture, coords);
            }
            
            private static delegate* unmanaged<sbyte, void> _TexCoord1bOES_fnptr = &TexCoord1bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1bOES(sbyte s) => _TexCoord1bOES_fnptr(s);
            [UnmanagedCallersOnly]
            private static void TexCoord1bOES_Lazy(sbyte s)
            {
                _TexCoord1bOES_fnptr = (delegate* unmanaged<sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1bOES");
                _TexCoord1bOES_fnptr(s);
            }
            
            private static delegate* unmanaged<sbyte*, void> _TexCoord1bvOES_fnptr = &TexCoord1bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1bvOES(sbyte* coords) => _TexCoord1bvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void TexCoord1bvOES_Lazy(sbyte* coords)
            {
                _TexCoord1bvOES_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1bvOES");
                _TexCoord1bvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<sbyte, sbyte, void> _TexCoord2bOES_fnptr = &TexCoord2bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2bOES(sbyte s, sbyte t) => _TexCoord2bOES_fnptr(s, t);
            [UnmanagedCallersOnly]
            private static void TexCoord2bOES_Lazy(sbyte s, sbyte t)
            {
                _TexCoord2bOES_fnptr = (delegate* unmanaged<sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2bOES");
                _TexCoord2bOES_fnptr(s, t);
            }
            
            private static delegate* unmanaged<sbyte*, void> _TexCoord2bvOES_fnptr = &TexCoord2bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2bvOES(sbyte* coords) => _TexCoord2bvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void TexCoord2bvOES_Lazy(sbyte* coords)
            {
                _TexCoord2bvOES_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2bvOES");
                _TexCoord2bvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<sbyte, sbyte, sbyte, void> _TexCoord3bOES_fnptr = &TexCoord3bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3bOES(sbyte s, sbyte t, sbyte r) => _TexCoord3bOES_fnptr(s, t, r);
            [UnmanagedCallersOnly]
            private static void TexCoord3bOES_Lazy(sbyte s, sbyte t, sbyte r)
            {
                _TexCoord3bOES_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3bOES");
                _TexCoord3bOES_fnptr(s, t, r);
            }
            
            private static delegate* unmanaged<sbyte*, void> _TexCoord3bvOES_fnptr = &TexCoord3bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3bvOES(sbyte* coords) => _TexCoord3bvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void TexCoord3bvOES_Lazy(sbyte* coords)
            {
                _TexCoord3bvOES_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3bvOES");
                _TexCoord3bvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<sbyte, sbyte, sbyte, sbyte, void> _TexCoord4bOES_fnptr = &TexCoord4bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4bOES(sbyte s, sbyte t, sbyte r, sbyte q) => _TexCoord4bOES_fnptr(s, t, r, q);
            [UnmanagedCallersOnly]
            private static void TexCoord4bOES_Lazy(sbyte s, sbyte t, sbyte r, sbyte q)
            {
                _TexCoord4bOES_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4bOES");
                _TexCoord4bOES_fnptr(s, t, r, q);
            }
            
            private static delegate* unmanaged<sbyte*, void> _TexCoord4bvOES_fnptr = &TexCoord4bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4bvOES(sbyte* coords) => _TexCoord4bvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void TexCoord4bvOES_Lazy(sbyte* coords)
            {
                _TexCoord4bvOES_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4bvOES");
                _TexCoord4bvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<sbyte, sbyte, void> _Vertex2bOES_fnptr = &Vertex2bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2bOES(sbyte x, sbyte y) => _Vertex2bOES_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void Vertex2bOES_Lazy(sbyte x, sbyte y)
            {
                _Vertex2bOES_fnptr = (delegate* unmanaged<sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2bOES");
                _Vertex2bOES_fnptr(x, y);
            }
            
            private static delegate* unmanaged<sbyte*, void> _Vertex2bvOES_fnptr = &Vertex2bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2bvOES(sbyte* coords) => _Vertex2bvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void Vertex2bvOES_Lazy(sbyte* coords)
            {
                _Vertex2bvOES_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2bvOES");
                _Vertex2bvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<sbyte, sbyte, sbyte, void> _Vertex3bOES_fnptr = &Vertex3bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3bOES(sbyte x, sbyte y, sbyte z) => _Vertex3bOES_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void Vertex3bOES_Lazy(sbyte x, sbyte y, sbyte z)
            {
                _Vertex3bOES_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3bOES");
                _Vertex3bOES_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<sbyte*, void> _Vertex3bvOES_fnptr = &Vertex3bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3bvOES(sbyte* coords) => _Vertex3bvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void Vertex3bvOES_Lazy(sbyte* coords)
            {
                _Vertex3bvOES_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3bvOES");
                _Vertex3bvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<sbyte, sbyte, sbyte, sbyte, void> _Vertex4bOES_fnptr = &Vertex4bOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4bOES(sbyte x, sbyte y, sbyte z, sbyte w) => _Vertex4bOES_fnptr(x, y, z, w);
            [UnmanagedCallersOnly]
            private static void Vertex4bOES_Lazy(sbyte x, sbyte y, sbyte z, sbyte w)
            {
                _Vertex4bOES_fnptr = (delegate* unmanaged<sbyte, sbyte, sbyte, sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4bOES");
                _Vertex4bOES_fnptr(x, y, z, w);
            }
            
            private static delegate* unmanaged<sbyte*, void> _Vertex4bvOES_fnptr = &Vertex4bvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4bvOES(sbyte* coords) => _Vertex4bvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void Vertex4bvOES_Lazy(sbyte* coords)
            {
                _Vertex4bvOES_fnptr = (delegate* unmanaged<sbyte*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4bvOES");
                _Vertex4bvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<AlphaFunction, int, void> _AlphaFuncxOES_fnptr = &AlphaFuncxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaFuncxOES(AlphaFunction func, int reference) => _AlphaFuncxOES_fnptr(func, reference);
            [UnmanagedCallersOnly]
            private static void AlphaFuncxOES_Lazy(AlphaFunction func, int reference)
            {
                _AlphaFuncxOES_fnptr = (delegate* unmanaged<AlphaFunction, int, void>)GLLoader.BindingsContext.GetProcAddress("glAlphaFuncxOES");
                _AlphaFuncxOES_fnptr(func, reference);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _ClearColorxOES_fnptr = &ClearColorxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearColorxOES(int red, int green, int blue, int alpha) => _ClearColorxOES_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void ClearColorxOES_Lazy(int red, int green, int blue, int alpha)
            {
                _ClearColorxOES_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glClearColorxOES");
                _ClearColorxOES_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<int, void> _ClearDepthxOES_fnptr = &ClearDepthxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearDepthxOES(int depth) => _ClearDepthxOES_fnptr(depth);
            [UnmanagedCallersOnly]
            private static void ClearDepthxOES_Lazy(int depth)
            {
                _ClearDepthxOES_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glClearDepthxOES");
                _ClearDepthxOES_fnptr(depth);
            }
            
            private static delegate* unmanaged<ClipPlaneName, int*, void> _ClipPlanexOES_fnptr = &ClipPlanexOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClipPlanexOES(ClipPlaneName plane, int* equation) => _ClipPlanexOES_fnptr(plane, equation);
            [UnmanagedCallersOnly]
            private static void ClipPlanexOES_Lazy(ClipPlaneName plane, int* equation)
            {
                _ClipPlanexOES_fnptr = (delegate* unmanaged<ClipPlaneName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glClipPlanexOES");
                _ClipPlanexOES_fnptr(plane, equation);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _Color4xOES_fnptr = &Color4xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4xOES(int red, int green, int blue, int alpha) => _Color4xOES_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void Color4xOES_Lazy(int red, int green, int blue, int alpha)
            {
                _Color4xOES_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glColor4xOES");
                _Color4xOES_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<int, int, void> _DepthRangexOES_fnptr = &DepthRangexOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangexOES(int n, int f) => _DepthRangexOES_fnptr(n, f);
            [UnmanagedCallersOnly]
            private static void DepthRangexOES_Lazy(int n, int f)
            {
                _DepthRangexOES_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangexOES");
                _DepthRangexOES_fnptr(n, f);
            }
            
            private static delegate* unmanaged<FogPName, int, void> _FogxOES_fnptr = &FogxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogxOES(FogPName pname, int param) => _FogxOES_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void FogxOES_Lazy(FogPName pname, int param)
            {
                _FogxOES_fnptr = (delegate* unmanaged<FogPName, int, void>)GLLoader.BindingsContext.GetProcAddress("glFogxOES");
                _FogxOES_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<FogPName, int*, void> _FogxvOES_fnptr = &FogxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogxvOES(FogPName pname, int* param) => _FogxvOES_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void FogxvOES_Lazy(FogPName pname, int* param)
            {
                _FogxvOES_fnptr = (delegate* unmanaged<FogPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glFogxvOES");
                _FogxvOES_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<int, int, int, int, int, int, void> _FrustumxOES_fnptr = &FrustumxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FrustumxOES(int l, int r, int b, int t, int n, int f) => _FrustumxOES_fnptr(l, r, b, t, n, f);
            [UnmanagedCallersOnly]
            private static void FrustumxOES_Lazy(int l, int r, int b, int t, int n, int f)
            {
                _FrustumxOES_fnptr = (delegate* unmanaged<int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFrustumxOES");
                _FrustumxOES_fnptr(l, r, b, t, n, f);
            }
            
            private static delegate* unmanaged<ClipPlaneName, int*, void> _GetClipPlanexOES_fnptr = &GetClipPlanexOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetClipPlanexOES(ClipPlaneName plane, int* equation) => _GetClipPlanexOES_fnptr(plane, equation);
            [UnmanagedCallersOnly]
            private static void GetClipPlanexOES_Lazy(ClipPlaneName plane, int* equation)
            {
                _GetClipPlanexOES_fnptr = (delegate* unmanaged<ClipPlaneName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetClipPlanexOES");
                _GetClipPlanexOES_fnptr(plane, equation);
            }
            
            private static delegate* unmanaged<GetPName, int*, void> _GetFixedvOES_fnptr = &GetFixedvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFixedvOES(GetPName pname, int* parameters) => _GetFixedvOES_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFixedvOES_Lazy(GetPName pname, int* parameters)
            {
                _GetFixedvOES_fnptr = (delegate* unmanaged<GetPName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFixedvOES");
                _GetFixedvOES_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int*, void> _GetTexEnvxvOES_fnptr = &GetTexEnvxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => _GetTexEnvxvOES_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTexEnvxvOES_Lazy(TextureEnvTarget target, TextureEnvParameter pname, int* parameters)
            {
                _GetTexEnvxvOES_fnptr = (delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexEnvxvOES");
                _GetTexEnvxvOES_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void> _GetTexParameterxvOES_fnptr = &GetTexParameterxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, int* parameters) => _GetTexParameterxvOES_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTexParameterxvOES_Lazy(TextureTarget target, GetTextureParameter pname, int* parameters)
            {
                _GetTexParameterxvOES_fnptr = (delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexParameterxvOES");
                _GetTexParameterxvOES_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<LightModelParameter, int, void> _LightModelxOES_fnptr = &LightModelxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightModelxOES(LightModelParameter pname, int param) => _LightModelxOES_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void LightModelxOES_Lazy(LightModelParameter pname, int param)
            {
                _LightModelxOES_fnptr = (delegate* unmanaged<LightModelParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glLightModelxOES");
                _LightModelxOES_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<LightModelParameter, int*, void> _LightModelxvOES_fnptr = &LightModelxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightModelxvOES(LightModelParameter pname, int* param) => _LightModelxvOES_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void LightModelxvOES_Lazy(LightModelParameter pname, int* param)
            {
                _LightModelxvOES_fnptr = (delegate* unmanaged<LightModelParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glLightModelxvOES");
                _LightModelxvOES_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<LightName, LightParameter, int, void> _LightxOES_fnptr = &LightxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightxOES(LightName light, LightParameter pname, int param) => _LightxOES_fnptr(light, pname, param);
            [UnmanagedCallersOnly]
            private static void LightxOES_Lazy(LightName light, LightParameter pname, int param)
            {
                _LightxOES_fnptr = (delegate* unmanaged<LightName, LightParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glLightxOES");
                _LightxOES_fnptr(light, pname, param);
            }
            
            private static delegate* unmanaged<LightName, LightParameter, int*, void> _LightxvOES_fnptr = &LightxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightxvOES(LightName light, LightParameter pname, int* parameters) => _LightxvOES_fnptr(light, pname, parameters);
            [UnmanagedCallersOnly]
            private static void LightxvOES_Lazy(LightName light, LightParameter pname, int* parameters)
            {
                _LightxvOES_fnptr = (delegate* unmanaged<LightName, LightParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glLightxvOES");
                _LightxvOES_fnptr(light, pname, parameters);
            }
            
            private static delegate* unmanaged<int, void> _LineWidthxOES_fnptr = &LineWidthxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LineWidthxOES(int width) => _LineWidthxOES_fnptr(width);
            [UnmanagedCallersOnly]
            private static void LineWidthxOES_Lazy(int width)
            {
                _LineWidthxOES_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glLineWidthxOES");
                _LineWidthxOES_fnptr(width);
            }
            
            private static delegate* unmanaged<int*, void> _LoadMatrixxOES_fnptr = &LoadMatrixxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadMatrixxOES(int* m) => _LoadMatrixxOES_fnptr(m);
            [UnmanagedCallersOnly]
            private static void LoadMatrixxOES_Lazy(int* m)
            {
                _LoadMatrixxOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glLoadMatrixxOES");
                _LoadMatrixxOES_fnptr(m);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, int, void> _MaterialxOES_fnptr = &MaterialxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MaterialxOES(MaterialFace face, MaterialParameter pname, int param) => _MaterialxOES_fnptr(face, pname, param);
            [UnmanagedCallersOnly]
            private static void MaterialxOES_Lazy(MaterialFace face, MaterialParameter pname, int param)
            {
                _MaterialxOES_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glMaterialxOES");
                _MaterialxOES_fnptr(face, pname, param);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, int*, void> _MaterialxvOES_fnptr = &MaterialxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MaterialxvOES(MaterialFace face, MaterialParameter pname, int* param) => _MaterialxvOES_fnptr(face, pname, param);
            [UnmanagedCallersOnly]
            private static void MaterialxvOES_Lazy(MaterialFace face, MaterialParameter pname, int* param)
            {
                _MaterialxvOES_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMaterialxvOES");
                _MaterialxvOES_fnptr(face, pname, param);
            }
            
            private static delegate* unmanaged<int*, void> _MultMatrixxOES_fnptr = &MultMatrixxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultMatrixxOES(int* m) => _MultMatrixxOES_fnptr(m);
            [UnmanagedCallersOnly]
            private static void MultMatrixxOES_Lazy(int* m)
            {
                _MultMatrixxOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultMatrixxOES");
                _MultMatrixxOES_fnptr(m);
            }
            
            private static delegate* unmanaged<TextureUnit, int, int, int, int, void> _MultiTexCoord4xOES_fnptr = &MultiTexCoord4xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4xOES(TextureUnit texture, int s, int t, int r, int q) => _MultiTexCoord4xOES_fnptr(texture, s, t, r, q);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4xOES_Lazy(TextureUnit texture, int s, int t, int r, int q)
            {
                _MultiTexCoord4xOES_fnptr = (delegate* unmanaged<TextureUnit, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4xOES");
                _MultiTexCoord4xOES_fnptr(texture, s, t, r, q);
            }
            
            private static delegate* unmanaged<int, int, int, void> _Normal3xOES_fnptr = &Normal3xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3xOES(int nx, int ny, int nz) => _Normal3xOES_fnptr(nx, ny, nz);
            [UnmanagedCallersOnly]
            private static void Normal3xOES_Lazy(int nx, int ny, int nz)
            {
                _Normal3xOES_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3xOES");
                _Normal3xOES_fnptr(nx, ny, nz);
            }
            
            private static delegate* unmanaged<int, int, int, int, int, int, void> _OrthoxOES_fnptr = &OrthoxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void OrthoxOES(int l, int r, int b, int t, int n, int f) => _OrthoxOES_fnptr(l, r, b, t, n, f);
            [UnmanagedCallersOnly]
            private static void OrthoxOES_Lazy(int l, int r, int b, int t, int n, int f)
            {
                _OrthoxOES_fnptr = (delegate* unmanaged<int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glOrthoxOES");
                _OrthoxOES_fnptr(l, r, b, t, n, f);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, int*, void> _PointParameterxvOES_fnptr = &PointParameterxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterxvOES(PointParameterNameARB pname, int* parameters) => _PointParameterxvOES_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void PointParameterxvOES_Lazy(PointParameterNameARB pname, int* parameters)
            {
                _PointParameterxvOES_fnptr = (delegate* unmanaged<PointParameterNameARB, int*, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterxvOES");
                _PointParameterxvOES_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<int, void> _PointSizexOES_fnptr = &PointSizexOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointSizexOES(int size) => _PointSizexOES_fnptr(size);
            [UnmanagedCallersOnly]
            private static void PointSizexOES_Lazy(int size)
            {
                _PointSizexOES_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glPointSizexOES");
                _PointSizexOES_fnptr(size);
            }
            
            private static delegate* unmanaged<int, int, void> _PolygonOffsetxOES_fnptr = &PolygonOffsetxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PolygonOffsetxOES(int factor, int units) => _PolygonOffsetxOES_fnptr(factor, units);
            [UnmanagedCallersOnly]
            private static void PolygonOffsetxOES_Lazy(int factor, int units)
            {
                _PolygonOffsetxOES_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glPolygonOffsetxOES");
                _PolygonOffsetxOES_fnptr(factor, units);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _RotatexOES_fnptr = &RotatexOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RotatexOES(int angle, int x, int y, int z) => _RotatexOES_fnptr(angle, x, y, z);
            [UnmanagedCallersOnly]
            private static void RotatexOES_Lazy(int angle, int x, int y, int z)
            {
                _RotatexOES_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRotatexOES");
                _RotatexOES_fnptr(angle, x, y, z);
            }
            
            private static delegate* unmanaged<int, int, int, void> _ScalexOES_fnptr = &ScalexOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ScalexOES(int x, int y, int z) => _ScalexOES_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void ScalexOES_Lazy(int x, int y, int z)
            {
                _ScalexOES_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glScalexOES");
                _ScalexOES_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int, void> _TexEnvxOES_fnptr = &TexEnvxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexEnvxOES(TextureEnvTarget target, TextureEnvParameter pname, int param) => _TexEnvxOES_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void TexEnvxOES_Lazy(TextureEnvTarget target, TextureEnvParameter pname, int param)
            {
                _TexEnvxOES_fnptr = (delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexEnvxOES");
                _TexEnvxOES_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int*, void> _TexEnvxvOES_fnptr = &TexEnvxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => _TexEnvxvOES_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TexEnvxvOES_Lazy(TextureEnvTarget target, TextureEnvParameter pname, int* parameters)
            {
                _TexEnvxvOES_fnptr = (delegate* unmanaged<TextureEnvTarget, TextureEnvParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexEnvxvOES");
                _TexEnvxvOES_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, GetTextureParameter, int, void> _TexParameterxOES_fnptr = &TexParameterxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexParameterxOES(TextureTarget target, GetTextureParameter pname, int param) => _TexParameterxOES_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void TexParameterxOES_Lazy(TextureTarget target, GetTextureParameter pname, int param)
            {
                _TexParameterxOES_fnptr = (delegate* unmanaged<TextureTarget, GetTextureParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameterxOES");
                _TexParameterxOES_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void> _TexParameterxvOES_fnptr = &TexParameterxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, int* parameters) => _TexParameterxvOES_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TexParameterxvOES_Lazy(TextureTarget target, GetTextureParameter pname, int* parameters)
            {
                _TexParameterxvOES_fnptr = (delegate* unmanaged<TextureTarget, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexParameterxvOES");
                _TexParameterxvOES_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<int, int, int, void> _TranslatexOES_fnptr = &TranslatexOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TranslatexOES(int x, int y, int z) => _TranslatexOES_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void TranslatexOES_Lazy(int x, int y, int z)
            {
                _TranslatexOES_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTranslatexOES");
                _TranslatexOES_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<LightName, LightParameter, int*, void> _GetLightxvOES_fnptr = &GetLightxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLightxvOES(LightName light, LightParameter pname, int* parameters) => _GetLightxvOES_fnptr(light, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetLightxvOES_Lazy(LightName light, LightParameter pname, int* parameters)
            {
                _GetLightxvOES_fnptr = (delegate* unmanaged<LightName, LightParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetLightxvOES");
                _GetLightxvOES_fnptr(light, pname, parameters);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, int*, void> _GetMaterialxvOES_fnptr = &GetMaterialxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMaterialxvOES(MaterialFace face, MaterialParameter pname, int* parameters) => _GetMaterialxvOES_fnptr(face, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetMaterialxvOES_Lazy(MaterialFace face, MaterialParameter pname, int* parameters)
            {
                _GetMaterialxvOES_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMaterialxvOES");
                _GetMaterialxvOES_fnptr(face, pname, parameters);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, int, void> _PointParameterxOES_fnptr = &PointParameterxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterxOES(PointParameterNameARB pname, int param) => _PointParameterxOES_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PointParameterxOES_Lazy(PointParameterNameARB pname, int param)
            {
                _PointParameterxOES_fnptr = (delegate* unmanaged<PointParameterNameARB, int, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterxOES");
                _PointParameterxOES_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<int, byte, void> _SampleCoveragexOES_fnptr = &SampleCoveragexOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleCoveragexOES(int value, byte invert) => _SampleCoveragexOES_fnptr(value, invert);
            [UnmanagedCallersOnly]
            private static void SampleCoveragexOES_Lazy(int value, byte invert)
            {
                _SampleCoveragexOES_fnptr = (delegate* unmanaged<int, byte, void>)GLLoader.BindingsContext.GetProcAddress("glSampleCoveragexOES");
                _SampleCoveragexOES_fnptr(value, invert);
            }
            
            private static delegate* unmanaged<All, int, void> _AccumxOES_fnptr = &AccumxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AccumxOES(All op, int value) => _AccumxOES_fnptr(op, value);
            [UnmanagedCallersOnly]
            private static void AccumxOES_Lazy(All op, int value)
            {
                _AccumxOES_fnptr = (delegate* unmanaged<All, int, void>)GLLoader.BindingsContext.GetProcAddress("glAccumxOES");
                _AccumxOES_fnptr(op, value);
            }
            
            private static delegate* unmanaged<int, int, int, int, int, int, byte*, void> _BitmapxOES_fnptr = &BitmapxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, byte* bitmap) => _BitmapxOES_fnptr(width, height, xorig, yorig, xmove, ymove, bitmap);
            [UnmanagedCallersOnly]
            private static void BitmapxOES_Lazy(int width, int height, int xorig, int yorig, int xmove, int ymove, byte* bitmap)
            {
                _BitmapxOES_fnptr = (delegate* unmanaged<int, int, int, int, int, int, byte*, void>)GLLoader.BindingsContext.GetProcAddress("glBitmapxOES");
                _BitmapxOES_fnptr(width, height, xorig, yorig, xmove, ymove, bitmap);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _BlendColorxOES_fnptr = &BlendColorxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendColorxOES(int red, int green, int blue, int alpha) => _BlendColorxOES_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void BlendColorxOES_Lazy(int red, int green, int blue, int alpha)
            {
                _BlendColorxOES_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glBlendColorxOES");
                _BlendColorxOES_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _ClearAccumxOES_fnptr = &ClearAccumxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearAccumxOES(int red, int green, int blue, int alpha) => _ClearAccumxOES_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void ClearAccumxOES_Lazy(int red, int green, int blue, int alpha)
            {
                _ClearAccumxOES_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glClearAccumxOES");
                _ClearAccumxOES_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<int, int, int, void> _Color3xOES_fnptr = &Color3xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3xOES(int red, int green, int blue) => _Color3xOES_fnptr(red, green, blue);
            [UnmanagedCallersOnly]
            private static void Color3xOES_Lazy(int red, int green, int blue)
            {
                _Color3xOES_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glColor3xOES");
                _Color3xOES_fnptr(red, green, blue);
            }
            
            private static delegate* unmanaged<int*, void> _Color3xvOES_fnptr = &Color3xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3xvOES(int* components) => _Color3xvOES_fnptr(components);
            [UnmanagedCallersOnly]
            private static void Color3xvOES_Lazy(int* components)
            {
                _Color3xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3xvOES");
                _Color3xvOES_fnptr(components);
            }
            
            private static delegate* unmanaged<int*, void> _Color4xvOES_fnptr = &Color4xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4xvOES(int* components) => _Color4xvOES_fnptr(components);
            [UnmanagedCallersOnly]
            private static void Color4xvOES_Lazy(int* components)
            {
                _Color4xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4xvOES");
                _Color4xvOES_fnptr(components);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int, void> _ConvolutionParameterxOES_fnptr = &ConvolutionParameterxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterxOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int param) => _ConvolutionParameterxOES_fnptr(target, pname, param);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameterxOES_Lazy(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int param)
            {
                _ConvolutionParameterxOES_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameterxOES");
                _ConvolutionParameterxOES_fnptr(target, pname, param);
            }
            
            private static delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int*, void> _ConvolutionParameterxvOES_fnptr = &ConvolutionParameterxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int* parameters) => _ConvolutionParameterxvOES_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ConvolutionParameterxvOES_Lazy(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int* parameters)
            {
                _ConvolutionParameterxvOES_fnptr = (delegate* unmanaged<ConvolutionTargetEXT, ConvolutionParameterEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glConvolutionParameterxvOES");
                _ConvolutionParameterxvOES_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<int, void> _EvalCoord1xOES_fnptr = &EvalCoord1xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalCoord1xOES(int u) => _EvalCoord1xOES_fnptr(u);
            [UnmanagedCallersOnly]
            private static void EvalCoord1xOES_Lazy(int u)
            {
                _EvalCoord1xOES_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord1xOES");
                _EvalCoord1xOES_fnptr(u);
            }
            
            private static delegate* unmanaged<int*, void> _EvalCoord1xvOES_fnptr = &EvalCoord1xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalCoord1xvOES(int* coords) => _EvalCoord1xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void EvalCoord1xvOES_Lazy(int* coords)
            {
                _EvalCoord1xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord1xvOES");
                _EvalCoord1xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, int, void> _EvalCoord2xOES_fnptr = &EvalCoord2xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalCoord2xOES(int u, int v) => _EvalCoord2xOES_fnptr(u, v);
            [UnmanagedCallersOnly]
            private static void EvalCoord2xOES_Lazy(int u, int v)
            {
                _EvalCoord2xOES_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord2xOES");
                _EvalCoord2xOES_fnptr(u, v);
            }
            
            private static delegate* unmanaged<int*, void> _EvalCoord2xvOES_fnptr = &EvalCoord2xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalCoord2xvOES(int* coords) => _EvalCoord2xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void EvalCoord2xvOES_Lazy(int* coords)
            {
                _EvalCoord2xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glEvalCoord2xvOES");
                _EvalCoord2xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, All, int*, void> _FeedbackBufferxOES_fnptr = &FeedbackBufferxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FeedbackBufferxOES(int n, All type, int* buffer) => _FeedbackBufferxOES_fnptr(n, type, buffer);
            [UnmanagedCallersOnly]
            private static void FeedbackBufferxOES_Lazy(int n, All type, int* buffer)
            {
                _FeedbackBufferxOES_fnptr = (delegate* unmanaged<int, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glFeedbackBufferxOES");
                _FeedbackBufferxOES_fnptr(n, type, buffer);
            }
            
            private static delegate* unmanaged<All, All, int*, void> _GetConvolutionParameterxvOES_fnptr = &GetConvolutionParameterxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetConvolutionParameterxvOES(All target, All pname, int* parameters) => _GetConvolutionParameterxvOES_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetConvolutionParameterxvOES_Lazy(All target, All pname, int* parameters)
            {
                _GetConvolutionParameterxvOES_fnptr = (delegate* unmanaged<All, All, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetConvolutionParameterxvOES");
                _GetConvolutionParameterxvOES_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, int*, void> _GetHistogramParameterxvOES_fnptr = &GetHistogramParameterxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => _GetHistogramParameterxvOES_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetHistogramParameterxvOES_Lazy(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters)
            {
                _GetHistogramParameterxvOES_fnptr = (delegate* unmanaged<HistogramTargetEXT, GetHistogramParameterPNameEXT, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetHistogramParameterxvOES");
                _GetHistogramParameterxvOES_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<LightName, LightParameter, int*, void> _GetLightxOES_fnptr = &GetLightxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLightxOES(LightName light, LightParameter pname, int* parameters) => _GetLightxOES_fnptr(light, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetLightxOES_Lazy(LightName light, LightParameter pname, int* parameters)
            {
                _GetLightxOES_fnptr = (delegate* unmanaged<LightName, LightParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetLightxOES");
                _GetLightxOES_fnptr(light, pname, parameters);
            }
            
            private static delegate* unmanaged<MapTarget, GetMapQuery, int*, void> _GetMapxvOES_fnptr = &GetMapxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapxvOES(MapTarget target, GetMapQuery query, int* v) => _GetMapxvOES_fnptr(target, query, v);
            [UnmanagedCallersOnly]
            private static void GetMapxvOES_Lazy(MapTarget target, GetMapQuery query, int* v)
            {
                _GetMapxvOES_fnptr = (delegate* unmanaged<MapTarget, GetMapQuery, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetMapxvOES");
                _GetMapxvOES_fnptr(target, query, v);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, int, void> _GetMaterialxOES_fnptr = &GetMaterialxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMaterialxOES(MaterialFace face, MaterialParameter pname, int param) => _GetMaterialxOES_fnptr(face, pname, param);
            [UnmanagedCallersOnly]
            private static void GetMaterialxOES_Lazy(MaterialFace face, MaterialParameter pname, int param)
            {
                _GetMaterialxOES_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glGetMaterialxOES");
                _GetMaterialxOES_fnptr(face, pname, param);
            }
            
            private static delegate* unmanaged<PixelMap, int, int*, void> _GetPixelMapxv_fnptr = &GetPixelMapxv_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelMapxv(PixelMap map, int size, int* values) => _GetPixelMapxv_fnptr(map, size, values);
            [UnmanagedCallersOnly]
            private static void GetPixelMapxv_Lazy(PixelMap map, int size, int* values)
            {
                _GetPixelMapxv_fnptr = (delegate* unmanaged<PixelMap, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPixelMapxv");
                _GetPixelMapxv_fnptr(map, size, values);
            }
            
            private static delegate* unmanaged<TextureCoordName, TextureGenParameter, int*, void> _GetTexGenxvOES_fnptr = &GetTexGenxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int* parameters) => _GetTexGenxvOES_fnptr(coord, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTexGenxvOES_Lazy(TextureCoordName coord, TextureGenParameter pname, int* parameters)
            {
                _GetTexGenxvOES_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexGenxvOES");
                _GetTexGenxvOES_fnptr(coord, pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, int, GetTextureParameter, int*, void> _GetTexLevelParameterxvOES_fnptr = &GetTexLevelParameterxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => _GetTexLevelParameterxvOES_fnptr(target, level, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetTexLevelParameterxvOES_Lazy(TextureTarget target, int level, GetTextureParameter pname, int* parameters)
            {
                _GetTexLevelParameterxvOES_fnptr = (delegate* unmanaged<TextureTarget, int, GetTextureParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexLevelParameterxvOES");
                _GetTexLevelParameterxvOES_fnptr(target, level, pname, parameters);
            }
            
            private static delegate* unmanaged<int, void> _IndexxOES_fnptr = &IndexxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexxOES(int component) => _IndexxOES_fnptr(component);
            [UnmanagedCallersOnly]
            private static void IndexxOES_Lazy(int component)
            {
                _IndexxOES_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glIndexxOES");
                _IndexxOES_fnptr(component);
            }
            
            private static delegate* unmanaged<int*, void> _IndexxvOES_fnptr = &IndexxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexxvOES(int* component) => _IndexxvOES_fnptr(component);
            [UnmanagedCallersOnly]
            private static void IndexxvOES_Lazy(int* component)
            {
                _IndexxvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glIndexxvOES");
                _IndexxvOES_fnptr(component);
            }
            
            private static delegate* unmanaged<int*, void> _LoadTransposeMatrixxOES_fnptr = &LoadTransposeMatrixxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadTransposeMatrixxOES(int* m) => _LoadTransposeMatrixxOES_fnptr(m);
            [UnmanagedCallersOnly]
            private static void LoadTransposeMatrixxOES_Lazy(int* m)
            {
                _LoadTransposeMatrixxOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glLoadTransposeMatrixxOES");
                _LoadTransposeMatrixxOES_fnptr(m);
            }
            
            private static delegate* unmanaged<MapTarget, int, int, int, int, int, void> _Map1xOES_fnptr = &Map1xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Map1xOES(MapTarget target, int u1, int u2, int stride, int order, int points) => _Map1xOES_fnptr(target, u1, u2, stride, order, points);
            [UnmanagedCallersOnly]
            private static void Map1xOES_Lazy(MapTarget target, int u1, int u2, int stride, int order, int points)
            {
                _Map1xOES_fnptr = (delegate* unmanaged<MapTarget, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMap1xOES");
                _Map1xOES_fnptr(target, u1, u2, stride, order, points);
            }
            
            private static delegate* unmanaged<MapTarget, int, int, int, int, int, int, int, int, int, void> _Map2xOES_fnptr = &Map2xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Map2xOES(MapTarget target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points) => _Map2xOES_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            [UnmanagedCallersOnly]
            private static void Map2xOES_Lazy(MapTarget target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points)
            {
                _Map2xOES_fnptr = (delegate* unmanaged<MapTarget, int, int, int, int, int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMap2xOES");
                _Map2xOES_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            
            private static delegate* unmanaged<int, int, int, void> _MapGrid1xOES_fnptr = &MapGrid1xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapGrid1xOES(int n, int u1, int u2) => _MapGrid1xOES_fnptr(n, u1, u2);
            [UnmanagedCallersOnly]
            private static void MapGrid1xOES_Lazy(int n, int u1, int u2)
            {
                _MapGrid1xOES_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMapGrid1xOES");
                _MapGrid1xOES_fnptr(n, u1, u2);
            }
            
            private static delegate* unmanaged<int, int, int, int, int, void> _MapGrid2xOES_fnptr = &MapGrid2xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapGrid2xOES(int n, int u1, int u2, int v1, int v2) => _MapGrid2xOES_fnptr(n, u1, u2, v1, v2);
            [UnmanagedCallersOnly]
            private static void MapGrid2xOES_Lazy(int n, int u1, int u2, int v1, int v2)
            {
                _MapGrid2xOES_fnptr = (delegate* unmanaged<int, int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMapGrid2xOES");
                _MapGrid2xOES_fnptr(n, u1, u2, v1, v2);
            }
            
            private static delegate* unmanaged<int*, void> _MultTransposeMatrixxOES_fnptr = &MultTransposeMatrixxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultTransposeMatrixxOES(int* m) => _MultTransposeMatrixxOES_fnptr(m);
            [UnmanagedCallersOnly]
            private static void MultTransposeMatrixxOES_Lazy(int* m)
            {
                _MultTransposeMatrixxOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultTransposeMatrixxOES");
                _MultTransposeMatrixxOES_fnptr(m);
            }
            
            private static delegate* unmanaged<TextureUnit, int, void> _MultiTexCoord1xOES_fnptr = &MultiTexCoord1xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1xOES(TextureUnit texture, int s) => _MultiTexCoord1xOES_fnptr(texture, s);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1xOES_Lazy(TextureUnit texture, int s)
            {
                _MultiTexCoord1xOES_fnptr = (delegate* unmanaged<TextureUnit, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1xOES");
                _MultiTexCoord1xOES_fnptr(texture, s);
            }
            
            private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord1xvOES_fnptr = &MultiTexCoord1xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1xvOES(TextureUnit texture, int* coords) => _MultiTexCoord1xvOES_fnptr(texture, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord1xvOES_Lazy(TextureUnit texture, int* coords)
            {
                _MultiTexCoord1xvOES_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord1xvOES");
                _MultiTexCoord1xvOES_fnptr(texture, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, int, int, void> _MultiTexCoord2xOES_fnptr = &MultiTexCoord2xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2xOES(TextureUnit texture, int s, int t) => _MultiTexCoord2xOES_fnptr(texture, s, t);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2xOES_Lazy(TextureUnit texture, int s, int t)
            {
                _MultiTexCoord2xOES_fnptr = (delegate* unmanaged<TextureUnit, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2xOES");
                _MultiTexCoord2xOES_fnptr(texture, s, t);
            }
            
            private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord2xvOES_fnptr = &MultiTexCoord2xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2xvOES(TextureUnit texture, int* coords) => _MultiTexCoord2xvOES_fnptr(texture, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord2xvOES_Lazy(TextureUnit texture, int* coords)
            {
                _MultiTexCoord2xvOES_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord2xvOES");
                _MultiTexCoord2xvOES_fnptr(texture, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, int, int, int, void> _MultiTexCoord3xOES_fnptr = &MultiTexCoord3xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3xOES(TextureUnit texture, int s, int t, int r) => _MultiTexCoord3xOES_fnptr(texture, s, t, r);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3xOES_Lazy(TextureUnit texture, int s, int t, int r)
            {
                _MultiTexCoord3xOES_fnptr = (delegate* unmanaged<TextureUnit, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3xOES");
                _MultiTexCoord3xOES_fnptr(texture, s, t, r);
            }
            
            private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord3xvOES_fnptr = &MultiTexCoord3xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3xvOES(TextureUnit texture, int* coords) => _MultiTexCoord3xvOES_fnptr(texture, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord3xvOES_Lazy(TextureUnit texture, int* coords)
            {
                _MultiTexCoord3xvOES_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord3xvOES");
                _MultiTexCoord3xvOES_fnptr(texture, coords);
            }
            
            private static delegate* unmanaged<TextureUnit, int*, void> _MultiTexCoord4xvOES_fnptr = &MultiTexCoord4xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4xvOES(TextureUnit texture, int* coords) => _MultiTexCoord4xvOES_fnptr(texture, coords);
            [UnmanagedCallersOnly]
            private static void MultiTexCoord4xvOES_Lazy(TextureUnit texture, int* coords)
            {
                _MultiTexCoord4xvOES_fnptr = (delegate* unmanaged<TextureUnit, int*, void>)GLLoader.BindingsContext.GetProcAddress("glMultiTexCoord4xvOES");
                _MultiTexCoord4xvOES_fnptr(texture, coords);
            }
            
            private static delegate* unmanaged<int*, void> _Normal3xvOES_fnptr = &Normal3xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3xvOES(int* coords) => _Normal3xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void Normal3xvOES_Lazy(int* coords)
            {
                _Normal3xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3xvOES");
                _Normal3xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, void> _PassThroughxOES_fnptr = &PassThroughxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PassThroughxOES(int token) => _PassThroughxOES_fnptr(token);
            [UnmanagedCallersOnly]
            private static void PassThroughxOES_Lazy(int token)
            {
                _PassThroughxOES_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glPassThroughxOES");
                _PassThroughxOES_fnptr(token);
            }
            
            private static delegate* unmanaged<PixelMap, int, int*, void> _PixelMapx_fnptr = &PixelMapx_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelMapx(PixelMap map, int size, int* values) => _PixelMapx_fnptr(map, size, values);
            [UnmanagedCallersOnly]
            private static void PixelMapx_Lazy(PixelMap map, int size, int* values)
            {
                _PixelMapx_fnptr = (delegate* unmanaged<PixelMap, int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glPixelMapx");
                _PixelMapx_fnptr(map, size, values);
            }
            
            private static delegate* unmanaged<PixelStoreParameter, int, void> _PixelStorex_fnptr = &PixelStorex_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelStorex(PixelStoreParameter pname, int param) => _PixelStorex_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PixelStorex_Lazy(PixelStoreParameter pname, int param)
            {
                _PixelStorex_fnptr = (delegate* unmanaged<PixelStoreParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glPixelStorex");
                _PixelStorex_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<PixelTransferParameter, int, void> _PixelTransferxOES_fnptr = &PixelTransferxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransferxOES(PixelTransferParameter pname, int param) => _PixelTransferxOES_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PixelTransferxOES_Lazy(PixelTransferParameter pname, int param)
            {
                _PixelTransferxOES_fnptr = (delegate* unmanaged<PixelTransferParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTransferxOES");
                _PixelTransferxOES_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<int, int, void> _PixelZoomxOES_fnptr = &PixelZoomxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelZoomxOES(int xfactor, int yfactor) => _PixelZoomxOES_fnptr(xfactor, yfactor);
            [UnmanagedCallersOnly]
            private static void PixelZoomxOES_Lazy(int xfactor, int yfactor)
            {
                _PixelZoomxOES_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glPixelZoomxOES");
                _PixelZoomxOES_fnptr(xfactor, yfactor);
            }
            
            private static delegate* unmanaged<int, TextureHandle*, int*, void> _PrioritizeTexturesxOES_fnptr = &PrioritizeTexturesxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrioritizeTexturesxOES(int n, TextureHandle* textures, int* priorities) => _PrioritizeTexturesxOES_fnptr(n, textures, priorities);
            [UnmanagedCallersOnly]
            private static void PrioritizeTexturesxOES_Lazy(int n, TextureHandle* textures, int* priorities)
            {
                _PrioritizeTexturesxOES_fnptr = (delegate* unmanaged<int, TextureHandle*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glPrioritizeTexturesxOES");
                _PrioritizeTexturesxOES_fnptr(n, textures, priorities);
            }
            
            private static delegate* unmanaged<int, int, void> _RasterPos2xOES_fnptr = &RasterPos2xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos2xOES(int x, int y) => _RasterPos2xOES_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void RasterPos2xOES_Lazy(int x, int y)
            {
                _RasterPos2xOES_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2xOES");
                _RasterPos2xOES_fnptr(x, y);
            }
            
            private static delegate* unmanaged<int*, void> _RasterPos2xvOES_fnptr = &RasterPos2xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos2xvOES(int* coords) => _RasterPos2xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void RasterPos2xvOES_Lazy(int* coords)
            {
                _RasterPos2xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos2xvOES");
                _RasterPos2xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, int, int, void> _RasterPos3xOES_fnptr = &RasterPos3xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos3xOES(int x, int y, int z) => _RasterPos3xOES_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void RasterPos3xOES_Lazy(int x, int y, int z)
            {
                _RasterPos3xOES_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3xOES");
                _RasterPos3xOES_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<int*, void> _RasterPos3xvOES_fnptr = &RasterPos3xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos3xvOES(int* coords) => _RasterPos3xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void RasterPos3xvOES_Lazy(int* coords)
            {
                _RasterPos3xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos3xvOES");
                _RasterPos3xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _RasterPos4xOES_fnptr = &RasterPos4xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos4xOES(int x, int y, int z, int w) => _RasterPos4xOES_fnptr(x, y, z, w);
            [UnmanagedCallersOnly]
            private static void RasterPos4xOES_Lazy(int x, int y, int z, int w)
            {
                _RasterPos4xOES_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4xOES");
                _RasterPos4xOES_fnptr(x, y, z, w);
            }
            
            private static delegate* unmanaged<int*, void> _RasterPos4xvOES_fnptr = &RasterPos4xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos4xvOES(int* coords) => _RasterPos4xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void RasterPos4xvOES_Lazy(int* coords)
            {
                _RasterPos4xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glRasterPos4xvOES");
                _RasterPos4xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _RectxOES_fnptr = &RectxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RectxOES(int x1, int y1, int x2, int y2) => _RectxOES_fnptr(x1, y1, x2, y2);
            [UnmanagedCallersOnly]
            private static void RectxOES_Lazy(int x1, int y1, int x2, int y2)
            {
                _RectxOES_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glRectxOES");
                _RectxOES_fnptr(x1, y1, x2, y2);
            }
            
            private static delegate* unmanaged<int*, int*, void> _RectxvOES_fnptr = &RectxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RectxvOES(int* v1, int* v2) => _RectxvOES_fnptr(v1, v2);
            [UnmanagedCallersOnly]
            private static void RectxvOES_Lazy(int* v1, int* v2)
            {
                _RectxvOES_fnptr = (delegate* unmanaged<int*, int*, void>)GLLoader.BindingsContext.GetProcAddress("glRectxvOES");
                _RectxvOES_fnptr(v1, v2);
            }
            
            private static delegate* unmanaged<int, void> _TexCoord1xOES_fnptr = &TexCoord1xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1xOES(int s) => _TexCoord1xOES_fnptr(s);
            [UnmanagedCallersOnly]
            private static void TexCoord1xOES_Lazy(int s)
            {
                _TexCoord1xOES_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1xOES");
                _TexCoord1xOES_fnptr(s);
            }
            
            private static delegate* unmanaged<int*, void> _TexCoord1xvOES_fnptr = &TexCoord1xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1xvOES(int* coords) => _TexCoord1xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void TexCoord1xvOES_Lazy(int* coords)
            {
                _TexCoord1xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord1xvOES");
                _TexCoord1xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, int, void> _TexCoord2xOES_fnptr = &TexCoord2xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2xOES(int s, int t) => _TexCoord2xOES_fnptr(s, t);
            [UnmanagedCallersOnly]
            private static void TexCoord2xOES_Lazy(int s, int t)
            {
                _TexCoord2xOES_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2xOES");
                _TexCoord2xOES_fnptr(s, t);
            }
            
            private static delegate* unmanaged<int*, void> _TexCoord2xvOES_fnptr = &TexCoord2xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2xvOES(int* coords) => _TexCoord2xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void TexCoord2xvOES_Lazy(int* coords)
            {
                _TexCoord2xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2xvOES");
                _TexCoord2xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, int, int, void> _TexCoord3xOES_fnptr = &TexCoord3xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3xOES(int s, int t, int r) => _TexCoord3xOES_fnptr(s, t, r);
            [UnmanagedCallersOnly]
            private static void TexCoord3xOES_Lazy(int s, int t, int r)
            {
                _TexCoord3xOES_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3xOES");
                _TexCoord3xOES_fnptr(s, t, r);
            }
            
            private static delegate* unmanaged<int*, void> _TexCoord3xvOES_fnptr = &TexCoord3xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3xvOES(int* coords) => _TexCoord3xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void TexCoord3xvOES_Lazy(int* coords)
            {
                _TexCoord3xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord3xvOES");
                _TexCoord3xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, int, int, int, void> _TexCoord4xOES_fnptr = &TexCoord4xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4xOES(int s, int t, int r, int q) => _TexCoord4xOES_fnptr(s, t, r, q);
            [UnmanagedCallersOnly]
            private static void TexCoord4xOES_Lazy(int s, int t, int r, int q)
            {
                _TexCoord4xOES_fnptr = (delegate* unmanaged<int, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4xOES");
                _TexCoord4xOES_fnptr(s, t, r, q);
            }
            
            private static delegate* unmanaged<int*, void> _TexCoord4xvOES_fnptr = &TexCoord4xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4xvOES(int* coords) => _TexCoord4xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void TexCoord4xvOES_Lazy(int* coords)
            {
                _TexCoord4xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4xvOES");
                _TexCoord4xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<TextureCoordName, TextureGenParameter, int, void> _TexGenxOES_fnptr = &TexGenxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexGenxOES(TextureCoordName coord, TextureGenParameter pname, int param) => _TexGenxOES_fnptr(coord, pname, param);
            [UnmanagedCallersOnly]
            private static void TexGenxOES_Lazy(TextureCoordName coord, TextureGenParameter pname, int param)
            {
                _TexGenxOES_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glTexGenxOES");
                _TexGenxOES_fnptr(coord, pname, param);
            }
            
            private static delegate* unmanaged<TextureCoordName, TextureGenParameter, int*, void> _TexGenxvOES_fnptr = &TexGenxvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int* parameters) => _TexGenxvOES_fnptr(coord, pname, parameters);
            [UnmanagedCallersOnly]
            private static void TexGenxvOES_Lazy(TextureCoordName coord, TextureGenParameter pname, int* parameters)
            {
                _TexGenxvOES_fnptr = (delegate* unmanaged<TextureCoordName, TextureGenParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glTexGenxvOES");
                _TexGenxvOES_fnptr(coord, pname, parameters);
            }
            
            private static delegate* unmanaged<int, void> _Vertex2xOES_fnptr = &Vertex2xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2xOES(int x) => _Vertex2xOES_fnptr(x);
            [UnmanagedCallersOnly]
            private static void Vertex2xOES_Lazy(int x)
            {
                _Vertex2xOES_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2xOES");
                _Vertex2xOES_fnptr(x);
            }
            
            private static delegate* unmanaged<int*, void> _Vertex2xvOES_fnptr = &Vertex2xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2xvOES(int* coords) => _Vertex2xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void Vertex2xvOES_Lazy(int* coords)
            {
                _Vertex2xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex2xvOES");
                _Vertex2xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, int, void> _Vertex3xOES_fnptr = &Vertex3xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3xOES(int x, int y) => _Vertex3xOES_fnptr(x, y);
            [UnmanagedCallersOnly]
            private static void Vertex3xOES_Lazy(int x, int y)
            {
                _Vertex3xOES_fnptr = (delegate* unmanaged<int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3xOES");
                _Vertex3xOES_fnptr(x, y);
            }
            
            private static delegate* unmanaged<int*, void> _Vertex3xvOES_fnptr = &Vertex3xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3xvOES(int* coords) => _Vertex3xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void Vertex3xvOES_Lazy(int* coords)
            {
                _Vertex3xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex3xvOES");
                _Vertex3xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int, int, int, void> _Vertex4xOES_fnptr = &Vertex4xOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4xOES(int x, int y, int z) => _Vertex4xOES_fnptr(x, y, z);
            [UnmanagedCallersOnly]
            private static void Vertex4xOES_Lazy(int x, int y, int z)
            {
                _Vertex4xOES_fnptr = (delegate* unmanaged<int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4xOES");
                _Vertex4xOES_fnptr(x, y, z);
            }
            
            private static delegate* unmanaged<int*, void> _Vertex4xvOES_fnptr = &Vertex4xvOES_Lazy;
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4xvOES(int* coords) => _Vertex4xvOES_fnptr(coords);
            [UnmanagedCallersOnly]
            private static void Vertex4xvOES_Lazy(int* coords)
            {
                _Vertex4xvOES_fnptr = (delegate* unmanaged<int*, void>)GLLoader.BindingsContext.GetProcAddress("glVertex4xvOES");
                _Vertex4xvOES_fnptr(coords);
            }
            
            private static delegate* unmanaged<int*, int*, All> _QueryMatrixxOES_fnptr = &QueryMatrixxOES_Lazy;
            /// <summary> <b>[requires: GL_OES_query_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All QueryMatrixxOES(int* mantissa, int* exponent) => _QueryMatrixxOES_fnptr(mantissa, exponent);
            [UnmanagedCallersOnly]
            private static All QueryMatrixxOES_Lazy(int* mantissa, int* exponent)
            {
                _QueryMatrixxOES_fnptr = (delegate* unmanaged<int*, int*, All>)GLLoader.BindingsContext.GetProcAddress("glQueryMatrixxOES");
                return _QueryMatrixxOES_fnptr(mantissa, exponent);
            }
            
            private static delegate* unmanaged<float, void> _ClearDepthfOES_fnptr = &ClearDepthfOES_Lazy;
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearDepthfOES(float depth) => _ClearDepthfOES_fnptr(depth);
            [UnmanagedCallersOnly]
            private static void ClearDepthfOES_Lazy(float depth)
            {
                _ClearDepthfOES_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glClearDepthfOES");
                _ClearDepthfOES_fnptr(depth);
            }
            
            private static delegate* unmanaged<ClipPlaneName, float*, void> _ClipPlanefOES_fnptr = &ClipPlanefOES_Lazy;
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClipPlanefOES(ClipPlaneName plane, float* equation) => _ClipPlanefOES_fnptr(plane, equation);
            [UnmanagedCallersOnly]
            private static void ClipPlanefOES_Lazy(ClipPlaneName plane, float* equation)
            {
                _ClipPlanefOES_fnptr = (delegate* unmanaged<ClipPlaneName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glClipPlanefOES");
                _ClipPlanefOES_fnptr(plane, equation);
            }
            
            private static delegate* unmanaged<float, float, void> _DepthRangefOES_fnptr = &DepthRangefOES_Lazy;
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangefOES(float n, float f) => _DepthRangefOES_fnptr(n, f);
            [UnmanagedCallersOnly]
            private static void DepthRangefOES_Lazy(float n, float f)
            {
                _DepthRangefOES_fnptr = (delegate* unmanaged<float, float, void>)GLLoader.BindingsContext.GetProcAddress("glDepthRangefOES");
                _DepthRangefOES_fnptr(n, f);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, void> _FrustumfOES_fnptr = &FrustumfOES_Lazy;
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FrustumfOES(float l, float r, float b, float t, float n, float f) => _FrustumfOES_fnptr(l, r, b, t, n, f);
            [UnmanagedCallersOnly]
            private static void FrustumfOES_Lazy(float l, float r, float b, float t, float n, float f)
            {
                _FrustumfOES_fnptr = (delegate* unmanaged<float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glFrustumfOES");
                _FrustumfOES_fnptr(l, r, b, t, n, f);
            }
            
            private static delegate* unmanaged<ClipPlaneName, float*, void> _GetClipPlanefOES_fnptr = &GetClipPlanefOES_Lazy;
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetClipPlanefOES(ClipPlaneName plane, float* equation) => _GetClipPlanefOES_fnptr(plane, equation);
            [UnmanagedCallersOnly]
            private static void GetClipPlanefOES_Lazy(ClipPlaneName plane, float* equation)
            {
                _GetClipPlanefOES_fnptr = (delegate* unmanaged<ClipPlaneName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetClipPlanefOES");
                _GetClipPlanefOES_fnptr(plane, equation);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, void> _OrthofOES_fnptr = &OrthofOES_Lazy;
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void OrthofOES(float l, float r, float b, float t, float n, float f) => _OrthofOES_fnptr(l, r, b, t, n, f);
            [UnmanagedCallersOnly]
            private static void OrthofOES_Lazy(float l, float r, float b, float t, float n, float f)
            {
                _OrthofOES_fnptr = (delegate* unmanaged<float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glOrthofOES");
                _OrthofOES_fnptr(l, r, b, t, n, f);
            }
            
        }
        public static unsafe partial class OVR
        {
            private static delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, int, void> _FramebufferTextureMultiviewOVR_fnptr = &FramebufferTextureMultiviewOVR_Lazy;
            /// <summary> <b>[requires: GL_OVR_multiview]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureMultiviewOVR(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int baseViewIndex, int numViews) => _FramebufferTextureMultiviewOVR_fnptr(target, attachment, texture, level, baseViewIndex, numViews);
            [UnmanagedCallersOnly]
            private static void FramebufferTextureMultiviewOVR_Lazy(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int baseViewIndex, int numViews)
            {
                _FramebufferTextureMultiviewOVR_fnptr = (delegate* unmanaged<FramebufferTarget, FramebufferAttachment, TextureHandle, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glFramebufferTextureMultiviewOVR");
                _FramebufferTextureMultiviewOVR_fnptr(target, attachment, texture, level, baseViewIndex, numViews);
            }
            
        }
        public static unsafe partial class PGI
        {
            private static delegate* unmanaged<HintTargetPGI, int, void> _HintPGI_fnptr = &HintPGI_Lazy;
            /// <summary> <b>[requires: GL_PGI_misc_hints]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void HintPGI(HintTargetPGI target, int mode) => _HintPGI_fnptr(target, mode);
            [UnmanagedCallersOnly]
            private static void HintPGI_Lazy(HintTargetPGI target, int mode)
            {
                _HintPGI_fnptr = (delegate* unmanaged<HintTargetPGI, int, void>)GLLoader.BindingsContext.GetProcAddress("glHintPGI");
                _HintPGI_fnptr(target, mode);
            }
            
        }
        public static unsafe partial class SGIS
        {
            private static delegate* unmanaged<TextureTarget, int, float*, void> _DetailTexFuncSGIS_fnptr = &DetailTexFuncSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_detail_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DetailTexFuncSGIS(TextureTarget target, int n, float* points) => _DetailTexFuncSGIS_fnptr(target, n, points);
            [UnmanagedCallersOnly]
            private static void DetailTexFuncSGIS_Lazy(TextureTarget target, int n, float* points)
            {
                _DetailTexFuncSGIS_fnptr = (delegate* unmanaged<TextureTarget, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glDetailTexFuncSGIS");
                _DetailTexFuncSGIS_fnptr(target, n, points);
            }
            
            private static delegate* unmanaged<TextureTarget, float*, void> _GetDetailTexFuncSGIS_fnptr = &GetDetailTexFuncSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_detail_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetDetailTexFuncSGIS(TextureTarget target, float* points) => _GetDetailTexFuncSGIS_fnptr(target, points);
            [UnmanagedCallersOnly]
            private static void GetDetailTexFuncSGIS_Lazy(TextureTarget target, float* points)
            {
                _GetDetailTexFuncSGIS_fnptr = (delegate* unmanaged<TextureTarget, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetDetailTexFuncSGIS");
                _GetDetailTexFuncSGIS_fnptr(target, points);
            }
            
            private static delegate* unmanaged<int, float*, void> _FogFuncSGIS_fnptr = &FogFuncSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_fog_function]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogFuncSGIS(int n, float* points) => _FogFuncSGIS_fnptr(n, points);
            [UnmanagedCallersOnly]
            private static void FogFuncSGIS_Lazy(int n, float* points)
            {
                _FogFuncSGIS_fnptr = (delegate* unmanaged<int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glFogFuncSGIS");
                _FogFuncSGIS_fnptr(n, points);
            }
            
            private static delegate* unmanaged<float*, void> _GetFogFuncSGIS_fnptr = &GetFogFuncSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_fog_function]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFogFuncSGIS(float* points) => _GetFogFuncSGIS_fnptr(points);
            [UnmanagedCallersOnly]
            private static void GetFogFuncSGIS_Lazy(float* points)
            {
                _GetFogFuncSGIS_fnptr = (delegate* unmanaged<float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFogFuncSGIS");
                _GetFogFuncSGIS_fnptr(points);
            }
            
            private static delegate* unmanaged<float, byte, void> _SampleMaskSGIS_fnptr = &SampleMaskSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleMaskSGIS(float value, byte invert) => _SampleMaskSGIS_fnptr(value, invert);
            [UnmanagedCallersOnly]
            private static void SampleMaskSGIS_Lazy(float value, byte invert)
            {
                _SampleMaskSGIS_fnptr = (delegate* unmanaged<float, byte, void>)GLLoader.BindingsContext.GetProcAddress("glSampleMaskSGIS");
                _SampleMaskSGIS_fnptr(value, invert);
            }
            
            private static delegate* unmanaged<SamplePatternSGIS, void> _SamplePatternSGIS_fnptr = &SamplePatternSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SamplePatternSGIS(SamplePatternSGIS pattern) => _SamplePatternSGIS_fnptr(pattern);
            [UnmanagedCallersOnly]
            private static void SamplePatternSGIS_Lazy(SamplePatternSGIS pattern)
            {
                _SamplePatternSGIS_fnptr = (delegate* unmanaged<SamplePatternSGIS, void>)GLLoader.BindingsContext.GetProcAddress("glSamplePatternSGIS");
                _SamplePatternSGIS_fnptr(pattern);
            }
            
            private static delegate* unmanaged<PixelTexGenParameterNameSGIS, int, void> _PixelTexGenParameteriSGIS_fnptr = &PixelTexGenParameteriSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenParameteriSGIS(PixelTexGenParameterNameSGIS pname, int param) => _PixelTexGenParameteriSGIS_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PixelTexGenParameteriSGIS_Lazy(PixelTexGenParameterNameSGIS pname, int param)
            {
                _PixelTexGenParameteriSGIS_fnptr = (delegate* unmanaged<PixelTexGenParameterNameSGIS, int, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTexGenParameteriSGIS");
                _PixelTexGenParameteriSGIS_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<PixelTexGenParameterNameSGIS, int*, void> _PixelTexGenParameterivSGIS_fnptr = &PixelTexGenParameterivSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int* parameters) => _PixelTexGenParameterivSGIS_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void PixelTexGenParameterivSGIS_Lazy(PixelTexGenParameterNameSGIS pname, int* parameters)
            {
                _PixelTexGenParameterivSGIS_fnptr = (delegate* unmanaged<PixelTexGenParameterNameSGIS, int*, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTexGenParameterivSGIS");
                _PixelTexGenParameterivSGIS_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<PixelTexGenParameterNameSGIS, float, void> _PixelTexGenParameterfSGIS_fnptr = &PixelTexGenParameterfSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenParameterfSGIS(PixelTexGenParameterNameSGIS pname, float param) => _PixelTexGenParameterfSGIS_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PixelTexGenParameterfSGIS_Lazy(PixelTexGenParameterNameSGIS pname, float param)
            {
                _PixelTexGenParameterfSGIS_fnptr = (delegate* unmanaged<PixelTexGenParameterNameSGIS, float, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTexGenParameterfSGIS");
                _PixelTexGenParameterfSGIS_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<PixelTexGenParameterNameSGIS, float*, void> _PixelTexGenParameterfvSGIS_fnptr = &PixelTexGenParameterfvSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float* parameters) => _PixelTexGenParameterfvSGIS_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void PixelTexGenParameterfvSGIS_Lazy(PixelTexGenParameterNameSGIS pname, float* parameters)
            {
                _PixelTexGenParameterfvSGIS_fnptr = (delegate* unmanaged<PixelTexGenParameterNameSGIS, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTexGenParameterfvSGIS");
                _PixelTexGenParameterfvSGIS_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<PixelTexGenParameterNameSGIS, int*, void> _GetPixelTexGenParameterivSGIS_fnptr = &GetPixelTexGenParameterivSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int* parameters) => _GetPixelTexGenParameterivSGIS_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetPixelTexGenParameterivSGIS_Lazy(PixelTexGenParameterNameSGIS pname, int* parameters)
            {
                _GetPixelTexGenParameterivSGIS_fnptr = (delegate* unmanaged<PixelTexGenParameterNameSGIS, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPixelTexGenParameterivSGIS");
                _GetPixelTexGenParameterivSGIS_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<PixelTexGenParameterNameSGIS, float*, void> _GetPixelTexGenParameterfvSGIS_fnptr = &GetPixelTexGenParameterfvSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float* parameters) => _GetPixelTexGenParameterfvSGIS_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetPixelTexGenParameterfvSGIS_Lazy(PixelTexGenParameterNameSGIS pname, float* parameters)
            {
                _GetPixelTexGenParameterfvSGIS_fnptr = (delegate* unmanaged<PixelTexGenParameterNameSGIS, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetPixelTexGenParameterfvSGIS");
                _GetPixelTexGenParameterfvSGIS_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, float, void> _PointParameterfSGIS_fnptr = &PointParameterfSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfSGIS(PointParameterNameARB pname, float param) => _PointParameterfSGIS_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void PointParameterfSGIS_Lazy(PointParameterNameARB pname, float param)
            {
                _PointParameterfSGIS_fnptr = (delegate* unmanaged<PointParameterNameARB, float, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterfSGIS");
                _PointParameterfSGIS_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<PointParameterNameARB, float*, void> _PointParameterfvSGIS_fnptr = &PointParameterfvSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfvSGIS(PointParameterNameARB pname, float* parameters) => _PointParameterfvSGIS_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void PointParameterfvSGIS_Lazy(PointParameterNameARB pname, float* parameters)
            {
                _PointParameterfvSGIS_fnptr = (delegate* unmanaged<PointParameterNameARB, float*, void>)GLLoader.BindingsContext.GetProcAddress("glPointParameterfvSGIS");
                _PointParameterfvSGIS_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<TextureTarget, int, float*, void> _SharpenTexFuncSGIS_fnptr = &SharpenTexFuncSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SharpenTexFuncSGIS(TextureTarget target, int n, float* points) => _SharpenTexFuncSGIS_fnptr(target, n, points);
            [UnmanagedCallersOnly]
            private static void SharpenTexFuncSGIS_Lazy(TextureTarget target, int n, float* points)
            {
                _SharpenTexFuncSGIS_fnptr = (delegate* unmanaged<TextureTarget, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glSharpenTexFuncSGIS");
                _SharpenTexFuncSGIS_fnptr(target, n, points);
            }
            
            private static delegate* unmanaged<TextureTarget, float*, void> _GetSharpenTexFuncSGIS_fnptr = &GetSharpenTexFuncSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetSharpenTexFuncSGIS(TextureTarget target, float* points) => _GetSharpenTexFuncSGIS_fnptr(target, points);
            [UnmanagedCallersOnly]
            private static void GetSharpenTexFuncSGIS_Lazy(TextureTarget target, float* points)
            {
                _GetSharpenTexFuncSGIS_fnptr = (delegate* unmanaged<TextureTarget, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetSharpenTexFuncSGIS");
                _GetSharpenTexFuncSGIS_fnptr(target, points);
            }
            
            private static delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TexImage4DSGIS_fnptr = &TexImage4DSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_texture4D]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexImage4DSGIS(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, void* pixels) => _TexImage4DSGIS_fnptr(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TexImage4DSGIS_Lazy(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, void* pixels)
            {
                _TexImage4DSGIS_fnptr = (delegate* unmanaged<TextureTarget, int, InternalFormat, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexImage4DSGIS");
                _TexImage4DSGIS_fnptr(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
            }
            
            private static delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void> _TexSubImage4DSGIS_fnptr = &TexSubImage4DSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_texture4D]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexSubImage4DSGIS(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, void* pixels) => _TexSubImage4DSGIS_fnptr(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
            [UnmanagedCallersOnly]
            private static void TexSubImage4DSGIS_Lazy(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, void* pixels)
            {
                _TexSubImage4DSGIS_fnptr = (delegate* unmanaged<TextureTarget, int, int, int, int, int, int, int, int, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glTexSubImage4DSGIS");
                _TexSubImage4DSGIS_fnptr(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
            }
            
            private static delegate* unmanaged<byte, byte, byte, byte, void> _TextureColorMaskSGIS_fnptr = &TextureColorMaskSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_texture_color_mask]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureColorMaskSGIS(byte red, byte green, byte blue, byte alpha) => _TextureColorMaskSGIS_fnptr(red, green, blue, alpha);
            [UnmanagedCallersOnly]
            private static void TextureColorMaskSGIS_Lazy(byte red, byte green, byte blue, byte alpha)
            {
                _TextureColorMaskSGIS_fnptr = (delegate* unmanaged<byte, byte, byte, byte, void>)GLLoader.BindingsContext.GetProcAddress("glTextureColorMaskSGIS");
                _TextureColorMaskSGIS_fnptr(red, green, blue, alpha);
            }
            
            private static delegate* unmanaged<TextureTarget, TextureFilterSGIS, float*, void> _GetTexFilterFuncSGIS_fnptr = &GetTexFilterFuncSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_texture_filter4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, float* weights) => _GetTexFilterFuncSGIS_fnptr(target, filter, weights);
            [UnmanagedCallersOnly]
            private static void GetTexFilterFuncSGIS_Lazy(TextureTarget target, TextureFilterSGIS filter, float* weights)
            {
                _GetTexFilterFuncSGIS_fnptr = (delegate* unmanaged<TextureTarget, TextureFilterSGIS, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetTexFilterFuncSGIS");
                _GetTexFilterFuncSGIS_fnptr(target, filter, weights);
            }
            
            private static delegate* unmanaged<TextureTarget, TextureFilterSGIS, int, float*, void> _TexFilterFuncSGIS_fnptr = &TexFilterFuncSGIS_Lazy;
            /// <summary> <b>[requires: GL_SGIS_texture_filter4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, int n, float* weights) => _TexFilterFuncSGIS_fnptr(target, filter, n, weights);
            [UnmanagedCallersOnly]
            private static void TexFilterFuncSGIS_Lazy(TextureTarget target, TextureFilterSGIS filter, int n, float* weights)
            {
                _TexFilterFuncSGIS_fnptr = (delegate* unmanaged<TextureTarget, TextureFilterSGIS, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexFilterFuncSGIS");
                _TexFilterFuncSGIS_fnptr(target, filter, n, weights);
            }
            
        }
        public static unsafe partial class SGIX
        {
            private static delegate* unmanaged<uint, void> _AsyncMarkerSGIX_fnptr = &AsyncMarkerSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AsyncMarkerSGIX(uint marker) => _AsyncMarkerSGIX_fnptr(marker);
            [UnmanagedCallersOnly]
            private static void AsyncMarkerSGIX_Lazy(uint marker)
            {
                _AsyncMarkerSGIX_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glAsyncMarkerSGIX");
                _AsyncMarkerSGIX_fnptr(marker);
            }
            
            private static delegate* unmanaged<uint*, int> _FinishAsyncSGIX_fnptr = &FinishAsyncSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int FinishAsyncSGIX(uint* markerp) => _FinishAsyncSGIX_fnptr(markerp);
            [UnmanagedCallersOnly]
            private static int FinishAsyncSGIX_Lazy(uint* markerp)
            {
                _FinishAsyncSGIX_fnptr = (delegate* unmanaged<uint*, int>)GLLoader.BindingsContext.GetProcAddress("glFinishAsyncSGIX");
                return _FinishAsyncSGIX_fnptr(markerp);
            }
            
            private static delegate* unmanaged<uint*, int> _PollAsyncSGIX_fnptr = &PollAsyncSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int PollAsyncSGIX(uint* markerp) => _PollAsyncSGIX_fnptr(markerp);
            [UnmanagedCallersOnly]
            private static int PollAsyncSGIX_Lazy(uint* markerp)
            {
                _PollAsyncSGIX_fnptr = (delegate* unmanaged<uint*, int>)GLLoader.BindingsContext.GetProcAddress("glPollAsyncSGIX");
                return _PollAsyncSGIX_fnptr(markerp);
            }
            
            private static delegate* unmanaged<int, uint> _GenAsyncMarkersSGIX_fnptr = &GenAsyncMarkersSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenAsyncMarkersSGIX(int range) => _GenAsyncMarkersSGIX_fnptr(range);
            [UnmanagedCallersOnly]
            private static uint GenAsyncMarkersSGIX_Lazy(int range)
            {
                _GenAsyncMarkersSGIX_fnptr = (delegate* unmanaged<int, uint>)GLLoader.BindingsContext.GetProcAddress("glGenAsyncMarkersSGIX");
                return _GenAsyncMarkersSGIX_fnptr(range);
            }
            
            private static delegate* unmanaged<uint, int, void> _DeleteAsyncMarkersSGIX_fnptr = &DeleteAsyncMarkersSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteAsyncMarkersSGIX(uint marker, int range) => _DeleteAsyncMarkersSGIX_fnptr(marker, range);
            [UnmanagedCallersOnly]
            private static void DeleteAsyncMarkersSGIX_Lazy(uint marker, int range)
            {
                _DeleteAsyncMarkersSGIX_fnptr = (delegate* unmanaged<uint, int, void>)GLLoader.BindingsContext.GetProcAddress("glDeleteAsyncMarkersSGIX");
                _DeleteAsyncMarkersSGIX_fnptr(marker, range);
            }
            
            private static delegate* unmanaged<uint, byte> _IsAsyncMarkerSGIX_fnptr = &IsAsyncMarkerSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static byte IsAsyncMarkerSGIX(uint marker) => _IsAsyncMarkerSGIX_fnptr(marker);
            [UnmanagedCallersOnly]
            private static byte IsAsyncMarkerSGIX_Lazy(uint marker)
            {
                _IsAsyncMarkerSGIX_fnptr = (delegate* unmanaged<uint, byte>)GLLoader.BindingsContext.GetProcAddress("glIsAsyncMarkerSGIX");
                return _IsAsyncMarkerSGIX_fnptr(marker);
            }
            
            private static delegate* unmanaged<void> _FlushRasterSGIX_fnptr = &FlushRasterSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_flush_raster]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushRasterSGIX() => _FlushRasterSGIX_fnptr();
            [UnmanagedCallersOnly]
            private static void FlushRasterSGIX_Lazy()
            {
                _FlushRasterSGIX_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glFlushRasterSGIX");
                _FlushRasterSGIX_fnptr();
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, void> _FragmentColorMaterialSGIX_fnptr = &FragmentColorMaterialSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentColorMaterialSGIX(MaterialFace face, MaterialParameter mode) => _FragmentColorMaterialSGIX_fnptr(face, mode);
            [UnmanagedCallersOnly]
            private static void FragmentColorMaterialSGIX_Lazy(MaterialFace face, MaterialParameter mode)
            {
                _FragmentColorMaterialSGIX_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentColorMaterialSGIX");
                _FragmentColorMaterialSGIX_fnptr(face, mode);
            }
            
            private static delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, float, void> _FragmentLightfSGIX_fnptr = &FragmentLightfSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightfSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float param) => _FragmentLightfSGIX_fnptr(light, pname, param);
            [UnmanagedCallersOnly]
            private static void FragmentLightfSGIX_Lazy(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float param)
            {
                _FragmentLightfSGIX_fnptr = (delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, float, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentLightfSGIX");
                _FragmentLightfSGIX_fnptr(light, pname, param);
            }
            
            private static delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, float*, void> _FragmentLightfvSGIX_fnptr = &FragmentLightfvSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => _FragmentLightfvSGIX_fnptr(light, pname, parameters);
            [UnmanagedCallersOnly]
            private static void FragmentLightfvSGIX_Lazy(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters)
            {
                _FragmentLightfvSGIX_fnptr = (delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, float*, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentLightfvSGIX");
                _FragmentLightfvSGIX_fnptr(light, pname, parameters);
            }
            
            private static delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, int, void> _FragmentLightiSGIX_fnptr = &FragmentLightiSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightiSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int param) => _FragmentLightiSGIX_fnptr(light, pname, param);
            [UnmanagedCallersOnly]
            private static void FragmentLightiSGIX_Lazy(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int param)
            {
                _FragmentLightiSGIX_fnptr = (delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, int, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentLightiSGIX");
                _FragmentLightiSGIX_fnptr(light, pname, param);
            }
            
            private static delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, int*, void> _FragmentLightivSGIX_fnptr = &FragmentLightivSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => _FragmentLightivSGIX_fnptr(light, pname, parameters);
            [UnmanagedCallersOnly]
            private static void FragmentLightivSGIX_Lazy(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters)
            {
                _FragmentLightivSGIX_fnptr = (delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, int*, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentLightivSGIX");
                _FragmentLightivSGIX_fnptr(light, pname, parameters);
            }
            
            private static delegate* unmanaged<FragmentLightModelParameterSGIX, float, void> _FragmentLightModelfSGIX_fnptr = &FragmentLightModelfSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightModelfSGIX(FragmentLightModelParameterSGIX pname, float param) => _FragmentLightModelfSGIX_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void FragmentLightModelfSGIX_Lazy(FragmentLightModelParameterSGIX pname, float param)
            {
                _FragmentLightModelfSGIX_fnptr = (delegate* unmanaged<FragmentLightModelParameterSGIX, float, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentLightModelfSGIX");
                _FragmentLightModelfSGIX_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<FragmentLightModelParameterSGIX, float*, void> _FragmentLightModelfvSGIX_fnptr = &FragmentLightModelfvSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, float* parameters) => _FragmentLightModelfvSGIX_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void FragmentLightModelfvSGIX_Lazy(FragmentLightModelParameterSGIX pname, float* parameters)
            {
                _FragmentLightModelfvSGIX_fnptr = (delegate* unmanaged<FragmentLightModelParameterSGIX, float*, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentLightModelfvSGIX");
                _FragmentLightModelfvSGIX_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<FragmentLightModelParameterSGIX, int, void> _FragmentLightModeliSGIX_fnptr = &FragmentLightModeliSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightModeliSGIX(FragmentLightModelParameterSGIX pname, int param) => _FragmentLightModeliSGIX_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void FragmentLightModeliSGIX_Lazy(FragmentLightModelParameterSGIX pname, int param)
            {
                _FragmentLightModeliSGIX_fnptr = (delegate* unmanaged<FragmentLightModelParameterSGIX, int, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentLightModeliSGIX");
                _FragmentLightModeliSGIX_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<FragmentLightModelParameterSGIX, int*, void> _FragmentLightModelivSGIX_fnptr = &FragmentLightModelivSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, int* parameters) => _FragmentLightModelivSGIX_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void FragmentLightModelivSGIX_Lazy(FragmentLightModelParameterSGIX pname, int* parameters)
            {
                _FragmentLightModelivSGIX_fnptr = (delegate* unmanaged<FragmentLightModelParameterSGIX, int*, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentLightModelivSGIX");
                _FragmentLightModelivSGIX_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, float, void> _FragmentMaterialfSGIX_fnptr = &FragmentMaterialfSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentMaterialfSGIX(MaterialFace face, MaterialParameter pname, float param) => _FragmentMaterialfSGIX_fnptr(face, pname, param);
            [UnmanagedCallersOnly]
            private static void FragmentMaterialfSGIX_Lazy(MaterialFace face, MaterialParameter pname, float param)
            {
                _FragmentMaterialfSGIX_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, float, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentMaterialfSGIX");
                _FragmentMaterialfSGIX_fnptr(face, pname, param);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, float*, void> _FragmentMaterialfvSGIX_fnptr = &FragmentMaterialfvSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, float* parameters) => _FragmentMaterialfvSGIX_fnptr(face, pname, parameters);
            [UnmanagedCallersOnly]
            private static void FragmentMaterialfvSGIX_Lazy(MaterialFace face, MaterialParameter pname, float* parameters)
            {
                _FragmentMaterialfvSGIX_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentMaterialfvSGIX");
                _FragmentMaterialfvSGIX_fnptr(face, pname, parameters);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, int, void> _FragmentMaterialiSGIX_fnptr = &FragmentMaterialiSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentMaterialiSGIX(MaterialFace face, MaterialParameter pname, int param) => _FragmentMaterialiSGIX_fnptr(face, pname, param);
            [UnmanagedCallersOnly]
            private static void FragmentMaterialiSGIX_Lazy(MaterialFace face, MaterialParameter pname, int param)
            {
                _FragmentMaterialiSGIX_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentMaterialiSGIX");
                _FragmentMaterialiSGIX_fnptr(face, pname, param);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, int*, void> _FragmentMaterialivSGIX_fnptr = &FragmentMaterialivSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, int* parameters) => _FragmentMaterialivSGIX_fnptr(face, pname, parameters);
            [UnmanagedCallersOnly]
            private static void FragmentMaterialivSGIX_Lazy(MaterialFace face, MaterialParameter pname, int* parameters)
            {
                _FragmentMaterialivSGIX_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glFragmentMaterialivSGIX");
                _FragmentMaterialivSGIX_fnptr(face, pname, parameters);
            }
            
            private static delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, float*, void> _GetFragmentLightfvSGIX_fnptr = &GetFragmentLightfvSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => _GetFragmentLightfvSGIX_fnptr(light, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFragmentLightfvSGIX_Lazy(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters)
            {
                _GetFragmentLightfvSGIX_fnptr = (delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFragmentLightfvSGIX");
                _GetFragmentLightfvSGIX_fnptr(light, pname, parameters);
            }
            
            private static delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, int*, void> _GetFragmentLightivSGIX_fnptr = &GetFragmentLightivSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => _GetFragmentLightivSGIX_fnptr(light, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFragmentLightivSGIX_Lazy(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters)
            {
                _GetFragmentLightivSGIX_fnptr = (delegate* unmanaged<FragmentLightNameSGIX, FragmentLightParameterSGIX, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFragmentLightivSGIX");
                _GetFragmentLightivSGIX_fnptr(light, pname, parameters);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, float*, void> _GetFragmentMaterialfvSGIX_fnptr = &GetFragmentMaterialfvSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, float* parameters) => _GetFragmentMaterialfvSGIX_fnptr(face, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFragmentMaterialfvSGIX_Lazy(MaterialFace face, MaterialParameter pname, float* parameters)
            {
                _GetFragmentMaterialfvSGIX_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFragmentMaterialfvSGIX");
                _GetFragmentMaterialfvSGIX_fnptr(face, pname, parameters);
            }
            
            private static delegate* unmanaged<MaterialFace, MaterialParameter, int*, void> _GetFragmentMaterialivSGIX_fnptr = &GetFragmentMaterialivSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, int* parameters) => _GetFragmentMaterialivSGIX_fnptr(face, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetFragmentMaterialivSGIX_Lazy(MaterialFace face, MaterialParameter pname, int* parameters)
            {
                _GetFragmentMaterialivSGIX_fnptr = (delegate* unmanaged<MaterialFace, MaterialParameter, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetFragmentMaterialivSGIX");
                _GetFragmentMaterialivSGIX_fnptr(face, pname, parameters);
            }
            
            private static delegate* unmanaged<LightEnvParameterSGIX, int, void> _LightEnviSGIX_fnptr = &LightEnviSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightEnviSGIX(LightEnvParameterSGIX pname, int param) => _LightEnviSGIX_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void LightEnviSGIX_Lazy(LightEnvParameterSGIX pname, int param)
            {
                _LightEnviSGIX_fnptr = (delegate* unmanaged<LightEnvParameterSGIX, int, void>)GLLoader.BindingsContext.GetProcAddress("glLightEnviSGIX");
                _LightEnviSGIX_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<int, void> _FrameZoomSGIX_fnptr = &FrameZoomSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_framezoom]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FrameZoomSGIX(int factor) => _FrameZoomSGIX_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void FrameZoomSGIX_Lazy(int factor)
            {
                _FrameZoomSGIX_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glFrameZoomSGIX");
                _FrameZoomSGIX_fnptr(factor);
            }
            
            private static delegate* unmanaged<All, void*, void> _IglooInterfaceSGIX_fnptr = &IglooInterfaceSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_igloo_interface]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IglooInterfaceSGIX(All pname, void* parameters) => _IglooInterfaceSGIX_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void IglooInterfaceSGIX_Lazy(All pname, void* parameters)
            {
                _IglooInterfaceSGIX_fnptr = (delegate* unmanaged<All, void*, void>)GLLoader.BindingsContext.GetProcAddress("glIglooInterfaceSGIX");
                _IglooInterfaceSGIX_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<int> _GetInstrumentsSGIX_fnptr = &GetInstrumentsSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetInstrumentsSGIX() => _GetInstrumentsSGIX_fnptr();
            [UnmanagedCallersOnly]
            private static int GetInstrumentsSGIX_Lazy()
            {
                _GetInstrumentsSGIX_fnptr = (delegate* unmanaged<int>)GLLoader.BindingsContext.GetProcAddress("glGetInstrumentsSGIX");
                return _GetInstrumentsSGIX_fnptr();
            }
            
            private static delegate* unmanaged<int, int*, void> _InstrumentsBufferSGIX_fnptr = &InstrumentsBufferSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void InstrumentsBufferSGIX(int size, int* buffer) => _InstrumentsBufferSGIX_fnptr(size, buffer);
            [UnmanagedCallersOnly]
            private static void InstrumentsBufferSGIX_Lazy(int size, int* buffer)
            {
                _InstrumentsBufferSGIX_fnptr = (delegate* unmanaged<int, int*, void>)GLLoader.BindingsContext.GetProcAddress("glInstrumentsBufferSGIX");
                _InstrumentsBufferSGIX_fnptr(size, buffer);
            }
            
            private static delegate* unmanaged<int*, int> _PollInstrumentsSGIX_fnptr = &PollInstrumentsSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int PollInstrumentsSGIX(int* marker_p) => _PollInstrumentsSGIX_fnptr(marker_p);
            [UnmanagedCallersOnly]
            private static int PollInstrumentsSGIX_Lazy(int* marker_p)
            {
                _PollInstrumentsSGIX_fnptr = (delegate* unmanaged<int*, int>)GLLoader.BindingsContext.GetProcAddress("glPollInstrumentsSGIX");
                return _PollInstrumentsSGIX_fnptr(marker_p);
            }
            
            private static delegate* unmanaged<int, void> _ReadInstrumentsSGIX_fnptr = &ReadInstrumentsSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReadInstrumentsSGIX(int marker) => _ReadInstrumentsSGIX_fnptr(marker);
            [UnmanagedCallersOnly]
            private static void ReadInstrumentsSGIX_Lazy(int marker)
            {
                _ReadInstrumentsSGIX_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glReadInstrumentsSGIX");
                _ReadInstrumentsSGIX_fnptr(marker);
            }
            
            private static delegate* unmanaged<void> _StartInstrumentsSGIX_fnptr = &StartInstrumentsSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StartInstrumentsSGIX() => _StartInstrumentsSGIX_fnptr();
            [UnmanagedCallersOnly]
            private static void StartInstrumentsSGIX_Lazy()
            {
                _StartInstrumentsSGIX_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glStartInstrumentsSGIX");
                _StartInstrumentsSGIX_fnptr();
            }
            
            private static delegate* unmanaged<int, void> _StopInstrumentsSGIX_fnptr = &StopInstrumentsSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StopInstrumentsSGIX(int marker) => _StopInstrumentsSGIX_fnptr(marker);
            [UnmanagedCallersOnly]
            private static void StopInstrumentsSGIX_Lazy(int marker)
            {
                _StopInstrumentsSGIX_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glStopInstrumentsSGIX");
                _StopInstrumentsSGIX_fnptr(marker);
            }
            
            private static delegate* unmanaged<uint, ListParameterName, float*, void> _GetListParameterfvSGIX_fnptr = &GetListParameterfvSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetListParameterfvSGIX(uint list, ListParameterName pname, float* parameters) => _GetListParameterfvSGIX_fnptr(list, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetListParameterfvSGIX_Lazy(uint list, ListParameterName pname, float* parameters)
            {
                _GetListParameterfvSGIX_fnptr = (delegate* unmanaged<uint, ListParameterName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetListParameterfvSGIX");
                _GetListParameterfvSGIX_fnptr(list, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, ListParameterName, int*, void> _GetListParameterivSGIX_fnptr = &GetListParameterivSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetListParameterivSGIX(uint list, ListParameterName pname, int* parameters) => _GetListParameterivSGIX_fnptr(list, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetListParameterivSGIX_Lazy(uint list, ListParameterName pname, int* parameters)
            {
                _GetListParameterivSGIX_fnptr = (delegate* unmanaged<uint, ListParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetListParameterivSGIX");
                _GetListParameterivSGIX_fnptr(list, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, ListParameterName, float, void> _ListParameterfSGIX_fnptr = &ListParameterfSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListParameterfSGIX(uint list, ListParameterName pname, float param) => _ListParameterfSGIX_fnptr(list, pname, param);
            [UnmanagedCallersOnly]
            private static void ListParameterfSGIX_Lazy(uint list, ListParameterName pname, float param)
            {
                _ListParameterfSGIX_fnptr = (delegate* unmanaged<uint, ListParameterName, float, void>)GLLoader.BindingsContext.GetProcAddress("glListParameterfSGIX");
                _ListParameterfSGIX_fnptr(list, pname, param);
            }
            
            private static delegate* unmanaged<uint, ListParameterName, float*, void> _ListParameterfvSGIX_fnptr = &ListParameterfvSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListParameterfvSGIX(uint list, ListParameterName pname, float* parameters) => _ListParameterfvSGIX_fnptr(list, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ListParameterfvSGIX_Lazy(uint list, ListParameterName pname, float* parameters)
            {
                _ListParameterfvSGIX_fnptr = (delegate* unmanaged<uint, ListParameterName, float*, void>)GLLoader.BindingsContext.GetProcAddress("glListParameterfvSGIX");
                _ListParameterfvSGIX_fnptr(list, pname, parameters);
            }
            
            private static delegate* unmanaged<uint, ListParameterName, int, void> _ListParameteriSGIX_fnptr = &ListParameteriSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListParameteriSGIX(uint list, ListParameterName pname, int param) => _ListParameteriSGIX_fnptr(list, pname, param);
            [UnmanagedCallersOnly]
            private static void ListParameteriSGIX_Lazy(uint list, ListParameterName pname, int param)
            {
                _ListParameteriSGIX_fnptr = (delegate* unmanaged<uint, ListParameterName, int, void>)GLLoader.BindingsContext.GetProcAddress("glListParameteriSGIX");
                _ListParameteriSGIX_fnptr(list, pname, param);
            }
            
            private static delegate* unmanaged<uint, ListParameterName, int*, void> _ListParameterivSGIX_fnptr = &ListParameterivSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListParameterivSGIX(uint list, ListParameterName pname, int* parameters) => _ListParameterivSGIX_fnptr(list, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ListParameterivSGIX_Lazy(uint list, ListParameterName pname, int* parameters)
            {
                _ListParameterivSGIX_fnptr = (delegate* unmanaged<uint, ListParameterName, int*, void>)GLLoader.BindingsContext.GetProcAddress("glListParameterivSGIX");
                _ListParameterivSGIX_fnptr(list, pname, parameters);
            }
            
            private static delegate* unmanaged<PixelTexGenModeSGIX, void> _PixelTexGenSGIX_fnptr = &PixelTexGenSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenSGIX(PixelTexGenModeSGIX mode) => _PixelTexGenSGIX_fnptr(mode);
            [UnmanagedCallersOnly]
            private static void PixelTexGenSGIX_Lazy(PixelTexGenModeSGIX mode)
            {
                _PixelTexGenSGIX_fnptr = (delegate* unmanaged<PixelTexGenModeSGIX, void>)GLLoader.BindingsContext.GetProcAddress("glPixelTexGenSGIX");
                _PixelTexGenSGIX_fnptr(mode);
            }
            
            private static delegate* unmanaged<FfdTargetSGIX, double, double, int, int, double, double, int, int, double, double, int, int, double*, void> _DeformationMap3dSGIX_fnptr = &DeformationMap3dSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double* points) => _DeformationMap3dSGIX_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            [UnmanagedCallersOnly]
            private static void DeformationMap3dSGIX_Lazy(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double* points)
            {
                _DeformationMap3dSGIX_fnptr = (delegate* unmanaged<FfdTargetSGIX, double, double, int, int, double, double, int, int, double, double, int, int, double*, void>)GLLoader.BindingsContext.GetProcAddress("glDeformationMap3dSGIX");
                _DeformationMap3dSGIX_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            }
            
            private static delegate* unmanaged<FfdTargetSGIX, float, float, int, int, float, float, int, int, float, float, int, int, float*, void> _DeformationMap3fSGIX_fnptr = &DeformationMap3fSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float* points) => _DeformationMap3fSGIX_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            [UnmanagedCallersOnly]
            private static void DeformationMap3fSGIX_Lazy(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float* points)
            {
                _DeformationMap3fSGIX_fnptr = (delegate* unmanaged<FfdTargetSGIX, float, float, int, int, float, float, int, int, float, float, int, int, float*, void>)GLLoader.BindingsContext.GetProcAddress("glDeformationMap3fSGIX");
                _DeformationMap3fSGIX_fnptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            }
            
            private static delegate* unmanaged<FfdMaskSGIX, void> _DeformSGIX_fnptr = &DeformSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeformSGIX(FfdMaskSGIX mask) => _DeformSGIX_fnptr(mask);
            [UnmanagedCallersOnly]
            private static void DeformSGIX_Lazy(FfdMaskSGIX mask)
            {
                _DeformSGIX_fnptr = (delegate* unmanaged<FfdMaskSGIX, void>)GLLoader.BindingsContext.GetProcAddress("glDeformSGIX");
                _DeformSGIX_fnptr(mask);
            }
            
            private static delegate* unmanaged<FfdMaskSGIX, void> _LoadIdentityDeformationMapSGIX_fnptr = &LoadIdentityDeformationMapSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadIdentityDeformationMapSGIX(FfdMaskSGIX mask) => _LoadIdentityDeformationMapSGIX_fnptr(mask);
            [UnmanagedCallersOnly]
            private static void LoadIdentityDeformationMapSGIX_Lazy(FfdMaskSGIX mask)
            {
                _LoadIdentityDeformationMapSGIX_fnptr = (delegate* unmanaged<FfdMaskSGIX, void>)GLLoader.BindingsContext.GetProcAddress("glLoadIdentityDeformationMapSGIX");
                _LoadIdentityDeformationMapSGIX_fnptr(mask);
            }
            
            private static delegate* unmanaged<double*, void> _ReferencePlaneSGIX_fnptr = &ReferencePlaneSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_reference_plane]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReferencePlaneSGIX(double* equation) => _ReferencePlaneSGIX_fnptr(equation);
            [UnmanagedCallersOnly]
            private static void ReferencePlaneSGIX_Lazy(double* equation)
            {
                _ReferencePlaneSGIX_fnptr = (delegate* unmanaged<double*, void>)GLLoader.BindingsContext.GetProcAddress("glReferencePlaneSGIX");
                _ReferencePlaneSGIX_fnptr(equation);
            }
            
            private static delegate* unmanaged<SpriteParameterNameSGIX, float, void> _SpriteParameterfSGIX_fnptr = &SpriteParameterfSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpriteParameterfSGIX(SpriteParameterNameSGIX pname, float param) => _SpriteParameterfSGIX_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void SpriteParameterfSGIX_Lazy(SpriteParameterNameSGIX pname, float param)
            {
                _SpriteParameterfSGIX_fnptr = (delegate* unmanaged<SpriteParameterNameSGIX, float, void>)GLLoader.BindingsContext.GetProcAddress("glSpriteParameterfSGIX");
                _SpriteParameterfSGIX_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<SpriteParameterNameSGIX, float*, void> _SpriteParameterfvSGIX_fnptr = &SpriteParameterfvSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, float* parameters) => _SpriteParameterfvSGIX_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void SpriteParameterfvSGIX_Lazy(SpriteParameterNameSGIX pname, float* parameters)
            {
                _SpriteParameterfvSGIX_fnptr = (delegate* unmanaged<SpriteParameterNameSGIX, float*, void>)GLLoader.BindingsContext.GetProcAddress("glSpriteParameterfvSGIX");
                _SpriteParameterfvSGIX_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<SpriteParameterNameSGIX, int, void> _SpriteParameteriSGIX_fnptr = &SpriteParameteriSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpriteParameteriSGIX(SpriteParameterNameSGIX pname, int param) => _SpriteParameteriSGIX_fnptr(pname, param);
            [UnmanagedCallersOnly]
            private static void SpriteParameteriSGIX_Lazy(SpriteParameterNameSGIX pname, int param)
            {
                _SpriteParameteriSGIX_fnptr = (delegate* unmanaged<SpriteParameterNameSGIX, int, void>)GLLoader.BindingsContext.GetProcAddress("glSpriteParameteriSGIX");
                _SpriteParameteriSGIX_fnptr(pname, param);
            }
            
            private static delegate* unmanaged<SpriteParameterNameSGIX, int*, void> _SpriteParameterivSGIX_fnptr = &SpriteParameterivSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, int* parameters) => _SpriteParameterivSGIX_fnptr(pname, parameters);
            [UnmanagedCallersOnly]
            private static void SpriteParameterivSGIX_Lazy(SpriteParameterNameSGIX pname, int* parameters)
            {
                _SpriteParameterivSGIX_fnptr = (delegate* unmanaged<SpriteParameterNameSGIX, int*, void>)GLLoader.BindingsContext.GetProcAddress("glSpriteParameterivSGIX");
                _SpriteParameterivSGIX_fnptr(pname, parameters);
            }
            
            private static delegate* unmanaged<void> _TagSampleBufferSGIX_fnptr = &TagSampleBufferSGIX_Lazy;
            /// <summary> <b>[requires: GL_SGIX_tag_sample_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TagSampleBufferSGIX() => _TagSampleBufferSGIX_fnptr();
            [UnmanagedCallersOnly]
            private static void TagSampleBufferSGIX_Lazy()
            {
                _TagSampleBufferSGIX_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glTagSampleBufferSGIX");
                _TagSampleBufferSGIX_fnptr();
            }
            
        }
        public static unsafe partial class SGI
        {
            private static delegate* unmanaged<ColorTableTargetSGI, InternalFormat, int, PixelFormat, PixelType, void*, void> _ColorTableSGI_fnptr = &ColorTableSGI_Lazy;
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table) => _ColorTableSGI_fnptr(target, internalformat, width, format, type, table);
            [UnmanagedCallersOnly]
            private static void ColorTableSGI_Lazy(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table)
            {
                _ColorTableSGI_fnptr = (delegate* unmanaged<ColorTableTargetSGI, InternalFormat, int, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glColorTableSGI");
                _ColorTableSGI_fnptr(target, internalformat, width, format, type, table);
            }
            
            private static delegate* unmanaged<ColorTableTargetSGI, ColorTableParameterPNameSGI, float*, void> _ColorTableParameterfvSGI_fnptr = &ColorTableParameterfvSGI_Lazy;
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, float* parameters) => _ColorTableParameterfvSGI_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ColorTableParameterfvSGI_Lazy(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, float* parameters)
            {
                _ColorTableParameterfvSGI_fnptr = (delegate* unmanaged<ColorTableTargetSGI, ColorTableParameterPNameSGI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glColorTableParameterfvSGI");
                _ColorTableParameterfvSGI_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ColorTableTargetSGI, ColorTableParameterPNameSGI, int*, void> _ColorTableParameterivSGI_fnptr = &ColorTableParameterivSGI_Lazy;
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, int* parameters) => _ColorTableParameterivSGI_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void ColorTableParameterivSGI_Lazy(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, int* parameters)
            {
                _ColorTableParameterivSGI_fnptr = (delegate* unmanaged<ColorTableTargetSGI, ColorTableParameterPNameSGI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glColorTableParameterivSGI");
                _ColorTableParameterivSGI_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ColorTableTargetSGI, InternalFormat, int, int, int, void> _CopyColorTableSGI_fnptr = &CopyColorTableSGI_Lazy;
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int x, int y, int width) => _CopyColorTableSGI_fnptr(target, internalformat, x, y, width);
            [UnmanagedCallersOnly]
            private static void CopyColorTableSGI_Lazy(ColorTableTargetSGI target, InternalFormat internalformat, int x, int y, int width)
            {
                _CopyColorTableSGI_fnptr = (delegate* unmanaged<ColorTableTargetSGI, InternalFormat, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glCopyColorTableSGI");
                _CopyColorTableSGI_fnptr(target, internalformat, x, y, width);
            }
            
            private static delegate* unmanaged<ColorTableTargetSGI, PixelFormat, PixelType, void*, void> _GetColorTableSGI_fnptr = &GetColorTableSGI_Lazy;
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableSGI(ColorTableTargetSGI target, PixelFormat format, PixelType type, void* table) => _GetColorTableSGI_fnptr(target, format, type, table);
            [UnmanagedCallersOnly]
            private static void GetColorTableSGI_Lazy(ColorTableTargetSGI target, PixelFormat format, PixelType type, void* table)
            {
                _GetColorTableSGI_fnptr = (delegate* unmanaged<ColorTableTargetSGI, PixelFormat, PixelType, void*, void>)GLLoader.BindingsContext.GetProcAddress("glGetColorTableSGI");
                _GetColorTableSGI_fnptr(target, format, type, table);
            }
            
            private static delegate* unmanaged<ColorTableTargetSGI, GetColorTableParameterPNameSGI, float*, void> _GetColorTableParameterfvSGI_fnptr = &GetColorTableParameterfvSGI_Lazy;
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableParameterfvSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, float* parameters) => _GetColorTableParameterfvSGI_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetColorTableParameterfvSGI_Lazy(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, float* parameters)
            {
                _GetColorTableParameterfvSGI_fnptr = (delegate* unmanaged<ColorTableTargetSGI, GetColorTableParameterPNameSGI, float*, void>)GLLoader.BindingsContext.GetProcAddress("glGetColorTableParameterfvSGI");
                _GetColorTableParameterfvSGI_fnptr(target, pname, parameters);
            }
            
            private static delegate* unmanaged<ColorTableTargetSGI, GetColorTableParameterPNameSGI, int*, void> _GetColorTableParameterivSGI_fnptr = &GetColorTableParameterivSGI_Lazy;
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableParameterivSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, int* parameters) => _GetColorTableParameterivSGI_fnptr(target, pname, parameters);
            [UnmanagedCallersOnly]
            private static void GetColorTableParameterivSGI_Lazy(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, int* parameters)
            {
                _GetColorTableParameterivSGI_fnptr = (delegate* unmanaged<ColorTableTargetSGI, GetColorTableParameterPNameSGI, int*, void>)GLLoader.BindingsContext.GetProcAddress("glGetColorTableParameterivSGI");
                _GetColorTableParameterivSGI_fnptr(target, pname, parameters);
            }
            
        }
        public static unsafe partial class SUNX
        {
            private static delegate* unmanaged<void> _FinishTextureSUNX_fnptr = &FinishTextureSUNX_Lazy;
            /// <summary> <b>[requires: GL_SUNX_constant_data]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinishTextureSUNX() => _FinishTextureSUNX_fnptr();
            [UnmanagedCallersOnly]
            private static void FinishTextureSUNX_Lazy()
            {
                _FinishTextureSUNX_fnptr = (delegate* unmanaged<void>)GLLoader.BindingsContext.GetProcAddress("glFinishTextureSUNX");
                _FinishTextureSUNX_fnptr();
            }
            
        }
        public static unsafe partial class SUN
        {
            private static delegate* unmanaged<sbyte, void> _GlobalAlphaFactorbSUN_fnptr = &GlobalAlphaFactorbSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorbSUN(sbyte factor) => _GlobalAlphaFactorbSUN_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void GlobalAlphaFactorbSUN_Lazy(sbyte factor)
            {
                _GlobalAlphaFactorbSUN_fnptr = (delegate* unmanaged<sbyte, void>)GLLoader.BindingsContext.GetProcAddress("glGlobalAlphaFactorbSUN");
                _GlobalAlphaFactorbSUN_fnptr(factor);
            }
            
            private static delegate* unmanaged<short, void> _GlobalAlphaFactorsSUN_fnptr = &GlobalAlphaFactorsSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorsSUN(short factor) => _GlobalAlphaFactorsSUN_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void GlobalAlphaFactorsSUN_Lazy(short factor)
            {
                _GlobalAlphaFactorsSUN_fnptr = (delegate* unmanaged<short, void>)GLLoader.BindingsContext.GetProcAddress("glGlobalAlphaFactorsSUN");
                _GlobalAlphaFactorsSUN_fnptr(factor);
            }
            
            private static delegate* unmanaged<int, void> _GlobalAlphaFactoriSUN_fnptr = &GlobalAlphaFactoriSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactoriSUN(int factor) => _GlobalAlphaFactoriSUN_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void GlobalAlphaFactoriSUN_Lazy(int factor)
            {
                _GlobalAlphaFactoriSUN_fnptr = (delegate* unmanaged<int, void>)GLLoader.BindingsContext.GetProcAddress("glGlobalAlphaFactoriSUN");
                _GlobalAlphaFactoriSUN_fnptr(factor);
            }
            
            private static delegate* unmanaged<float, void> _GlobalAlphaFactorfSUN_fnptr = &GlobalAlphaFactorfSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorfSUN(float factor) => _GlobalAlphaFactorfSUN_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void GlobalAlphaFactorfSUN_Lazy(float factor)
            {
                _GlobalAlphaFactorfSUN_fnptr = (delegate* unmanaged<float, void>)GLLoader.BindingsContext.GetProcAddress("glGlobalAlphaFactorfSUN");
                _GlobalAlphaFactorfSUN_fnptr(factor);
            }
            
            private static delegate* unmanaged<double, void> _GlobalAlphaFactordSUN_fnptr = &GlobalAlphaFactordSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactordSUN(double factor) => _GlobalAlphaFactordSUN_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void GlobalAlphaFactordSUN_Lazy(double factor)
            {
                _GlobalAlphaFactordSUN_fnptr = (delegate* unmanaged<double, void>)GLLoader.BindingsContext.GetProcAddress("glGlobalAlphaFactordSUN");
                _GlobalAlphaFactordSUN_fnptr(factor);
            }
            
            private static delegate* unmanaged<byte, void> _GlobalAlphaFactorubSUN_fnptr = &GlobalAlphaFactorubSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorubSUN(byte factor) => _GlobalAlphaFactorubSUN_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void GlobalAlphaFactorubSUN_Lazy(byte factor)
            {
                _GlobalAlphaFactorubSUN_fnptr = (delegate* unmanaged<byte, void>)GLLoader.BindingsContext.GetProcAddress("glGlobalAlphaFactorubSUN");
                _GlobalAlphaFactorubSUN_fnptr(factor);
            }
            
            private static delegate* unmanaged<ushort, void> _GlobalAlphaFactorusSUN_fnptr = &GlobalAlphaFactorusSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorusSUN(ushort factor) => _GlobalAlphaFactorusSUN_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void GlobalAlphaFactorusSUN_Lazy(ushort factor)
            {
                _GlobalAlphaFactorusSUN_fnptr = (delegate* unmanaged<ushort, void>)GLLoader.BindingsContext.GetProcAddress("glGlobalAlphaFactorusSUN");
                _GlobalAlphaFactorusSUN_fnptr(factor);
            }
            
            private static delegate* unmanaged<uint, void> _GlobalAlphaFactoruiSUN_fnptr = &GlobalAlphaFactoruiSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactoruiSUN(uint factor) => _GlobalAlphaFactoruiSUN_fnptr(factor);
            [UnmanagedCallersOnly]
            private static void GlobalAlphaFactoruiSUN_Lazy(uint factor)
            {
                _GlobalAlphaFactoruiSUN_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glGlobalAlphaFactoruiSUN");
                _GlobalAlphaFactoruiSUN_fnptr(factor);
            }
            
            private static delegate* unmanaged<PrimitiveType, int, int, int, void> _DrawMeshArraysSUN_fnptr = &DrawMeshArraysSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_mesh_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawMeshArraysSUN(PrimitiveType mode, int first, int count, int width) => _DrawMeshArraysSUN_fnptr(mode, first, count, width);
            [UnmanagedCallersOnly]
            private static void DrawMeshArraysSUN_Lazy(PrimitiveType mode, int first, int count, int width)
            {
                _DrawMeshArraysSUN_fnptr = (delegate* unmanaged<PrimitiveType, int, int, int, void>)GLLoader.BindingsContext.GetProcAddress("glDrawMeshArraysSUN");
                _DrawMeshArraysSUN_fnptr(mode, first, count, width);
            }
            
            private static delegate* unmanaged<uint, void> _ReplacementCodeuiSUN_fnptr = &ReplacementCodeuiSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiSUN(uint code) => _ReplacementCodeuiSUN_fnptr(code);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiSUN_Lazy(uint code)
            {
                _ReplacementCodeuiSUN_fnptr = (delegate* unmanaged<uint, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiSUN");
                _ReplacementCodeuiSUN_fnptr(code);
            }
            
            private static delegate* unmanaged<ushort, void> _ReplacementCodeusSUN_fnptr = &ReplacementCodeusSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeusSUN(ushort code) => _ReplacementCodeusSUN_fnptr(code);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeusSUN_Lazy(ushort code)
            {
                _ReplacementCodeusSUN_fnptr = (delegate* unmanaged<ushort, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeusSUN");
                _ReplacementCodeusSUN_fnptr(code);
            }
            
            private static delegate* unmanaged<byte, void> _ReplacementCodeubSUN_fnptr = &ReplacementCodeubSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeubSUN(byte code) => _ReplacementCodeubSUN_fnptr(code);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeubSUN_Lazy(byte code)
            {
                _ReplacementCodeubSUN_fnptr = (delegate* unmanaged<byte, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeubSUN");
                _ReplacementCodeubSUN_fnptr(code);
            }
            
            private static delegate* unmanaged<uint*, void> _ReplacementCodeuivSUN_fnptr = &ReplacementCodeuivSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuivSUN(uint* code) => _ReplacementCodeuivSUN_fnptr(code);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuivSUN_Lazy(uint* code)
            {
                _ReplacementCodeuivSUN_fnptr = (delegate* unmanaged<uint*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuivSUN");
                _ReplacementCodeuivSUN_fnptr(code);
            }
            
            private static delegate* unmanaged<ushort*, void> _ReplacementCodeusvSUN_fnptr = &ReplacementCodeusvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeusvSUN(ushort* code) => _ReplacementCodeusvSUN_fnptr(code);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeusvSUN_Lazy(ushort* code)
            {
                _ReplacementCodeusvSUN_fnptr = (delegate* unmanaged<ushort*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeusvSUN");
                _ReplacementCodeusvSUN_fnptr(code);
            }
            
            private static delegate* unmanaged<byte*, void> _ReplacementCodeubvSUN_fnptr = &ReplacementCodeubvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeubvSUN(byte* code) => _ReplacementCodeubvSUN_fnptr(code);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeubvSUN_Lazy(byte* code)
            {
                _ReplacementCodeubvSUN_fnptr = (delegate* unmanaged<byte*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeubvSUN");
                _ReplacementCodeubvSUN_fnptr(code);
            }
            
            private static delegate* unmanaged<ReplacementCodeTypeSUN, int, void**, void> _ReplacementCodePointerSUN_fnptr = &ReplacementCodePointerSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodePointerSUN(ReplacementCodeTypeSUN type, int stride, void** pointer) => _ReplacementCodePointerSUN_fnptr(type, stride, pointer);
            [UnmanagedCallersOnly]
            private static void ReplacementCodePointerSUN_Lazy(ReplacementCodeTypeSUN type, int stride, void** pointer)
            {
                _ReplacementCodePointerSUN_fnptr = (delegate* unmanaged<ReplacementCodeTypeSUN, int, void**, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodePointerSUN");
                _ReplacementCodePointerSUN_fnptr(type, stride, pointer);
            }
            
            private static delegate* unmanaged<byte, byte, byte, byte, float, float, void> _Color4ubVertex2fSUN_fnptr = &Color4ubVertex2fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4ubVertex2fSUN(byte r, byte g, byte b, byte a, float x, float y) => _Color4ubVertex2fSUN_fnptr(r, g, b, a, x, y);
            [UnmanagedCallersOnly]
            private static void Color4ubVertex2fSUN_Lazy(byte r, byte g, byte b, byte a, float x, float y)
            {
                _Color4ubVertex2fSUN_fnptr = (delegate* unmanaged<byte, byte, byte, byte, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glColor4ubVertex2fSUN");
                _Color4ubVertex2fSUN_fnptr(r, g, b, a, x, y);
            }
            
            private static delegate* unmanaged<byte*, float*, void> _Color4ubVertex2fvSUN_fnptr = &Color4ubVertex2fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4ubVertex2fvSUN(byte* c, float* v) => _Color4ubVertex2fvSUN_fnptr(c, v);
            [UnmanagedCallersOnly]
            private static void Color4ubVertex2fvSUN_Lazy(byte* c, float* v)
            {
                _Color4ubVertex2fvSUN_fnptr = (delegate* unmanaged<byte*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4ubVertex2fvSUN");
                _Color4ubVertex2fvSUN_fnptr(c, v);
            }
            
            private static delegate* unmanaged<byte, byte, byte, byte, float, float, float, void> _Color4ubVertex3fSUN_fnptr = &Color4ubVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4ubVertex3fSUN(byte r, byte g, byte b, byte a, float x, float y, float z) => _Color4ubVertex3fSUN_fnptr(r, g, b, a, x, y, z);
            [UnmanagedCallersOnly]
            private static void Color4ubVertex3fSUN_Lazy(byte r, byte g, byte b, byte a, float x, float y, float z)
            {
                _Color4ubVertex3fSUN_fnptr = (delegate* unmanaged<byte, byte, byte, byte, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glColor4ubVertex3fSUN");
                _Color4ubVertex3fSUN_fnptr(r, g, b, a, x, y, z);
            }
            
            private static delegate* unmanaged<byte*, float*, void> _Color4ubVertex3fvSUN_fnptr = &Color4ubVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4ubVertex3fvSUN(byte* c, float* v) => _Color4ubVertex3fvSUN_fnptr(c, v);
            [UnmanagedCallersOnly]
            private static void Color4ubVertex3fvSUN_Lazy(byte* c, float* v)
            {
                _Color4ubVertex3fvSUN_fnptr = (delegate* unmanaged<byte*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4ubVertex3fvSUN");
                _Color4ubVertex3fvSUN_fnptr(c, v);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, void> _Color3fVertex3fSUN_fnptr = &Color3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3fVertex3fSUN(float r, float g, float b, float x, float y, float z) => _Color3fVertex3fSUN_fnptr(r, g, b, x, y, z);
            [UnmanagedCallersOnly]
            private static void Color3fVertex3fSUN_Lazy(float r, float g, float b, float x, float y, float z)
            {
                _Color3fVertex3fSUN_fnptr = (delegate* unmanaged<float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glColor3fVertex3fSUN");
                _Color3fVertex3fSUN_fnptr(r, g, b, x, y, z);
            }
            
            private static delegate* unmanaged<float*, float*, void> _Color3fVertex3fvSUN_fnptr = &Color3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3fVertex3fvSUN(float* c, float* v) => _Color3fVertex3fvSUN_fnptr(c, v);
            [UnmanagedCallersOnly]
            private static void Color3fVertex3fvSUN_Lazy(float* c, float* v)
            {
                _Color3fVertex3fvSUN_fnptr = (delegate* unmanaged<float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glColor3fVertex3fvSUN");
                _Color3fVertex3fvSUN_fnptr(c, v);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, void> _Normal3fVertex3fSUN_fnptr = &Normal3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3fVertex3fSUN(float nx, float ny, float nz, float x, float y, float z) => _Normal3fVertex3fSUN_fnptr(nx, ny, nz, x, y, z);
            [UnmanagedCallersOnly]
            private static void Normal3fVertex3fSUN_Lazy(float nx, float ny, float nz, float x, float y, float z)
            {
                _Normal3fVertex3fSUN_fnptr = (delegate* unmanaged<float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3fVertex3fSUN");
                _Normal3fVertex3fSUN_fnptr(nx, ny, nz, x, y, z);
            }
            
            private static delegate* unmanaged<float*, float*, void> _Normal3fVertex3fvSUN_fnptr = &Normal3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3fVertex3fvSUN(float* n, float* v) => _Normal3fVertex3fvSUN_fnptr(n, v);
            [UnmanagedCallersOnly]
            private static void Normal3fVertex3fvSUN_Lazy(float* n, float* v)
            {
                _Normal3fVertex3fvSUN_fnptr = (delegate* unmanaged<float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glNormal3fVertex3fvSUN");
                _Normal3fVertex3fvSUN_fnptr(n, v);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, float, float, float, float, void> _Color4fNormal3fVertex3fSUN_fnptr = &Color4fNormal3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4fNormal3fVertex3fSUN(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => _Color4fNormal3fVertex3fSUN_fnptr(r, g, b, a, nx, ny, nz, x, y, z);
            [UnmanagedCallersOnly]
            private static void Color4fNormal3fVertex3fSUN_Lazy(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z)
            {
                _Color4fNormal3fVertex3fSUN_fnptr = (delegate* unmanaged<float, float, float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glColor4fNormal3fVertex3fSUN");
                _Color4fNormal3fVertex3fSUN_fnptr(r, g, b, a, nx, ny, nz, x, y, z);
            }
            
            private static delegate* unmanaged<float*, float*, float*, void> _Color4fNormal3fVertex3fvSUN_fnptr = &Color4fNormal3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4fNormal3fVertex3fvSUN(float* c, float* n, float* v) => _Color4fNormal3fVertex3fvSUN_fnptr(c, n, v);
            [UnmanagedCallersOnly]
            private static void Color4fNormal3fVertex3fvSUN_Lazy(float* c, float* n, float* v)
            {
                _Color4fNormal3fVertex3fvSUN_fnptr = (delegate* unmanaged<float*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glColor4fNormal3fVertex3fvSUN");
                _Color4fNormal3fVertex3fvSUN_fnptr(c, n, v);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, void> _TexCoord2fVertex3fSUN_fnptr = &TexCoord2fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fVertex3fSUN(float s, float t, float x, float y, float z) => _TexCoord2fVertex3fSUN_fnptr(s, t, x, y, z);
            [UnmanagedCallersOnly]
            private static void TexCoord2fVertex3fSUN_Lazy(float s, float t, float x, float y, float z)
            {
                _TexCoord2fVertex3fSUN_fnptr = (delegate* unmanaged<float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fVertex3fSUN");
                _TexCoord2fVertex3fSUN_fnptr(s, t, x, y, z);
            }
            
            private static delegate* unmanaged<float*, float*, void> _TexCoord2fVertex3fvSUN_fnptr = &TexCoord2fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fVertex3fvSUN(float* tc, float* v) => _TexCoord2fVertex3fvSUN_fnptr(tc, v);
            [UnmanagedCallersOnly]
            private static void TexCoord2fVertex3fvSUN_Lazy(float* tc, float* v)
            {
                _TexCoord2fVertex3fvSUN_fnptr = (delegate* unmanaged<float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fVertex3fvSUN");
                _TexCoord2fVertex3fvSUN_fnptr(tc, v);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, float, float, void> _TexCoord4fVertex4fSUN_fnptr = &TexCoord4fVertex4fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4fVertex4fSUN(float s, float t, float p, float q, float x, float y, float z, float w) => _TexCoord4fVertex4fSUN_fnptr(s, t, p, q, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void TexCoord4fVertex4fSUN_Lazy(float s, float t, float p, float q, float x, float y, float z, float w)
            {
                _TexCoord4fVertex4fSUN_fnptr = (delegate* unmanaged<float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4fVertex4fSUN");
                _TexCoord4fVertex4fSUN_fnptr(s, t, p, q, x, y, z, w);
            }
            
            private static delegate* unmanaged<float*, float*, void> _TexCoord4fVertex4fvSUN_fnptr = &TexCoord4fVertex4fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4fVertex4fvSUN(float* tc, float* v) => _TexCoord4fVertex4fvSUN_fnptr(tc, v);
            [UnmanagedCallersOnly]
            private static void TexCoord4fVertex4fvSUN_Lazy(float* tc, float* v)
            {
                _TexCoord4fVertex4fvSUN_fnptr = (delegate* unmanaged<float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4fVertex4fvSUN");
                _TexCoord4fVertex4fvSUN_fnptr(tc, v);
            }
            
            private static delegate* unmanaged<float, float, byte, byte, byte, byte, float, float, float, void> _TexCoord2fColor4ubVertex3fSUN_fnptr = &TexCoord2fColor4ubVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor4ubVertex3fSUN(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z) => _TexCoord2fColor4ubVertex3fSUN_fnptr(s, t, r, g, b, a, x, y, z);
            [UnmanagedCallersOnly]
            private static void TexCoord2fColor4ubVertex3fSUN_Lazy(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z)
            {
                _TexCoord2fColor4ubVertex3fSUN_fnptr = (delegate* unmanaged<float, float, byte, byte, byte, byte, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fColor4ubVertex3fSUN");
                _TexCoord2fColor4ubVertex3fSUN_fnptr(s, t, r, g, b, a, x, y, z);
            }
            
            private static delegate* unmanaged<float*, byte*, float*, void> _TexCoord2fColor4ubVertex3fvSUN_fnptr = &TexCoord2fColor4ubVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor4ubVertex3fvSUN(float* tc, byte* c, float* v) => _TexCoord2fColor4ubVertex3fvSUN_fnptr(tc, c, v);
            [UnmanagedCallersOnly]
            private static void TexCoord2fColor4ubVertex3fvSUN_Lazy(float* tc, byte* c, float* v)
            {
                _TexCoord2fColor4ubVertex3fvSUN_fnptr = (delegate* unmanaged<float*, byte*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fColor4ubVertex3fvSUN");
                _TexCoord2fColor4ubVertex3fvSUN_fnptr(tc, c, v);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, float, float, void> _TexCoord2fColor3fVertex3fSUN_fnptr = &TexCoord2fColor3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor3fVertex3fSUN(float s, float t, float r, float g, float b, float x, float y, float z) => _TexCoord2fColor3fVertex3fSUN_fnptr(s, t, r, g, b, x, y, z);
            [UnmanagedCallersOnly]
            private static void TexCoord2fColor3fVertex3fSUN_Lazy(float s, float t, float r, float g, float b, float x, float y, float z)
            {
                _TexCoord2fColor3fVertex3fSUN_fnptr = (delegate* unmanaged<float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fColor3fVertex3fSUN");
                _TexCoord2fColor3fVertex3fSUN_fnptr(s, t, r, g, b, x, y, z);
            }
            
            private static delegate* unmanaged<float*, float*, float*, void> _TexCoord2fColor3fVertex3fvSUN_fnptr = &TexCoord2fColor3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor3fVertex3fvSUN(float* tc, float* c, float* v) => _TexCoord2fColor3fVertex3fvSUN_fnptr(tc, c, v);
            [UnmanagedCallersOnly]
            private static void TexCoord2fColor3fVertex3fvSUN_Lazy(float* tc, float* c, float* v)
            {
                _TexCoord2fColor3fVertex3fvSUN_fnptr = (delegate* unmanaged<float*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fColor3fVertex3fvSUN");
                _TexCoord2fColor3fVertex3fvSUN_fnptr(tc, c, v);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, float, float, void> _TexCoord2fNormal3fVertex3fSUN_fnptr = &TexCoord2fNormal3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fNormal3fVertex3fSUN(float s, float t, float nx, float ny, float nz, float x, float y, float z) => _TexCoord2fNormal3fVertex3fSUN_fnptr(s, t, nx, ny, nz, x, y, z);
            [UnmanagedCallersOnly]
            private static void TexCoord2fNormal3fVertex3fSUN_Lazy(float s, float t, float nx, float ny, float nz, float x, float y, float z)
            {
                _TexCoord2fNormal3fVertex3fSUN_fnptr = (delegate* unmanaged<float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fNormal3fVertex3fSUN");
                _TexCoord2fNormal3fVertex3fSUN_fnptr(s, t, nx, ny, nz, x, y, z);
            }
            
            private static delegate* unmanaged<float*, float*, float*, void> _TexCoord2fNormal3fVertex3fvSUN_fnptr = &TexCoord2fNormal3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fNormal3fVertex3fvSUN(float* tc, float* n, float* v) => _TexCoord2fNormal3fVertex3fvSUN_fnptr(tc, n, v);
            [UnmanagedCallersOnly]
            private static void TexCoord2fNormal3fVertex3fvSUN_Lazy(float* tc, float* n, float* v)
            {
                _TexCoord2fNormal3fVertex3fvSUN_fnptr = (delegate* unmanaged<float*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fNormal3fVertex3fvSUN");
                _TexCoord2fNormal3fVertex3fvSUN_fnptr(tc, n, v);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, float, float, float, float, float, float, void> _TexCoord2fColor4fNormal3fVertex3fSUN_fnptr = &TexCoord2fColor4fNormal3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor4fNormal3fVertex3fSUN(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => _TexCoord2fColor4fNormal3fVertex3fSUN_fnptr(s, t, r, g, b, a, nx, ny, nz, x, y, z);
            [UnmanagedCallersOnly]
            private static void TexCoord2fColor4fNormal3fVertex3fSUN_Lazy(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z)
            {
                _TexCoord2fColor4fNormal3fVertex3fSUN_fnptr = (delegate* unmanaged<float, float, float, float, float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fColor4fNormal3fVertex3fSUN");
                _TexCoord2fColor4fNormal3fVertex3fSUN_fnptr(s, t, r, g, b, a, nx, ny, nz, x, y, z);
            }
            
            private static delegate* unmanaged<float*, float*, float*, float*, void> _TexCoord2fColor4fNormal3fVertex3fvSUN_fnptr = &TexCoord2fColor4fNormal3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float* c, float* n, float* v) => _TexCoord2fColor4fNormal3fVertex3fvSUN_fnptr(tc, c, n, v);
            [UnmanagedCallersOnly]
            private static void TexCoord2fColor4fNormal3fVertex3fvSUN_Lazy(float* tc, float* c, float* n, float* v)
            {
                _TexCoord2fColor4fNormal3fVertex3fvSUN_fnptr = (delegate* unmanaged<float*, float*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord2fColor4fNormal3fVertex3fvSUN");
                _TexCoord2fColor4fNormal3fVertex3fvSUN_fnptr(tc, c, n, v);
            }
            
            private static delegate* unmanaged<float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, void> _TexCoord4fColor4fNormal3fVertex4fSUN_fnptr = &TexCoord4fColor4fNormal3fVertex4fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4fColor4fNormal3fVertex4fSUN(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w) => _TexCoord4fColor4fNormal3fVertex4fSUN_fnptr(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
            [UnmanagedCallersOnly]
            private static void TexCoord4fColor4fNormal3fVertex4fSUN_Lazy(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w)
            {
                _TexCoord4fColor4fNormal3fVertex4fSUN_fnptr = (delegate* unmanaged<float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4fColor4fNormal3fVertex4fSUN");
                _TexCoord4fColor4fNormal3fVertex4fSUN_fnptr(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
            }
            
            private static delegate* unmanaged<float*, float*, float*, float*, void> _TexCoord4fColor4fNormal3fVertex4fvSUN_fnptr = &TexCoord4fColor4fNormal3fVertex4fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float* c, float* n, float* v) => _TexCoord4fColor4fNormal3fVertex4fvSUN_fnptr(tc, c, n, v);
            [UnmanagedCallersOnly]
            private static void TexCoord4fColor4fNormal3fVertex4fvSUN_Lazy(float* tc, float* c, float* n, float* v)
            {
                _TexCoord4fColor4fNormal3fVertex4fvSUN_fnptr = (delegate* unmanaged<float*, float*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glTexCoord4fColor4fNormal3fVertex4fvSUN");
                _TexCoord4fColor4fNormal3fVertex4fvSUN_fnptr(tc, c, n, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, void> _ReplacementCodeuiVertex3fSUN_fnptr = &ReplacementCodeuiVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiVertex3fSUN(uint rc, float x, float y, float z) => _ReplacementCodeuiVertex3fSUN_fnptr(rc, x, y, z);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiVertex3fSUN_Lazy(uint rc, float x, float y, float z)
            {
                _ReplacementCodeuiVertex3fSUN_fnptr = (delegate* unmanaged<uint, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiVertex3fSUN");
                _ReplacementCodeuiVertex3fSUN_fnptr(rc, x, y, z);
            }
            
            private static delegate* unmanaged<uint*, float*, void> _ReplacementCodeuiVertex3fvSUN_fnptr = &ReplacementCodeuiVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiVertex3fvSUN(uint* rc, float* v) => _ReplacementCodeuiVertex3fvSUN_fnptr(rc, v);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiVertex3fvSUN_Lazy(uint* rc, float* v)
            {
                _ReplacementCodeuiVertex3fvSUN_fnptr = (delegate* unmanaged<uint*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiVertex3fvSUN");
                _ReplacementCodeuiVertex3fvSUN_fnptr(rc, v);
            }
            
            private static delegate* unmanaged<uint, byte, byte, byte, byte, float, float, float, void> _ReplacementCodeuiColor4ubVertex3fSUN_fnptr = &ReplacementCodeuiColor4ubVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor4ubVertex3fSUN(uint rc, byte r, byte g, byte b, byte a, float x, float y, float z) => _ReplacementCodeuiColor4ubVertex3fSUN_fnptr(rc, r, g, b, a, x, y, z);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiColor4ubVertex3fSUN_Lazy(uint rc, byte r, byte g, byte b, byte a, float x, float y, float z)
            {
                _ReplacementCodeuiColor4ubVertex3fSUN_fnptr = (delegate* unmanaged<uint, byte, byte, byte, byte, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiColor4ubVertex3fSUN");
                _ReplacementCodeuiColor4ubVertex3fSUN_fnptr(rc, r, g, b, a, x, y, z);
            }
            
            private static delegate* unmanaged<uint*, byte*, float*, void> _ReplacementCodeuiColor4ubVertex3fvSUN_fnptr = &ReplacementCodeuiColor4ubVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor4ubVertex3fvSUN(uint* rc, byte* c, float* v) => _ReplacementCodeuiColor4ubVertex3fvSUN_fnptr(rc, c, v);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiColor4ubVertex3fvSUN_Lazy(uint* rc, byte* c, float* v)
            {
                _ReplacementCodeuiColor4ubVertex3fvSUN_fnptr = (delegate* unmanaged<uint*, byte*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiColor4ubVertex3fvSUN");
                _ReplacementCodeuiColor4ubVertex3fvSUN_fnptr(rc, c, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, float, float, float, void> _ReplacementCodeuiColor3fVertex3fSUN_fnptr = &ReplacementCodeuiColor3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor3fVertex3fSUN(uint rc, float r, float g, float b, float x, float y, float z) => _ReplacementCodeuiColor3fVertex3fSUN_fnptr(rc, r, g, b, x, y, z);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiColor3fVertex3fSUN_Lazy(uint rc, float r, float g, float b, float x, float y, float z)
            {
                _ReplacementCodeuiColor3fVertex3fSUN_fnptr = (delegate* unmanaged<uint, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiColor3fVertex3fSUN");
                _ReplacementCodeuiColor3fVertex3fSUN_fnptr(rc, r, g, b, x, y, z);
            }
            
            private static delegate* unmanaged<uint*, float*, float*, void> _ReplacementCodeuiColor3fVertex3fvSUN_fnptr = &ReplacementCodeuiColor3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor3fVertex3fvSUN(uint* rc, float* c, float* v) => _ReplacementCodeuiColor3fVertex3fvSUN_fnptr(rc, c, v);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiColor3fVertex3fvSUN_Lazy(uint* rc, float* c, float* v)
            {
                _ReplacementCodeuiColor3fVertex3fvSUN_fnptr = (delegate* unmanaged<uint*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiColor3fVertex3fvSUN");
                _ReplacementCodeuiColor3fVertex3fvSUN_fnptr(rc, c, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, float, float, float, void> _ReplacementCodeuiNormal3fVertex3fSUN_fnptr = &ReplacementCodeuiNormal3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiNormal3fVertex3fSUN(uint rc, float nx, float ny, float nz, float x, float y, float z) => _ReplacementCodeuiNormal3fVertex3fSUN_fnptr(rc, nx, ny, nz, x, y, z);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiNormal3fVertex3fSUN_Lazy(uint rc, float nx, float ny, float nz, float x, float y, float z)
            {
                _ReplacementCodeuiNormal3fVertex3fSUN_fnptr = (delegate* unmanaged<uint, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiNormal3fVertex3fSUN");
                _ReplacementCodeuiNormal3fVertex3fSUN_fnptr(rc, nx, ny, nz, x, y, z);
            }
            
            private static delegate* unmanaged<uint*, float*, float*, void> _ReplacementCodeuiNormal3fVertex3fvSUN_fnptr = &ReplacementCodeuiNormal3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiNormal3fVertex3fvSUN(uint* rc, float* n, float* v) => _ReplacementCodeuiNormal3fVertex3fvSUN_fnptr(rc, n, v);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiNormal3fVertex3fvSUN_Lazy(uint* rc, float* n, float* v)
            {
                _ReplacementCodeuiNormal3fVertex3fvSUN_fnptr = (delegate* unmanaged<uint*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiNormal3fVertex3fvSUN");
                _ReplacementCodeuiNormal3fVertex3fvSUN_fnptr(rc, n, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, float, float, float, float, float, float, float, void> _ReplacementCodeuiColor4fNormal3fVertex3fSUN_fnptr = &ReplacementCodeuiColor4fNormal3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor4fNormal3fVertex3fSUN(uint rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => _ReplacementCodeuiColor4fNormal3fVertex3fSUN_fnptr(rc, r, g, b, a, nx, ny, nz, x, y, z);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiColor4fNormal3fVertex3fSUN_Lazy(uint rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z)
            {
                _ReplacementCodeuiColor4fNormal3fVertex3fSUN_fnptr = (delegate* unmanaged<uint, float, float, float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiColor4fNormal3fVertex3fSUN");
                _ReplacementCodeuiColor4fNormal3fVertex3fSUN_fnptr(rc, r, g, b, a, nx, ny, nz, x, y, z);
            }
            
            private static delegate* unmanaged<uint*, float*, float*, float*, void> _ReplacementCodeuiColor4fNormal3fVertex3fvSUN_fnptr = &ReplacementCodeuiColor4fNormal3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float* c, float* n, float* v) => _ReplacementCodeuiColor4fNormal3fVertex3fvSUN_fnptr(rc, c, n, v);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiColor4fNormal3fVertex3fvSUN_Lazy(uint* rc, float* c, float* n, float* v)
            {
                _ReplacementCodeuiColor4fNormal3fVertex3fvSUN_fnptr = (delegate* unmanaged<uint*, float*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiColor4fNormal3fVertex3fvSUN");
                _ReplacementCodeuiColor4fNormal3fVertex3fvSUN_fnptr(rc, c, n, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, float, float, void> _ReplacementCodeuiTexCoord2fVertex3fSUN_fnptr = &ReplacementCodeuiTexCoord2fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fVertex3fSUN(uint rc, float s, float t, float x, float y, float z) => _ReplacementCodeuiTexCoord2fVertex3fSUN_fnptr(rc, s, t, x, y, z);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiTexCoord2fVertex3fSUN_Lazy(uint rc, float s, float t, float x, float y, float z)
            {
                _ReplacementCodeuiTexCoord2fVertex3fSUN_fnptr = (delegate* unmanaged<uint, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiTexCoord2fVertex3fSUN");
                _ReplacementCodeuiTexCoord2fVertex3fSUN_fnptr(rc, s, t, x, y, z);
            }
            
            private static delegate* unmanaged<uint*, float*, float*, void> _ReplacementCodeuiTexCoord2fVertex3fvSUN_fnptr = &ReplacementCodeuiTexCoord2fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fVertex3fvSUN(uint* rc, float* tc, float* v) => _ReplacementCodeuiTexCoord2fVertex3fvSUN_fnptr(rc, tc, v);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiTexCoord2fVertex3fvSUN_Lazy(uint* rc, float* tc, float* v)
            {
                _ReplacementCodeuiTexCoord2fVertex3fvSUN_fnptr = (delegate* unmanaged<uint*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiTexCoord2fVertex3fvSUN");
                _ReplacementCodeuiTexCoord2fVertex3fvSUN_fnptr(rc, tc, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, float, float, float, float, float, void> _ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_fnptr = &ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(uint rc, float s, float t, float nx, float ny, float nz, float x, float y, float z) => _ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_fnptr(rc, s, t, nx, ny, nz, x, y, z);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_Lazy(uint rc, float s, float t, float nx, float ny, float nz, float x, float y, float z)
            {
                _ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_fnptr = (delegate* unmanaged<uint, float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN");
                _ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_fnptr(rc, s, t, nx, ny, nz, x, y, z);
            }
            
            private static delegate* unmanaged<uint*, float*, float*, float*, void> _ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_fnptr = &ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float* tc, float* n, float* v) => _ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_fnptr(rc, tc, n, v);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_Lazy(uint* rc, float* tc, float* n, float* v)
            {
                _ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_fnptr = (delegate* unmanaged<uint*, float*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN");
                _ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_fnptr(rc, tc, n, v);
            }
            
            private static delegate* unmanaged<uint, float, float, float, float, float, float, float, float, float, float, float, float, void> _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_fnptr = &ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(uint rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_fnptr(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_Lazy(uint rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z)
            {
                _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_fnptr = (delegate* unmanaged<uint, float, float, float, float, float, float, float, float, float, float, float, float, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN");
                _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_fnptr(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
            }
            
            private static delegate* unmanaged<uint*, float*, float*, float*, float*, void> _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_fnptr = &ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_Lazy;
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float* c, float* n, float* v) => _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_fnptr(rc, tc, c, n, v);
            [UnmanagedCallersOnly]
            private static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_Lazy(uint* rc, float* tc, float* c, float* n, float* v)
            {
                _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_fnptr = (delegate* unmanaged<uint*, float*, float*, float*, float*, void>)GLLoader.BindingsContext.GetProcAddress("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN");
                _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_fnptr(rc, tc, c, n, v);
            }
            
        }
    }
}
