// This file is auto generated, do not edit.
using System;
using System.Runtime.InteropServices;
using OpenTK.Graphics;
using OpenTK.Graphics.Wgl;
using OpenTK.Graphics.Glx;
using OpenTK.Graphics.Egl;

namespace OpenTK.Graphics.OpenGL
{
    public static unsafe partial class GL
    {
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glActiveShaderProgram</c>]</b><br/> Set the active program object for a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
        /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ActiveShaderProgram(int pipeline, int program) => GLPointers.glActiveShaderProgram_Lazy(pipeline, program);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glActiveTexture</c>]</b><br/> Select active texture unit. </summary>
        /// <param name="texture"> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from zero to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS minus one. The initial value is GL_TEXTURE0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveTexture.xhtml"/></remarks>
        public static void ActiveTexture(TextureUnit texture) => GLPointers.glActiveTexture_Lazy((uint)texture);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glAttachShader</c>]</b><br/> Attaches a shader object to a program object. </summary>
        /// <param name="program">Specifies the program object to which a shader object will be attached.</param>
        /// <param name="shader">Specifies the shader object that is to be attached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glAttachShader.xhtml"/></remarks>
        public static void AttachShader(int program, int shader) => GLPointers.glAttachShader_Lazy(program, shader);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glBeginConditionalRender</c>]</b><br/> Start conditional rendering. </summary>
        /// <param name="id"> Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded. </param>
        /// <param name="mode"> Specifies how glBeginConditionalRender interprets the results of the occlusion query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml"/></remarks>
        public static void BeginConditionalRender(uint id, ConditionalRenderMode mode) => GLPointers.glBeginConditionalRender_Lazy(id, (uint)mode);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glBeginQuery</c>]</b><br/> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml"/></remarks>
        public static void BeginQuery(QueryTarget target, int id) => GLPointers.glBeginQuery_Lazy((uint)target, id);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glBeginQueryIndexed</c>]</b><br/> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback3.txt"/></remarks>
        public static void BeginQueryIndexed(QueryTarget target, uint index, int id) => GLPointers.glBeginQueryIndexed_Lazy((uint)target, index, id);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glBeginTransformFeedback</c>]</b><br/> Start transform feedback operation. </summary>
        /// <param name="primitiveMode"> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml"/></remarks>
        public static void BeginTransformFeedback(PrimitiveType primitiveMode) => GLPointers.glBeginTransformFeedback_Lazy((uint)primitiveMode);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glBindAttribLocation</c>]</b><br/> Associates a generic vertex attribute index with a named attribute variable. </summary>
        /// <param name="program">Specifies the handle of the program object in which the association is to be made.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be bound.</param>
        /// <param name="name">Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindAttribLocation.xhtml"/></remarks>
        public static void BindAttribLocation(int program, uint index, byte* name) => GLPointers.glBindAttribLocation_Lazy(program, index, name);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glBindBuffer</c>]</b><br/> Bind a named buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml"/></remarks>
        public static void BindBuffer(BufferTarget target, int buffer) => GLPointers.glBindBuffer_Lazy((uint)target, buffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glBindBufferBase</c>]</b><br/> Bind a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static void BindBufferBase(BufferTarget target, uint index, int buffer) => GLPointers.glBindBufferBase_Lazy((uint)target, index, buffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glBindBufferRange</c>]</b><br/> Bind a range within a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
        /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static void BindBufferRange(BufferTarget target, uint index, int buffer, IntPtr offset, nint size) => GLPointers.glBindBufferRange_Lazy((uint)target, index, buffer, offset, size);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindBuffersBase</c>]</b><br/> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
        public static void BindBuffersBase(BufferTarget target, uint first, int count, int* buffers) => GLPointers.glBindBuffersBase_Lazy((uint)target, first, count, buffers);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindBuffersRange</c>]</b><br/> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
        public static void BindBuffersRange(BufferTarget target, uint first, int count, int* buffers, IntPtr* offsets, nint* sizes) => GLPointers.glBindBuffersRange_Lazy((uint)target, first, count, buffers, offsets, sizes);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glBindFragDataLocation</c>]</b><br/> Bind a user-defined varying out variable to a fragment shader color number. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="color"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocation.xhtml"/></remarks>
        public static void BindFragDataLocation(int program, uint color, byte* name) => GLPointers.glBindFragDataLocation_Lazy(program, color, name);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> <b>[entry point: <c>glBindFragDataLocationIndexed</c>]</b><br/> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_blend_func_extended.txt"/></remarks>
        public static void BindFragDataLocationIndexed(int program, uint colorNumber, uint index, byte* name) => GLPointers.glBindFragDataLocationIndexed_Lazy(program, colorNumber, index, name);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBindFramebuffer</c>]</b><br/> Bind a framebuffer to a framebuffer target. </summary>
        /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void BindFramebuffer(FramebufferTarget target, int framebuffer) => GLPointers.glBindFramebuffer_Lazy((uint)target, framebuffer);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> <b>[entry point: <c>glBindImageTexture</c>]</b><br/> Bind a level of a texture to an image unit. </summary>
        /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
        /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
        /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
        /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
        /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
        /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
        /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_image_load_store.txt"/></remarks>
        public static void BindImageTexture(uint unit, int texture, int level, bool layered, int layer, BufferAccess access, InternalFormat format) => GLPointers.glBindImageTexture_Lazy(unit, texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, (uint)format);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindImageTextures</c>]</b><br/> Bind one or more named texture images to a sequence of consecutive image units. </summary>
        /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
        public static void BindImageTextures(uint first, int count, int* textures) => GLPointers.glBindImageTextures_Lazy(first, count, textures);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glBindProgramPipeline</c>]</b><br/> Bind a program pipeline to the current context. </summary>
        /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void BindProgramPipeline(int pipeline) => GLPointers.glBindProgramPipeline_Lazy(pipeline);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBindRenderbuffer</c>]</b><br/> Bind a renderbuffer to a renderbuffer target. </summary>
        /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void BindRenderbuffer(RenderbufferTarget target, int renderbuffer) => GLPointers.glBindRenderbuffer_Lazy((uint)target, renderbuffer);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glBindSampler</c>]</b><br/> Bind a named sampler to a texturing target. </summary>
        /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
        /// <param name="sampler"> Specifies the name of a sampler. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void BindSampler(uint unit, int sampler) => GLPointers.glBindSampler_Lazy(unit, sampler);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindSamplers</c>]</b><br/> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
        /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
        /// <param name="count"> Specifies the number of samplers to bind. </param>
        /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
        public static void BindSamplers(uint first, int count, int* samplers) => GLPointers.glBindSamplers_Lazy(first, count, samplers);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glBindTexture</c>]</b><br/> Bind a named texture to a texturing target. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="texture"> Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTexture.xhtml"/></remarks>
        public static void BindTexture(TextureTarget target, int texture) => GLPointers.glBindTexture_Lazy((uint)target, texture);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindTextures</c>]</b><br/> Bind one or more named textures to a sequence of consecutive texture units. </summary>
        /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
        public static void BindTextures(uint first, int count, int* textures) => GLPointers.glBindTextures_Lazy(first, count, textures);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glBindTextureUnit</c>]</b><br/> Bind an existing texture object to the specified texture unit . </summary>
        /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
        /// <param name="texture">Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void BindTextureUnit(uint unit, int texture) => GLPointers.glBindTextureUnit_Lazy(unit, texture);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glBindTransformFeedback</c>]</b><br/> Bind a transform feedback object. </summary>
        /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
        /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
        public static void BindTransformFeedback(BindTransformFeedbackTarget target, int id) => GLPointers.glBindTransformFeedback_Lazy((uint)target, id);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glBindVertexArray</c>]</b><br/> Bind a vertex array object. </summary>
        /// <param name="array"> Specifies the name of the vertex array to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_array_object.txt"/></remarks>
        public static void BindVertexArray(int array) => GLPointers.glBindVertexArray_Lazy(array);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glBindVertexBuffer</c>]</b><br/> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
        public static void BindVertexBuffer(uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers.glBindVertexBuffer_Lazy(bindingindex, buffer, offset, stride);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindVertexBuffers</c>]</b><br/> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
        public static void BindVertexBuffers(uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers.glBindVertexBuffers_Lazy(first, count, buffers, offsets, strides);
        
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> <b>[entry point: <c>glBlendColor</c>]</b><br/> Set the blend color. </summary>
        /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
        public static void BlendColor(float red, float green, float blue, float alpha) => GLPointers.glBlendColor_Lazy(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> <b>[entry point: <c>glBlendEquation</c>]</b><br/> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
        public static void BlendEquation(BlendEquationMode mode) => GLPointers.glBlendEquation_Lazy((uint)mode);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glBlendEquationi</c>]</b><br/> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="buf"> for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation. </param>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml"/></remarks>
        public static void BlendEquationi(uint buf, BlendEquationMode mode) => GLPointers.glBlendEquationi_Lazy(buf, (uint)mode);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glBlendEquationSeparate</c>]</b><br/> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml"/></remarks>
        public static void BlendEquationSeparate(BlendEquationMode modeRGB, BlendEquationMode modeAlpha) => GLPointers.glBlendEquationSeparate_Lazy((uint)modeRGB, (uint)modeAlpha);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glBlendEquationSeparatei</c>]</b><br/> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="buf"> for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations. </param>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml"/></remarks>
        public static void BlendEquationSeparatei(uint buf, BlendEquationMode modeRGB, BlendEquationMode modeAlpha) => GLPointers.glBlendEquationSeparatei_Lazy(buf, (uint)modeRGB, (uint)modeAlpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glBlendFunc</c>]</b><br/> Specify pixel arithmetic. </summary>
        /// <param name="sfactor"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactor"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml"/></remarks>
        public static void BlendFunc(BlendingFactor sfactor, BlendingFactor dfactor) => GLPointers.glBlendFunc_Lazy((uint)sfactor, (uint)dfactor);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glBlendFunci</c>]</b><br/> Specify pixel arithmetic. </summary>
        /// <param name="buf"> For glBlendFunci, specifies the index of the draw buffer for which to set the blend function. </param>
        /// <param name="src"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dst"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml"/></remarks>
        public static void BlendFunci(uint buf, BlendingFactor src, BlendingFactor dst) => GLPointers.glBlendFunci_Lazy(buf, (uint)src, (uint)dst);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glBlendFuncSeparate</c>]</b><br/> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="sfactorRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactorRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="sfactorAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dfactorAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml"/></remarks>
        public static void BlendFuncSeparate(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers.glBlendFuncSeparate_Lazy((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glBlendFuncSeparatei</c>]</b><br/> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="buf"> For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions. </param>
        /// <param name="srcRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dstRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="srcAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dstAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml"/></remarks>
        public static void BlendFuncSeparatei(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers.glBlendFuncSeparatei_Lazy(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBlitFramebuffer</c>]</b><br/> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers.glBlitFramebuffer_Lazy(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glBlitNamedFramebuffer</c>]</b><br/> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void BlitNamedFramebuffer(int readFramebuffer, int drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers.glBlitNamedFramebuffer_Lazy(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glBufferData</c>]</b><br/> Creates and initializes a buffer object&apos;s data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml"/></remarks>
        public static void BufferData(BufferTarget target, nint size, void* data, BufferUsage usage) => GLPointers.glBufferData_Lazy((uint)target, size, data, (uint)usage);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage]</b> <b>[entry point: <c>glBufferStorage</c>]</b><br/> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_buffer_storage.txt"/></remarks>
        public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => GLPointers.glBufferStorage_Lazy((uint)target, size, data, (uint)flags);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glBufferSubData</c>]</b><br/> Updates a subset of a buffer object&apos;s data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml"/></remarks>
        public static void BufferSubData(BufferTarget target, IntPtr offset, nint size, void* data) => GLPointers.glBufferSubData_Lazy((uint)target, offset, size, data);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glCheckFramebufferStatus</c>]</b><br/> Check the completeness status of a framebuffer. </summary>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => (FramebufferStatus) GLPointers.glCheckFramebufferStatus_Lazy((uint)target);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCheckNamedFramebufferStatus</c>]</b><br/> Check the completeness status of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static FramebufferStatus CheckNamedFramebufferStatus(int framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers.glCheckNamedFramebufferStatus_Lazy(framebuffer, (uint)target);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClampColor</c>]</b><br/> Specify whether data read via glReadPixels should be clamped. </summary>
        /// <param name="target"> Target for color clamping. target must be GL_CLAMP_READ_COLOR. </param>
        /// <param name="clamp"> Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClampColor.xhtml"/></remarks>
        public static void ClampColor(ClampColorTargetARB target, ClampColorModeARB clamp) => GLPointers.glClampColor_Lazy((uint)target, (uint)clamp);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glClear</c>]</b><br/> Clear buffers to preset values. </summary>
        /// <param name="mask"> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml"/></remarks>
        public static void Clear(ClearBufferMask mask) => GLPointers.glClear_Lazy((uint)mask);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> <b>[entry point: <c>glClearBufferData</c>]</b><br/> Fill a buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clear_buffer_object.txt"/></remarks>
        public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers.glClearBufferData_Lazy((uint)target, (uint)internalformat, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClearBufferfi</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/></remarks>
        public static void ClearBufferfi(Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers.glClearBufferfi_Lazy((uint)buffer, drawbuffer, depth, stencil);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClearBufferfv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/></remarks>
        public static void ClearBufferfv(Buffer buffer, int drawbuffer, float* value) => GLPointers.glClearBufferfv_Lazy((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClearBufferiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/></remarks>
        public static void ClearBufferiv(Buffer buffer, int drawbuffer, int* value) => GLPointers.glClearBufferiv_Lazy((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> <b>[entry point: <c>glClearBufferSubData</c>]</b><br/> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clear_buffer_object.txt"/></remarks>
        public static void ClearBufferSubData(BufferTarget target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers.glClearBufferSubData_Lazy((uint)target, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClearBufferuiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/></remarks>
        public static void ClearBufferuiv(Buffer buffer, int drawbuffer, uint* value) => GLPointers.glClearBufferuiv_Lazy((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glClearColor</c>]</b><br/> Specify clear values for the color buffers. </summary>
        /// <param name="red"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="green"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="blue"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="alpha"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml"/></remarks>
        public static void ClearColor(float red, float green, float blue, float alpha) => GLPointers.glClearColor_Lazy(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glClearDepth</c>]</b><br/> Specify the clear value for the depth buffer. </summary>
        /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml"/></remarks>
        public static void ClearDepth(double depth) => GLPointers.glClearDepth_Lazy(depth);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glClearDepthf</c>]</b><br/> Specify the clear value for the depth buffer. </summary>
        /// <param name="d"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
        public static void ClearDepthf(float d) => GLPointers.glClearDepthf_Lazy(d);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferData</c>]</b><br/> Fill a buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void ClearNamedBufferData(int buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers.glClearNamedBufferData_Lazy(buffer, (uint)internalformat, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferSubData</c>]</b><br/> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void ClearNamedBufferSubData(int buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers.glClearNamedBufferSubData_Lazy(buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferfi</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void ClearNamedFramebufferfi(int framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers.glClearNamedFramebufferfi_Lazy(framebuffer, (uint)buffer, drawbuffer, depth, stencil);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferfv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void ClearNamedFramebufferfv(int framebuffer, Buffer buffer, int drawbuffer, float* value) => GLPointers.glClearNamedFramebufferfv_Lazy(framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void ClearNamedFramebufferiv(int framebuffer, Buffer buffer, int drawbuffer, int* value) => GLPointers.glClearNamedFramebufferiv_Lazy(framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferuiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void ClearNamedFramebufferuiv(int framebuffer, Buffer buffer, int drawbuffer, uint* value) => GLPointers.glClearNamedFramebufferuiv_Lazy(framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glClearStencil</c>]</b><br/> Specify the clear value for the stencil buffer. </summary>
        /// <param name="s"> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearStencil.xhtml"/></remarks>
        public static void ClearStencil(int s) => GLPointers.glClearStencil_Lazy(s);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> <b>[entry point: <c>glClearTexImage</c>]</b><br/> Fills all a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clear_texture.txt"/></remarks>
        public static void ClearTexImage(int texture, int level, PixelFormat format, PixelType type, void* data) => GLPointers.glClearTexImage_Lazy(texture, level, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> <b>[entry point: <c>glClearTexSubImage</c>]</b><br/> Fills all or part of a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
        /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
        /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
        /// <param name="width"> The width of the region to be cleared. </param>
        /// <param name="height"> The height of the region to be cleared. </param>
        /// <param name="depth"> The depth of the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clear_texture.txt"/></remarks>
        public static void ClearTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => GLPointers.glClearTexSubImage_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glClientWaitSync</c>]</b><br/> Block and wait for a sync object to become signaled. </summary>
        /// <param name="sync"> The sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
        /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
        public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => (SyncStatus) GLPointers.glClientWaitSync_Lazy((IntPtr)sync, (uint)flags, timeout);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control]</b> <b>[entry point: <c>glClipControl</c>]</b><br/> Control clip coordinate to window coordinate behavior. </summary>
        /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
        /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clip_control.txt"/></remarks>
        public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => GLPointers.glClipControl_Lazy((uint)origin, (uint)depth);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glColorMask</c>]</b><br/> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="red"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="green"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="blue"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="alpha"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml"/></remarks>
        public static void ColorMask(bool red, bool green, bool blue, bool alpha) => GLPointers.glColorMask_Lazy((byte)(red ? 1 : 0), (byte)(green ? 1 : 0), (byte)(blue ? 1 : 0), (byte)(alpha ? 1 : 0));
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glColorMaski</c>]</b><br/> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="index"> For glColorMaski, specifies the index of the draw buffer whose color mask to set. </param>
        /// <param name="r"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="g"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="b"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="a"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml"/></remarks>
        public static void ColorMaski(uint index, bool r, bool g, bool b, bool a) => GLPointers.glColorMaski_Lazy(index, (byte)(r ? 1 : 0), (byte)(g ? 1 : 0), (byte)(b ? 1 : 0), (byte)(a ? 1 : 0));
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glCompileShader</c>]</b><br/> Compiles a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be compiled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompileShader.xhtml"/></remarks>
        public static void CompileShader(int shader) => GLPointers.glCompileShader_Lazy(shader);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexImage1D</c>]</b><br/> Specify a one-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage1D.xhtml"/></remarks>
        public static void CompressedTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => GLPointers.glCompressedTexImage1D_Lazy((uint)target, level, (uint)internalformat, width, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexImage2D</c>]</b><br/> Specify a two-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage2D.xhtml"/></remarks>
        public static void CompressedTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => GLPointers.glCompressedTexImage2D_Lazy((uint)target, level, (uint)internalformat, width, height, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexImage3D</c>]</b><br/> Specify a three-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage3D.xhtml"/></remarks>
        public static void CompressedTexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => GLPointers.glCompressedTexImage3D_Lazy((uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="target">Specifies the target, to which the texture is bound, for glCompressedTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml"/></remarks>
        public static void CompressedTexSubImage1D(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTexSubImage1D_Lazy((uint)target, level, xoffset, width, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml"/></remarks>
        public static void CompressedTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTexSubImage2D_Lazy((uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage3D function. Must be GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml"/></remarks>
        public static void CompressedTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTexSubImage3D_Lazy((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CompressedTextureSubImage1D(int texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTextureSubImage1D_Lazy(texture, level, xoffset, width, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CompressedTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTextureSubImage2D_Lazy(texture, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CompressedTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTextureSubImage3D_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer]</b> <b>[entry point: <c>glCopyBufferSubData</c>]</b><br/> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
        /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_copy_buffer.txt"/></remarks>
        public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers.glCopyBufferSubData_Lazy((uint)readTarget, (uint)writeTarget, readOffset, writeOffset, size);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image]</b> <b>[entry point: <c>glCopyImageSubData</c>]</b><br/> Perform a raw data copy between two images. </summary>
        /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
        /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
        /// <param name="srcLevel"> The mipmap level to read from the source. </param>
        /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
        /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
        /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
        /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
        /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
        /// <param name="dstLevel">!!missing documentation!!</param>
        /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
        /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
        /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
        /// <param name="srcWidth"> The width of the region to be copied. </param>
        /// <param name="srcHeight"> The height of the region to be copied. </param>
        /// <param name="srcDepth"> The depth of the region to be copied. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_copy_image.txt"/></remarks>
        public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers.glCopyImageSubData_Lazy(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyNamedBufferSubData</c>]</b><br/> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CopyNamedBufferSubData(int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers.glCopyNamedBufferSubData_Lazy(readBuffer, writeBuffer, readOffset, writeOffset, size);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glCopyTexImage1D</c>]</b><br/> Copy pixels into a 1D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. The height of the texture image is 1. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage1D.xhtml"/></remarks>
        public static void CopyTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers.glCopyTexImage1D_Lazy((uint)target, level, (uint)internalformat, x, y, width, border);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glCopyTexImage2D</c>]</b><br/> Copy pixels into a 2D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. </param>
        /// <param name="height"> Specifies the height of the texture image. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage2D.xhtml"/></remarks>
        public static void CopyTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers.glCopyTexImage2D_Lazy((uint)target, level, (uint)internalformat, x, y, width, height, border);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glCopyTexSubImage1D</c>]</b><br/> Copy a one-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml"/></remarks>
        public static void CopyTexSubImage1D(TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers.glCopyTexSubImage1D_Lazy((uint)target, level, xoffset, x, y, width);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glCopyTexSubImage2D</c>]</b><br/> Copy a two-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml"/></remarks>
        public static void CopyTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers.glCopyTexSubImage2D_Lazy((uint)target, level, xoffset, yoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v1.2]</b> <b>[entry point: <c>glCopyTexSubImage3D</c>]</b><br/> Copy a three-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage3D function. Must be GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml"/></remarks>
        public static void CopyTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers.glCopyTexSubImage3D_Lazy((uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage1D</c>]</b><br/> Copy a one-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CopyTextureSubImage1D(int texture, int level, int xoffset, int x, int y, int width) => GLPointers.glCopyTextureSubImage1D_Lazy(texture, level, xoffset, x, y, width);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage2D</c>]</b><br/> Copy a two-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CopyTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers.glCopyTextureSubImage2D_Lazy(texture, level, xoffset, yoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage3D</c>]</b><br/> Copy a three-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CopyTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers.glCopyTextureSubImage3D_Lazy(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateBuffers</c>]</b><br/> Create buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to create. </param>
        /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CreateBuffers(int n, int* buffers) => GLPointers.glCreateBuffers_Lazy(n, buffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateFramebuffers</c>]</b><br/> Create framebuffer objects. </summary>
        /// <param name="n"> Number of framebuffer objects to create. </param>
        /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CreateFramebuffers(int n, int* framebuffers) => GLPointers.glCreateFramebuffers_Lazy(n, framebuffers);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glCreateProgram</c>]</b><br/> Creates a program object. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml"/></remarks>
        public static int CreateProgram() => GLPointers.glCreateProgram_Lazy();
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateProgramPipelines</c>]</b><br/> Create program pipeline objects. </summary>
        /// <param name="n"> Number of program pipeline objects to create. </param>
        /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CreateProgramPipelines(int n, int* pipelines) => GLPointers.glCreateProgramPipelines_Lazy(n, pipelines);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateQueries</c>]</b><br/> Create query objects. </summary>
        /// <param name="target"> Specifies the target of each created query object. </param>
        /// <param name="n"> Number of query objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CreateQueries(QueryTarget target, int n, int* ids) => GLPointers.glCreateQueries_Lazy((uint)target, n, ids);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateRenderbuffers</c>]</b><br/> Create renderbuffer objects. </summary>
        /// <param name="n"> Number of renderbuffer objects to create. </param>
        /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CreateRenderbuffers(int n, int* renderbuffers) => GLPointers.glCreateRenderbuffers_Lazy(n, renderbuffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateSamplers</c>]</b><br/> Create sampler objects. </summary>
        /// <param name="n"> Number of sampler objects to create. </param>
        /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CreateSamplers(int n, int* samplers) => GLPointers.glCreateSamplers_Lazy(n, samplers);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glCreateShader</c>]</b><br/> Creates a shader object. </summary>
        /// <param name="type">Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml"/></remarks>
        public static int CreateShader(ShaderType type) => GLPointers.glCreateShader_Lazy((uint)type);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glCreateShaderProgramv</c>]</b><br/> Create a stand-alone program from an array of null-terminated source code strings. </summary>
        /// <param name="type"> Specifies the type of shader to create. </param>
        /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
        /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static int CreateShaderProgramv(ShaderType type, int count, byte** strings) => GLPointers.glCreateShaderProgramv_Lazy((uint)type, count, strings);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateTextures</c>]</b><br/> Create texture objects. </summary>
        /// <param name="target"> Specifies the effective texture target of each created texture. </param>
        /// <param name="n"> Number of texture objects to create. </param>
        /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CreateTextures(TextureTarget target, int n, int* textures) => GLPointers.glCreateTextures_Lazy((uint)target, n, textures);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateTransformFeedbacks</c>]</b><br/> Create transform feedback objects. </summary>
        /// <param name="n"> Number of transform feedback objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CreateTransformFeedbacks(int n, int* ids) => GLPointers.glCreateTransformFeedbacks_Lazy(n, ids);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateVertexArrays</c>]</b><br/> Create vertex array objects. </summary>
        /// <param name="n"> Number of vertex array objects to create. </param>
        /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void CreateVertexArrays(int n, int* arrays) => GLPointers.glCreateVertexArrays_Lazy(n, arrays);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glCullFace</c>]</b><br/> Specify whether front- or back-facing facets can be culled. </summary>
        /// <param name="mode"> Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCullFace.xhtml"/></remarks>
        public static void CullFace(TriangleFace mode) => GLPointers.glCullFace_Lazy((uint)mode);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageCallback</c>]</b><br/> Specify a callback to receive debugging messages from the GL. </summary>
        /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
        /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers.glDebugMessageCallback_Lazy(callback, userParam);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageControl</c>]</b><br/> Control the reporting of debug messages in a debug context. </summary>
        /// <param name="source"> The source of debug messages to enable or disable. </param>
        /// <param name="type"> The type of debug messages to enable or disable. </param>
        /// <param name="severity"> The severity of debug messages to enable or disable. </param>
        /// <param name="count"> The length of the array ids. </param>
        /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
        /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers.glDebugMessageControl_Lazy((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageInsert</c>]</b><br/> Inject an application-supplied message into the debug message queue. </summary>
        /// <param name="source"> The source of the debug message to insert. </param>
        /// <param name="type"> The type of the debug message insert. </param>
        /// <param name="id"> The user-supplied identifier of the message to insert. </param>
        /// <param name="severity"> The severity of the debug messages to insert. </param>
        /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
        /// <param name="buf"> The address of a character array containing the message to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers.glDebugMessageInsert_Lazy((uint)source, (uint)type, id, (uint)severity, length, buf);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glDeleteBuffers</c>]</b><br/> Delete named buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to be deleted. </param>
        /// <param name="buffers"> Specifies an array of buffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml"/></remarks>
        public static void DeleteBuffers(int n, int* buffers) => GLPointers.glDeleteBuffers_Lazy(n, buffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glDeleteFramebuffers</c>]</b><br/> Delete framebuffer objects. </summary>
        /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
        /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void DeleteFramebuffers(int n, int* framebuffers) => GLPointers.glDeleteFramebuffers_Lazy(n, framebuffers);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDeleteProgram</c>]</b><br/> Deletes a program object. </summary>
        /// <param name="program">Specifies the program object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml"/></remarks>
        public static void DeleteProgram(int program) => GLPointers.glDeleteProgram_Lazy(program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glDeleteProgramPipelines</c>]</b><br/> Delete program pipeline objects. </summary>
        /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
        /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void DeleteProgramPipelines(int n, int* pipelines) => GLPointers.glDeleteProgramPipelines_Lazy(n, pipelines);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glDeleteQueries</c>]</b><br/> Delete named query objects. </summary>
        /// <param name="n"> Specifies the number of query objects to be deleted. </param>
        /// <param name="ids"> Specifies an array of query objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteQueries.xhtml"/></remarks>
        public static void DeleteQueries(int n, int* ids) => GLPointers.glDeleteQueries_Lazy(n, ids);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glDeleteRenderbuffers</c>]</b><br/> Delete renderbuffer objects. </summary>
        /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
        /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void DeleteRenderbuffers(int n, int* renderbuffers) => GLPointers.glDeleteRenderbuffers_Lazy(n, renderbuffers);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glDeleteSamplers</c>]</b><br/> Delete named sampler objects. </summary>
        /// <param name="count"> Specifies the number of sampler objects to be deleted. </param>
        /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void DeleteSamplers(int count, int* samplers) => GLPointers.glDeleteSamplers_Lazy(count, samplers);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDeleteShader</c>]</b><br/> Deletes a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml"/></remarks>
        public static void DeleteShader(int shader) => GLPointers.glDeleteShader_Lazy(shader);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glDeleteSync</c>]</b><br/> Delete a sync object. </summary>
        /// <param name="sync"> The sync object to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
        public static void DeleteSync(GLSync sync) => GLPointers.glDeleteSync_Lazy((IntPtr)sync);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glDeleteTextures</c>]</b><br/> Delete named textures. </summary>
        /// <param name="n"> Specifies the number of textures to be deleted. </param>
        /// <param name="textures"> Specifies an array of textures to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTextures.xhtml"/></remarks>
        public static void DeleteTextures(int n, int* textures) => GLPointers.glDeleteTextures_Lazy(n, textures);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glDeleteTransformFeedbacks</c>]</b><br/> Delete transform feedback objects. </summary>
        /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
        /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
        public static void DeleteTransformFeedbacks(int n, int* ids) => GLPointers.glDeleteTransformFeedbacks_Lazy(n, ids);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glDeleteVertexArrays</c>]</b><br/> Delete vertex array objects. </summary>
        /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
        /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_array_object.txt"/></remarks>
        public static void DeleteVertexArrays(int n, int* arrays) => GLPointers.glDeleteVertexArrays_Lazy(n, arrays);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDepthFunc</c>]</b><br/> Specify the value used for depth buffer comparisons. </summary>
        /// <param name="func"> Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml"/></remarks>
        public static void DepthFunc(DepthFunction func) => GLPointers.glDepthFunc_Lazy((uint)func);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDepthMask</c>]</b><br/> Enable or disable writing into the depth buffer. </summary>
        /// <param name="flag"> Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthMask.xhtml"/></remarks>
        public static void DepthMask(bool flag) => GLPointers.glDepthMask_Lazy((byte)(flag ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDepthRange</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="n"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="f"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml"/></remarks>
        public static void DepthRange(double n, double f) => GLPointers.glDepthRange_Lazy(n, f);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeArrayv</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
        /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
        /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void DepthRangeArrayv(uint first, int count, double* v) => GLPointers.glDepthRangeArrayv_Lazy(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glDepthRangef</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="n"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="f"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
        public static void DepthRangef(float n, float f) => GLPointers.glDepthRangef_Lazy(n, f);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeIndexed</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
        /// <param name="n"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="f"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void DepthRangeIndexed(uint index, double n, double f) => GLPointers.glDepthRangeIndexed_Lazy(index, n, f);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDetachShader</c>]</b><br/> Detaches a shader object from a program object to which it is attached. </summary>
        /// <param name="program">Specifies the program object from which to detach the shader object.</param>
        /// <param name="shader">Specifies the shader object to be detached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDetachShader.xhtml"/></remarks>
        public static void DetachShader(int program, int shader) => GLPointers.glDetachShader_Lazy(program, shader);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDisable</c>]</b><br/> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml"/></remarks>
        public static void Disable(EnableCap cap) => GLPointers.glDisable_Lazy((uint)cap);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glDisablei</c>]</b><br/> Enable or disable server-side GL capabilities. </summary>
        /// <param name="target"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml"/></remarks>
        public static void Disablei(EnableCap target, uint index) => GLPointers.glDisablei_Lazy((uint)target, index);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glDisableVertexArrayAttrib</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void DisableVertexArrayAttrib(int vaobj, uint index) => GLPointers.glDisableVertexArrayAttrib_Lazy(vaobj, index);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDisableVertexAttribArray</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml"/></remarks>
        public static void DisableVertexAttribArray(uint index) => GLPointers.glDisableVertexAttribArray_Lazy(index);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> <b>[entry point: <c>glDispatchCompute</c>]</b><br/> Launch one or more compute work groups. </summary>
        /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
        /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
        /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_compute_shader.txt"/></remarks>
        public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => GLPointers.glDispatchCompute_Lazy(num_groups_x, num_groups_y, num_groups_z);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> <b>[entry point: <c>glDispatchComputeIndirect</c>]</b><br/> Launch one or more compute work groups using parameters stored in a buffer. </summary>
        /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_compute_shader.txt"/></remarks>
        public static void DispatchComputeIndirect(IntPtr indirect) => GLPointers.glDispatchComputeIndirect_Lazy(indirect);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glDrawArrays</c>]</b><br/> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml"/></remarks>
        public static void DrawArrays(PrimitiveType mode, int first, int count) => GLPointers.glDrawArrays_Lazy((uint)mode, first, count);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> <b>[entry point: <c>glDrawArraysIndirect</c>]</b><br/> Render primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_indirect.txt"/></remarks>
        public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => GLPointers.glDrawArraysIndirect_Lazy((uint)mode, indirect);
        
        /// <summary> <b>[requires: v3.1]</b> <b>[entry point: <c>glDrawArraysInstanced</c>]</b><br/> Draw multiple instances of a range of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstanced.xhtml"/></remarks>
        public static void DrawArraysInstanced(PrimitiveType mode, int first, int count, int instancecount) => GLPointers.glDrawArraysInstanced_Lazy((uint)mode, first, count, instancecount);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawArraysInstancedBaseInstance</c>]</b><br/> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_base_instance.txt"/></remarks>
        public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => GLPointers.glDrawArraysInstancedBaseInstance_Lazy((uint)mode, first, count, instancecount, baseinstance);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDrawBuffer</c>]</b><br/> Specify which color buffers are to be drawn into. </summary>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml"/></remarks>
        public static void DrawBuffer(DrawBufferMode buf) => GLPointers.glDrawBuffer_Lazy((uint)buf);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDrawBuffers</c>]</b><br/> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml"/></remarks>
        public static void DrawBuffers(int n, DrawBufferMode* bufs) => GLPointers.glDrawBuffers_Lazy(n, (uint*)bufs);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glDrawElements</c>]</b><br/> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElements.xhtml"/></remarks>
        public static void DrawElements(PrimitiveType mode, int count, DrawElementsType type, void* indices) => GLPointers.glDrawElements_Lazy((uint)mode, count, (uint)type, indices);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawElementsBaseVertex</c>]</b><br/> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_elements_base_vertex.txt"/></remarks>
        public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers.glDrawElementsBaseVertex_Lazy((uint)mode, count, (uint)type, indices, basevertex);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> <b>[entry point: <c>glDrawElementsIndirect</c>]</b><br/> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_indirect.txt"/></remarks>
        public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => GLPointers.glDrawElementsIndirect_Lazy((uint)mode, (uint)type, indirect);
        
        /// <summary> <b>[requires: v3.1]</b> <b>[entry point: <c>glDrawElementsInstanced</c>]</b><br/> Draw multiple instances of a set of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstanced.xhtml"/></remarks>
        public static void DrawElementsInstanced(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount) => GLPointers.glDrawElementsInstanced_Lazy((uint)mode, count, (uint)type, indices, instancecount);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawElementsInstancedBaseInstance</c>]</b><br/> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_base_instance.txt"/></remarks>
        public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, uint baseinstance) => GLPointers.glDrawElementsInstancedBaseInstance_Lazy((uint)mode, count, (uint)type, indices, instancecount, baseinstance);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawElementsInstancedBaseVertex</c>]</b><br/> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_elements_base_vertex.txt"/></remarks>
        public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => GLPointers.glDrawElementsInstancedBaseVertex_Lazy((uint)mode, count, (uint)type, indices, instancecount, basevertex);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawElementsInstancedBaseVertexBaseInstance</c>]</b><br/> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_base_instance.txt"/></remarks>
        public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => GLPointers.glDrawElementsInstancedBaseVertexBaseInstance_Lazy((uint)mode, count, (uint)type, indices, instancecount, basevertex, baseinstance);
        
        /// <summary> <b>[requires: v1.2]</b> <b>[entry point: <c>glDrawRangeElements</c>]</b><br/> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElements.xhtml"/></remarks>
        public static void DrawRangeElements(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => GLPointers.glDrawRangeElements_Lazy((uint)mode, start, end, count, (uint)type, indices);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawRangeElementsBaseVertex</c>]</b><br/> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_elements_base_vertex.txt"/></remarks>
        public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers.glDrawRangeElementsBaseVertex_Lazy((uint)mode, start, end, count, (uint)type, indices, basevertex);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glDrawTransformFeedback</c>]</b><br/> Render primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
        public static void DrawTransformFeedback(PrimitiveType mode, int id) => GLPointers.glDrawTransformFeedback_Lazy((uint)mode, id);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> <b>[entry point: <c>glDrawTransformFeedbackInstanced</c>]</b><br/> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback_instanced.txt"/></remarks>
        public static void DrawTransformFeedbackInstanced(PrimitiveType mode, int id, int instancecount) => GLPointers.glDrawTransformFeedbackInstanced_Lazy((uint)mode, id, instancecount);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glDrawTransformFeedbackStream</c>]</b><br/> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback3.txt"/></remarks>
        public static void DrawTransformFeedbackStream(PrimitiveType mode, int id, uint stream) => GLPointers.glDrawTransformFeedbackStream_Lazy((uint)mode, id, stream);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> <b>[entry point: <c>glDrawTransformFeedbackStreamInstanced</c>]</b><br/> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback_instanced.txt"/></remarks>
        public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, int id, uint stream, int instancecount) => GLPointers.glDrawTransformFeedbackStreamInstanced_Lazy((uint)mode, id, stream, instancecount);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glEnable</c>]</b><br/> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml"/></remarks>
        public static void Enable(EnableCap cap) => GLPointers.glEnable_Lazy((uint)cap);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glEnablei</c>]</b><br/> Enable or disable server-side GL capabilities. </summary>
        /// <param name="target"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml"/></remarks>
        public static void Enablei(EnableCap target, uint index) => GLPointers.glEnablei_Lazy((uint)target, index);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glEnableVertexArrayAttrib</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void EnableVertexArrayAttrib(int vaobj, uint index) => GLPointers.glEnableVertexArrayAttrib_Lazy(vaobj, index);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glEnableVertexAttribArray</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml"/></remarks>
        public static void EnableVertexAttribArray(uint index) => GLPointers.glEnableVertexAttribArray_Lazy(index);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glEndConditionalRender</c>]</b><br/> Start conditional rendering. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml"/></remarks>
        public static void EndConditionalRender() => GLPointers.glEndConditionalRender_Lazy();
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glEndQuery</c>]</b><br/> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml"/></remarks>
        public static void EndQuery(QueryTarget target) => GLPointers.glEndQuery_Lazy((uint)target);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glEndQueryIndexed</c>]</b><br/> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback3.txt"/></remarks>
        public static void EndQueryIndexed(QueryTarget target, uint index) => GLPointers.glEndQueryIndexed_Lazy((uint)target, index);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glEndTransformFeedback</c>]</b><br/> Start transform feedback operation. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml"/></remarks>
        public static void EndTransformFeedback() => GLPointers.glEndTransformFeedback_Lazy();
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glFenceSync</c>]</b><br/> Create a new sync object and insert it into the GL command stream. </summary>
        /// <param name="condition"> Specifies the condition that must be met to set the sync object&apos;s state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
        /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
        public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) GLPointers.glFenceSync_Lazy((uint)condition, (uint)flags);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glFinish</c>]</b><br/> Block until all GL execution is complete. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFinish.xhtml"/></remarks>
        public static void Finish() => GLPointers.glFinish_Lazy();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glFlush</c>]</b><br/> Force execution of GL commands in finite time. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlush.xhtml"/></remarks>
        public static void Flush() => GLPointers.glFlush_Lazy();
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> <b>[entry point: <c>glFlushMappedBufferRange</c>]</b><br/> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_map_buffer_range.txt"/></remarks>
        public static void FlushMappedBufferRange(BufferTarget target, IntPtr offset, nint length) => GLPointers.glFlushMappedBufferRange_Lazy((uint)target, offset, length);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glFlushMappedNamedBufferRange</c>]</b><br/> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void FlushMappedNamedBufferRange(int buffer, IntPtr offset, nint length) => GLPointers.glFlushMappedNamedBufferRange_Lazy(buffer, offset, length);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> <b>[entry point: <c>glFramebufferParameteri</c>]</b><br/> Set a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_no_attachments.txt"/></remarks>
        public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers.glFramebufferParameteri_Lazy((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferRenderbuffer</c>]</b><br/> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers.glFramebufferRenderbuffer_Lazy((uint)target, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
        
        /// <summary> <b>[requires: v3.2]</b> <b>[entry point: <c>glFramebufferTexture</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml"/></remarks>
        public static void FramebufferTexture(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level) => GLPointers.glFramebufferTexture_Lazy((uint)target, (uint)attachment, texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture1D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers.glFramebufferTexture1D_Lazy((uint)target, (uint)attachment, (uint)textarget, texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture2D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers.glFramebufferTexture2D_Lazy((uint)target, (uint)attachment, (uint)textarget, texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture3D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers.glFramebufferTexture3D_Lazy((uint)target, (uint)attachment, (uint)textarget, texture, level, zoffset);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTextureLayer</c>]</b><br/> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers.glFramebufferTextureLayer_Lazy((uint)target, (uint)attachment, texture, level, layer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glFrontFace</c>]</b><br/> Define front- and back-facing polygons. </summary>
        /// <param name="mode"> Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFrontFace.xhtml"/></remarks>
        public static void FrontFace(FrontFaceDirection mode) => GLPointers.glFrontFace_Lazy((uint)mode);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGenBuffers</c>]</b><br/> Generate buffer object names. </summary>
        /// <param name="n"> Specifies the number of buffer object names to be generated. </param>
        /// <param name="buffers"> Specifies an array in which the generated buffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml"/></remarks>
        public static void GenBuffers(int n, int* buffers) => GLPointers.glGenBuffers_Lazy(n, buffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenerateMipmap</c>]</b><br/> Generate mipmaps for a specified texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void GenerateMipmap(TextureTarget target) => GLPointers.glGenerateMipmap_Lazy((uint)target);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGenerateTextureMipmap</c>]</b><br/> Generate mipmaps for a specified texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GenerateTextureMipmap(int texture) => GLPointers.glGenerateTextureMipmap_Lazy(texture);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenFramebuffers</c>]</b><br/> Generate framebuffer object names. </summary>
        /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
        /// <param name="framebuffers"> Specifies an array in which the generated framebuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void GenFramebuffers(int n, int* framebuffers) => GLPointers.glGenFramebuffers_Lazy(n, framebuffers);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGenProgramPipelines</c>]</b><br/> Reserve program pipeline object names. </summary>
        /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
        /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void GenProgramPipelines(int n, int* pipelines) => GLPointers.glGenProgramPipelines_Lazy(n, pipelines);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGenQueries</c>]</b><br/> Generate query object names. </summary>
        /// <param name="n"> Specifies the number of query object names to be generated. </param>
        /// <param name="ids"> Specifies an array in which the generated query object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenQueries.xhtml"/></remarks>
        public static void GenQueries(int n, int* ids) => GLPointers.glGenQueries_Lazy(n, ids);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenRenderbuffers</c>]</b><br/> Generate renderbuffer object names. </summary>
        /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
        /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void GenRenderbuffers(int n, int* renderbuffers) => GLPointers.glGenRenderbuffers_Lazy(n, renderbuffers);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGenSamplers</c>]</b><br/> Generate sampler object names. </summary>
        /// <param name="count"> Specifies the number of sampler object names to generate. </param>
        /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void GenSamplers(int count, int* samplers) => GLPointers.glGenSamplers_Lazy(count, samplers);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glGenTextures</c>]</b><br/> Generate texture names. </summary>
        /// <param name="n"> Specifies the number of texture names to be generated. </param>
        /// <param name="textures"> Specifies an array in which the generated texture names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTextures.xhtml"/></remarks>
        public static void GenTextures(int n, int* textures) => GLPointers.glGenTextures_Lazy(n, textures);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glGenTransformFeedbacks</c>]</b><br/> Reserve transform feedback object names. </summary>
        /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
        /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
        public static void GenTransformFeedbacks(int n, int* ids) => GLPointers.glGenTransformFeedbacks_Lazy(n, ids);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glGenVertexArrays</c>]</b><br/> Generate vertex array object names. </summary>
        /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
        /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_array_object.txt"/></remarks>
        public static void GenVertexArrays(int n, int* arrays) => GLPointers.glGenVertexArrays_Lazy(n, arrays);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters]</b> <b>[entry point: <c>glGetActiveAtomicCounterBufferiv</c>]</b><br/> Retrieve information about the set of active atomic counter buffers for a program. </summary>
        /// <param name="program"> The name of a program object from which to retrieve information. </param>
        /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
        /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_atomic_counters.txt"/></remarks>
        public static void GetActiveAtomicCounterBufferiv(int program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => GLPointers.glGetActiveAtomicCounterBufferiv_Lazy(program, bufferIndex, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetActiveAttrib</c>]</b><br/> Returns information about an active attribute variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the attribute variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute variable.</param>
        /// <param name="type">Returns the data type of the attribute variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the attribute variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAttrib.xhtml"/></remarks>
        public static void GetActiveAttrib(int program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers.glGetActiveAttrib_Lazy(program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineName</c>]</b><br/> Query the name of an active shader subroutine. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
        /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
        public static void GetActiveSubroutineName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers.glGetActiveSubroutineName_Lazy(program, (uint)shadertype, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineUniformiv</c>]</b><br/> Query a property of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
        /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
        public static void GetActiveSubroutineUniformiv(int program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => GLPointers.glGetActiveSubroutineUniformiv_Lazy(program, (uint)shadertype, index, (uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineUniformName</c>]</b><br/> Query the name of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
        /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
        public static void GetActiveSubroutineUniformName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers.glGetActiveSubroutineUniformName_Lazy(program, (uint)shadertype, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetActiveUniform</c>]</b><br/> Returns information about an active uniform variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform variable.</param>
        /// <param name="type">Returns the data type of the uniform variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniform.xhtml"/></remarks>
        public static void GetActiveUniform(int program, uint index, int bufSize, int* length, int* size, UniformType* type, byte* name) => GLPointers.glGetActiveUniform_Lazy(program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformBlockiv</c>]</b><br/> Query information about an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="pname"> Specifies the name of the parameter to query. </param>
        /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static void GetActiveUniformBlockiv(int program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => GLPointers.glGetActiveUniformBlockiv_Lazy(program, uniformBlockIndex, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformBlockName</c>]</b><br/> Retrieve the name of an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static void GetActiveUniformBlockName(int program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => GLPointers.glGetActiveUniformBlockName_Lazy(program, uniformBlockIndex, bufSize, length, uniformBlockName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformName</c>]</b><br/> Query the name of an active uniform. </summary>
        /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
        /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
        /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
        /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
        /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static void GetActiveUniformName(int program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => GLPointers.glGetActiveUniformName_Lazy(program, uniformIndex, bufSize, length, uniformName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformsiv</c>]</b><br/> Returns information about several active uniform variables for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
        /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
        /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
        /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static void GetActiveUniformsiv(int program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => GLPointers.glGetActiveUniformsiv_Lazy(program, uniformCount, uniformIndices, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetAttachedShaders</c>]</b><br/> Returns the handles of the shader objects attached to a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned in shaders.</param>
        /// <param name="shaders">Specifies an array that is used to return the names of attached shader objects.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml"/></remarks>
        public static void GetAttachedShaders(int program, int maxCount, int* count, int* shaders) => GLPointers.glGetAttachedShaders_Lazy(program, maxCount, count, shaders);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetAttribLocation</c>]</b><br/> Returns the location of an attribute variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttribLocation.xhtml"/></remarks>
        public static int GetAttribLocation(int program, byte* name) => GLPointers.glGetAttribLocation_Lazy(program, name);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetBooleani_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/></remarks>
        public static void GetBooleani_v(BufferTarget target, uint index, bool* data) => GLPointers.glGetBooleani_v_Lazy((uint)target, index, (byte*)data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetBooleanv</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/></remarks>
        public static void GetBooleanv(GetPName pname, bool* data) => GLPointers.glGetBooleanv_Lazy((uint)pname, (byte*)data);
        
        /// <summary> <b>[requires: v3.2]</b> <b>[entry point: <c>glGetBufferParameteri64v</c>]</b><br/> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="pname"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="parameters"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml"/></remarks>
        public static void GetBufferParameteri64v(BufferTarget target, BufferPName pname, long* parameters) => GLPointers.glGetBufferParameteri64v_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetBufferParameteriv</c>]</b><br/> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="pname"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="parameters"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml"/></remarks>
        public static void GetBufferParameteriv(BufferTarget target, BufferPName pname, int* parameters) => GLPointers.glGetBufferParameteriv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetBufferPointerv</c>]</b><br/> Return the pointer to a mapped buffer object&apos;s data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml"/></remarks>
        public static void GetBufferPointerv(BufferTarget target, BufferPointerNameARB pname, void** parameters) => GLPointers.glGetBufferPointerv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetBufferSubData</c>]</b><br/> Returns a subset of a buffer object&apos;s data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml"/></remarks>
        public static void GetBufferSubData(BufferTarget target, IntPtr offset, nint size, void* data) => GLPointers.glGetBufferSubData_Lazy((uint)target, offset, size, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glGetCompressedTexImage</c>]</b><br/> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="img">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml"/></remarks>
        public static void GetCompressedTexImage(TextureTarget target, int level, void* img) => GLPointers.glGetCompressedTexImage_Lazy((uint)target, level, img);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetCompressedTextureImage</c>]</b><br/> Return a compressed texture image. </summary>
        /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetCompressedTextureImage(int texture, int level, int bufSize, void* pixels) => GLPointers.glGetCompressedTextureImage_Lazy(texture, level, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> <b>[entry point: <c>glGetCompressedTextureSubImage</c>]</b><br/> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block&apos;s width, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block&apos;s height, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block&apos;s depth, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_texture_sub_image.txt"/></remarks>
        public static void GetCompressedTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => GLPointers.glGetCompressedTextureSubImage_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetDebugMessageLog</c>]</b><br/> Retrieve messages from the debug message log. </summary>
        /// <param name="count"> The number of debug messages to retrieve from the log. </param>
        /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
        /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
        /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
        /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
        /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
        /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
        /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers.glGetDebugMessageLog_Lazy(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glGetDoublei_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void GetDoublei_v(GetPName target, uint index, double* data) => GLPointers.glGetDoublei_v_Lazy((uint)target, index, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetDoublev</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/></remarks>
        public static void GetDoublev(GetPName pname, double* data) => GLPointers.glGetDoublev_Lazy((uint)pname, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetError</c>]</b><br/> Return error information. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetError.xhtml"/></remarks>
        public static ErrorCode GetError() => (ErrorCode) GLPointers.glGetError_Lazy();
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glGetFloati_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void GetFloati_v(GetPName target, uint index, float* data) => GLPointers.glGetFloati_v_Lazy((uint)target, index, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetFloatv</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/></remarks>
        public static void GetFloatv(GetPName pname, float* data) => GLPointers.glGetFloatv_Lazy((uint)pname, data);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> <b>[entry point: <c>glGetFragDataIndex</c>]</b><br/> Query the bindings of color indices to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_blend_func_extended.txt"/></remarks>
        public static int GetFragDataIndex(int program, byte* name) => GLPointers.glGetFragDataIndex_Lazy(program, name);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetFragDataLocation</c>]</b><br/> Query the bindings of color numbers to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataLocation.xhtml"/></remarks>
        public static int GetFragDataLocation(int program, byte* name) => GLPointers.glGetFragDataLocation_Lazy(program, name);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGetFramebufferAttachmentParameteriv</c>]</b><br/> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers.glGetFramebufferAttachmentParameteriv_Lazy((uint)target, (uint)attachment, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> <b>[entry point: <c>glGetFramebufferParameteriv</c>]</b><br/> Query a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_no_attachments.txt"/></remarks>
        public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers.glGetFramebufferParameteriv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetGraphicsResetStatus</c>]</b><br/> Check if the rendering context has not been lost due to software or hardware issues. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
        public static GraphicsResetStatus GetGraphicsResetStatus() => (GraphicsResetStatus) GLPointers.glGetGraphicsResetStatus_Lazy();
        
        /// <summary> <b>[requires: v3.2]</b> <b>[entry point: <c>glGetInteger64i_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/></remarks>
        public static void GetInteger64i_v(GetPName target, uint index, long* data) => GLPointers.glGetInteger64i_v_Lazy((uint)target, index, data);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glGetInteger64v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
        public static void GetInteger64v(GetPName pname, long* data) => GLPointers.glGetInteger64v_Lazy((uint)pname, data);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetIntegeri_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static void GetIntegeri_v(GetPName target, uint index, int* data) => GLPointers.glGetIntegeri_v_Lazy((uint)target, index, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetIntegerv</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/></remarks>
        public static void GetIntegerv(GetPName pname, int* data) => GLPointers.glGetIntegerv_Lazy((uint)pname, data);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2]</b> <b>[entry point: <c>glGetInternalformati64v</c>]</b><br/> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="count"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_internalformat_query2.txt"/></remarks>
        public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => GLPointers.glGetInternalformati64v_Lazy((uint)target, (uint)internalformat, (uint)pname, count, parameters);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query]</b> <b>[entry point: <c>glGetInternalformativ</c>]</b><br/> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="count"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_internalformat_query.txt"/></remarks>
        public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => GLPointers.glGetInternalformativ_Lazy((uint)target, (uint)internalformat, (uint)pname, count, parameters);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glGetMultisamplefv</c>]</b><br/> Retrieve the location of a sample. </summary>
        /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
        /// <param name="index"> Specifies the index of the sample whose position to query. </param>
        /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_multisample.txt"/></remarks>
        public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers.glGetMultisamplefv_Lazy((uint)pname, index, val);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameteri64v</c>]</b><br/> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetNamedBufferParameteri64v(int buffer, BufferPName pname, long* parameters) => GLPointers.glGetNamedBufferParameteri64v_Lazy(buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameteriv</c>]</b><br/> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetNamedBufferParameteriv(int buffer, BufferPName pname, int* parameters) => GLPointers.glGetNamedBufferParameteriv_Lazy(buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferPointerv</c>]</b><br/> Return the pointer to a mapped buffer object&apos;s data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetNamedBufferPointerv(int buffer, BufferPointerNameARB pname, void** parameters) => GLPointers.glGetNamedBufferPointerv_Lazy(buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferSubData</c>]</b><br/> Returns a subset of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetNamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers.glGetNamedBufferSubData_Lazy(buffer, offset, size, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferAttachmentParameteriv</c>]</b><br/> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetNamedFramebufferAttachmentParameteriv(int framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers.glGetNamedFramebufferAttachmentParameteriv_Lazy(framebuffer, (uint)attachment, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferParameteriv</c>]</b><br/> Query a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="param">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetNamedFramebufferParameteriv(int framebuffer, GetFramebufferParameter pname, int* param) => GLPointers.glGetNamedFramebufferParameteriv_Lazy(framebuffer, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedRenderbufferParameteriv</c>]</b><br/> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetNamedRenderbufferParameteriv(int renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers.glGetNamedRenderbufferParameteriv_Lazy(renderbuffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnCompressedTexImage</c>]</b><br/> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="lod">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml"/></remarks>
        public static void GetnCompressedTexImage(TextureTarget target, int lod, int bufSize, void* pixels) => GLPointers.glGetnCompressedTexImage_Lazy((uint)target, lod, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnTexImage</c>]</b><br/> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml"/></remarks>
        public static void GetnTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers.glGetnTexImage_Lazy((uint)target, level, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnUniformdv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/></remarks>
        public static void GetnUniformdv(int program, int location, int bufSize, double* parameters) => GLPointers.glGetnUniformdv_Lazy(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformfv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
        public static void GetnUniformfv(int program, int location, int bufSize, float* parameters) => GLPointers.glGetnUniformfv_Lazy(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
        public static void GetnUniformiv(int program, int location, int bufSize, int* parameters) => GLPointers.glGetnUniformiv_Lazy(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformuiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
        public static void GetnUniformuiv(int program, int location, int bufSize, uint* parameters) => GLPointers.glGetnUniformuiv_Lazy(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectLabel</c>]</b><br/> Retrieve the label of a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => GLPointers.glGetObjectLabel_Lazy((uint)identifier, name, bufSize, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectPtrLabel</c>]</b><br/> Retrieve the label of a sync object identified by a pointer. </summary>
        /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => GLPointers.glGetObjectPtrLabel_Lazy(ptr, bufSize, length, label);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> <b>[entry point: <c>glGetProgramBinary</c>]</b><br/> Return a binary representation of a program object&apos;s compiled and linked executable source. </summary>
        /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
        /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
        /// <param name="binary"> Specifies the address an array into which the GL will return program&apos;s binary representation. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_program_binary.txt"/></remarks>
        public static void GetProgramBinary(int program, int bufSize, int* length, All* binaryFormat, void* binary) => GLPointers.glGetProgramBinary_Lazy(program, bufSize, length, (uint*)binaryFormat, binary);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetProgramInfoLog</c>]</b><br/> Returns the information log for a program object. </summary>
        /// <param name="program">Specifies the program object whose information log is to be queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml"/></remarks>
        public static void GetProgramInfoLog(int program, int bufSize, int* length, byte* infoLog) => GLPointers.glGetProgramInfoLog_Lazy(program, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramInterfaceiv</c>]</b><br/> Query a property of an interface in a program. </summary>
        /// <param name="program"> The name of a program object whose interface to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program to query. </param>
        /// <param name="pname"> The name of the parameter within programInterface to query. </param>
        /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
        public static void GetProgramInterfaceiv(int program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => GLPointers.glGetProgramInterfaceiv_Lazy(program, (uint)programInterface, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetProgramiv</c>]</b><br/> Returns a parameter from a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgram.xhtml"/></remarks>
        public static void GetProgramiv(int program, ProgramProperty pname, int* parameters) => GLPointers.glGetProgramiv_Lazy(program, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineInfoLog</c>]</b><br/> Retrieve the info log string from a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
        /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
        /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
        /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void GetProgramPipelineInfoLog(int pipeline, int bufSize, int* length, byte* infoLog) => GLPointers.glGetProgramPipelineInfoLog_Lazy(pipeline, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineiv</c>]</b><br/> Retrieve properties of a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
        /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void GetProgramPipelineiv(int pipeline, PipelineParameterName pname, int* parameters) => GLPointers.glGetProgramPipelineiv_Lazy(pipeline, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceIndex</c>]</b><br/> Query the index of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the index of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
        public static uint GetProgramResourceIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers.glGetProgramResourceIndex_Lazy(program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceiv</c>]</b><br/> Retrieve values for multiple properties of a single active resource within a program object. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="index">!!missing documentation!!</param>
        /// <param name="propCount">!!missing documentation!!</param>
        /// <param name="props">!!missing documentation!!</param>
        /// <param name="count">!!missing documentation!!</param>
        /// <param name="length">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
        public static void GetProgramResourceiv(int program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => GLPointers.glGetProgramResourceiv_Lazy(program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceLocation</c>]</b><br/> Query the location of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
        public static int GetProgramResourceLocation(int program, ProgramInterface programInterface, byte* name) => GLPointers.glGetProgramResourceLocation_Lazy(program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceLocationIndex</c>]</b><br/> Query the fragment color index of a named variable within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
        public static int GetProgramResourceLocationIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers.glGetProgramResourceLocationIndex_Lazy(program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceName</c>]</b><br/> Query the name of an indexed resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
        /// <param name="index"> The index of the resource within programInterface of program. </param>
        /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
        /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
        /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
        public static void GetProgramResourceName(int program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => GLPointers.glGetProgramResourceName_Lazy(program, (uint)programInterface, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetProgramStageiv</c>]</b><br/> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
        /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
        public static void GetProgramStageiv(int program, ShaderType shadertype, ProgramStagePName pname, int* values) => GLPointers.glGetProgramStageiv_Lazy(program, (uint)shadertype, (uint)pname, values);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjecti64v</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetQueryBufferObjecti64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers.glGetQueryBufferObjecti64v_Lazy(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectiv</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetQueryBufferObjectiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers.glGetQueryBufferObjectiv_Lazy(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectui64v</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetQueryBufferObjectui64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers.glGetQueryBufferObjectui64v_Lazy(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectuiv</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetQueryBufferObjectuiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers.glGetQueryBufferObjectuiv_Lazy(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glGetQueryIndexediv</c>]</b><br/> Return parameters of an indexed query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="index"> Specifies the index of the query object target. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback3.txt"/></remarks>
        public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => GLPointers.glGetQueryIndexediv_Lazy((uint)target, index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetQueryiv</c>]</b><br/> Return parameters of a query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryiv.xhtml"/></remarks>
        public static void GetQueryiv(QueryTarget target, QueryParameterName pname, int* parameters) => GLPointers.glGetQueryiv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glGetQueryObjecti64v</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_timer_query.txt"/></remarks>
        public static void GetQueryObjecti64v(int id, QueryObjectParameterName pname, long* parameters) => GLPointers.glGetQueryObjecti64v_Lazy(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetQueryObjectiv</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/></remarks>
        public static void GetQueryObjectiv(int id, QueryObjectParameterName pname, int* parameters) => GLPointers.glGetQueryObjectiv_Lazy(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glGetQueryObjectui64v</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_timer_query.txt"/></remarks>
        public static void GetQueryObjectui64v(int id, QueryObjectParameterName pname, ulong* parameters) => GLPointers.glGetQueryObjectui64v_Lazy(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetQueryObjectuiv</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/></remarks>
        public static void GetQueryObjectuiv(int id, QueryObjectParameterName pname, uint* parameters) => GLPointers.glGetQueryObjectuiv_Lazy(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGetRenderbufferParameteriv</c>]</b><br/> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers.glGetRenderbufferParameteriv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterfv</c>]</b><br/> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void GetSamplerParameterfv(int sampler, SamplerParameterF pname, float* parameters) => GLPointers.glGetSamplerParameterfv_Lazy(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterIiv</c>]</b><br/> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void GetSamplerParameterIiv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers.glGetSamplerParameterIiv_Lazy(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterIuiv</c>]</b><br/> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void GetSamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* parameters) => GLPointers.glGetSamplerParameterIuiv_Lazy(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameteriv</c>]</b><br/> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void GetSamplerParameteriv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers.glGetSamplerParameteriv_Lazy(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetShaderInfoLog</c>]</b><br/> Returns the information log for a shader object. </summary>
        /// <param name="shader">Specifies the shader object whose information log is to be queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml"/></remarks>
        public static void GetShaderInfoLog(int shader, int bufSize, int* length, byte* infoLog) => GLPointers.glGetShaderInfoLog_Lazy(shader, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetShaderiv</c>]</b><br/> Returns a parameter from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShader.xhtml"/></remarks>
        public static void GetShaderiv(int shader, ShaderParameterName pname, int* parameters) => GLPointers.glGetShaderiv_Lazy(shader, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glGetShaderPrecisionFormat</c>]</b><br/> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
        /// <param name="shadertype"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="precisiontype"> Specifies the numeric format whose precision and range to query. </param>
        /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation&apos;s numeric range are returned. </param>
        /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
        public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => GLPointers.glGetShaderPrecisionFormat_Lazy((uint)shadertype, (uint)precisiontype, range, precision);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetShaderSource</c>]</b><br/> Returns the source code string from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in source (excluding the null terminator).</param>
        /// <param name="source">Specifies an array of characters that is used to return the source code string.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderSource.xhtml"/></remarks>
        public static void GetShaderSource(int shader, int bufSize, int* length, byte* source) => GLPointers.glGetShaderSource_Lazy(shader, bufSize, length, source);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetString</c>]</b><br/> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml"/></remarks>
        public static byte* GetString_(StringName name) => GLPointers.glGetString_Lazy((uint)name);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetStringi</c>]</b><br/> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <param name="index"> For glGetStringi, specifies the index of the string to return. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml"/></remarks>
        public static byte* GetStringi_(StringName name, uint index) => GLPointers.glGetStringi_Lazy((uint)name, index);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetSubroutineIndex</c>]</b><br/> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
        public static uint GetSubroutineIndex(int program, ShaderType shadertype, byte* name) => GLPointers.glGetSubroutineIndex_Lazy(program, (uint)shadertype, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetSubroutineUniformLocation</c>]</b><br/> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
        public static int GetSubroutineUniformLocation(int program, ShaderType shadertype, byte* name) => GLPointers.glGetSubroutineUniformLocation_Lazy(program, (uint)shadertype, name);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glGetSynciv</c>]</b><br/> Query the properties of a sync object. </summary>
        /// <param name="sync"> Specifies the sync object whose properties to query. </param>
        /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
        /// <param name="count"> Specifies the size of the buffer whose address is given in values. </param>
        /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
        /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
        public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => GLPointers.glGetSynciv_Lazy((IntPtr)sync, (uint)pname, count, length, values);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexImage</c>]</b><br/> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml"/></remarks>
        public static void GetTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers.glGetTexImage_Lazy((uint)target, level, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexLevelParameterfv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml"/></remarks>
        public static void GetTexLevelParameterfv(TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers.glGetTexLevelParameterfv_Lazy((uint)target, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexLevelParameteriv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml"/></remarks>
        public static void GetTexLevelParameteriv(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers.glGetTexLevelParameteriv_Lazy((uint)target, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexParameterfv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/></remarks>
        public static void GetTexParameterfv(TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers.glGetTexParameterfv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetTexParameterIiv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/></remarks>
        public static void GetTexParameterIiv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers.glGetTexParameterIiv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetTexParameterIuiv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/></remarks>
        public static void GetTexParameterIuiv(TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers.glGetTexParameterIuiv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexParameteriv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/></remarks>
        public static void GetTexParameteriv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers.glGetTexParameteriv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureImage</c>]</b><br/> Return a texture image. </summary>
        /// <param name="texture"> Specifies the texture object name. </param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTextureImage(int texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers.glGetTextureImage_Lazy(texture, level, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameterfv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTextureLevelParameterfv(int texture, int level, GetTextureParameter pname, float* parameters) => GLPointers.glGetTextureLevelParameterfv_Lazy(texture, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameteriv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTextureLevelParameteriv(int texture, int level, GetTextureParameter pname, int* parameters) => GLPointers.glGetTextureLevelParameteriv_Lazy(texture, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterfv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTextureParameterfv(int texture, GetTextureParameter pname, float* parameters) => GLPointers.glGetTextureParameterfv_Lazy(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIiv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTextureParameterIiv(int texture, GetTextureParameter pname, int* parameters) => GLPointers.glGetTextureParameterIiv_Lazy(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIuiv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTextureParameterIuiv(int texture, GetTextureParameter pname, uint* parameters) => GLPointers.glGetTextureParameterIuiv_Lazy(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameteriv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTextureParameteriv(int texture, GetTextureParameter pname, int* parameters) => GLPointers.glGetTextureParameteriv_Lazy(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> <b>[entry point: <c>glGetTextureSubImage</c>]</b><br/> Retrieve a sub-region of a texture image from a texture    object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_texture_sub_image.txt"/></remarks>
        public static void GetTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers.glGetTextureSubImage_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbacki_v</c>]</b><br/> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTransformFeedbacki_v(int xfb, TransformFeedbackPName pname, uint index, int* param) => GLPointers.glGetTransformFeedbacki_v_Lazy(xfb, (uint)pname, index, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbacki64_v</c>]</b><br/> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTransformFeedbacki64_v(int xfb, TransformFeedbackPName pname, uint index, long* param) => GLPointers.glGetTransformFeedbacki64_v_Lazy(xfb, (uint)pname, index, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbackiv</c>]</b><br/> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetTransformFeedbackiv(int xfb, TransformFeedbackPName pname, int* param) => GLPointers.glGetTransformFeedbackiv_Lazy(xfb, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetTransformFeedbackVarying</c>]</b><br/> Retrieve information about varying variables selected for transform feedback. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="index"> The index of the varying variable whose information to retrieve. </param>
        /// <param name="bufSize"> The maximum number of characters, including the null terminator, that may be written into name. </param>
        /// <param name="length"> The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned. </param>
        /// <param name="size"> The address of a variable that will receive the size of the varying. </param>
        /// <param name="type"> The address of a variable that will receive the type of the varying. </param>
        /// <param name="name"> The address of a buffer into which will be written the name of the varying. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedbackVarying.xhtml"/></remarks>
        public static void GetTransformFeedbackVarying(int program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers.glGetTransformFeedbackVarying_Lazy(program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetUniformBlockIndex</c>]</b><br/> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static uint GetUniformBlockIndex(int program, byte* uniformBlockName) => GLPointers.glGetUniformBlockIndex_Lazy(program, uniformBlockName);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glGetUniformdv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void GetUniformdv(int program, int location, double* parameters) => GLPointers.glGetUniformdv_Lazy(program, location, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetUniformfv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/></remarks>
        public static void GetUniformfv(int program, int location, float* parameters) => GLPointers.glGetUniformfv_Lazy(program, location, parameters);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetUniformIndices</c>]</b><br/> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
        /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
        /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
        /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static void GetUniformIndices(int program, int uniformCount, byte** uniformNames, uint* uniformIndices) => GLPointers.glGetUniformIndices_Lazy(program, uniformCount, uniformNames, uniformIndices);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetUniformiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/></remarks>
        public static void GetUniformiv(int program, int location, int* parameters) => GLPointers.glGetUniformiv_Lazy(program, location, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetUniformLocation</c>]</b><br/> Returns the location of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml"/></remarks>
        public static int GetUniformLocation(int program, byte* name) => GLPointers.glGetUniformLocation_Lazy(program, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetUniformSubroutineuiv</c>]</b><br/> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="location"> Specifies the location of the subroutine uniform. </param>
        /// <param name="parameters"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
        public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => GLPointers.glGetUniformSubroutineuiv_Lazy((uint)shadertype, location, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetUniformuiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/></remarks>
        public static void GetUniformuiv(int program, int location, uint* parameters) => GLPointers.glGetUniformuiv_Lazy(program, location, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIndexed64iv</c>]</b><br/> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetVertexArrayIndexed64iv(int vaobj, uint index, VertexArrayPName pname, long* param) => GLPointers.glGetVertexArrayIndexed64iv_Lazy(vaobj, index, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIndexediv</c>]</b><br/> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetVertexArrayIndexediv(int vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers.glGetVertexArrayIndexediv_Lazy(vaobj, index, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayiv</c>]</b><br/> Retrieve parameters of a vertex array object. </summary>
        /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
        /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void GetVertexArrayiv(int vaobj, VertexArrayPName pname, int* param) => GLPointers.glGetVertexArrayiv_Lazy(vaobj, (uint)pname, param);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetVertexAttribdv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml"/></remarks>
        public static void GetVertexAttribdv(uint index, VertexAttribPropertyARB pname, double* parameters) => GLPointers.glGetVertexAttribdv_Lazy(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetVertexAttribfv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml"/></remarks>
        public static void GetVertexAttribfv(uint index, VertexAttribPropertyARB pname, float* parameters) => GLPointers.glGetVertexAttribfv_Lazy(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetVertexAttribIiv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml"/></remarks>
        public static void GetVertexAttribIiv(uint index, VertexAttribEnum pname, int* parameters) => GLPointers.glGetVertexAttribIiv_Lazy(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetVertexAttribIuiv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml"/></remarks>
        public static void GetVertexAttribIuiv(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers.glGetVertexAttribIuiv_Lazy(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetVertexAttribiv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml"/></remarks>
        public static void GetVertexAttribiv(uint index, VertexAttribPropertyARB pname, int* parameters) => GLPointers.glGetVertexAttribiv_Lazy(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glGetVertexAttribLdv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => GLPointers.glGetVertexAttribLdv_Lazy(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetVertexAttribPointerv</c>]</b><br/> Return the address of the specified generic vertex attribute pointer. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be returned.</param>
        /// <param name="pname">Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.</param>
        /// <param name="pointer">Returns the pointer value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttribPointerv.xhtml"/></remarks>
        public static void GetVertexAttribPointerv(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => GLPointers.glGetVertexAttribPointerv_Lazy(index, (uint)pname, pointer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glHint</c>]</b><br/> Specify implementation-specific hints. </summary>
        /// <param name="target"> Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted. </param>
        /// <param name="mode"> Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glHint.xhtml"/></remarks>
        public static void Hint(HintTarget target, HintMode mode) => GLPointers.glHint_Lazy((uint)target, (uint)mode);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateBufferData</c>]</b><br/> Invalidate the content of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
        public static void InvalidateBufferData(int buffer) => GLPointers.glInvalidateBufferData_Lazy(buffer);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateBufferSubData</c>]</b><br/> Invalidate a region of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
        /// <param name="offset"> The offset within the buffer&apos;s data store of the start of the range to be invalidated. </param>
        /// <param name="length"> The length of the range within the buffer&apos;s data store to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
        public static void InvalidateBufferSubData(int buffer, IntPtr offset, nint length) => GLPointers.glInvalidateBufferSubData_Lazy(buffer, offset, length);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateFramebuffer</c>]</b><br/> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
        public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => GLPointers.glInvalidateFramebuffer_Lazy((uint)target, numAttachments, (uint*)attachments);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glInvalidateNamedFramebufferData</c>]</b><br/> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void InvalidateNamedFramebufferData(int framebuffer, int numAttachments, FramebufferAttachment* attachments) => GLPointers.glInvalidateNamedFramebufferData_Lazy(framebuffer, numAttachments, (uint*)attachments);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glInvalidateNamedFramebufferSubData</c>]</b><br/> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void InvalidateNamedFramebufferSubData(int framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers.glInvalidateNamedFramebufferSubData_Lazy(framebuffer, numAttachments, (uint*)attachments, x, y, width, height);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateSubFramebuffer</c>]</b><br/> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
        public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers.glInvalidateSubFramebuffer_Lazy((uint)target, numAttachments, (uint*)attachments, x, y, width, height);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateTexImage</c>]</b><br/> Invalidate the entirety a texture image. </summary>
        /// <param name="texture"> The name of a texture object to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
        public static void InvalidateTexImage(int texture, int level) => GLPointers.glInvalidateTexImage_Lazy(texture, level);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateTexSubImage</c>]</b><br/> Invalidate a region of a texture image. </summary>
        /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
        /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
        /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
        /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
        /// <param name="width"> The width of the region to be invalidated. </param>
        /// <param name="height"> The height of the region to be invalidated. </param>
        /// <param name="depth"> The depth of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
        public static void InvalidateTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => GLPointers.glInvalidateTexSubImage_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glIsBuffer</c>]</b><br/> Determine if a name corresponds to a buffer object. </summary>
        /// <param name="buffer"> Specifies a value that may be the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsBuffer.xhtml"/></remarks>
        public static bool IsBuffer(int buffer) => GLPointers.glIsBuffer_Lazy(buffer) != 0;
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glIsEnabled</c>]</b><br/> Test whether a capability is enabled. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml"/></remarks>
        public static bool IsEnabled(EnableCap cap) => GLPointers.glIsEnabled_Lazy((uint)cap) != 0;
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glIsEnabledi</c>]</b><br/> Test whether a capability is enabled. </summary>
        /// <param name="target"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml"/></remarks>
        public static bool IsEnabledi(EnableCap target, uint index) => GLPointers.glIsEnabledi_Lazy((uint)target, index) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glIsFramebuffer</c>]</b><br/> Determine if a name corresponds to a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static bool IsFramebuffer(int framebuffer) => GLPointers.glIsFramebuffer_Lazy(framebuffer) != 0;
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glIsProgram</c>]</b><br/> Determines if a name corresponds to a program object. </summary>
        /// <param name="program">Specifies a potential program object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgram.xhtml"/></remarks>
        public static bool IsProgram(int program) => GLPointers.glIsProgram_Lazy(program) != 0;
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glIsProgramPipeline</c>]</b><br/> Determine if a name corresponds to a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static bool IsProgramPipeline(int pipeline) => GLPointers.glIsProgramPipeline_Lazy(pipeline) != 0;
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glIsQuery</c>]</b><br/> Determine if a name corresponds to a query object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsQuery.xhtml"/></remarks>
        public static bool IsQuery(int id) => GLPointers.glIsQuery_Lazy(id) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glIsRenderbuffer</c>]</b><br/> Determine if a name corresponds to a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static bool IsRenderbuffer(int renderbuffer) => GLPointers.glIsRenderbuffer_Lazy(renderbuffer) != 0;
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glIsSampler</c>]</b><br/> Determine if a name corresponds to a sampler object. </summary>
        /// <param name="sampler"> Specifies a value that may be the name of a sampler object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static bool IsSampler(int sampler) => GLPointers.glIsSampler_Lazy(sampler) != 0;
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glIsShader</c>]</b><br/> Determines if a name corresponds to a shader object. </summary>
        /// <param name="shader">Specifies a potential shader object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsShader.xhtml"/></remarks>
        public static bool IsShader(int shader) => GLPointers.glIsShader_Lazy(shader) != 0;
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glIsSync</c>]</b><br/> Determine if a name corresponds to a sync object. </summary>
        /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
        public static bool IsSync(GLSync sync) => GLPointers.glIsSync_Lazy((IntPtr)sync) != 0;
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glIsTexture</c>]</b><br/> Determine if a name corresponds to a texture. </summary>
        /// <param name="texture"> Specifies a value that may be the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTexture.xhtml"/></remarks>
        public static bool IsTexture(int texture) => GLPointers.glIsTexture_Lazy(texture) != 0;
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glIsTransformFeedback</c>]</b><br/> Determine if a name corresponds to a transform feedback object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
        public static bool IsTransformFeedback(int id) => GLPointers.glIsTransformFeedback_Lazy(id) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glIsVertexArray</c>]</b><br/> Determine if a name corresponds to a vertex array object. </summary>
        /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_array_object.txt"/></remarks>
        public static bool IsVertexArray(int array) => GLPointers.glIsVertexArray_Lazy(array) != 0;
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glLineWidth</c>]</b><br/> Specify the width of rasterized lines. </summary>
        /// <param name="width"> Specifies the width of rasterized lines. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLineWidth.xhtml"/></remarks>
        public static void LineWidth(float width) => GLPointers.glLineWidth_Lazy(width);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glLinkProgram</c>]</b><br/> Links a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be linked.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml"/></remarks>
        public static void LinkProgram(int program) => GLPointers.glLinkProgram_Lazy(program);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glLogicOp</c>]</b><br/> Specify a logical pixel operation for rendering. </summary>
        /// <param name="opcode"> Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLogicOp.xhtml"/></remarks>
        public static void LogicOp(LogicOp opcode) => GLPointers.glLogicOp_Lazy((uint)opcode);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glMapBuffer</c>]</b><br/> Map all of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object&apos;s mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml"/></remarks>
        public static void* MapBuffer(BufferTarget target, BufferAccess access) => GLPointers.glMapBuffer_Lazy((uint)target, (uint)access);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> <b>[entry point: <c>glMapBufferRange</c>]</b><br/> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_map_buffer_range.txt"/></remarks>
        public static void* MapBufferRange(BufferTarget target, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers.glMapBufferRange_Lazy((uint)target, offset, length, (uint)access);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glMapNamedBuffer</c>]</b><br/> Map all of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object&apos;s mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void* MapNamedBuffer(int buffer, BufferAccess access) => GLPointers.glMapNamedBuffer_Lazy(buffer, (uint)access);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glMapNamedBufferRange</c>]</b><br/> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void* MapNamedBufferRange(int buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers.glMapNamedBufferRange_Lazy(buffer, offset, length, (uint)access);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> <b>[entry point: <c>glMemoryBarrier</c>]</b><br/> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_image_load_store.txt"/></remarks>
        public static void MemoryBarrier(MemoryBarrierMask barriers) => GLPointers.glMemoryBarrier_Lazy((uint)barriers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility]</b> <b>[entry point: <c>glMemoryBarrierByRegion</c>]</b><br/> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES3_1_compatibility.txt"/></remarks>
        public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => GLPointers.glMemoryBarrierByRegion_Lazy((uint)barriers);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glMinSampleShading</c>]</b><br/> Specifies minimum rate at which sample shading takes place. </summary>
        /// <param name="value"> Specifies the rate at which samples are shaded within each covered pixel. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMinSampleShading.xhtml"/></remarks>
        public static void MinSampleShading(float value) => GLPointers.glMinSampleShading_Lazy(value);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glMultiDrawArrays</c>]</b><br/> Render multiple sets of primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Points to an array of starting indices in the enabled arrays. </param>
        /// <param name="count"> Points to an array of the number of indices to be rendered. </param>
        /// <param name="drawcount"> Specifies the size of the first and count </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArrays.xhtml"/></remarks>
        public static void MultiDrawArrays(PrimitiveType mode, int* first, int* count, int drawcount) => GLPointers.glMultiDrawArrays_Lazy((uint)mode, first, count, drawcount);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawArraysIndirect</c>]</b><br/> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_draw_indirect.txt"/></remarks>
        public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => GLPointers.glMultiDrawArraysIndirect_Lazy((uint)mode, indirect, drawcount, stride);
        
        /// <summary> <b>[requires: v4.6]</b> <b>[entry point: <c>glMultiDrawArraysIndirectCount</c>]</b><br/>  </summary>
        public static void MultiDrawArraysIndirectCount(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers.glMultiDrawArraysIndirectCount_Lazy((uint)mode, indirect, drawcount, maxdrawcount, stride);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glMultiDrawElements</c>]</b><br/> Render multiple sets of primitives by specifying indices of array data elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count and indices arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElements.xhtml"/></remarks>
        public static void MultiDrawElements(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount) => GLPointers.glMultiDrawElements_Lazy((uint)mode, count, (uint)type, indices, drawcount);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glMultiDrawElementsBaseVertex</c>]</b><br/> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
        /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_elements_base_vertex.txt"/></remarks>
        public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => GLPointers.glMultiDrawElementsBaseVertex_Lazy((uint)mode, count, (uint)type, indices, drawcount, basevertex);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawElementsIndirect</c>]</b><br/> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_draw_indirect.txt"/></remarks>
        public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => GLPointers.glMultiDrawElementsIndirect_Lazy((uint)mode, (uint)type, indirect, drawcount, stride);
        
        /// <summary> <b>[requires: v4.6]</b> <b>[entry point: <c>glMultiDrawElementsIndirectCount</c>]</b><br/>  </summary>
        public static void MultiDrawElementsIndirectCount(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers.glMultiDrawElementsIndirectCount_Lazy((uint)mode, (uint)type, indirect, drawcount, maxdrawcount, stride);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferData</c>]</b><br/> Creates and initializes a buffer object&apos;s data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedBufferData(int buffer, nint size, void* data, BufferUsage usage) => GLPointers.glNamedBufferData_Lazy(buffer, size, data, (uint)usage);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferStorage</c>]</b><br/> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedBufferStorage(int buffer, nint size, void* data, BufferStorageMask flags) => GLPointers.glNamedBufferStorage_Lazy(buffer, size, data, (uint)flags);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferSubData</c>]</b><br/> Updates a subset of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers.glNamedBufferSubData_Lazy(buffer, offset, size, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferDrawBuffer</c>]</b><br/> Specify which color buffers are to be drawn into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedFramebufferDrawBuffer(int framebuffer, ColorBuffer buf) => GLPointers.glNamedFramebufferDrawBuffer_Lazy(framebuffer, (uint)buf);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferDrawBuffers</c>]</b><br/> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedFramebufferDrawBuffers(int framebuffer, int n, ColorBuffer* bufs) => GLPointers.glNamedFramebufferDrawBuffers_Lazy(framebuffer, n, (uint*)bufs);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferParameteri</c>]</b><br/> Set a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedFramebufferParameteri(int framebuffer, FramebufferParameterName pname, int param) => GLPointers.glNamedFramebufferParameteri_Lazy(framebuffer, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferReadBuffer</c>]</b><br/> Select a color buffer source for pixels. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
        /// <param name="src">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedFramebufferReadBuffer(int framebuffer, ColorBuffer src) => GLPointers.glNamedFramebufferReadBuffer_Lazy(framebuffer, (uint)src);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferRenderbuffer</c>]</b><br/> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedFramebufferRenderbuffer(int framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers.glNamedFramebufferRenderbuffer_Lazy(framebuffer, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedFramebufferTexture(int framebuffer, FramebufferAttachment attachment, int texture, int level) => GLPointers.glNamedFramebufferTexture_Lazy(framebuffer, (uint)attachment, texture, level);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureLayer</c>]</b><br/> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedFramebufferTextureLayer(int framebuffer, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers.glNamedFramebufferTextureLayer_Lazy(framebuffer, (uint)attachment, texture, level, layer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorage</c>]</b><br/> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedRenderbufferStorage(int renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers.glNamedRenderbufferStorage_Lazy(renderbuffer, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisample</c>]</b><br/> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void NamedRenderbufferStorageMultisample(int renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers.glNamedRenderbufferStorageMultisample_Lazy(renderbuffer, samples, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glObjectLabel</c>]</b><br/> Label a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object to label. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers.glObjectLabel_Lazy((uint)identifier, name, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glObjectPtrLabel</c>]</b><br/> Label a sync object identified by a pointer. </summary>
        /// <param name="ptr"> A pointer identifying a sync object. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static void ObjectPtrLabel(void* ptr, int length, byte* label) => GLPointers.glObjectPtrLabel_Lazy(ptr, length, label);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> <b>[entry point: <c>glPatchParameterfv</c>]</b><br/> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_tessellation_shader.txt"/></remarks>
        public static void PatchParameterfv(PatchParameterName pname, float* values) => GLPointers.glPatchParameterfv_Lazy((uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> <b>[entry point: <c>glPatchParameteri</c>]</b><br/> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_tessellation_shader.txt"/></remarks>
        public static void PatchParameteri(PatchParameterName pname, int value) => GLPointers.glPatchParameteri_Lazy((uint)pname, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glPauseTransformFeedback</c>]</b><br/> Pause transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
        public static void PauseTransformFeedback() => GLPointers.glPauseTransformFeedback_Lazy();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glPixelStoref</c>]</b><br/> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml"/></remarks>
        public static void PixelStoref(PixelStoreParameter pname, float param) => GLPointers.glPixelStoref_Lazy((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glPixelStorei</c>]</b><br/> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml"/></remarks>
        public static void PixelStorei(PixelStoreParameter pname, int param) => GLPointers.glPixelStorei_Lazy((uint)pname, param);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glPointParameterf</c>]</b><br/> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml"/></remarks>
        public static void PointParameterf(PointParameterNameARB pname, float param) => GLPointers.glPointParameterf_Lazy((uint)pname, param);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glPointParameterfv</c>]</b><br/> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml"/></remarks>
        public static void PointParameterfv(PointParameterNameARB pname, float* parameters) => GLPointers.glPointParameterfv_Lazy((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glPointParameteri</c>]</b><br/> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml"/></remarks>
        public static void PointParameteri(PointParameterNameARB pname, int param) => GLPointers.glPointParameteri_Lazy((uint)pname, param);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glPointParameteriv</c>]</b><br/> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml"/></remarks>
        public static void PointParameteriv(PointParameterNameARB pname, int* parameters) => GLPointers.glPointParameteriv_Lazy((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glPointSize</c>]</b><br/> Specify the diameter of rasterized points. </summary>
        /// <param name="size"> Specifies the diameter of rasterized points. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointSize.xhtml"/></remarks>
        public static void PointSize(float size) => GLPointers.glPointSize_Lazy(size);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glPolygonMode</c>]</b><br/> Select a polygon rasterization mode. </summary>
        /// <param name="face"> Specifies the polygons that mode applies to. Must be GL_FRONT_AND_BACK for front- and back-facing polygons. </param>
        /// <param name="mode"> Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The initial value is GL_FILL for both front- and back-facing polygons. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonMode.xhtml"/></remarks>
        public static void PolygonMode(TriangleFace face, PolygonMode mode) => GLPointers.glPolygonMode_Lazy((uint)face, (uint)mode);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glPolygonOffset</c>]</b><br/> Set the scale and units used to calculate depth values. </summary>
        /// <param name="factor"> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </param>
        /// <param name="units"> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml"/></remarks>
        public static void PolygonOffset(float factor, float units) => GLPointers.glPolygonOffset_Lazy(factor, units);
        
        /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp]</b> <b>[entry point: <c>glPolygonOffsetClamp</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_polygon_offset_clamp.txt"/></remarks>
        public static void PolygonOffsetClamp(float factor, float units, float clamp) => GLPointers.glPolygonOffsetClamp_Lazy(factor, units, clamp);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glPopDebugGroup</c>]</b><br/> Pop the active debug group. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static void PopDebugGroup() => GLPointers.glPopDebugGroup_Lazy();
        
        /// <summary> <b>[requires: v3.1]</b> <b>[entry point: <c>glPrimitiveRestartIndex</c>]</b><br/> Specify the primitive restart index. </summary>
        /// <param name="index"> Specifies the value to be interpreted as the primitive restart index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPrimitiveRestartIndex.xhtml"/></remarks>
        public static void PrimitiveRestartIndex(uint index) => GLPointers.glPrimitiveRestartIndex_Lazy(index);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> <b>[entry point: <c>glProgramBinary</c>]</b><br/> Load a program object with a program binary. </summary>
        /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
        /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
        /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
        /// <param name="length"> Specifies the number of bytes contained in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_program_binary.txt"/></remarks>
        public static void ProgramBinary(int program, All binaryFormat, void* binary, int length) => GLPointers.glProgramBinary_Lazy(program, (uint)binaryFormat, binary, length);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramParameteri</c>]</b><br/> Specify a parameter for a program object. </summary>
        /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the name of the parameter to modify. </param>
        /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_program_binary.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramParameteri(int program, ProgramParameterPName pname, int value) => GLPointers.glProgramParameteri_Lazy(program, (uint)pname, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1d</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform1d(int program, int location, double v0) => GLPointers.glProgramUniform1d_Lazy(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform1dv(int program, int location, int count, double* value) => GLPointers.glProgramUniform1dv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform1f(int program, int location, float v0) => GLPointers.glProgramUniform1f_Lazy(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform1fv(int program, int location, int count, float* value) => GLPointers.glProgramUniform1fv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform1i(int program, int location, int v0) => GLPointers.glProgramUniform1i_Lazy(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform1iv(int program, int location, int count, int* value) => GLPointers.glProgramUniform1iv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform1ui(int program, int location, uint v0) => GLPointers.glProgramUniform1ui_Lazy(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform1uiv(int program, int location, int count, uint* value) => GLPointers.glProgramUniform1uiv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2d</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform2d(int program, int location, double v0, double v1) => GLPointers.glProgramUniform2d_Lazy(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform2dv(int program, int location, int count, double* value) => GLPointers.glProgramUniform2dv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform2f(int program, int location, float v0, float v1) => GLPointers.glProgramUniform2f_Lazy(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform2fv(int program, int location, int count, float* value) => GLPointers.glProgramUniform2fv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform2i(int program, int location, int v0, int v1) => GLPointers.glProgramUniform2i_Lazy(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform2iv(int program, int location, int count, int* value) => GLPointers.glProgramUniform2iv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform2ui(int program, int location, uint v0, uint v1) => GLPointers.glProgramUniform2ui_Lazy(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform2uiv(int program, int location, int count, uint* value) => GLPointers.glProgramUniform2uiv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3d</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform3d(int program, int location, double v0, double v1, double v2) => GLPointers.glProgramUniform3d_Lazy(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform3dv(int program, int location, int count, double* value) => GLPointers.glProgramUniform3dv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform3f(int program, int location, float v0, float v1, float v2) => GLPointers.glProgramUniform3f_Lazy(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform3fv(int program, int location, int count, float* value) => GLPointers.glProgramUniform3fv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform3i(int program, int location, int v0, int v1, int v2) => GLPointers.glProgramUniform3i_Lazy(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform3iv(int program, int location, int count, int* value) => GLPointers.glProgramUniform3iv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform3ui(int program, int location, uint v0, uint v1, uint v2) => GLPointers.glProgramUniform3ui_Lazy(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform3uiv(int program, int location, int count, uint* value) => GLPointers.glProgramUniform3uiv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4d</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform4d(int program, int location, double v0, double v1, double v2, double v3) => GLPointers.glProgramUniform4d_Lazy(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform4dv(int program, int location, int count, double* value) => GLPointers.glProgramUniform4dv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3) => GLPointers.glProgramUniform4f_Lazy(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform4fv(int program, int location, int count, float* value) => GLPointers.glProgramUniform4fv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3) => GLPointers.glProgramUniform4i_Lazy(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform4iv(int program, int location, int count, int* value) => GLPointers.glProgramUniform4iv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform4ui(int program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers.glProgramUniform4ui_Lazy(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniform4uiv(int program, int location, int count, uint* value) => GLPointers.glProgramUniform4uiv_Lazy(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix2dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix2dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix2fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix2fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix2x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix2x3dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix2x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix2x3fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix2x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix2x4dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix2x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix2x4fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix3dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix3dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix3fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix3fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix3x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix3x2dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix3x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix3x2fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix3x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix3x4dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix3x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix3x4fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix4dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix4dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix4fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix4fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix4x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix4x2dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix4x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix4x2fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix4x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix4x3dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ProgramUniformMatrix4x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix4x3fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex]</b> <b>[entry point: <c>glProvokingVertex</c>]</b><br/> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
        /// <param name="mode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_provoking_vertex.txt"/></remarks>
        public static void ProvokingVertex(VertexProvokingMode mode) => GLPointers.glProvokingVertex_Lazy((uint)mode);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glPushDebugGroup</c>]</b><br/> Push a named debug group into the command stream. </summary>
        /// <param name="source"> The source of the debug message. </param>
        /// <param name="id"> The identifier of the message. </param>
        /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
        /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
        public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => GLPointers.glPushDebugGroup_Lazy((uint)source, id, length, message);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glQueryCounter</c>]</b><br/> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
        /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
        /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_timer_query.txt"/></remarks>
        public static void QueryCounter(int id, QueryCounterTarget target) => GLPointers.glQueryCounter_Lazy(id, (uint)target);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glReadBuffer</c>]</b><br/> Select a color buffer source for pixels. </summary>
        /// <param name="src">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml"/></remarks>
        public static void ReadBuffer(ReadBufferMode src) => GLPointers.glReadBuffer_Lazy((uint)src);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glReadnPixels</c>]</b><br/> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
        /// <param name="data">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
        public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers.glReadnPixels_Lazy(x, y, width, height, (uint)format, (uint)type, bufSize, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glReadPixels</c>]</b><br/> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="pixels">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml"/></remarks>
        public static void ReadPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers.glReadPixels_Lazy(x, y, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glReleaseShaderCompiler</c>]</b><br/> Release resources consumed by the implementation&apos;s shader compiler. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
        public static void ReleaseShaderCompiler() => GLPointers.glReleaseShaderCompiler_Lazy();
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorage</c>]</b><br/> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers.glRenderbufferStorage_Lazy((uint)target, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorageMultisample</c>]</b><br/> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
        public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers.glRenderbufferStorageMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glResumeTransformFeedback</c>]</b><br/> Resume transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
        public static void ResumeTransformFeedback() => GLPointers.glResumeTransformFeedback_Lazy();
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glSampleCoverage</c>]</b><br/> Specify multisample coverage parameters. </summary>
        /// <param name="value"> Specify a single floating-point sample coverage value. The value is clamped to the range 0 1 . The initial value is 1.0. </param>
        /// <param name="invert"> Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleCoverage.xhtml"/></remarks>
        public static void SampleCoverage(float value, bool invert) => GLPointers.glSampleCoverage_Lazy(value, (byte)(invert ? 1 : 0));
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glSampleMaski</c>]</b><br/> Set the value of a sub-word of the sample mask. </summary>
        /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
        /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_multisample.txt"/></remarks>
        public static void SampleMaski(uint maskNumber, uint mask) => GLPointers.glSampleMaski_Lazy(maskNumber, mask);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterf</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void SamplerParameterf(int sampler, SamplerParameterF pname, float param) => GLPointers.glSamplerParameterf_Lazy(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterfv</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void SamplerParameterfv(int sampler, SamplerParameterF pname, float* param) => GLPointers.glSamplerParameterfv_Lazy(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameteri</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void SamplerParameteri(int sampler, SamplerParameterI pname, int param) => GLPointers.glSamplerParameteri_Lazy(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterIiv</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void SamplerParameterIiv(int sampler, SamplerParameterI pname, int* param) => GLPointers.glSamplerParameterIiv_Lazy(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterIuiv</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void SamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* param) => GLPointers.glSamplerParameterIuiv_Lazy(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameteriv</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
        public static void SamplerParameteriv(int sampler, SamplerParameterI pname, int* param) => GLPointers.glSamplerParameteriv_Lazy(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glScissor</c>]</b><br/> Define the scissor box. </summary>
        /// <param name="x"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="y"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="width"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissor.xhtml"/></remarks>
        public static void Scissor(int x, int y, int width, int height) => GLPointers.glScissor_Lazy(x, y, width, height);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorArrayv</c>]</b><br/> Define the scissor box for multiple viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
        /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
        /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void ScissorArrayv(uint first, int count, int* v) => GLPointers.glScissorArrayv_Lazy(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorIndexed</c>]</b><br/> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => GLPointers.glScissorIndexed_Lazy(index, left, bottom, width, height);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorIndexedv</c>]</b><br/> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void ScissorIndexedv(uint index, int* v) => GLPointers.glScissorIndexedv_Lazy(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glShaderBinary</c>]</b><br/> Load pre-compiled shader binaries. </summary>
        /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
        /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
        /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
        /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
        /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
        public static void ShaderBinary(int count, int* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => GLPointers.glShaderBinary_Lazy(count, shaders, (uint)binaryFormat, binary, length);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glShaderSource</c>]</b><br/> Replaces the source code in a shader object. </summary>
        /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the string and length arrays.</param>
        /// <param name="str">Specifies an array of pointers to strings containing the source code to be loaded into the shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderSource.xhtml"/></remarks>
        public static void ShaderSource(int shader, int count, byte** str, int* length) => GLPointers.glShaderSource_Lazy(shader, count, str, length);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object]</b> <b>[entry point: <c>glShaderStorageBlockBinding</c>]</b><br/> Change an active shader storage block binding. </summary>
        /// <param name="program"> The name of the program containing the block whose binding to change. </param>
        /// <param name="storageBlockIndex"> The index storage block within the program. </param>
        /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_storage_buffer_object.txt"/></remarks>
        public static void ShaderStorageBlockBinding(int program, uint storageBlockIndex, uint storageBlockBinding) => GLPointers.glShaderStorageBlockBinding_Lazy(program, storageBlockIndex, storageBlockBinding);
        
        /// <summary> <b>[requires: v4.6]</b> <b>[entry point: <c>glSpecializeShader</c>]</b><br/>  </summary>
        public static void SpecializeShader(int shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => GLPointers.glSpecializeShader_Lazy(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glStencilFunc</c>]</b><br/> Set front and back function and reference value for stencil testing. </summary>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml"/></remarks>
        public static void StencilFunc(StencilFunction func, int reference, uint mask) => GLPointers.glStencilFunc_Lazy((uint)func, reference, mask);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glStencilFuncSeparate</c>]</b><br/> Set front and/or back function and reference value for stencil testing. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFuncSeparate.xhtml"/></remarks>
        public static void StencilFuncSeparate(TriangleFace face, StencilFunction func, int reference, uint mask) => GLPointers.glStencilFuncSeparate_Lazy((uint)face, (uint)func, reference, mask);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glStencilMask</c>]</b><br/> Control the front and back writing of individual bits in the stencil planes. </summary>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMask.xhtml"/></remarks>
        public static void StencilMask(uint mask) => GLPointers.glStencilMask_Lazy(mask);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glStencilMaskSeparate</c>]</b><br/> Control the front and/or back writing of individual bits in the stencil planes. </summary>
        /// <param name="face"> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMaskSeparate.xhtml"/></remarks>
        public static void StencilMaskSeparate(TriangleFace face, uint mask) => GLPointers.glStencilMaskSeparate_Lazy((uint)face, mask);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glStencilOp</c>]</b><br/> Set front and back stencil test actions. </summary>
        /// <param name="fail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="zfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="zpass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOp.xhtml"/></remarks>
        public static void StencilOp(StencilOp fail, StencilOp zfail, StencilOp zpass) => GLPointers.glStencilOp_Lazy((uint)fail, (uint)zfail, (uint)zpass);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glStencilOpSeparate</c>]</b><br/> Set front and/or back stencil test actions. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="sfail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="dpfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="dppass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOpSeparate.xhtml"/></remarks>
        public static void StencilOpSeparate(TriangleFace face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => GLPointers.glStencilOpSeparate_Lazy((uint)face, (uint)sfail, (uint)dpfail, (uint)dppass);
        
        /// <summary> <b>[requires: v3.1]</b> <b>[entry point: <c>glTexBuffer</c>]</b><br/> Attach a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml"/></remarks>
        public static void TexBuffer(TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers.glTexBuffer_Lazy((uint)target, (uint)internalformat, buffer);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range]</b> <b>[entry point: <c>glTexBufferRange</c>]</b><br/> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_buffer_range.txt"/></remarks>
        public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers.glTexBufferRange_Lazy((uint)target, (uint)internalformat, buffer, offset, size);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexImage1D</c>]</b><br/> Specify a one-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage1D.xhtml"/></remarks>
        public static void TexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexImage1D_Lazy((uint)target, level, (int)internalformat, width, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexImage2D</c>]</b><br/> Specify a two-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml"/></remarks>
        public static void TexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexImage2D_Lazy((uint)target, level, (int)internalformat, width, height, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glTexImage2DMultisample</c>]</b><br/> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
        /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_multisample.txt"/></remarks>
        public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers.glTexImage2DMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v1.2]</b> <b>[entry point: <c>glTexImage3D</c>]</b><br/> Specify a three-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3D.xhtml"/></remarks>
        public static void TexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexImage3D_Lazy((uint)target, level, (int)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glTexImage3DMultisample</c>]</b><br/> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
        /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
        /// <param name="depth">!!missing documentation!!</param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_multisample.txt"/></remarks>
        public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers.glTexImage3DMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexParameterf</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/></remarks>
        public static void TexParameterf(TextureTarget target, TextureParameterName pname, float param) => GLPointers.glTexParameterf_Lazy((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexParameterfv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/></remarks>
        public static void TexParameterfv(TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers.glTexParameterfv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexParameteri</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/></remarks>
        public static void TexParameteri(TextureTarget target, TextureParameterName pname, int param) => GLPointers.glTexParameteri_Lazy((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glTexParameterIiv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/></remarks>
        public static void TexParameterIiv(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers.glTexParameterIiv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glTexParameterIuiv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/></remarks>
        public static void TexParameterIuiv(TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers.glTexParameterIuiv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexParameteriv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/></remarks>
        public static void TexParameteriv(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers.glTexParameteriv_Lazy((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage1D</c>]</b><br/> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage.txt"/></remarks>
        public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers.glTexStorage1D_Lazy((uint)target, levels, (uint)internalformat, width);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage2D</c>]</b><br/> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage.txt"/></remarks>
        public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers.glTexStorage2D_Lazy((uint)target, levels, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> <b>[entry point: <c>glTexStorage2DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage_multisample.txt"/></remarks>
        public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers.glTexStorage2DMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage3D</c>]</b><br/> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage.txt"/></remarks>
        public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers.glTexStorage3D_Lazy((uint)target, levels, (uint)internalformat, width, height, depth);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> <b>[entry point: <c>glTexStorage3DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage_multisample.txt"/></remarks>
        public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers.glTexStorage3DMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glTexSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage1D. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml"/></remarks>
        public static void TexSubImage1D(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexSubImage1D_Lazy((uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glTexSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage2D. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml"/></remarks>
        public static void TexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexSubImage2D_Lazy((uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.2]</b> <b>[entry point: <c>glTexSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage3D. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml"/></remarks>
        public static void TexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexSubImage3D_Lazy((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier]</b> <b>[entry point: <c>glTextureBarrier</c>]</b><br/> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_barrier.txt"/></remarks>
        public static void TextureBarrier() => GLPointers.glTextureBarrier_Lazy();
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureBuffer</c>]</b><br/> Attach a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureBuffer(int texture, SizedInternalFormat internalformat, int buffer) => GLPointers.glTextureBuffer_Lazy(texture, (uint)internalformat, buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureBufferRange</c>]</b><br/> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureBufferRange(int texture, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers.glTextureBufferRange_Lazy(texture, (uint)internalformat, buffer, offset, size);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterf</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureParameterf(int texture, TextureParameterName pname, float param) => GLPointers.glTextureParameterf_Lazy(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterfv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureParameterfv(int texture, TextureParameterName pname, float* param) => GLPointers.glTextureParameterfv_Lazy(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameteri</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureParameteri(int texture, TextureParameterName pname, int param) => GLPointers.glTextureParameteri_Lazy(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIiv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureParameterIiv(int texture, TextureParameterName pname, int* parameters) => GLPointers.glTextureParameterIiv_Lazy(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIuiv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureParameterIuiv(int texture, TextureParameterName pname, uint* parameters) => GLPointers.glTextureParameterIuiv_Lazy(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameteriv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureParameteriv(int texture, TextureParameterName pname, int* param) => GLPointers.glTextureParameteriv_Lazy(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage1D</c>]</b><br/> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureStorage1D(int texture, int levels, SizedInternalFormat internalformat, int width) => GLPointers.glTextureStorage1D_Lazy(texture, levels, (uint)internalformat, width);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2D</c>]</b><br/> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureStorage2D(int texture, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers.glTextureStorage2D_Lazy(texture, levels, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureStorage2DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers.glTextureStorage2DMultisample_Lazy(texture, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3D</c>]</b><br/> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureStorage3D(int texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers.glTextureStorage3D_Lazy(texture, levels, (uint)internalformat, width, height, depth);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureStorage3DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers.glTextureStorage3DMultisample_Lazy(texture, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureSubImage1D(int texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureSubImage1D_Lazy(texture, level, xoffset, width, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureSubImage2D_Lazy(texture, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureSubImage3D_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view]</b> <b>[entry point: <c>glTextureView</c>]</b><br/> Initialize a texture as a data alias of another texture&apos;s data store. </summary>
        /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
        /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
        /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
        /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
        /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
        /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
        /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
        /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_view.txt"/></remarks>
        public static void TextureView(int texture, TextureTarget target, int origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => GLPointers.glTextureView_Lazy(texture, (uint)target, origtexture, (uint)internalformat, minlevel, numlevels, minlayer, numlayers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTransformFeedbackBufferBase</c>]</b><br/> Bind a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TransformFeedbackBufferBase(int xfb, uint index, int buffer) => GLPointers.glTransformFeedbackBufferBase_Lazy(xfb, index, buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTransformFeedbackBufferRange</c>]</b><br/> Bind a range within a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
        /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void TransformFeedbackBufferRange(int xfb, uint index, int buffer, IntPtr offset, nint size) => GLPointers.glTransformFeedbackBufferRange_Lazy(xfb, index, buffer, offset, size);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glTransformFeedbackVaryings</c>]</b><br/> Specify values to record in transform feedback buffers. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="count"> The number of varying variables used for transform feedback. </param>
        /// <param name="varyings"> An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback. </param>
        /// <param name="bufferMode"> Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackVaryings.xhtml"/></remarks>
        public static void TransformFeedbackVaryings(int program, int count, byte** varyings, TransformFeedbackBufferMode bufferMode) => GLPointers.glTransformFeedbackVaryings_Lazy(program, count, varyings, (uint)bufferMode);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform1d</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void Uniform1d(int location, double x) => GLPointers.glUniform1d_Lazy(location, x);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform1dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void Uniform1dv(int location, int count, double* value) => GLPointers.glUniform1dv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform1f</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform1f(int location, float v0) => GLPointers.glUniform1f_Lazy(location, v0);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform1fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform1fv(int location, int count, float* value) => GLPointers.glUniform1fv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform1i</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform1i(int location, int v0) => GLPointers.glUniform1i_Lazy(location, v0);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform1iv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform1iv(int location, int count, int* value) => GLPointers.glUniform1iv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform1ui</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform1ui(int location, uint v0) => GLPointers.glUniform1ui_Lazy(location, v0);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform1uiv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform1uiv(int location, int count, uint* value) => GLPointers.glUniform1uiv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform2d</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void Uniform2d(int location, double x, double y) => GLPointers.glUniform2d_Lazy(location, x, y);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform2dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void Uniform2dv(int location, int count, double* value) => GLPointers.glUniform2dv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform2f</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform2f(int location, float v0, float v1) => GLPointers.glUniform2f_Lazy(location, v0, v1);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform2fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform2fv(int location, int count, float* value) => GLPointers.glUniform2fv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform2i</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform2i(int location, int v0, int v1) => GLPointers.glUniform2i_Lazy(location, v0, v1);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform2iv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform2iv(int location, int count, int* value) => GLPointers.glUniform2iv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform2ui</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform2ui(int location, uint v0, uint v1) => GLPointers.glUniform2ui_Lazy(location, v0, v1);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform2uiv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform2uiv(int location, int count, uint* value) => GLPointers.glUniform2uiv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform3d</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void Uniform3d(int location, double x, double y, double z) => GLPointers.glUniform3d_Lazy(location, x, y, z);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform3dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void Uniform3dv(int location, int count, double* value) => GLPointers.glUniform3dv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform3f</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform3f(int location, float v0, float v1, float v2) => GLPointers.glUniform3f_Lazy(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform3fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform3fv(int location, int count, float* value) => GLPointers.glUniform3fv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform3i</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform3i(int location, int v0, int v1, int v2) => GLPointers.glUniform3i_Lazy(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform3iv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform3iv(int location, int count, int* value) => GLPointers.glUniform3iv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform3ui</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform3ui(int location, uint v0, uint v1, uint v2) => GLPointers.glUniform3ui_Lazy(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform3uiv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform3uiv(int location, int count, uint* value) => GLPointers.glUniform3uiv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform4d</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void Uniform4d(int location, double x, double y, double z, double w) => GLPointers.glUniform4d_Lazy(location, x, y, z, w);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform4dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void Uniform4dv(int location, int count, double* value) => GLPointers.glUniform4dv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform4f</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform4f(int location, float v0, float v1, float v2, float v3) => GLPointers.glUniform4f_Lazy(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform4fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform4fv(int location, int count, float* value) => GLPointers.glUniform4fv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform4i</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform4i(int location, int v0, int v1, int v2, int v3) => GLPointers.glUniform4i_Lazy(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform4iv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform4iv(int location, int count, int* value) => GLPointers.glUniform4iv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform4ui</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3) => GLPointers.glUniform4ui_Lazy(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform4uiv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void Uniform4uiv(int location, int count, uint* value) => GLPointers.glUniform4uiv_Lazy(location, count, value);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glUniformBlockBinding</c>]</b><br/> Assign a binding point to an active uniform block. </summary>
        /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
        /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
        /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
        public static void UniformBlockBinding(int program, uint uniformBlockIndex, uint uniformBlockBinding) => GLPointers.glUniformBlockBinding_Lazy(program, uniformBlockIndex, uniformBlockBinding);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void UniformMatrix2dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix2dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniformMatrix2fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void UniformMatrix2fv(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix2fv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2x3dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void UniformMatrix2x3dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix2x3dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix2x3fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void UniformMatrix2x3fv(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix2x3fv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2x4dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void UniformMatrix2x4dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix2x4dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix2x4fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void UniformMatrix2x4fv(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix2x4fv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void UniformMatrix3dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix3dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniformMatrix3fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void UniformMatrix3fv(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix3fv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3x2dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void UniformMatrix3x2dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix3x2dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix3x2fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void UniformMatrix3x2fv(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix3x2fv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3x4dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void UniformMatrix3x4dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix3x4dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix3x4fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void UniformMatrix3x4fv(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix3x4fv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void UniformMatrix4dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix4dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniformMatrix4fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void UniformMatrix4fv(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix4fv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4x2dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void UniformMatrix4x2dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix4x2dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix4x2fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void UniformMatrix4x2fv(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix4x2fv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4x3dv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
        public static void UniformMatrix4x3dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix4x3dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix4x3fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml"/></remarks>
        public static void UniformMatrix4x3fv(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix4x3fv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glUniformSubroutinesuiv</c>]</b><br/> Load active subroutine uniforms. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
        /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
        public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => GLPointers.glUniformSubroutinesuiv_Lazy((uint)shadertype, count, indices);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glUnmapBuffer</c>]</b><br/> Release the mapping of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glUnmapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml"/></remarks>
        public static bool UnmapBuffer(BufferTarget target) => GLPointers.glUnmapBuffer_Lazy((uint)target) != 0;
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glUnmapNamedBuffer</c>]</b><br/> Release the mapping of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static bool UnmapNamedBuffer(int buffer) => GLPointers.glUnmapNamedBuffer_Lazy(buffer) != 0;
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUseProgram</c>]</b><br/> Installs a program object as part of current rendering state. </summary>
        /// <param name="program">Specifies the handle of the program object whose executables are to be used as part of current rendering state.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgram.xhtml"/></remarks>
        public static void UseProgram(int program) => GLPointers.glUseProgram_Lazy(program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glUseProgramStages</c>]</b><br/> Bind stages of a program object to a program pipeline. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
        /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
        /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void UseProgramStages(int pipeline, UseProgramStageMask stages, int program) => GLPointers.glUseProgramStages_Lazy(pipeline, (uint)stages, program);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glValidateProgram</c>]</b><br/> Validates a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be validated.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgram.xhtml"/></remarks>
        public static void ValidateProgram(int program) => GLPointers.glValidateProgram_Lazy(program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glValidateProgramPipeline</c>]</b><br/> Validate a program pipeline object against current GL state. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
        public static void ValidateProgramPipeline(int pipeline) => GLPointers.glValidateProgramPipeline_Lazy(pipeline);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribBinding</c>]</b><br/> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void VertexArrayAttribBinding(int vaobj, uint attribindex, uint bindingindex) => GLPointers.glVertexArrayAttribBinding_Lazy(vaobj, attribindex, bindingindex);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void VertexArrayAttribFormat(int vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers.glVertexArrayAttribFormat_Lazy(vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribIFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void VertexArrayAttribIFormat(int vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers.glVertexArrayAttribIFormat_Lazy(vaobj, attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribLFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void VertexArrayAttribLFormat(int vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers.glVertexArrayAttribLFormat_Lazy(vaobj, attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayBindingDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void VertexArrayBindingDivisor(int vaobj, uint bindingindex, uint divisor) => GLPointers.glVertexArrayBindingDivisor_Lazy(vaobj, bindingindex, divisor);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayElementBuffer</c>]</b><br/> Configures element array buffer binding of a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
        /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void VertexArrayElementBuffer(int vaobj, int buffer) => GLPointers.glVertexArrayElementBuffer_Lazy(vaobj, buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBuffer</c>]</b><br/> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void VertexArrayVertexBuffer(int vaobj, uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers.glVertexArrayVertexBuffer_Lazy(vaobj, bindingindex, buffer, offset, stride);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBuffers</c>]</b><br/> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
        public static void VertexArrayVertexBuffers(int vaobj, uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers.glVertexArrayVertexBuffers_Lazy(vaobj, first, count, buffers, offsets, strides);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib1d(uint index, double x) => GLPointers.glVertexAttrib1d_Lazy(index, x);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib1dv(uint index, double* v) => GLPointers.glVertexAttrib1dv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1f</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib1f(uint index, float x) => GLPointers.glVertexAttrib1f_Lazy(index, x);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1fv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib1fv(uint index, float* v) => GLPointers.glVertexAttrib1fv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1s</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib1s(uint index, short x) => GLPointers.glVertexAttrib1s_Lazy(index, x);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib1sv(uint index, short* v) => GLPointers.glVertexAttrib1sv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib2d(uint index, double x, double y) => GLPointers.glVertexAttrib2d_Lazy(index, x, y);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib2dv(uint index, double* v) => GLPointers.glVertexAttrib2dv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2f</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib2f(uint index, float x, float y) => GLPointers.glVertexAttrib2f_Lazy(index, x, y);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2fv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib2fv(uint index, float* v) => GLPointers.glVertexAttrib2fv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2s</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib2s(uint index, short x, short y) => GLPointers.glVertexAttrib2s_Lazy(index, x, y);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib2sv(uint index, short* v) => GLPointers.glVertexAttrib2sv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib3d(uint index, double x, double y, double z) => GLPointers.glVertexAttrib3d_Lazy(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib3dv(uint index, double* v) => GLPointers.glVertexAttrib3dv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3f</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib3f(uint index, float x, float y, float z) => GLPointers.glVertexAttrib3f_Lazy(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3fv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib3fv(uint index, float* v) => GLPointers.glVertexAttrib3fv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3s</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib3s(uint index, short x, short y, short z) => GLPointers.glVertexAttrib3s_Lazy(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib3sv(uint index, short* v) => GLPointers.glVertexAttrib3sv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4bv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4bv(uint index, sbyte* v) => GLPointers.glVertexAttrib4bv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="w"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4d(uint index, double x, double y, double z, double w) => GLPointers.glVertexAttrib4d_Lazy(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4dv(uint index, double* v) => GLPointers.glVertexAttrib4dv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4f</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="w"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4f(uint index, float x, float y, float z, float w) => GLPointers.glVertexAttrib4f_Lazy(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4fv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4fv(uint index, float* v) => GLPointers.glVertexAttrib4fv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4iv(uint index, int* v) => GLPointers.glVertexAttrib4iv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nbv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4Nbv(uint index, sbyte* v) => GLPointers.glVertexAttrib4Nbv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Niv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4Niv(uint index, int* v) => GLPointers.glVertexAttrib4Niv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nsv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4Nsv(uint index, short* v) => GLPointers.glVertexAttrib4Nsv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nub</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="w"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4Nub(uint index, byte x, byte y, byte z, byte w) => GLPointers.glVertexAttrib4Nub_Lazy(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nubv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4Nubv(uint index, byte* v) => GLPointers.glVertexAttrib4Nubv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nuiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4Nuiv(uint index, uint* v) => GLPointers.glVertexAttrib4Nuiv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nusv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4Nusv(uint index, ushort* v) => GLPointers.glVertexAttrib4Nusv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4s</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="w"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4s(uint index, short x, short y, short z, short w) => GLPointers.glVertexAttrib4s_Lazy(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4sv(uint index, short* v) => GLPointers.glVertexAttrib4sv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4ubv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4ubv(uint index, byte* v) => GLPointers.glVertexAttrib4ubv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4uiv(uint index, uint* v) => GLPointers.glVertexAttrib4uiv_Lazy(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4usv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttrib4usv(uint index, ushort* v) => GLPointers.glVertexAttrib4usv_Lazy(index, v);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribBinding</c>]</b><br/> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
        public static void VertexAttribBinding(uint attribindex, uint bindingindex) => GLPointers.glVertexAttribBinding_Lazy(attribindex, bindingindex);
        
        /// <summary> <b>[requires: v3.3]</b> <b>[entry point: <c>glVertexAttribDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes advance during instanced rendering. </summary>
        /// <param name="index"> Specify the index of the generic vertex attribute. </param>
        /// <param name="divisor"> Specify the number of instances that will pass between updates of the generic attribute at slot index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribDivisor.xhtml"/></remarks>
        public static void VertexAttribDivisor(uint index, uint divisor) => GLPointers.glVertexAttribDivisor_Lazy(index, divisor);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
        public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers.glVertexAttribFormat_Lazy(attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI1i</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI1i(uint index, int x) => GLPointers.glVertexAttribI1i_Lazy(index, x);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI1iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI1iv(uint index, int* v) => GLPointers.glVertexAttribI1iv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI1ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI1ui(uint index, uint x) => GLPointers.glVertexAttribI1ui_Lazy(index, x);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI1uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI1uiv(uint index, uint* v) => GLPointers.glVertexAttribI1uiv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI2i</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI2i(uint index, int x, int y) => GLPointers.glVertexAttribI2i_Lazy(index, x, y);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI2iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI2iv(uint index, int* v) => GLPointers.glVertexAttribI2iv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI2ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI2ui(uint index, uint x, uint y) => GLPointers.glVertexAttribI2ui_Lazy(index, x, y);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI2uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI2uiv(uint index, uint* v) => GLPointers.glVertexAttribI2uiv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI3i</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI3i(uint index, int x, int y, int z) => GLPointers.glVertexAttribI3i_Lazy(index, x, y, z);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI3iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI3iv(uint index, int* v) => GLPointers.glVertexAttribI3iv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI3ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI3ui(uint index, uint x, uint y, uint z) => GLPointers.glVertexAttribI3ui_Lazy(index, x, y, z);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI3uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI3uiv(uint index, uint* v) => GLPointers.glVertexAttribI3uiv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4bv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI4bv(uint index, sbyte* v) => GLPointers.glVertexAttribI4bv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4i</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="w"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI4i(uint index, int x, int y, int z, int w) => GLPointers.glVertexAttribI4i_Lazy(index, x, y, z, w);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI4iv(uint index, int* v) => GLPointers.glVertexAttribI4iv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI4sv(uint index, short* v) => GLPointers.glVertexAttribI4sv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4ubv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI4ubv(uint index, byte* v) => GLPointers.glVertexAttribI4ubv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="w"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w) => GLPointers.glVertexAttribI4ui_Lazy(index, x, y, z, w);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI4uiv(uint index, uint* v) => GLPointers.glVertexAttribI4uiv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4usv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/></remarks>
        public static void VertexAttribI4usv(uint index, ushort* v) => GLPointers.glVertexAttribI4usv_Lazy(index, v);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribIFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
        public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers.glVertexAttribIFormat_Lazy(attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribIPointer</c>]</b><br/> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml"/></remarks>
        public static void VertexAttribIPointer(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers.glVertexAttribIPointer_Lazy(index, size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void VertexAttribL1d(uint index, double x) => GLPointers.glVertexAttribL1d_Lazy(index, x);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void VertexAttribL1dv(uint index, double* v) => GLPointers.glVertexAttribL1dv_Lazy(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void VertexAttribL2d(uint index, double x, double y) => GLPointers.glVertexAttribL2d_Lazy(index, x, y);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void VertexAttribL2dv(uint index, double* v) => GLPointers.glVertexAttribL2dv_Lazy(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void VertexAttribL3d(uint index, double x, double y, double z) => GLPointers.glVertexAttribL3d_Lazy(index, x, y, z);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void VertexAttribL3dv(uint index, double* v) => GLPointers.glVertexAttribL3dv_Lazy(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="w"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => GLPointers.glVertexAttribL4d_Lazy(index, x, y, z, w);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void VertexAttribL4dv(uint index, double* v) => GLPointers.glVertexAttribL4dv_Lazy(index, v);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribLFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
        public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers.glVertexAttribLFormat_Lazy(attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribLPointer</c>]</b><br/> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
        public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers.glVertexAttribLPointer_Lazy(index, size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP1ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
        public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers.glVertexAttribP1ui_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP1uiv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
        public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers.glVertexAttribP1uiv_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP2ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
        public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers.glVertexAttribP2ui_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP2uiv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
        public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers.glVertexAttribP2uiv_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP3ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
        public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers.glVertexAttribP3ui_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP3uiv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
        public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers.glVertexAttribP3uiv_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP4ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
        public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers.glVertexAttribP4ui_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP4uiv</c>]</b><br/>  </summary>
        /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
        public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers.glVertexAttribP4uiv_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttribPointer</c>]</b><br/> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml"/></remarks>
        public static void VertexAttribPointer(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, void* pointer) => GLPointers.glVertexAttribPointer_Lazy(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, pointer);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexBindingDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
        public static void VertexBindingDivisor(uint bindingindex, uint divisor) => GLPointers.glVertexBindingDivisor_Lazy(bindingindex, divisor);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glViewport</c>]</b><br/> Set the viewport. </summary>
        /// <param name="x"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="width"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml"/></remarks>
        public static void Viewport(int x, int y, int width, int height) => GLPointers.glViewport_Lazy(x, y, width, height);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportArrayv</c>]</b><br/> Set multiple viewports. </summary>
        /// <param name="first"> Specify the first viewport to set. </param>
        /// <param name="count"> Specify the number of viewports to set. </param>
        /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void ViewportArrayv(uint first, int count, float* v) => GLPointers.glViewportArrayv_Lazy(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportIndexedf</c>]</b><br/> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => GLPointers.glViewportIndexedf_Lazy(index, x, y, w, h);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportIndexedfv</c>]</b><br/> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
        public static void ViewportIndexedfv(uint index, float* v) => GLPointers.glViewportIndexedfv_Lazy(index, v);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glWaitSync</c>]</b><br/> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
        /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
        /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
        public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => GLPointers.glWaitSync_Lazy((IntPtr)sync, (uint)flags, timeout);
        
        /// <summary>_3DFX extensions.</summary>
        public static unsafe partial class _3DFX
        {
            /// <summary> <b>[requires: GL_3DFX_tbuffer]</b> <b>[entry point: <c>glTbufferMask3DFX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/_3DFX/3DFX_tbuffer.txt"/></remarks>
            public static void TbufferMask3DFX(uint mask) => GLPointers.glTbufferMask3DFX_Lazy(mask);
            
        }
        /// <summary>AMD extensions.</summary>
        public static unsafe partial class AMD
        {
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glBeginPerfMonitorAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void BeginPerfMonitorAMD(uint monitor) => GLPointers.glBeginPerfMonitorAMD_Lazy(monitor);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b> <b>[entry point: <c>glBlendEquationIndexedAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_draw_buffers_blend.txt"/></remarks>
            public static void BlendEquationIndexedAMD(uint buf, BlendEquationMode mode) => GLPointers.glBlendEquationIndexedAMD_Lazy(buf, (uint)mode);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b> <b>[entry point: <c>glBlendEquationSeparateIndexedAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_draw_buffers_blend.txt"/></remarks>
            public static void BlendEquationSeparateIndexedAMD(uint buf, BlendEquationMode modeRGB, BlendEquationMode modeAlpha) => GLPointers.glBlendEquationSeparateIndexedAMD_Lazy(buf, (uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b> <b>[entry point: <c>glBlendFuncIndexedAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_draw_buffers_blend.txt"/></remarks>
            public static void BlendFuncIndexedAMD(uint buf, All src, All dst) => GLPointers.glBlendFuncIndexedAMD_Lazy(buf, (uint)src, (uint)dst);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b> <b>[entry point: <c>glBlendFuncSeparateIndexedAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_draw_buffers_blend.txt"/></remarks>
            public static void BlendFuncSeparateIndexedAMD(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers.glBlendFuncSeparateIndexedAMD_Lazy(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b> <b>[entry point: <c>glDebugMessageCallbackAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_debug_output.txt"/></remarks>
            public static void DebugMessageCallbackAMD(IntPtr callback, void* userParam) => GLPointers.glDebugMessageCallbackAMD_Lazy(callback, userParam);
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b> <b>[entry point: <c>glDebugMessageEnableAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_debug_output.txt"/></remarks>
            public static void DebugMessageEnableAMD(All category, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers.glDebugMessageEnableAMD_Lazy((uint)category, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b> <b>[entry point: <c>glDebugMessageInsertAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_debug_output.txt"/></remarks>
            public static void DebugMessageInsertAMD(All category, DebugSeverity severity, uint id, int length, byte* buf) => GLPointers.glDebugMessageInsertAMD_Lazy((uint)category, (uint)severity, id, length, buf);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b> <b>[entry point: <c>glDeleteNamesAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_name_gen_delete.txt"/></remarks>
            public static void DeleteNamesAMD(All identifier, uint num, uint* names) => GLPointers.glDeleteNamesAMD_Lazy((uint)identifier, num, names);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glDeletePerfMonitorsAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void DeletePerfMonitorsAMD(int n, uint* monitors) => GLPointers.glDeletePerfMonitorsAMD_Lazy(n, monitors);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glEndPerfMonitorAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void EndPerfMonitorAMD(uint monitor) => GLPointers.glEndPerfMonitorAMD_Lazy(monitor);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b> <b>[entry point: <c>glFramebufferSamplePositionsfvAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_framebuffer_sample_positions.txt"/></remarks>
            public static void FramebufferSamplePositionsfvAMD(FramebufferTarget target, uint numsamples, uint pixelindex, float* values) => GLPointers.glFramebufferSamplePositionsfvAMD_Lazy((uint)target, numsamples, pixelindex, values);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b> <b>[entry point: <c>glGenNamesAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_name_gen_delete.txt"/></remarks>
            public static void GenNamesAMD(All identifier, uint num, uint* names) => GLPointers.glGenNamesAMD_Lazy((uint)identifier, num, names);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGenPerfMonitorsAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void GenPerfMonitorsAMD(int n, uint* monitors) => GLPointers.glGenPerfMonitorsAMD_Lazy(n, monitors);
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b> <b>[entry point: <c>glGetDebugMessageLogAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_debug_output.txt"/></remarks>
            public static uint GetDebugMessageLogAMD(uint count, int bufSize, All* categories, DebugSeverity* severities, uint* ids, int* lengths, byte* message) => GLPointers.glGetDebugMessageLogAMD_Lazy(count, bufSize, (uint*)categories, (uint*)severities, ids, lengths, message);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b> <b>[entry point: <c>glGetFramebufferParameterfvAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_framebuffer_sample_positions.txt"/></remarks>
            public static void GetFramebufferParameterfvAMD(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, float* values) => GLPointers.glGetFramebufferParameterfvAMD_Lazy((uint)target, (uint)pname, numsamples, pixelindex, size, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b> <b>[entry point: <c>glGetNamedFramebufferParameterfvAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_framebuffer_sample_positions.txt"/></remarks>
            public static void GetNamedFramebufferParameterfvAMD(int framebuffer, All pname, uint numsamples, uint pixelindex, int size, float* values) => GLPointers.glGetNamedFramebufferParameterfvAMD_Lazy(framebuffer, (uint)pname, numsamples, pixelindex, size, values);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorCounterDataAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void GetPerfMonitorCounterDataAMD(uint monitor, All pname, int dataSize, uint* data, int* bytesWritten) => GLPointers.glGetPerfMonitorCounterDataAMD_Lazy(monitor, (uint)pname, dataSize, data, bytesWritten);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorCounterInfoAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void GetPerfMonitorCounterInfoAMD(uint group, uint counter, All pname, void* data) => GLPointers.glGetPerfMonitorCounterInfoAMD_Lazy(group, counter, (uint)pname, data);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorCountersAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void GetPerfMonitorCountersAMD(uint group, int* numCounters, int* maxActiveCounters, int counterSize, uint* counters) => GLPointers.glGetPerfMonitorCountersAMD_Lazy(group, numCounters, maxActiveCounters, counterSize, counters);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorCounterStringAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, int* length, byte* counterString) => GLPointers.glGetPerfMonitorCounterStringAMD_Lazy(group, counter, bufSize, length, counterString);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorGroupsAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void GetPerfMonitorGroupsAMD(int* numGroups, int groupsSize, uint* groups) => GLPointers.glGetPerfMonitorGroupsAMD_Lazy(numGroups, groupsSize, groups);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorGroupStringAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void GetPerfMonitorGroupStringAMD(uint group, int bufSize, int* length, byte* groupString) => GLPointers.glGetPerfMonitorGroupStringAMD_Lazy(group, bufSize, length, groupString);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glGetUniformi64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void GetUniformi64vNV(int program, int location, long* parameters) => GLPointers.glGetUniformi64vNV_Lazy(program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetUniformui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void GetUniformui64vNV(int program, int location, ulong* parameters) => GLPointers.glGetUniformui64vNV_Lazy(program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b> <b>[entry point: <c>glIsNameAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_name_gen_delete.txt"/></remarks>
            public static bool IsNameAMD(All identifier, uint name) => GLPointers.glIsNameAMD_Lazy((uint)identifier, name) != 0;
            
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawArraysIndirectAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_multi_draw_indirect.txt"/></remarks>
            public static void MultiDrawArraysIndirectAMD(PrimitiveType mode, void* indirect, int primcount, int stride) => GLPointers.glMultiDrawArraysIndirectAMD_Lazy((uint)mode, indirect, primcount, stride);
            
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawElementsIndirectAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_multi_draw_indirect.txt"/></remarks>
            public static void MultiDrawElementsIndirectAMD(PrimitiveType mode, DrawElementsType type, void* indirect, int primcount, int stride) => GLPointers.glMultiDrawElementsIndirectAMD_Lazy((uint)mode, (uint)type, indirect, primcount, stride);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b> <b>[entry point: <c>glNamedFramebufferSamplePositionsfvAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_framebuffer_sample_positions.txt"/></remarks>
            public static void NamedFramebufferSamplePositionsfvAMD(int framebuffer, uint numsamples, uint pixelindex, float* values) => GLPointers.glNamedFramebufferSamplePositionsfvAMD_Lazy(framebuffer, numsamples, pixelindex, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisampleAdvancedAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_framebuffer_multisample_advanced.txt"/></remarks>
            public static void NamedRenderbufferStorageMultisampleAdvancedAMD(int renderbuffer, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => GLPointers.glNamedRenderbufferStorageMultisampleAdvancedAMD_Lazy(renderbuffer, samples, storageSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform1i64NV(int program, int location, long x) => GLPointers.glProgramUniform1i64NV_Lazy(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform1i64vNV(int program, int location, int count, long* value) => GLPointers.glProgramUniform1i64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform1ui64NV(int program, int location, ulong x) => GLPointers.glProgramUniform1ui64NV_Lazy(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform1ui64vNV(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform1ui64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform2i64NV(int program, int location, long x, long y) => GLPointers.glProgramUniform2i64NV_Lazy(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform2i64vNV(int program, int location, int count, long* value) => GLPointers.glProgramUniform2i64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform2ui64NV(int program, int location, ulong x, ulong y) => GLPointers.glProgramUniform2ui64NV_Lazy(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform2ui64vNV(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform2ui64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform3i64NV(int program, int location, long x, long y, long z) => GLPointers.glProgramUniform3i64NV_Lazy(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform3i64vNV(int program, int location, int count, long* value) => GLPointers.glProgramUniform3i64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform3ui64NV(int program, int location, ulong x, ulong y, ulong z) => GLPointers.glProgramUniform3ui64NV_Lazy(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform3ui64vNV(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform3ui64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform4i64NV(int program, int location, long x, long y, long z, long w) => GLPointers.glProgramUniform4i64NV_Lazy(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform4i64vNV(int program, int location, int count, long* value) => GLPointers.glProgramUniform4i64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform4ui64NV(int program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers.glProgramUniform4ui64NV_Lazy(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform4ui64vNV(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform4ui64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_occlusion_query_event]</b> <b>[entry point: <c>glQueryObjectParameteruiAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_occlusion_query_event.txt"/></remarks>
            public static void QueryObjectParameteruiAMD(QueryTarget target, int id, All pname, OcclusionQueryEventMaskAMD param) => GLPointers.glQueryObjectParameteruiAMD_Lazy((uint)target, id, (uint)pname, (uint)param);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced]</b> <b>[entry point: <c>glRenderbufferStorageMultisampleAdvancedAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_framebuffer_multisample_advanced.txt"/></remarks>
            public static void RenderbufferStorageMultisampleAdvancedAMD(RenderbufferTarget target, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => GLPointers.glRenderbufferStorageMultisampleAdvancedAMD_Lazy((uint)target, samples, storageSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glSelectPerfMonitorCountersAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_performance_monitor.txt"/></remarks>
            public static void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, uint* counterList) => GLPointers.glSelectPerfMonitorCountersAMD_Lazy(monitor, (byte)(enable ? 1 : 0), group, numCounters, counterList);
            
            /// <summary> <b>[requires: GL_AMD_sample_positions]</b> <b>[entry point: <c>glSetMultisamplefvAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_sample_positions.txt"/></remarks>
            public static void SetMultisamplefvAMD(All pname, uint index, float* val) => GLPointers.glSetMultisamplefvAMD_Lazy((uint)pname, index, val);
            
            /// <summary> <b>[requires: GL_AMD_stencil_operation_extended]</b> <b>[entry point: <c>glStencilOpValueAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_stencil_operation_extended.txt"/></remarks>
            public static void StencilOpValueAMD(TriangleFace face, uint value) => GLPointers.glStencilOpValueAMD_Lazy((uint)face, value);
            
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator]</b> <b>[entry point: <c>glTessellationFactorAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_vertex_shader_tessellator.txt"/></remarks>
            public static void TessellationFactorAMD(float factor) => GLPointers.glTessellationFactorAMD_Lazy(factor);
            
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator]</b> <b>[entry point: <c>glTessellationModeAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_vertex_shader_tessellator.txt"/></remarks>
            public static void TessellationModeAMD(All mode) => GLPointers.glTessellationModeAMD_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_AMD_sparse_texture]</b> <b>[entry point: <c>glTexStorageSparseAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_sparse_texture.txt"/></remarks>
            public static void TexStorageSparseAMD(TextureTarget target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => GLPointers.glTexStorageSparseAMD_Lazy((uint)target, (uint)internalFormat, width, height, depth, layers, (uint)flags);
            
            /// <summary> <b>[requires: GL_AMD_sparse_texture]</b> <b>[entry point: <c>glTextureStorageSparseAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_sparse_texture.txt"/></remarks>
            public static void TextureStorageSparseAMD(int texture, TextureTarget target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => GLPointers.glTextureStorageSparseAMD_Lazy(texture, (uint)target, (uint)internalFormat, width, height, depth, layers, (uint)flags);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform1i64NV(int location, long x) => GLPointers.glUniform1i64NV_Lazy(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform1i64vNV(int location, int count, long* value) => GLPointers.glUniform1i64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform1ui64NV(int location, ulong x) => GLPointers.glUniform1ui64NV_Lazy(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform1ui64vNV(int location, int count, ulong* value) => GLPointers.glUniform1ui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform2i64NV(int location, long x, long y) => GLPointers.glUniform2i64NV_Lazy(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform2i64vNV(int location, int count, long* value) => GLPointers.glUniform2i64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform2ui64NV(int location, ulong x, ulong y) => GLPointers.glUniform2ui64NV_Lazy(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform2ui64vNV(int location, int count, ulong* value) => GLPointers.glUniform2ui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform3i64NV(int location, long x, long y, long z) => GLPointers.glUniform3i64NV_Lazy(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform3i64vNV(int location, int count, long* value) => GLPointers.glUniform3i64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z) => GLPointers.glUniform3ui64NV_Lazy(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform3ui64vNV(int location, int count, ulong* value) => GLPointers.glUniform3ui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform4i64NV(int location, long x, long y, long z, long w) => GLPointers.glUniform4i64NV_Lazy(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform4i64vNV(int location, int count, long* value) => GLPointers.glUniform4i64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers.glUniform4ui64NV_Lazy(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform4ui64vNV(int location, int count, ulong* value) => GLPointers.glUniform4ui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_interleaved_elements]</b> <b>[entry point: <c>glVertexAttribParameteriAMD</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_interleaved_elements.txt"/></remarks>
            public static void VertexAttribParameteriAMD(uint index, All pname, int param) => GLPointers.glVertexAttribParameteriAMD_Lazy(index, (uint)pname, param);
            
        }
        /// <summary>APPLE extensions.</summary>
        public static unsafe partial class APPLE
        {
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b> <b>[entry point: <c>glBindVertexArrayAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_array_object.txt"/></remarks>
            public static void BindVertexArrayAPPLE(int array) => GLPointers.glBindVertexArrayAPPLE_Lazy(array);
            
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range]</b> <b>[entry point: <c>glBufferParameteriAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_flush_buffer_range.txt"/></remarks>
            public static void BufferParameteriAPPLE(All target, All pname, int param) => GLPointers.glBufferParameteriAPPLE_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glDeleteFencesAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_fence.txt"/></remarks>
            public static void DeleteFencesAPPLE(int n, uint* fences) => GLPointers.glDeleteFencesAPPLE_Lazy(n, fences);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b> <b>[entry point: <c>glDeleteVertexArraysAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_array_object.txt"/></remarks>
            public static void DeleteVertexArraysAPPLE(int n, int* arrays) => GLPointers.glDeleteVertexArraysAPPLE_Lazy(n, arrays);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glDisableVertexAttribAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_program_evaluators.txt"/></remarks>
            public static void DisableVertexAttribAPPLE(uint index, All pname) => GLPointers.glDisableVertexAttribAPPLE_Lazy(index, (uint)pname);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glDrawElementArrayAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_element_array.txt"/></remarks>
            public static void DrawElementArrayAPPLE(PrimitiveType mode, int first, int count) => GLPointers.glDrawElementArrayAPPLE_Lazy((uint)mode, first, count);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glDrawRangeElementArrayAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_element_array.txt"/></remarks>
            public static void DrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int first, int count) => GLPointers.glDrawRangeElementArrayAPPLE_Lazy((uint)mode, start, end, first, count);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glElementPointerAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_element_array.txt"/></remarks>
            public static void ElementPointerAPPLE(ElementPointerTypeATI type, void* pointer) => GLPointers.glElementPointerAPPLE_Lazy((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glEnableVertexAttribAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_program_evaluators.txt"/></remarks>
            public static void EnableVertexAttribAPPLE(uint index, All pname) => GLPointers.glEnableVertexAttribAPPLE_Lazy(index, (uint)pname);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glFinishFenceAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_fence.txt"/></remarks>
            public static void FinishFenceAPPLE(uint fence) => GLPointers.glFinishFenceAPPLE_Lazy(fence);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glFinishObjectAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_fence.txt"/></remarks>
            public static void FinishObjectAPPLE(ObjectTypeAPPLE obj, int name) => GLPointers.glFinishObjectAPPLE_Lazy((uint)obj, name);
            
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range]</b> <b>[entry point: <c>glFlushMappedBufferRangeAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_flush_buffer_range.txt"/></remarks>
            public static void FlushMappedBufferRangeAPPLE(BufferTarget target, IntPtr offset, nint size) => GLPointers.glFlushMappedBufferRangeAPPLE_Lazy((uint)target, offset, size);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b> <b>[entry point: <c>glFlushVertexArrayRangeAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_array_range.txt"/></remarks>
            public static void FlushVertexArrayRangeAPPLE(int length, void* pointer) => GLPointers.glFlushVertexArrayRangeAPPLE_Lazy(length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glGenFencesAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_fence.txt"/></remarks>
            public static void GenFencesAPPLE(int n, uint* fences) => GLPointers.glGenFencesAPPLE_Lazy(n, fences);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b> <b>[entry point: <c>glGenVertexArraysAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_array_object.txt"/></remarks>
            public static void GenVertexArraysAPPLE(int n, int* arrays) => GLPointers.glGenVertexArraysAPPLE_Lazy(n, arrays);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b> <b>[entry point: <c>glGetObjectParameterivAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_object_purgeable.txt"/></remarks>
            public static void GetObjectParameterivAPPLE(All objectType, uint name, All pname, int* parameters) => GLPointers.glGetObjectParameterivAPPLE_Lazy((uint)objectType, name, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_APPLE_texture_range]</b> <b>[entry point: <c>glGetTexParameterPointervAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_texture_range.txt"/></remarks>
            public static void GetTexParameterPointervAPPLE(All target, All pname, void** parameters) => GLPointers.glGetTexParameterPointervAPPLE_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glIsFenceAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_fence.txt"/></remarks>
            public static bool IsFenceAPPLE(uint fence) => GLPointers.glIsFenceAPPLE_Lazy(fence) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b> <b>[entry point: <c>glIsVertexArrayAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_array_object.txt"/></remarks>
            public static bool IsVertexArrayAPPLE(int array) => GLPointers.glIsVertexArrayAPPLE_Lazy(array) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glIsVertexAttribEnabledAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_program_evaluators.txt"/></remarks>
            public static bool IsVertexAttribEnabledAPPLE(uint index, All pname) => GLPointers.glIsVertexAttribEnabledAPPLE_Lazy(index, (uint)pname) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glMapVertexAttrib1dAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_program_evaluators.txt"/></remarks>
            public static void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, double* points) => GLPointers.glMapVertexAttrib1dAPPLE_Lazy(index, size, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glMapVertexAttrib1fAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_program_evaluators.txt"/></remarks>
            public static void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, float* points) => GLPointers.glMapVertexAttrib1fAPPLE_Lazy(index, size, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glMapVertexAttrib2dAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_program_evaluators.txt"/></remarks>
            public static void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) => GLPointers.glMapVertexAttrib2dAPPLE_Lazy(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glMapVertexAttrib2fAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_program_evaluators.txt"/></remarks>
            public static void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) => GLPointers.glMapVertexAttrib2fAPPLE_Lazy(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glMultiDrawElementArrayAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_element_array.txt"/></remarks>
            public static void MultiDrawElementArrayAPPLE(PrimitiveType mode, int* first, int* count, int primcount) => GLPointers.glMultiDrawElementArrayAPPLE_Lazy((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glMultiDrawRangeElementArrayAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_element_array.txt"/></remarks>
            public static void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int* first, int* count, int primcount) => GLPointers.glMultiDrawRangeElementArrayAPPLE_Lazy((uint)mode, start, end, first, count, primcount);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b> <b>[entry point: <c>glObjectPurgeableAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_object_purgeable.txt"/></remarks>
            public static All ObjectPurgeableAPPLE(All objectType, uint name, All option) => (All) GLPointers.glObjectPurgeableAPPLE_Lazy((uint)objectType, name, (uint)option);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b> <b>[entry point: <c>glObjectUnpurgeableAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_object_purgeable.txt"/></remarks>
            public static All ObjectUnpurgeableAPPLE(All objectType, uint name, All option) => (All) GLPointers.glObjectUnpurgeableAPPLE_Lazy((uint)objectType, name, (uint)option);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glSetFenceAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_fence.txt"/></remarks>
            public static void SetFenceAPPLE(uint fence) => GLPointers.glSetFenceAPPLE_Lazy(fence);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glTestFenceAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_fence.txt"/></remarks>
            public static bool TestFenceAPPLE(uint fence) => GLPointers.glTestFenceAPPLE_Lazy(fence) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glTestObjectAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_fence.txt"/></remarks>
            public static bool TestObjectAPPLE(ObjectTypeAPPLE obj, uint name) => GLPointers.glTestObjectAPPLE_Lazy((uint)obj, name) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_texture_range]</b> <b>[entry point: <c>glTextureRangeAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_texture_range.txt"/></remarks>
            public static void TextureRangeAPPLE(All target, int length, void* pointer) => GLPointers.glTextureRangeAPPLE_Lazy((uint)target, length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b> <b>[entry point: <c>glVertexArrayParameteriAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_array_range.txt"/></remarks>
            public static void VertexArrayParameteriAPPLE(VertexArrayPNameAPPLE pname, int param) => GLPointers.glVertexArrayParameteriAPPLE_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b> <b>[entry point: <c>glVertexArrayRangeAPPLE</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/APPLE/APPLE_vertex_array_range.txt"/></remarks>
            public static void VertexArrayRangeAPPLE(int length, void* pointer) => GLPointers.glVertexArrayRangeAPPLE_Lazy(length, pointer);
            
        }
        /// <summary>ARB extensions.</summary>
        public static unsafe partial class ARB
        {
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glActiveShaderProgram</c>]</b><br/> Set the active program object for a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
            /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ActiveShaderProgram(int pipeline, int program) => GLPointers.glActiveShaderProgram_Lazy(pipeline, program);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glActiveTextureARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void ActiveTextureARB(TextureUnit texture) => GLPointers.glActiveTextureARB_Lazy((uint)texture);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glAttachObjectARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void AttachObjectARB(GLHandleARB containerObj, GLHandleARB obj) => GLPointers.glAttachObjectARB_Lazy((IntPtr)containerObj, (IntPtr)obj);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glBeginQueryARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_occlusion_query.txt"/></remarks>
            public static void BeginQueryARB(QueryTarget target, int id) => GLPointers.glBeginQueryARB_Lazy((uint)target, id);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glBeginQueryIndexed</c>]</b><br/> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback3.txt"/></remarks>
            public static void BeginQueryIndexed(QueryTarget target, uint index, int id) => GLPointers.glBeginQueryIndexed_Lazy((uint)target, index, id);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b> <b>[entry point: <c>glBindAttribLocationARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void BindAttribLocationARB(GLHandleARB programObj, uint index, byte* name) => GLPointers.glBindAttribLocationARB_Lazy((IntPtr)programObj, index, name);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glBindBufferARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static void BindBufferARB(BufferTarget target, int buffer) => GLPointers.glBindBufferARB_Lazy((uint)target, buffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glBindBufferBase</c>]</b><br/> Bind a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static void BindBufferBase(BufferTarget target, uint index, int buffer) => GLPointers.glBindBufferBase_Lazy((uint)target, index, buffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glBindBufferRange</c>]</b><br/> Bind a range within a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
            /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static void BindBufferRange(BufferTarget target, uint index, int buffer, IntPtr offset, nint size) => GLPointers.glBindBufferRange_Lazy((uint)target, index, buffer, offset, size);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindBuffersBase</c>]</b><br/> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
            public static void BindBuffersBase(BufferTarget target, uint first, int count, int* buffers) => GLPointers.glBindBuffersBase_Lazy((uint)target, first, count, buffers);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindBuffersRange</c>]</b><br/> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
            public static void BindBuffersRange(BufferTarget target, uint first, int count, int* buffers, IntPtr* offsets, nint* sizes) => GLPointers.glBindBuffersRange_Lazy((uint)target, first, count, buffers, offsets, sizes);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> <b>[entry point: <c>glBindFragDataLocationIndexed</c>]</b><br/> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
            /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
            /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
            /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_blend_func_extended.txt"/></remarks>
            public static void BindFragDataLocationIndexed(int program, uint colorNumber, uint index, byte* name) => GLPointers.glBindFragDataLocationIndexed_Lazy(program, colorNumber, index, name);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBindFramebuffer</c>]</b><br/> Bind a framebuffer to a framebuffer target. </summary>
            /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void BindFramebuffer(FramebufferTarget target, int framebuffer) => GLPointers.glBindFramebuffer_Lazy((uint)target, framebuffer);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> <b>[entry point: <c>glBindImageTexture</c>]</b><br/> Bind a level of a texture to an image unit. </summary>
            /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
            /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
            /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
            /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
            /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
            /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
            /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_image_load_store.txt"/></remarks>
            public static void BindImageTexture(uint unit, int texture, int level, bool layered, int layer, BufferAccess access, InternalFormat format) => GLPointers.glBindImageTexture_Lazy(unit, texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, (uint)format);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindImageTextures</c>]</b><br/> Bind one or more named texture images to a sequence of consecutive image units. </summary>
            /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
            public static void BindImageTextures(uint first, int count, int* textures) => GLPointers.glBindImageTextures_Lazy(first, count, textures);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glBindProgramARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void BindProgramARB(ProgramTarget target, int program) => GLPointers.glBindProgramARB_Lazy((uint)target, program);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glBindProgramPipeline</c>]</b><br/> Bind a program pipeline to the current context. </summary>
            /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void BindProgramPipeline(int pipeline) => GLPointers.glBindProgramPipeline_Lazy(pipeline);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBindRenderbuffer</c>]</b><br/> Bind a renderbuffer to a renderbuffer target. </summary>
            /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void BindRenderbuffer(RenderbufferTarget target, int renderbuffer) => GLPointers.glBindRenderbuffer_Lazy((uint)target, renderbuffer);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glBindSampler</c>]</b><br/> Bind a named sampler to a texturing target. </summary>
            /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
            /// <param name="sampler"> Specifies the name of a sampler. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void BindSampler(uint unit, int sampler) => GLPointers.glBindSampler_Lazy(unit, sampler);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindSamplers</c>]</b><br/> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
            /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
            /// <param name="count"> Specifies the number of samplers to bind. </param>
            /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
            public static void BindSamplers(uint first, int count, int* samplers) => GLPointers.glBindSamplers_Lazy(first, count, samplers);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindTextures</c>]</b><br/> Bind one or more named textures to a sequence of consecutive texture units. </summary>
            /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
            public static void BindTextures(uint first, int count, int* textures) => GLPointers.glBindTextures_Lazy(first, count, textures);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glBindTextureUnit</c>]</b><br/> Bind an existing texture object to the specified texture unit . </summary>
            /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
            /// <param name="texture">Specifies the name of a texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void BindTextureUnit(uint unit, int texture) => GLPointers.glBindTextureUnit_Lazy(unit, texture);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glBindTransformFeedback</c>]</b><br/> Bind a transform feedback object. </summary>
            /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
            /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
            public static void BindTransformFeedback(BindTransformFeedbackTarget target, int id) => GLPointers.glBindTransformFeedback_Lazy((uint)target, id);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glBindVertexArray</c>]</b><br/> Bind a vertex array object. </summary>
            /// <param name="array"> Specifies the name of the vertex array to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_array_object.txt"/></remarks>
            public static void BindVertexArray(int array) => GLPointers.glBindVertexArray_Lazy(array);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glBindVertexBuffer</c>]</b><br/> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
            public static void BindVertexBuffer(uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers.glBindVertexBuffer_Lazy(bindingindex, buffer, offset, stride);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindVertexBuffers</c>]</b><br/> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_bind.txt"/></remarks>
            public static void BindVertexBuffers(uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers.glBindVertexBuffers_Lazy(first, count, buffers, offsets, strides);
            
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> <b>[entry point: <c>glBlendColor</c>]</b><br/> Set the blend color. </summary>
            /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void BlendColor(float red, float green, float blue, float alpha) => GLPointers.glBlendColor_Lazy(red, green, blue, alpha);
            
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> <b>[entry point: <c>glBlendEquation</c>]</b><br/> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
            /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void BlendEquation(BlendEquationMode mode) => GLPointers.glBlendEquation_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b> <b>[entry point: <c>glBlendEquationiARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_buffers_blend.txt"/></remarks>
            public static void BlendEquationiARB(uint buf, BlendEquationMode mode) => GLPointers.glBlendEquationiARB_Lazy(buf, (uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b> <b>[entry point: <c>glBlendEquationSeparateiARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_buffers_blend.txt"/></remarks>
            public static void BlendEquationSeparateiARB(uint buf, BlendEquationMode modeRGB, BlendEquationMode modeAlpha) => GLPointers.glBlendEquationSeparateiARB_Lazy(buf, (uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b> <b>[entry point: <c>glBlendFunciARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_buffers_blend.txt"/></remarks>
            public static void BlendFunciARB(uint buf, BlendingFactor src, BlendingFactor dst) => GLPointers.glBlendFunciARB_Lazy(buf, (uint)src, (uint)dst);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b> <b>[entry point: <c>glBlendFuncSeparateiARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_buffers_blend.txt"/></remarks>
            public static void BlendFuncSeparateiARB(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers.glBlendFuncSeparateiARB_Lazy(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBlitFramebuffer</c>]</b><br/> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers.glBlitFramebuffer_Lazy(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glBlitNamedFramebuffer</c>]</b><br/> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void BlitNamedFramebuffer(int readFramebuffer, int drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers.glBlitNamedFramebuffer_Lazy(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glBufferDataARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static void BufferDataARB(BufferTarget target, nint size, void* data, BufferUsage usage) => GLPointers.glBufferDataARB_Lazy((uint)target, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b> <b>[entry point: <c>glBufferPageCommitmentARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sparse_buffer.txt"/></remarks>
            public static void BufferPageCommitmentARB(All target, IntPtr offset, nint size, bool commit) => GLPointers.glBufferPageCommitmentARB_Lazy((uint)target, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage]</b> <b>[entry point: <c>glBufferStorage</c>]</b><br/> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_buffer_storage.txt"/></remarks>
            public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => GLPointers.glBufferStorage_Lazy((uint)target, size, data, (uint)flags);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glBufferSubDataARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static void BufferSubDataARB(BufferTarget target, IntPtr offset, nint size, void* data) => GLPointers.glBufferSubDataARB_Lazy((uint)target, offset, size, data);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glCheckFramebufferStatus</c>]</b><br/> Check the completeness status of a framebuffer. </summary>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => (FramebufferStatus) GLPointers.glCheckFramebufferStatus_Lazy((uint)target);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCheckNamedFramebufferStatus</c>]</b><br/> Check the completeness status of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static FramebufferStatus CheckNamedFramebufferStatus(int framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers.glCheckNamedFramebufferStatus_Lazy(framebuffer, (uint)target);
            
            /// <summary> <b>[requires: GL_ARB_color_buffer_float]</b> <b>[entry point: <c>glClampColorARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_color_buffer_float.txt"/></remarks>
            public static void ClampColorARB(ClampColorTargetARB target, ClampColorModeARB clamp) => GLPointers.glClampColorARB_Lazy((uint)target, (uint)clamp);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> <b>[entry point: <c>glClearBufferData</c>]</b><br/> Fill a buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clear_buffer_object.txt"/></remarks>
            public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers.glClearBufferData_Lazy((uint)target, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> <b>[entry point: <c>glClearBufferSubData</c>]</b><br/> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clear_buffer_object.txt"/></remarks>
            public static void ClearBufferSubData(BufferTarget target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers.glClearBufferSubData_Lazy((uint)target, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glClearDepthf</c>]</b><br/> Specify the clear value for the depth buffer. </summary>
            /// <param name="d"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
            public static void ClearDepthf(float d) => GLPointers.glClearDepthf_Lazy(d);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferData</c>]</b><br/> Fill a buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void ClearNamedBufferData(int buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers.glClearNamedBufferData_Lazy(buffer, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferSubData</c>]</b><br/> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void ClearNamedBufferSubData(int buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers.glClearNamedBufferSubData_Lazy(buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferfi</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="depth"> The value to clear the depth buffer to. </param>
            /// <param name="stencil"> The value to clear the stencil buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void ClearNamedFramebufferfi(int framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers.glClearNamedFramebufferfi_Lazy(framebuffer, (uint)buffer, drawbuffer, depth, stencil);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferfv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void ClearNamedFramebufferfv(int framebuffer, Buffer buffer, int drawbuffer, float* value) => GLPointers.glClearNamedFramebufferfv_Lazy(framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void ClearNamedFramebufferiv(int framebuffer, Buffer buffer, int drawbuffer, int* value) => GLPointers.glClearNamedFramebufferiv_Lazy(framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferuiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void ClearNamedFramebufferuiv(int framebuffer, Buffer buffer, int drawbuffer, uint* value) => GLPointers.glClearNamedFramebufferuiv_Lazy(framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> <b>[entry point: <c>glClearTexImage</c>]</b><br/> Fills all a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clear_texture.txt"/></remarks>
            public static void ClearTexImage(int texture, int level, PixelFormat format, PixelType type, void* data) => GLPointers.glClearTexImage_Lazy(texture, level, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> <b>[entry point: <c>glClearTexSubImage</c>]</b><br/> Fills all or part of a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
            /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
            /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
            /// <param name="width"> The width of the region to be cleared. </param>
            /// <param name="height"> The height of the region to be cleared. </param>
            /// <param name="depth"> The depth of the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clear_texture.txt"/></remarks>
            public static void ClearTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => GLPointers.glClearTexSubImage_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glClientActiveTextureARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void ClientActiveTextureARB(TextureUnit texture) => GLPointers.glClientActiveTextureARB_Lazy((uint)texture);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glClientWaitSync</c>]</b><br/> Block and wait for a sync object to become signaled. </summary>
            /// <param name="sync"> The sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
            /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
            public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => (SyncStatus) GLPointers.glClientWaitSync_Lazy((IntPtr)sync, (uint)flags, timeout);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control]</b> <b>[entry point: <c>glClipControl</c>]</b><br/> Control clip coordinate to window coordinate behavior. </summary>
            /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
            /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_clip_control.txt"/></remarks>
            public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => GLPointers.glClipControl_Lazy((uint)origin, (uint)depth);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP3ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void ColorP3ui(ColorPointerType type, uint color) => GLPointers.glColorP3ui_Lazy((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP3uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void ColorP3uiv(ColorPointerType type, uint* color) => GLPointers.glColorP3uiv_Lazy((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP4ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void ColorP4ui(ColorPointerType type, uint color) => GLPointers.glColorP4ui_Lazy((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP4uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void ColorP4uiv(ColorPointerType type, uint* color) => GLPointers.glColorP4uiv_Lazy((uint)type, color);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glColorSubTable</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ColorSubTable(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data) => GLPointers.glColorSubTable_Lazy((uint)target, start, count, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glColorTable</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ColorTable(ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table) => GLPointers.glColorTable_Lazy((uint)target, (uint)internalformat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glColorTableParameterfv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ColorTableParameterfv(ColorTableTarget target, ColorTableParameterPName pname, float* parameters) => GLPointers.glColorTableParameterfv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glColorTableParameteriv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ColorTableParameteriv(ColorTableTarget target, ColorTableParameterPName pname, int* parameters) => GLPointers.glColorTableParameteriv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glCompileShaderARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void CompileShaderARB(GLHandleARB shaderObj) => GLPointers.glCompileShaderARB_Lazy((IntPtr)shaderObj);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glCompileShaderIncludeARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shading_language_include.txt"/></remarks>
            public static void CompileShaderIncludeARB(int shader, int count, byte** path, int* length) => GLPointers.glCompileShaderIncludeARB_Lazy(shader, count, path, length);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexImage1DARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_compression.txt"/></remarks>
            public static void CompressedTexImage1DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => GLPointers.glCompressedTexImage1DARB_Lazy((uint)target, level, (uint)internalformat, width, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexImage2DARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_compression.txt"/></remarks>
            public static void CompressedTexImage2DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => GLPointers.glCompressedTexImage2DARB_Lazy((uint)target, level, (uint)internalformat, width, height, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexImage3DARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_compression.txt"/></remarks>
            public static void CompressedTexImage3DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => GLPointers.glCompressedTexImage3DARB_Lazy((uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexSubImage1DARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_compression.txt"/></remarks>
            public static void CompressedTexSubImage1DARB(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTexSubImage1DARB_Lazy((uint)target, level, xoffset, width, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexSubImage2DARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_compression.txt"/></remarks>
            public static void CompressedTexSubImage2DARB(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTexSubImage2DARB_Lazy((uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexSubImage3DARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_compression.txt"/></remarks>
            public static void CompressedTexSubImage3DARB(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTexSubImage3DARB_Lazy((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage in a compressed    format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CompressedTextureSubImage1D(int texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTextureSubImage1D_Lazy(texture, level, xoffset, width, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CompressedTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTextureSubImage2D_Lazy(texture, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">!!missing documentation!!</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CompressedTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers.glCompressedTextureSubImage3D_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionFilter1D</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image) => GLPointers.glConvolutionFilter1D_Lazy((uint)target, (uint)internalformat, width, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionFilter2D</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image) => GLPointers.glConvolutionFilter2D_Lazy((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionParameterf</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ConvolutionParameterf(ConvolutionTarget target, ConvolutionParameter pname, float parameters) => GLPointers.glConvolutionParameterf_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionParameterfv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameter pname, float* parameters) => GLPointers.glConvolutionParameterfv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionParameteri</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ConvolutionParameteri(ConvolutionTarget target, ConvolutionParameter pname, int parameters) => GLPointers.glConvolutionParameteri_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionParameteriv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameter pname, int* parameters) => GLPointers.glConvolutionParameteriv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer]</b> <b>[entry point: <c>glCopyBufferSubData</c>]</b><br/> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
            /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_copy_buffer.txt"/></remarks>
            public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers.glCopyBufferSubData_Lazy((uint)readTarget, (uint)writeTarget, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glCopyColorSubTable</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void CopyColorSubTable(ColorTableTarget target, int start, int x, int y, int width) => GLPointers.glCopyColorSubTable_Lazy((uint)target, start, x, y, width);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glCopyColorTable</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void CopyColorTable(ColorTableTarget target, InternalFormat internalformat, int x, int y, int width) => GLPointers.glCopyColorTable_Lazy((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glCopyConvolutionFilter1D</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void CopyConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width) => GLPointers.glCopyConvolutionFilter1D_Lazy((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glCopyConvolutionFilter2D</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void CopyConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width, int height) => GLPointers.glCopyConvolutionFilter2D_Lazy((uint)target, (uint)internalformat, x, y, width, height);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image]</b> <b>[entry point: <c>glCopyImageSubData</c>]</b><br/> Perform a raw data copy between two images. </summary>
            /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
            /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
            /// <param name="srcLevel"> The mipmap level to read from the source. </param>
            /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
            /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
            /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
            /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
            /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
            /// <param name="dstLevel">!!missing documentation!!</param>
            /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
            /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
            /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
            /// <param name="srcWidth"> The width of the region to be copied. </param>
            /// <param name="srcHeight"> The height of the region to be copied. </param>
            /// <param name="srcDepth"> The depth of the region to be copied. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_copy_image.txt"/></remarks>
            public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers.glCopyImageSubData_Lazy(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyNamedBufferSubData</c>]</b><br/> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CopyNamedBufferSubData(int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers.glCopyNamedBufferSubData_Lazy(readBuffer, writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage1D</c>]</b><br/> Copy a one-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CopyTextureSubImage1D(int texture, int level, int xoffset, int x, int y, int width) => GLPointers.glCopyTextureSubImage1D_Lazy(texture, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage2D</c>]</b><br/> Copy a two-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CopyTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers.glCopyTextureSubImage2D_Lazy(texture, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage3D</c>]</b><br/> Copy a three-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CopyTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers.glCopyTextureSubImage3D_Lazy(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateBuffers</c>]</b><br/> Create buffer objects. </summary>
            /// <param name="n"> Specifies the number of buffer objects to create. </param>
            /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CreateBuffers(int n, int* buffers) => GLPointers.glCreateBuffers_Lazy(n, buffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateFramebuffers</c>]</b><br/> Create framebuffer objects. </summary>
            /// <param name="n"> Number of framebuffer objects to create. </param>
            /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CreateFramebuffers(int n, int* framebuffers) => GLPointers.glCreateFramebuffers_Lazy(n, framebuffers);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glCreateProgramObjectARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static GLHandleARB CreateProgramObjectARB() => (GLHandleARB) GLPointers.glCreateProgramObjectARB_Lazy();
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateProgramPipelines</c>]</b><br/> Create program pipeline objects. </summary>
            /// <param name="n"> Number of program pipeline objects to create. </param>
            /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CreateProgramPipelines(int n, int* pipelines) => GLPointers.glCreateProgramPipelines_Lazy(n, pipelines);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateQueries</c>]</b><br/> Create query objects. </summary>
            /// <param name="target"> Specifies the target of each created query object. </param>
            /// <param name="n"> Number of query objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CreateQueries(QueryTarget target, int n, int* ids) => GLPointers.glCreateQueries_Lazy((uint)target, n, ids);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateRenderbuffers</c>]</b><br/> Create renderbuffer objects. </summary>
            /// <param name="n"> Number of renderbuffer objects to create. </param>
            /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CreateRenderbuffers(int n, int* renderbuffers) => GLPointers.glCreateRenderbuffers_Lazy(n, renderbuffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateSamplers</c>]</b><br/> Create sampler objects. </summary>
            /// <param name="n"> Number of sampler objects to create. </param>
            /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CreateSamplers(int n, int* samplers) => GLPointers.glCreateSamplers_Lazy(n, samplers);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glCreateShaderObjectARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static GLHandleARB CreateShaderObjectARB(ShaderType shaderType) => (GLHandleARB) GLPointers.glCreateShaderObjectARB_Lazy((uint)shaderType);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glCreateShaderProgramv</c>]</b><br/> Create a stand-alone program from an array of null-terminated source code strings. </summary>
            /// <param name="type"> Specifies the type of shader to create. </param>
            /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
            /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static int CreateShaderProgramv(ShaderType type, int count, byte** strings) => GLPointers.glCreateShaderProgramv_Lazy((uint)type, count, strings);
            
            /// <summary> <b>[requires: GL_ARB_cl_event]</b> <b>[entry point: <c>glCreateSyncFromCLeventARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_cl_event.txt"/></remarks>
            public static GLSync CreateSyncFromCLeventARB(CLContext* context, CLEvent* @event, uint flags) => (GLSync) GLPointers.glCreateSyncFromCLeventARB_Lazy((IntPtr*)context, (IntPtr*)@event, flags);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateTextures</c>]</b><br/> Create texture objects. </summary>
            /// <param name="target"> Specifies the effective texture target of each created texture. </param>
            /// <param name="n"> Number of texture objects to create. </param>
            /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CreateTextures(TextureTarget target, int n, int* textures) => GLPointers.glCreateTextures_Lazy((uint)target, n, textures);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateTransformFeedbacks</c>]</b><br/> Create transform feedback objects. </summary>
            /// <param name="n"> Number of transform feedback objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CreateTransformFeedbacks(int n, int* ids) => GLPointers.glCreateTransformFeedbacks_Lazy(n, ids);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateVertexArrays</c>]</b><br/> Create vertex array objects. </summary>
            /// <param name="n"> Number of vertex array objects to create. </param>
            /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void CreateVertexArrays(int n, int* arrays) => GLPointers.glCreateVertexArrays_Lazy(n, arrays);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glCurrentPaletteMatrixARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_matrix_palette.txt"/></remarks>
            public static void CurrentPaletteMatrixARB(int index) => GLPointers.glCurrentPaletteMatrixARB_Lazy(index);
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b> <b>[entry point: <c>glDebugMessageCallbackARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_debug_output.txt"/></remarks>
            public static void DebugMessageCallbackARB(IntPtr callback, void* userParam) => GLPointers.glDebugMessageCallbackARB_Lazy(callback, userParam);
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b> <b>[entry point: <c>glDebugMessageControlARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_debug_output.txt"/></remarks>
            public static void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers.glDebugMessageControlARB_Lazy((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b> <b>[entry point: <c>glDebugMessageInsertARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_debug_output.txt"/></remarks>
            public static void DebugMessageInsertARB(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers.glDebugMessageInsertARB_Lazy((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glDeleteBuffersARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static void DeleteBuffersARB(int n, int* buffers) => GLPointers.glDeleteBuffersARB_Lazy(n, buffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glDeleteFramebuffers</c>]</b><br/> Delete framebuffer objects. </summary>
            /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
            /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void DeleteFramebuffers(int n, int* framebuffers) => GLPointers.glDeleteFramebuffers_Lazy(n, framebuffers);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glDeleteNamedStringARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shading_language_include.txt"/></remarks>
            public static void DeleteNamedStringARB(int namelen, byte* name) => GLPointers.glDeleteNamedStringARB_Lazy(namelen, name);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glDeleteObjectARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void DeleteObjectARB(GLHandleARB obj) => GLPointers.glDeleteObjectARB_Lazy((IntPtr)obj);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glDeleteProgramPipelines</c>]</b><br/> Delete program pipeline objects. </summary>
            /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
            /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void DeleteProgramPipelines(int n, int* pipelines) => GLPointers.glDeleteProgramPipelines_Lazy(n, pipelines);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glDeleteProgramsARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void DeleteProgramsARB(int n, int* programs) => GLPointers.glDeleteProgramsARB_Lazy(n, programs);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glDeleteQueriesARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_occlusion_query.txt"/></remarks>
            public static void DeleteQueriesARB(int n, int* ids) => GLPointers.glDeleteQueriesARB_Lazy(n, ids);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glDeleteRenderbuffers</c>]</b><br/> Delete renderbuffer objects. </summary>
            /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
            /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void DeleteRenderbuffers(int n, int* renderbuffers) => GLPointers.glDeleteRenderbuffers_Lazy(n, renderbuffers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glDeleteSamplers</c>]</b><br/> Delete named sampler objects. </summary>
            /// <param name="count"> Specifies the number of sampler objects to be deleted. </param>
            /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void DeleteSamplers(int count, int* samplers) => GLPointers.glDeleteSamplers_Lazy(count, samplers);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glDeleteSync</c>]</b><br/> Delete a sync object. </summary>
            /// <param name="sync"> The sync object to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
            public static void DeleteSync(GLSync sync) => GLPointers.glDeleteSync_Lazy((IntPtr)sync);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glDeleteTransformFeedbacks</c>]</b><br/> Delete transform feedback objects. </summary>
            /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
            /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
            public static void DeleteTransformFeedbacks(int n, int* ids) => GLPointers.glDeleteTransformFeedbacks_Lazy(n, ids);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glDeleteVertexArrays</c>]</b><br/> Delete vertex array objects. </summary>
            /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
            /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_array_object.txt"/></remarks>
            public static void DeleteVertexArrays(int n, int* arrays) => GLPointers.glDeleteVertexArrays_Lazy(n, arrays);
            
            /// <summary> <b>[requires: GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeArraydvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void DepthRangeArraydvNV(uint first, int count, double* v) => GLPointers.glDepthRangeArraydvNV_Lazy(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeArrayv</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
            /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
            /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void DepthRangeArrayv(uint first, int count, double* v) => GLPointers.glDepthRangeArrayv_Lazy(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glDepthRangef</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
            /// <param name="n"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="f"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
            public static void DepthRangef(float n, float f) => GLPointers.glDepthRangef_Lazy(n, f);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeIndexed</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
            /// <param name="n"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="f"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void DepthRangeIndexed(uint index, double n, double f) => GLPointers.glDepthRangeIndexed_Lazy(index, n, f);
            
            /// <summary> <b>[requires: GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeIndexeddNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void DepthRangeIndexeddNV(uint index, double n, double f) => GLPointers.glDepthRangeIndexeddNV_Lazy(index, n, f);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glDetachObjectARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void DetachObjectARB(GLHandleARB containerObj, GLHandleARB attachedObj) => GLPointers.glDetachObjectARB_Lazy((IntPtr)containerObj, (IntPtr)attachedObj);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glDisableVertexArrayAttrib</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void DisableVertexArrayAttrib(int vaobj, uint index) => GLPointers.glDisableVertexArrayAttrib_Lazy(vaobj, index);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glDisableVertexAttribArrayARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void DisableVertexAttribArrayARB(uint index) => GLPointers.glDisableVertexAttribArrayARB_Lazy(index);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> <b>[entry point: <c>glDispatchCompute</c>]</b><br/> Launch one or more compute work groups. </summary>
            /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
            /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
            /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_compute_shader.txt"/></remarks>
            public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => GLPointers.glDispatchCompute_Lazy(num_groups_x, num_groups_y, num_groups_z);
            
            /// <summary> <b>[requires: GL_ARB_compute_variable_group_size]</b> <b>[entry point: <c>glDispatchComputeGroupSizeARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_compute_variable_group_size.txt"/></remarks>
            public static void DispatchComputeGroupSizeARB(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z) => GLPointers.glDispatchComputeGroupSizeARB_Lazy(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> <b>[entry point: <c>glDispatchComputeIndirect</c>]</b><br/> Launch one or more compute work groups using parameters stored in a buffer. </summary>
            /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_compute_shader.txt"/></remarks>
            public static void DispatchComputeIndirect(IntPtr indirect) => GLPointers.glDispatchComputeIndirect_Lazy(indirect);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> <b>[entry point: <c>glDrawArraysIndirect</c>]</b><br/> Render primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_indirect.txt"/></remarks>
            public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => GLPointers.glDrawArraysIndirect_Lazy((uint)mode, indirect);
            
            /// <summary> <b>[requires: GL_ARB_draw_instanced]</b> <b>[entry point: <c>glDrawArraysInstancedARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_instanced.txt"/></remarks>
            public static void DrawArraysInstancedARB(PrimitiveType mode, int first, int count, int primcount) => GLPointers.glDrawArraysInstancedARB_Lazy((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawArraysInstancedBaseInstance</c>]</b><br/> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
            /// <param name="count"> Specifies the number of indices to be rendered. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_base_instance.txt"/></remarks>
            public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => GLPointers.glDrawArraysInstancedBaseInstance_Lazy((uint)mode, first, count, instancecount, baseinstance);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers]</b> <b>[entry point: <c>glDrawBuffersARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_buffers.txt"/></remarks>
            public static void DrawBuffersARB(int n, DrawBufferMode* bufs) => GLPointers.glDrawBuffersARB_Lazy(n, (uint*)bufs);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawElementsBaseVertex</c>]</b><br/> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_elements_base_vertex.txt"/></remarks>
            public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers.glDrawElementsBaseVertex_Lazy((uint)mode, count, (uint)type, indices, basevertex);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> <b>[entry point: <c>glDrawElementsIndirect</c>]</b><br/> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_indirect.txt"/></remarks>
            public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => GLPointers.glDrawElementsIndirect_Lazy((uint)mode, (uint)type, indirect);
            
            /// <summary> <b>[requires: GL_ARB_draw_instanced]</b> <b>[entry point: <c>glDrawElementsInstancedARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_instanced.txt"/></remarks>
            public static void DrawElementsInstancedARB(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => GLPointers.glDrawElementsInstancedARB_Lazy((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawElementsInstancedBaseInstance</c>]</b><br/> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_base_instance.txt"/></remarks>
            public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, uint baseinstance) => GLPointers.glDrawElementsInstancedBaseInstance_Lazy((uint)mode, count, (uint)type, indices, instancecount, baseinstance);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawElementsInstancedBaseVertex</c>]</b><br/> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_elements_base_vertex.txt"/></remarks>
            public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => GLPointers.glDrawElementsInstancedBaseVertex_Lazy((uint)mode, count, (uint)type, indices, instancecount, basevertex);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawElementsInstancedBaseVertexBaseInstance</c>]</b><br/> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_base_instance.txt"/></remarks>
            public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => GLPointers.glDrawElementsInstancedBaseVertexBaseInstance_Lazy((uint)mode, count, (uint)type, indices, instancecount, basevertex, baseinstance);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawRangeElementsBaseVertex</c>]</b><br/> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="start"> Specifies the minimum array index contained in indices. </param>
            /// <param name="end"> Specifies the maximum array index contained in indices. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_elements_base_vertex.txt"/></remarks>
            public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers.glDrawRangeElementsBaseVertex_Lazy((uint)mode, start, end, count, (uint)type, indices, basevertex);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glDrawTransformFeedback</c>]</b><br/> Render primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
            public static void DrawTransformFeedback(PrimitiveType mode, int id) => GLPointers.glDrawTransformFeedback_Lazy((uint)mode, id);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> <b>[entry point: <c>glDrawTransformFeedbackInstanced</c>]</b><br/> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback_instanced.txt"/></remarks>
            public static void DrawTransformFeedbackInstanced(PrimitiveType mode, int id, int instancecount) => GLPointers.glDrawTransformFeedbackInstanced_Lazy((uint)mode, id, instancecount);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glDrawTransformFeedbackStream</c>]</b><br/> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback3.txt"/></remarks>
            public static void DrawTransformFeedbackStream(PrimitiveType mode, int id, uint stream) => GLPointers.glDrawTransformFeedbackStream_Lazy((uint)mode, id, stream);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> <b>[entry point: <c>glDrawTransformFeedbackStreamInstanced</c>]</b><br/> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback_instanced.txt"/></remarks>
            public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, int id, uint stream, int instancecount) => GLPointers.glDrawTransformFeedbackStreamInstanced_Lazy((uint)mode, id, stream, instancecount);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glEnableVertexArrayAttrib</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void EnableVertexArrayAttrib(int vaobj, uint index) => GLPointers.glEnableVertexArrayAttrib_Lazy(vaobj, index);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glEnableVertexAttribArrayARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void EnableVertexAttribArrayARB(uint index) => GLPointers.glEnableVertexAttribArrayARB_Lazy(index);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glEndQueryARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_occlusion_query.txt"/></remarks>
            public static void EndQueryARB(QueryTarget target) => GLPointers.glEndQueryARB_Lazy((uint)target);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glEndQueryIndexed</c>]</b><br/> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback3.txt"/></remarks>
            public static void EndQueryIndexed(QueryTarget target, uint index) => GLPointers.glEndQueryIndexed_Lazy((uint)target, index);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b> <b>[entry point: <c>glEvaluateDepthValuesARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sample_locations.txt"/></remarks>
            public static void EvaluateDepthValuesARB() => GLPointers.glEvaluateDepthValuesARB_Lazy();
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glFenceSync</c>]</b><br/> Create a new sync object and insert it into the GL command stream. </summary>
            /// <param name="condition"> Specifies the condition that must be met to set the sync object&apos;s state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
            /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
            public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) GLPointers.glFenceSync_Lazy((uint)condition, (uint)flags);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> <b>[entry point: <c>glFlushMappedBufferRange</c>]</b><br/> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_map_buffer_range.txt"/></remarks>
            public static void FlushMappedBufferRange(BufferTarget target, IntPtr offset, nint length) => GLPointers.glFlushMappedBufferRange_Lazy((uint)target, offset, length);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glFlushMappedNamedBufferRange</c>]</b><br/> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void FlushMappedNamedBufferRange(int buffer, IntPtr offset, nint length) => GLPointers.glFlushMappedNamedBufferRange_Lazy(buffer, offset, length);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> <b>[entry point: <c>glFramebufferParameteri</c>]</b><br/> Set a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_no_attachments.txt"/></remarks>
            public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers.glFramebufferParameteri_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferRenderbuffer</c>]</b><br/> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers.glFramebufferRenderbuffer_Lazy((uint)target, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b> <b>[entry point: <c>glFramebufferSampleLocationsfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sample_locations.txt"/></remarks>
            public static void FramebufferSampleLocationsfvARB(FramebufferTarget target, uint start, int count, float* v) => GLPointers.glFramebufferSampleLocationsfvARB_Lazy((uint)target, start, count, v);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture1D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers.glFramebufferTexture1D_Lazy((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture2D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers.glFramebufferTexture2D_Lazy((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture3D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="zoffset">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers.glFramebufferTexture3D_Lazy((uint)target, (uint)attachment, (uint)textarget, texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b> <b>[entry point: <c>glFramebufferTextureARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_geometry_shader4.txt"/></remarks>
            public static void FramebufferTextureARB(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level) => GLPointers.glFramebufferTextureARB_Lazy((uint)target, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b> <b>[entry point: <c>glFramebufferTextureFaceARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_geometry_shader4.txt"/></remarks>
            public static void FramebufferTextureFaceARB(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, TextureTarget face) => GLPointers.glFramebufferTextureFaceARB_Lazy((uint)target, (uint)attachment, texture, level, (uint)face);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTextureLayer</c>]</b><br/> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers.glFramebufferTextureLayer_Lazy((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b> <b>[entry point: <c>glFramebufferTextureLayerARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_geometry_shader4.txt"/></remarks>
            public static void FramebufferTextureLayerARB(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers.glFramebufferTextureLayerARB_Lazy((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glGenBuffersARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static void GenBuffersARB(int n, int* buffers) => GLPointers.glGenBuffersARB_Lazy(n, buffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenerateMipmap</c>]</b><br/> Generate mipmaps for a specified texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void GenerateMipmap(TextureTarget target) => GLPointers.glGenerateMipmap_Lazy((uint)target);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGenerateTextureMipmap</c>]</b><br/> Generate mipmaps for a specified texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GenerateTextureMipmap(int texture) => GLPointers.glGenerateTextureMipmap_Lazy(texture);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenFramebuffers</c>]</b><br/> Generate framebuffer object names. </summary>
            /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
            /// <param name="framebuffers"> Specifies an array in which the generated framebuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void GenFramebuffers(int n, int* framebuffers) => GLPointers.glGenFramebuffers_Lazy(n, framebuffers);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGenProgramPipelines</c>]</b><br/> Reserve program pipeline object names. </summary>
            /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
            /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void GenProgramPipelines(int n, int* pipelines) => GLPointers.glGenProgramPipelines_Lazy(n, pipelines);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGenProgramsARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void GenProgramsARB(int n, int* programs) => GLPointers.glGenProgramsARB_Lazy(n, programs);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glGenQueriesARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_occlusion_query.txt"/></remarks>
            public static void GenQueriesARB(int n, int* ids) => GLPointers.glGenQueriesARB_Lazy(n, ids);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenRenderbuffers</c>]</b><br/> Generate renderbuffer object names. </summary>
            /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
            /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void GenRenderbuffers(int n, int* renderbuffers) => GLPointers.glGenRenderbuffers_Lazy(n, renderbuffers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGenSamplers</c>]</b><br/> Generate sampler object names. </summary>
            /// <param name="count"> Specifies the number of sampler object names to generate. </param>
            /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void GenSamplers(int count, int* samplers) => GLPointers.glGenSamplers_Lazy(count, samplers);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glGenTransformFeedbacks</c>]</b><br/> Reserve transform feedback object names. </summary>
            /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
            /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
            public static void GenTransformFeedbacks(int n, int* ids) => GLPointers.glGenTransformFeedbacks_Lazy(n, ids);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glGenVertexArrays</c>]</b><br/> Generate vertex array object names. </summary>
            /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
            /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_array_object.txt"/></remarks>
            public static void GenVertexArrays(int n, int* arrays) => GLPointers.glGenVertexArrays_Lazy(n, arrays);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters]</b> <b>[entry point: <c>glGetActiveAtomicCounterBufferiv</c>]</b><br/> Retrieve information about the set of active atomic counter buffers for a program. </summary>
            /// <param name="program"> The name of a program object from which to retrieve information. </param>
            /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
            /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_atomic_counters.txt"/></remarks>
            public static void GetActiveAtomicCounterBufferiv(int program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => GLPointers.glGetActiveAtomicCounterBufferiv_Lazy(program, bufferIndex, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetActiveAttribARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, AttributeType* type, byte* name) => GLPointers.glGetActiveAttribARB_Lazy((IntPtr)programObj, index, maxLength, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineName</c>]</b><br/> Query the name of an active shader subroutine. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
            /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
            public static void GetActiveSubroutineName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers.glGetActiveSubroutineName_Lazy(program, (uint)shadertype, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineUniformiv</c>]</b><br/> Query a property of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
            /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
            public static void GetActiveSubroutineUniformiv(int program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => GLPointers.glGetActiveSubroutineUniformiv_Lazy(program, (uint)shadertype, index, (uint)pname, values);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineUniformName</c>]</b><br/> Query the name of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
            /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
            public static void GetActiveSubroutineUniformName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers.glGetActiveSubroutineUniformName_Lazy(program, (uint)shadertype, index, bufSize, length, name);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetActiveUniformARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, UniformType* type, byte* name) => GLPointers.glGetActiveUniformARB_Lazy((IntPtr)programObj, index, maxLength, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformBlockiv</c>]</b><br/> Query information about an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="pname"> Specifies the name of the parameter to query. </param>
            /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static void GetActiveUniformBlockiv(int program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => GLPointers.glGetActiveUniformBlockiv_Lazy(program, uniformBlockIndex, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformBlockName</c>]</b><br/> Retrieve the name of an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static void GetActiveUniformBlockName(int program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => GLPointers.glGetActiveUniformBlockName_Lazy(program, uniformBlockIndex, bufSize, length, uniformBlockName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformName</c>]</b><br/> Query the name of an active uniform. </summary>
            /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
            /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
            /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
            /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
            /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static void GetActiveUniformName(int program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => GLPointers.glGetActiveUniformName_Lazy(program, uniformIndex, bufSize, length, uniformName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformsiv</c>]</b><br/> Returns information about several active uniform variables for the specified program object. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
            /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
            /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
            /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static void GetActiveUniformsiv(int program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => GLPointers.glGetActiveUniformsiv_Lazy(program, uniformCount, uniformIndices, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetAttachedObjectsARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void GetAttachedObjectsARB(GLHandleARB containerObj, int maxCount, int* count, GLHandleARB* obj) => GLPointers.glGetAttachedObjectsARB_Lazy((IntPtr)containerObj, maxCount, count, (IntPtr*)obj);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetAttribLocationARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static int GetAttribLocationARB(GLHandleARB programObj, byte* name) => GLPointers.glGetAttribLocationARB_Lazy((IntPtr)programObj, name);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glGetBufferParameterivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static void GetBufferParameterivARB(BufferTarget target, BufferPName pname, int* parameters) => GLPointers.glGetBufferParameterivARB_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glGetBufferPointervARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static void GetBufferPointervARB(BufferTarget target, BufferPointerNameARB pname, void** parameters) => GLPointers.glGetBufferPointervARB_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glGetBufferSubDataARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static void GetBufferSubDataARB(BufferTarget target, IntPtr offset, nint size, void* data) => GLPointers.glGetBufferSubDataARB_Lazy((uint)target, offset, size, data);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetColorTable</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetColorTable(ColorTableTarget target, PixelFormat format, PixelType type, void* table) => GLPointers.glGetColorTable_Lazy((uint)target, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetColorTableParameterfv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetColorTableParameterfv(ColorTableTarget target, ColorTableParameterPName pname, float* parameters) => GLPointers.glGetColorTableParameterfv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetColorTableParameteriv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetColorTableParameteriv(ColorTableTarget target, ColorTableParameterPName pname, int* parameters) => GLPointers.glGetColorTableParameteriv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glGetCompressedTexImageARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_compression.txt"/></remarks>
            public static void GetCompressedTexImageARB(TextureTarget target, int level, void* img) => GLPointers.glGetCompressedTexImageARB_Lazy((uint)target, level, img);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetCompressedTextureImage</c>]</b><br/> Return a compressed texture image. </summary>
            /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
            /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
            /// <param name="pixels">Returns the compressed texture image.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetCompressedTextureImage(int texture, int level, int bufSize, void* pixels) => GLPointers.glGetCompressedTextureImage_Lazy(texture, level, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> <b>[entry point: <c>glGetCompressedTextureSubImage</c>]</b><br/> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block&apos;s width, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block&apos;s height, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block&apos;s depth, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_texture_sub_image.txt"/></remarks>
            public static void GetCompressedTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => GLPointers.glGetCompressedTextureSubImage_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetConvolutionFilter</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, void* image) => GLPointers.glGetConvolutionFilter_Lazy((uint)target, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetConvolutionParameterfv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameter pname, float* parameters) => GLPointers.glGetConvolutionParameterfv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetConvolutionParameteriv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameter pname, int* parameters) => GLPointers.glGetConvolutionParameteriv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b> <b>[entry point: <c>glGetDebugMessageLogARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_debug_output.txt"/></remarks>
            public static uint GetDebugMessageLogARB(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers.glGetDebugMessageLogARB_Lazy(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glGetDoublei_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void GetDoublei_v(GetPName target, uint index, double* data) => GLPointers.glGetDoublei_v_Lazy((uint)target, index, data);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glGetFloati_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void GetFloati_v(GetPName target, uint index, float* data) => GLPointers.glGetFloati_v_Lazy((uint)target, index, data);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> <b>[entry point: <c>glGetFragDataIndex</c>]</b><br/> Query the bindings of color indices to user-defined varying out variables. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
            /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_blend_func_extended.txt"/></remarks>
            public static int GetFragDataIndex(int program, byte* name) => GLPointers.glGetFragDataIndex_Lazy(program, name);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGetFramebufferAttachmentParameteriv</c>]</b><br/> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers.glGetFramebufferAttachmentParameteriv_Lazy((uint)target, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> <b>[entry point: <c>glGetFramebufferParameteriv</c>]</b><br/> Query a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_no_attachments.txt"/></remarks>
            public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers.glGetFramebufferParameteriv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetGraphicsResetStatusARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatusARB() => (GraphicsResetStatus) GLPointers.glGetGraphicsResetStatusARB_Lazy();
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetHandleARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static GLHandleARB GetHandleARB(ContainerType pname) => (GLHandleARB) GLPointers.glGetHandleARB_Lazy((uint)pname);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetHistogram</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetHistogram(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers.glGetHistogram_Lazy((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetHistogramParameterfv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetHistogramParameterfv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters) => GLPointers.glGetHistogramParameterfv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetHistogramParameteriv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetHistogramParameteriv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers.glGetHistogramParameteriv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glGetImageHandleARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static ulong GetImageHandleARB(int texture, int level, bool layered, int layer, PixelFormat format) => GLPointers.glGetImageHandleARB_Lazy(texture, level, (byte)(layered ? 1 : 0), layer, (uint)format);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetInfoLogARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void GetInfoLogARB(GLHandleARB obj, int maxLength, int* length, byte* infoLog) => GLPointers.glGetInfoLogARB_Lazy((IntPtr)obj, maxLength, length, infoLog);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glGetInteger64v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
            /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
            public static void GetInteger64v(GetPName pname, long* data) => GLPointers.glGetInteger64v_Lazy((uint)pname, data);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetIntegeri_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static void GetIntegeri_v(GetPName target, uint index, int* data) => GLPointers.glGetIntegeri_v_Lazy((uint)target, index, data);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2]</b> <b>[entry point: <c>glGetInternalformati64v</c>]</b><br/> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="count"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_internalformat_query2.txt"/></remarks>
            public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => GLPointers.glGetInternalformati64v_Lazy((uint)target, (uint)internalformat, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query]</b> <b>[entry point: <c>glGetInternalformativ</c>]</b><br/> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="count"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_internalformat_query.txt"/></remarks>
            public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => GLPointers.glGetInternalformativ_Lazy((uint)target, (uint)internalformat, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetMinmax</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetMinmax(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers.glGetMinmax_Lazy((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetMinmaxParameterfv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetMinmaxParameterfv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters) => GLPointers.glGetMinmaxParameterfv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetMinmaxParameteriv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetMinmaxParameteriv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters) => GLPointers.glGetMinmaxParameteriv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glGetMultisamplefv</c>]</b><br/> Retrieve the location of a sample. </summary>
            /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
            /// <param name="index"> Specifies the index of the sample whose position to query. </param>
            /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_multisample.txt"/></remarks>
            public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers.glGetMultisamplefv_Lazy((uint)pname, index, val);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameteri64v</c>]</b><br/> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetNamedBufferParameteri64v(int buffer, BufferPName pname, long* parameters) => GLPointers.glGetNamedBufferParameteri64v_Lazy(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameteriv</c>]</b><br/> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetNamedBufferParameteriv(int buffer, BufferPName pname, int* parameters) => GLPointers.glGetNamedBufferParameteriv_Lazy(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferPointerv</c>]</b><br/> Return the pointer to a mapped buffer object&apos;s data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
            /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
            /// <param name="parameters"> Returns the pointer value specified by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetNamedBufferPointerv(int buffer, BufferPointerNameARB pname, void** parameters) => GLPointers.glGetNamedBufferPointerv_Lazy(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferSubData</c>]</b><br/> Returns a subset of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store from which data will be returned, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
            /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetNamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers.glGetNamedBufferSubData_Lazy(buffer, offset, size, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferAttachmentParameteriv</c>]</b><br/> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetNamedFramebufferAttachmentParameteriv(int framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers.glGetNamedFramebufferAttachmentParameteriv_Lazy(framebuffer, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferParameteriv</c>]</b><br/> Query a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="param">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetNamedFramebufferParameteriv(int framebuffer, GetFramebufferParameter pname, int* param) => GLPointers.glGetNamedFramebufferParameteriv_Lazy(framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedRenderbufferParameteriv</c>]</b><br/> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetNamedRenderbufferParameteriv(int renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers.glGetNamedRenderbufferParameteriv_Lazy(renderbuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glGetNamedStringARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shading_language_include.txt"/></remarks>
            public static void GetNamedStringARB(int namelen, byte* name, int bufSize, int* stringlen, byte* str) => GLPointers.glGetNamedStringARB_Lazy(namelen, name, bufSize, stringlen, str);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glGetNamedStringivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shading_language_include.txt"/></remarks>
            public static void GetNamedStringivARB(int namelen, byte* name, All pname, int* parameters) => GLPointers.glGetNamedStringivARB_Lazy(namelen, name, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnColorTableARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnColorTableARB(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, void* table) => GLPointers.glGetnColorTableARB_Lazy((uint)target, (uint)format, (uint)type, bufSize, table);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnCompressedTexImageARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnCompressedTexImageARB(TextureTarget target, int lod, int bufSize, void* img) => GLPointers.glGetnCompressedTexImageARB_Lazy((uint)target, lod, bufSize, img);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnConvolutionFilterARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnConvolutionFilterARB(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, void* image) => GLPointers.glGetnConvolutionFilterARB_Lazy((uint)target, (uint)format, (uint)type, bufSize, image);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnHistogramARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnHistogramARB(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers.glGetnHistogramARB_Lazy((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnMapdvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnMapdvARB(MapTarget target, MapQuery query, int bufSize, double* v) => GLPointers.glGetnMapdvARB_Lazy((uint)target, (uint)query, bufSize, v);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnMapfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnMapfvARB(MapTarget target, MapQuery query, int bufSize, float* v) => GLPointers.glGetnMapfvARB_Lazy((uint)target, (uint)query, bufSize, v);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnMapivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnMapivARB(MapTarget target, MapQuery query, int bufSize, int* v) => GLPointers.glGetnMapivARB_Lazy((uint)target, (uint)query, bufSize, v);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnMinmaxARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnMinmaxARB(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers.glGetnMinmaxARB_Lazy((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnPixelMapfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnPixelMapfvARB(PixelMap map, int bufSize, float* values) => GLPointers.glGetnPixelMapfvARB_Lazy((uint)map, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnPixelMapuivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnPixelMapuivARB(PixelMap map, int bufSize, uint* values) => GLPointers.glGetnPixelMapuivARB_Lazy((uint)map, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnPixelMapusvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnPixelMapusvARB(PixelMap map, int bufSize, ushort* values) => GLPointers.glGetnPixelMapusvARB_Lazy((uint)map, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnPolygonStippleARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnPolygonStippleARB(int bufSize, byte* pattern) => GLPointers.glGetnPolygonStippleARB_Lazy(bufSize, pattern);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnSeparableFilterARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnSeparableFilterARB(SeparableTargetEXT target, PixelFormat format, PixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span) => GLPointers.glGetnSeparableFilterARB_Lazy((uint)target, (uint)format, (uint)type, rowBufSize, row, columnBufSize, column, span);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnTexImageARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnTexImageARB(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* img) => GLPointers.glGetnTexImageARB_Lazy((uint)target, level, (uint)format, (uint)type, bufSize, img);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnUniformdvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnUniformdvARB(int program, int location, int bufSize, double* parameters) => GLPointers.glGetnUniformdvARB_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnUniformfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnUniformfvARB(int program, int location, int bufSize, float* parameters) => GLPointers.glGetnUniformfvARB_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glGetnUniformi64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void GetnUniformi64vARB(int program, int location, int bufSize, long* parameters) => GLPointers.glGetnUniformi64vARB_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnUniformivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnUniformivARB(int program, int location, int bufSize, int* parameters) => GLPointers.glGetnUniformivARB_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glGetnUniformui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void GetnUniformui64vARB(int program, int location, int bufSize, ulong* parameters) => GLPointers.glGetnUniformui64vARB_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnUniformuivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void GetnUniformuivARB(int program, int location, int bufSize, uint* parameters) => GLPointers.glGetnUniformuivARB_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetObjectParameterfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void GetObjectParameterfvARB(GLHandleARB obj, All pname, float* parameters) => GLPointers.glGetObjectParameterfvARB_Lazy((IntPtr)obj, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetObjectParameterivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void GetObjectParameterivARB(GLHandleARB obj, All pname, int* parameters) => GLPointers.glGetObjectParameterivARB_Lazy((IntPtr)obj, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> <b>[entry point: <c>glGetProgramBinary</c>]</b><br/> Return a binary representation of a program object&apos;s compiled and linked executable source. </summary>
            /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
            /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
            /// <param name="binary"> Specifies the address an array into which the GL will return program&apos;s binary representation. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_program_binary.txt"/></remarks>
            public static void GetProgramBinary(int program, int bufSize, int* length, All* binaryFormat, void* binary) => GLPointers.glGetProgramBinary_Lazy(program, bufSize, length, (uint*)binaryFormat, binary);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramEnvParameterdvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, double* parameters) => GLPointers.glGetProgramEnvParameterdvARB_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramEnvParameterfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, float* parameters) => GLPointers.glGetProgramEnvParameterfvARB_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramInterfaceiv</c>]</b><br/> Query a property of an interface in a program. </summary>
            /// <param name="program"> The name of a program object whose interface to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program to query. </param>
            /// <param name="pname"> The name of the parameter within programInterface to query. </param>
            /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
            public static void GetProgramInterfaceiv(int program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => GLPointers.glGetProgramInterfaceiv_Lazy(program, (uint)programInterface, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void GetProgramivARB(ProgramTarget target, ProgramProperty pname, int* parameters) => GLPointers.glGetProgramivARB_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramLocalParameterdvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, double* parameters) => GLPointers.glGetProgramLocalParameterdvARB_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramLocalParameterfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, float* parameters) => GLPointers.glGetProgramLocalParameterfvARB_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineInfoLog</c>]</b><br/> Retrieve the info log string from a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
            /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
            /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
            /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void GetProgramPipelineInfoLog(int pipeline, int bufSize, int* length, byte* infoLog) => GLPointers.glGetProgramPipelineInfoLog_Lazy(pipeline, bufSize, length, infoLog);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineiv</c>]</b><br/> Retrieve properties of a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
            /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void GetProgramPipelineiv(int pipeline, PipelineParameterName pname, int* parameters) => GLPointers.glGetProgramPipelineiv_Lazy(pipeline, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceIndex</c>]</b><br/> Query the index of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the index of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
            public static uint GetProgramResourceIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers.glGetProgramResourceIndex_Lazy(program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceiv</c>]</b><br/> Retrieve values for multiple properties of a single active resource within a program object. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="index">!!missing documentation!!</param>
            /// <param name="propCount">!!missing documentation!!</param>
            /// <param name="props">!!missing documentation!!</param>
            /// <param name="count">!!missing documentation!!</param>
            /// <param name="length">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
            public static void GetProgramResourceiv(int program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => GLPointers.glGetProgramResourceiv_Lazy(program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceLocation</c>]</b><br/> Query the location of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
            public static int GetProgramResourceLocation(int program, ProgramInterface programInterface, byte* name) => GLPointers.glGetProgramResourceLocation_Lazy(program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceLocationIndex</c>]</b><br/> Query the fragment color index of a named variable within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
            public static int GetProgramResourceLocationIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers.glGetProgramResourceLocationIndex_Lazy(program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceName</c>]</b><br/> Query the name of an indexed resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
            /// <param name="index"> The index of the resource within programInterface of program. </param>
            /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
            /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
            /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_program_interface_query.txt"/></remarks>
            public static void GetProgramResourceName(int program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => GLPointers.glGetProgramResourceName_Lazy(program, (uint)programInterface, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetProgramStageiv</c>]</b><br/> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
            /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
            public static void GetProgramStageiv(int program, ShaderType shadertype, ProgramStagePName pname, int* values) => GLPointers.glGetProgramStageiv_Lazy(program, (uint)shadertype, (uint)pname, values);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramStringARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void GetProgramStringARB(ProgramTarget target, ProgramStringProperty pname, void* str) => GLPointers.glGetProgramStringARB_Lazy((uint)target, (uint)pname, str);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjecti64v</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetQueryBufferObjecti64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers.glGetQueryBufferObjecti64v_Lazy(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectiv</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetQueryBufferObjectiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers.glGetQueryBufferObjectiv_Lazy(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectui64v</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetQueryBufferObjectui64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers.glGetQueryBufferObjectui64v_Lazy(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectuiv</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetQueryBufferObjectuiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers.glGetQueryBufferObjectuiv_Lazy(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glGetQueryIndexediv</c>]</b><br/> Return parameters of an indexed query object target. </summary>
            /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
            /// <param name="index"> Specifies the index of the query object target. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
            /// <param name="parameters"> Returns the requested data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback3.txt"/></remarks>
            public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => GLPointers.glGetQueryIndexediv_Lazy((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glGetQueryivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_occlusion_query.txt"/></remarks>
            public static void GetQueryivARB(QueryTarget target, QueryParameterName pname, int* parameters) => GLPointers.glGetQueryivARB_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glGetQueryObjecti64v</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_timer_query.txt"/></remarks>
            public static void GetQueryObjecti64v(int id, QueryObjectParameterName pname, long* parameters) => GLPointers.glGetQueryObjecti64v_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glGetQueryObjectivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_occlusion_query.txt"/></remarks>
            public static void GetQueryObjectivARB(int id, QueryObjectParameterName pname, int* parameters) => GLPointers.glGetQueryObjectivARB_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glGetQueryObjectui64v</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_timer_query.txt"/></remarks>
            public static void GetQueryObjectui64v(int id, QueryObjectParameterName pname, ulong* parameters) => GLPointers.glGetQueryObjectui64v_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glGetQueryObjectuivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_occlusion_query.txt"/></remarks>
            public static void GetQueryObjectuivARB(int id, QueryObjectParameterName pname, uint* parameters) => GLPointers.glGetQueryObjectuivARB_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGetRenderbufferParameteriv</c>]</b><br/> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers.glGetRenderbufferParameteriv_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterfv</c>]</b><br/> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void GetSamplerParameterfv(int sampler, SamplerParameterF pname, float* parameters) => GLPointers.glGetSamplerParameterfv_Lazy(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterIiv</c>]</b><br/> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void GetSamplerParameterIiv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers.glGetSamplerParameterIiv_Lazy(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterIuiv</c>]</b><br/> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void GetSamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* parameters) => GLPointers.glGetSamplerParameterIuiv_Lazy(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameteriv</c>]</b><br/> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void GetSamplerParameteriv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers.glGetSamplerParameteriv_Lazy(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetSeparableFilter</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void GetSeparableFilter(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span) => GLPointers.glGetSeparableFilter_Lazy((uint)target, (uint)format, (uint)type, row, column, span);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glGetShaderPrecisionFormat</c>]</b><br/> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
            /// <param name="shadertype"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="precisiontype"> Specifies the numeric format whose precision and range to query. </param>
            /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation&apos;s numeric range are returned. </param>
            /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
            public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => GLPointers.glGetShaderPrecisionFormat_Lazy((uint)shadertype, (uint)precisiontype, range, precision);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetShaderSourceARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void GetShaderSourceARB(GLHandleARB obj, int maxLength, int* length, byte* source) => GLPointers.glGetShaderSourceARB_Lazy((IntPtr)obj, maxLength, length, source);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetSubroutineIndex</c>]</b><br/> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
            public static uint GetSubroutineIndex(int program, ShaderType shadertype, byte* name) => GLPointers.glGetSubroutineIndex_Lazy(program, (uint)shadertype, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetSubroutineUniformLocation</c>]</b><br/> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
            public static int GetSubroutineUniformLocation(int program, ShaderType shadertype, byte* name) => GLPointers.glGetSubroutineUniformLocation_Lazy(program, (uint)shadertype, name);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glGetSynciv</c>]</b><br/> Query the properties of a sync object. </summary>
            /// <param name="sync"> Specifies the sync object whose properties to query. </param>
            /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
            /// <param name="count"> Specifies the size of the buffer whose address is given in values. </param>
            /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
            /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
            public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => GLPointers.glGetSynciv_Lazy((IntPtr)sync, (uint)pname, count, length, values);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glGetTextureHandleARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static ulong GetTextureHandleARB(int texture) => GLPointers.glGetTextureHandleARB_Lazy(texture);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureImage</c>]</b><br/> Return a texture image. </summary>
            /// <param name="texture"> Specifies the texture object name. </param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
            /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
            /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTextureImage(int texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers.glGetTextureImage_Lazy(texture, level, (uint)format, (uint)type, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameterfv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTextureLevelParameterfv(int texture, int level, GetTextureParameter pname, float* parameters) => GLPointers.glGetTextureLevelParameterfv_Lazy(texture, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameteriv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTextureLevelParameteriv(int texture, int level, GetTextureParameter pname, int* parameters) => GLPointers.glGetTextureLevelParameteriv_Lazy(texture, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterfv</c>]</b><br/> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTextureParameterfv(int texture, GetTextureParameter pname, float* parameters) => GLPointers.glGetTextureParameterfv_Lazy(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIiv</c>]</b><br/> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTextureParameterIiv(int texture, GetTextureParameter pname, int* parameters) => GLPointers.glGetTextureParameterIiv_Lazy(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIuiv</c>]</b><br/> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTextureParameterIuiv(int texture, GetTextureParameter pname, uint* parameters) => GLPointers.glGetTextureParameterIuiv_Lazy(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameteriv</c>]</b><br/> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTextureParameteriv(int texture, GetTextureParameter pname, int* parameters) => GLPointers.glGetTextureParameteriv_Lazy(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glGetTextureSamplerHandleARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static ulong GetTextureSamplerHandleARB(int texture, int sampler) => GLPointers.glGetTextureSamplerHandleARB_Lazy(texture, sampler);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> <b>[entry point: <c>glGetTextureSubImage</c>]</b><br/> Retrieve a sub-region of a texture image from a texture    object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
            /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_texture_sub_image.txt"/></remarks>
            public static void GetTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers.glGetTextureSubImage_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbacki_v</c>]</b><br/> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTransformFeedbacki_v(int xfb, TransformFeedbackPName pname, uint index, int* param) => GLPointers.glGetTransformFeedbacki_v_Lazy(xfb, (uint)pname, index, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbacki64_v</c>]</b><br/> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTransformFeedbacki64_v(int xfb, TransformFeedbackPName pname, uint index, long* param) => GLPointers.glGetTransformFeedbacki64_v_Lazy(xfb, (uint)pname, index, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbackiv</c>]</b><br/> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetTransformFeedbackiv(int xfb, TransformFeedbackPName pname, int* param) => GLPointers.glGetTransformFeedbackiv_Lazy(xfb, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetUniformBlockIndex</c>]</b><br/> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static uint GetUniformBlockIndex(int program, byte* uniformBlockName) => GLPointers.glGetUniformBlockIndex_Lazy(program, uniformBlockName);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glGetUniformdv</c>]</b><br/> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void GetUniformdv(int program, int location, double* parameters) => GLPointers.glGetUniformdv_Lazy(program, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetUniformfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void GetUniformfvARB(GLHandleARB programObj, int location, float* parameters) => GLPointers.glGetUniformfvARB_Lazy((IntPtr)programObj, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glGetUniformi64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void GetUniformi64vARB(int program, int location, long* parameters) => GLPointers.glGetUniformi64vARB_Lazy(program, location, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetUniformIndices</c>]</b><br/> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
            /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
            /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
            /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static void GetUniformIndices(int program, int uniformCount, byte** uniformNames, uint* uniformIndices) => GLPointers.glGetUniformIndices_Lazy(program, uniformCount, uniformNames, uniformIndices);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetUniformivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void GetUniformivARB(GLHandleARB programObj, int location, int* parameters) => GLPointers.glGetUniformivARB_Lazy((IntPtr)programObj, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetUniformLocationARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static int GetUniformLocationARB(GLHandleARB programObj, byte* name) => GLPointers.glGetUniformLocationARB_Lazy((IntPtr)programObj, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetUniformSubroutineuiv</c>]</b><br/> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="location"> Specifies the location of the subroutine uniform. </param>
            /// <param name="parameters"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
            public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => GLPointers.glGetUniformSubroutineuiv_Lazy((uint)shadertype, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glGetUniformui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void GetUniformui64vARB(int program, int location, ulong* parameters) => GLPointers.glGetUniformui64vARB_Lazy(program, location, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIndexed64iv</c>]</b><br/> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetVertexArrayIndexed64iv(int vaobj, uint index, VertexArrayPName pname, long* param) => GLPointers.glGetVertexArrayIndexed64iv_Lazy(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIndexediv</c>]</b><br/> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetVertexArrayIndexediv(int vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers.glGetVertexArrayIndexediv_Lazy(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayiv</c>]</b><br/> Retrieve parameters of a vertex array object. </summary>
            /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
            /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void GetVertexArrayiv(int vaobj, VertexArrayPName pname, int* param) => GLPointers.glGetVertexArrayiv_Lazy(vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetVertexAttribdvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, double* parameters) => GLPointers.glGetVertexAttribdvARB_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetVertexAttribfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, float* parameters) => GLPointers.glGetVertexAttribfvARB_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetVertexAttribivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, int* parameters) => GLPointers.glGetVertexAttribivARB_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glGetVertexAttribLdv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
            /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
            /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => GLPointers.glGetVertexAttribLdv_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glGetVertexAttribLui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void GetVertexAttribLui64vARB(uint index, VertexAttribEnum pname, ulong* parameters) => GLPointers.glGetVertexAttribLui64vARB_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetVertexAttribPointervARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void GetVertexAttribPointervARB(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => GLPointers.glGetVertexAttribPointervARB_Lazy(index, (uint)pname, pointer);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glHistogram</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void Histogram(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink) => GLPointers.glHistogram_Lazy((uint)target, width, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateBufferData</c>]</b><br/> Invalidate the content of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
            public static void InvalidateBufferData(int buffer) => GLPointers.glInvalidateBufferData_Lazy(buffer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateBufferSubData</c>]</b><br/> Invalidate a region of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
            /// <param name="offset"> The offset within the buffer&apos;s data store of the start of the range to be invalidated. </param>
            /// <param name="length"> The length of the range within the buffer&apos;s data store to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
            public static void InvalidateBufferSubData(int buffer, IntPtr offset, nint length) => GLPointers.glInvalidateBufferSubData_Lazy(buffer, offset, length);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateFramebuffer</c>]</b><br/> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
            public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => GLPointers.glInvalidateFramebuffer_Lazy((uint)target, numAttachments, (uint*)attachments);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glInvalidateNamedFramebufferData</c>]</b><br/> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void InvalidateNamedFramebufferData(int framebuffer, int numAttachments, FramebufferAttachment* attachments) => GLPointers.glInvalidateNamedFramebufferData_Lazy(framebuffer, numAttachments, (uint*)attachments);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glInvalidateNamedFramebufferSubData</c>]</b><br/> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void InvalidateNamedFramebufferSubData(int framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers.glInvalidateNamedFramebufferSubData_Lazy(framebuffer, numAttachments, (uint*)attachments, x, y, width, height);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateSubFramebuffer</c>]</b><br/> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
            public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers.glInvalidateSubFramebuffer_Lazy((uint)target, numAttachments, (uint*)attachments, x, y, width, height);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateTexImage</c>]</b><br/> Invalidate the entirety a texture image. </summary>
            /// <param name="texture"> The name of a texture object to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
            public static void InvalidateTexImage(int texture, int level) => GLPointers.glInvalidateTexImage_Lazy(texture, level);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateTexSubImage</c>]</b><br/> Invalidate a region of a texture image. </summary>
            /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
            /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
            /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
            /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
            /// <param name="width"> The width of the region to be invalidated. </param>
            /// <param name="height"> The height of the region to be invalidated. </param>
            /// <param name="depth"> The depth of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_invalidate_subdata.txt"/></remarks>
            public static void InvalidateTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => GLPointers.glInvalidateTexSubImage_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glIsBufferARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static bool IsBufferARB(int buffer) => GLPointers.glIsBufferARB_Lazy(buffer) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glIsFramebuffer</c>]</b><br/> Determine if a name corresponds to a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static bool IsFramebuffer(int framebuffer) => GLPointers.glIsFramebuffer_Lazy(framebuffer) != 0;
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glIsImageHandleResidentARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static bool IsImageHandleResidentARB(ulong handle) => GLPointers.glIsImageHandleResidentARB_Lazy(handle) != 0;
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glIsNamedStringARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shading_language_include.txt"/></remarks>
            public static bool IsNamedStringARB(int namelen, byte* name) => GLPointers.glIsNamedStringARB_Lazy(namelen, name) != 0;
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glIsProgramARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static bool IsProgramARB(int program) => GLPointers.glIsProgramARB_Lazy(program) != 0;
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glIsProgramPipeline</c>]</b><br/> Determine if a name corresponds to a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static bool IsProgramPipeline(int pipeline) => GLPointers.glIsProgramPipeline_Lazy(pipeline) != 0;
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glIsQueryARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_occlusion_query.txt"/></remarks>
            public static bool IsQueryARB(int id) => GLPointers.glIsQueryARB_Lazy(id) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glIsRenderbuffer</c>]</b><br/> Determine if a name corresponds to a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static bool IsRenderbuffer(int renderbuffer) => GLPointers.glIsRenderbuffer_Lazy(renderbuffer) != 0;
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glIsSampler</c>]</b><br/> Determine if a name corresponds to a sampler object. </summary>
            /// <param name="sampler"> Specifies a value that may be the name of a sampler object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static bool IsSampler(int sampler) => GLPointers.glIsSampler_Lazy(sampler) != 0;
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glIsSync</c>]</b><br/> Determine if a name corresponds to a sync object. </summary>
            /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
            public static bool IsSync(GLSync sync) => GLPointers.glIsSync_Lazy((IntPtr)sync) != 0;
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glIsTextureHandleResidentARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static bool IsTextureHandleResidentARB(ulong handle) => GLPointers.glIsTextureHandleResidentARB_Lazy(handle) != 0;
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glIsTransformFeedback</c>]</b><br/> Determine if a name corresponds to a transform feedback object. </summary>
            /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
            public static bool IsTransformFeedback(int id) => GLPointers.glIsTransformFeedback_Lazy(id) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glIsVertexArray</c>]</b><br/> Determine if a name corresponds to a vertex array object. </summary>
            /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_array_object.txt"/></remarks>
            public static bool IsVertexArray(int array) => GLPointers.glIsVertexArray_Lazy(array) != 0;
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glLinkProgramARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void LinkProgramARB(GLHandleARB programObj) => GLPointers.glLinkProgramARB_Lazy((IntPtr)programObj);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b> <b>[entry point: <c>glLoadTransposeMatrixdARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transpose_matrix.txt"/></remarks>
            public static void LoadTransposeMatrixdARB(double* m) => GLPointers.glLoadTransposeMatrixdARB_Lazy(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b> <b>[entry point: <c>glLoadTransposeMatrixfARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transpose_matrix.txt"/></remarks>
            public static void LoadTransposeMatrixfARB(float* m) => GLPointers.glLoadTransposeMatrixfARB_Lazy(m);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glMakeImageHandleNonResidentARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void MakeImageHandleNonResidentARB(ulong handle) => GLPointers.glMakeImageHandleNonResidentARB_Lazy(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glMakeImageHandleResidentARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void MakeImageHandleResidentARB(ulong handle, All access) => GLPointers.glMakeImageHandleResidentARB_Lazy(handle, (uint)access);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glMakeTextureHandleNonResidentARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void MakeTextureHandleNonResidentARB(ulong handle) => GLPointers.glMakeTextureHandleNonResidentARB_Lazy(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glMakeTextureHandleResidentARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void MakeTextureHandleResidentARB(ulong handle) => GLPointers.glMakeTextureHandleResidentARB_Lazy(handle);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glMapBufferARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static void* MapBufferARB(BufferTarget target, BufferAccess access) => GLPointers.glMapBufferARB_Lazy((uint)target, (uint)access);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> <b>[entry point: <c>glMapBufferRange</c>]</b><br/> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_map_buffer_range.txt"/></remarks>
            public static void* MapBufferRange(BufferTarget target, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers.glMapBufferRange_Lazy((uint)target, offset, length, (uint)access);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glMapNamedBuffer</c>]</b><br/> Map all of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
            /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object&apos;s mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void* MapNamedBuffer(int buffer, BufferAccess access) => GLPointers.glMapNamedBuffer_Lazy(buffer, (uint)access);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glMapNamedBufferRange</c>]</b><br/> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void* MapNamedBufferRange(int buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers.glMapNamedBufferRange_Lazy(buffer, offset, length, (uint)access);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glMatrixIndexPointerARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_matrix_palette.txt"/></remarks>
            public static void MatrixIndexPointerARB(int size, MatrixIndexPointerTypeARB type, int stride, void* pointer) => GLPointers.glMatrixIndexPointerARB_Lazy(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glMatrixIndexubvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_matrix_palette.txt"/></remarks>
            public static void MatrixIndexubvARB(int size, byte* indices) => GLPointers.glMatrixIndexubvARB_Lazy(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glMatrixIndexuivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_matrix_palette.txt"/></remarks>
            public static void MatrixIndexuivARB(int size, uint* indices) => GLPointers.glMatrixIndexuivARB_Lazy(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glMatrixIndexusvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_matrix_palette.txt"/></remarks>
            public static void MatrixIndexusvARB(int size, ushort* indices) => GLPointers.glMatrixIndexusvARB_Lazy(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_parallel_shader_compile]</b> <b>[entry point: <c>glMaxShaderCompilerThreadsARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_parallel_shader_compile.txt"/></remarks>
            public static void MaxShaderCompilerThreadsARB(uint count) => GLPointers.glMaxShaderCompilerThreadsARB_Lazy(count);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> <b>[entry point: <c>glMemoryBarrier</c>]</b><br/> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_image_load_store.txt"/></remarks>
            public static void MemoryBarrier(MemoryBarrierMask barriers) => GLPointers.glMemoryBarrier_Lazy((uint)barriers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility]</b> <b>[entry point: <c>glMemoryBarrierByRegion</c>]</b><br/> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES3_1_compatibility.txt"/></remarks>
            public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => GLPointers.glMemoryBarrierByRegion_Lazy((uint)barriers);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glMinmax</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void Minmax(MinmaxTargetEXT target, InternalFormat internalformat, bool sink) => GLPointers.glMinmax_Lazy((uint)target, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sample_shading]</b> <b>[entry point: <c>glMinSampleShadingARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sample_shading.txt"/></remarks>
            public static void MinSampleShadingARB(float value) => GLPointers.glMinSampleShadingARB_Lazy(value);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawArraysIndirect</c>]</b><br/> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_draw_indirect.txt"/></remarks>
            public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => GLPointers.glMultiDrawArraysIndirect_Lazy((uint)mode, indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_indirect_parameters]</b> <b>[entry point: <c>glMultiDrawArraysIndirectCountARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_indirect_parameters.txt"/></remarks>
            public static void MultiDrawArraysIndirectCountARB(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers.glMultiDrawArraysIndirectCountARB_Lazy((uint)mode, indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glMultiDrawElementsBaseVertex</c>]</b><br/> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Points to an array of the elements counts. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
            /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_draw_elements_base_vertex.txt"/></remarks>
            public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => GLPointers.glMultiDrawElementsBaseVertex_Lazy((uint)mode, count, (uint)type, indices, drawcount, basevertex);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawElementsIndirect</c>]</b><br/> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_draw_indirect.txt"/></remarks>
            public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => GLPointers.glMultiDrawElementsIndirect_Lazy((uint)mode, (uint)type, indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_indirect_parameters]</b> <b>[entry point: <c>glMultiDrawElementsIndirectCountARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_indirect_parameters.txt"/></remarks>
            public static void MultiDrawElementsIndirectCountARB(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers.glMultiDrawElementsIndirectCountARB_Lazy((uint)mode, (uint)type, indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord1dARB(TextureUnit target, double s) => GLPointers.glMultiTexCoord1dARB_Lazy((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord1dvARB(TextureUnit target, double* v) => GLPointers.glMultiTexCoord1dvARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord1fARB(TextureUnit target, float s) => GLPointers.glMultiTexCoord1fARB_Lazy((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord1fvARB(TextureUnit target, float* v) => GLPointers.glMultiTexCoord1fvARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord1iARB(TextureUnit target, int s) => GLPointers.glMultiTexCoord1iARB_Lazy((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord1ivARB(TextureUnit target, int* v) => GLPointers.glMultiTexCoord1ivARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord1sARB(TextureUnit target, short s) => GLPointers.glMultiTexCoord1sARB_Lazy((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord1svARB(TextureUnit target, short* v) => GLPointers.glMultiTexCoord1svARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord2dARB(TextureUnit target, double s, double t) => GLPointers.glMultiTexCoord2dARB_Lazy((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord2dvARB(TextureUnit target, double* v) => GLPointers.glMultiTexCoord2dvARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord2fARB(TextureUnit target, float s, float t) => GLPointers.glMultiTexCoord2fARB_Lazy((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord2fvARB(TextureUnit target, float* v) => GLPointers.glMultiTexCoord2fvARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord2iARB(TextureUnit target, int s, int t) => GLPointers.glMultiTexCoord2iARB_Lazy((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord2ivARB(TextureUnit target, int* v) => GLPointers.glMultiTexCoord2ivARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord2sARB(TextureUnit target, short s, short t) => GLPointers.glMultiTexCoord2sARB_Lazy((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord2svARB(TextureUnit target, short* v) => GLPointers.glMultiTexCoord2svARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord3dARB(TextureUnit target, double s, double t, double r) => GLPointers.glMultiTexCoord3dARB_Lazy((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord3dvARB(TextureUnit target, double* v) => GLPointers.glMultiTexCoord3dvARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord3fARB(TextureUnit target, float s, float t, float r) => GLPointers.glMultiTexCoord3fARB_Lazy((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord3fvARB(TextureUnit target, float* v) => GLPointers.glMultiTexCoord3fvARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord3iARB(TextureUnit target, int s, int t, int r) => GLPointers.glMultiTexCoord3iARB_Lazy((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord3ivARB(TextureUnit target, int* v) => GLPointers.glMultiTexCoord3ivARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord3sARB(TextureUnit target, short s, short t, short r) => GLPointers.glMultiTexCoord3sARB_Lazy((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord3svARB(TextureUnit target, short* v) => GLPointers.glMultiTexCoord3svARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord4dARB(TextureUnit target, double s, double t, double r, double q) => GLPointers.glMultiTexCoord4dARB_Lazy((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord4dvARB(TextureUnit target, double* v) => GLPointers.glMultiTexCoord4dvARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord4fARB(TextureUnit target, float s, float t, float r, float q) => GLPointers.glMultiTexCoord4fARB_Lazy((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord4fvARB(TextureUnit target, float* v) => GLPointers.glMultiTexCoord4fvARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord4iARB(TextureUnit target, int s, int t, int r, int q) => GLPointers.glMultiTexCoord4iARB_Lazy((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord4ivARB(TextureUnit target, int* v) => GLPointers.glMultiTexCoord4ivARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord4sARB(TextureUnit target, short s, short t, short r, short q) => GLPointers.glMultiTexCoord4sARB_Lazy((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multitexture.txt"/></remarks>
            public static void MultiTexCoord4svARB(TextureUnit target, short* v) => GLPointers.glMultiTexCoord4svARB_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP1ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void MultiTexCoordP1ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers.glMultiTexCoordP1ui_Lazy((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP1uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers.glMultiTexCoordP1uiv_Lazy((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP2ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void MultiTexCoordP2ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers.glMultiTexCoordP2ui_Lazy((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP2uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers.glMultiTexCoordP2uiv_Lazy((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP3ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void MultiTexCoordP3ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers.glMultiTexCoordP3ui_Lazy((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP3uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers.glMultiTexCoordP3uiv_Lazy((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP4ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void MultiTexCoordP4ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers.glMultiTexCoordP4ui_Lazy((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP4uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers.glMultiTexCoordP4uiv_Lazy((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b> <b>[entry point: <c>glMultTransposeMatrixdARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transpose_matrix.txt"/></remarks>
            public static void MultTransposeMatrixdARB(double* m) => GLPointers.glMultTransposeMatrixdARB_Lazy(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b> <b>[entry point: <c>glMultTransposeMatrixfARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transpose_matrix.txt"/></remarks>
            public static void MultTransposeMatrixfARB(float* m) => GLPointers.glMultTransposeMatrixfARB_Lazy(m);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferData</c>]</b><br/> Creates and initializes a buffer object&apos;s data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedBufferData(int buffer, nint size, void* data, BufferUsage usage) => GLPointers.glNamedBufferData_Lazy(buffer, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b> <b>[entry point: <c>glNamedBufferPageCommitmentARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sparse_buffer.txt"/></remarks>
            public static void NamedBufferPageCommitmentARB(int buffer, IntPtr offset, nint size, bool commit) => GLPointers.glNamedBufferPageCommitmentARB_Lazy(buffer, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b> <b>[entry point: <c>glNamedBufferPageCommitmentEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sparse_buffer.txt"/></remarks>
            public static void NamedBufferPageCommitmentEXT(int buffer, IntPtr offset, nint size, bool commit) => GLPointers.glNamedBufferPageCommitmentEXT_Lazy(buffer, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferStorage</c>]</b><br/> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedBufferStorage(int buffer, nint size, void* data, BufferStorageMask flags) => GLPointers.glNamedBufferStorage_Lazy(buffer, size, data, (uint)flags);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferSubData</c>]</b><br/> Updates a subset of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store where data replacement will begin, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
            /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers.glNamedBufferSubData_Lazy(buffer, offset, size, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferDrawBuffer</c>]</b><br/> Specify which color buffers are to be drawn into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
            /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferDrawBuffer(int framebuffer, ColorBuffer buf) => GLPointers.glNamedFramebufferDrawBuffer_Lazy(framebuffer, (uint)buf);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferDrawBuffers</c>]</b><br/> Specifies a list of color buffers to be drawn    into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
            /// <param name="n">Specifies the number of buffers in bufs.</param>
            /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferDrawBuffers(int framebuffer, int n, ColorBuffer* bufs) => GLPointers.glNamedFramebufferDrawBuffers_Lazy(framebuffer, n, (uint*)bufs);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferParameteri</c>]</b><br/> Set a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferParameteri(int framebuffer, FramebufferParameterName pname, int param) => GLPointers.glNamedFramebufferParameteri_Lazy(framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferReadBuffer</c>]</b><br/> Select a color buffer source for pixels. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
            /// <param name="src">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferReadBuffer(int framebuffer, ColorBuffer src) => GLPointers.glNamedFramebufferReadBuffer_Lazy(framebuffer, (uint)src);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferRenderbuffer</c>]</b><br/> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferRenderbuffer(int framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers.glNamedFramebufferRenderbuffer_Lazy(framebuffer, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b> <b>[entry point: <c>glNamedFramebufferSampleLocationsfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sample_locations.txt"/></remarks>
            public static void NamedFramebufferSampleLocationsfvARB(int framebuffer, uint start, int count, float* v) => GLPointers.glNamedFramebufferSampleLocationsfvARB_Lazy(framebuffer, start, count, v);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferTexture(int framebuffer, FramebufferAttachment attachment, int texture, int level) => GLPointers.glNamedFramebufferTexture_Lazy(framebuffer, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureLayer</c>]</b><br/> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferTextureLayer(int framebuffer, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers.glNamedFramebufferTextureLayer_Lazy(framebuffer, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorage</c>]</b><br/> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedRenderbufferStorage(int renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers.glNamedRenderbufferStorage_Lazy(renderbuffer, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisample</c>]</b><br/> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void NamedRenderbufferStorageMultisample(int renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers.glNamedRenderbufferStorageMultisample_Lazy(renderbuffer, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glNamedStringARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shading_language_include.txt"/></remarks>
            public static void NamedStringARB(All type, int namelen, byte* name, int stringlen, byte* str) => GLPointers.glNamedStringARB_Lazy((uint)type, namelen, name, stringlen, str);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glNormalP3ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void NormalP3ui(NormalPointerType type, uint coords) => GLPointers.glNormalP3ui_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glNormalP3uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void NormalP3uiv(NormalPointerType type, uint* coords) => GLPointers.glNormalP3uiv_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> <b>[entry point: <c>glPatchParameterfv</c>]</b><br/> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_tessellation_shader.txt"/></remarks>
            public static void PatchParameterfv(PatchParameterName pname, float* values) => GLPointers.glPatchParameterfv_Lazy((uint)pname, values);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> <b>[entry point: <c>glPatchParameteri</c>]</b><br/> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_tessellation_shader.txt"/></remarks>
            public static void PatchParameteri(PatchParameterName pname, int value) => GLPointers.glPatchParameteri_Lazy((uint)pname, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glPauseTransformFeedback</c>]</b><br/> Pause transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
            public static void PauseTransformFeedback() => GLPointers.glPauseTransformFeedback_Lazy();
            
            /// <summary> <b>[requires: GL_ARB_point_parameters]</b> <b>[entry point: <c>glPointParameterfARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_point_parameters.txt"/></remarks>
            public static void PointParameterfARB(PointParameterNameARB pname, float param) => GLPointers.glPointParameterfARB_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ARB_point_parameters]</b> <b>[entry point: <c>glPointParameterfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_point_parameters.txt"/></remarks>
            public static void PointParameterfvARB(PointParameterNameARB pname, float* parameters) => GLPointers.glPointParameterfvARB_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp]</b> <b>[entry point: <c>glPolygonOffsetClamp</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_polygon_offset_clamp.txt"/></remarks>
            public static void PolygonOffsetClamp(float factor, float units, float clamp) => GLPointers.glPolygonOffsetClamp_Lazy(factor, units, clamp);
            
            /// <summary> <b>[requires: GL_ARB_ES3_2_compatibility]</b> <b>[entry point: <c>glPrimitiveBoundingBoxARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES3_2_compatibility.txt"/></remarks>
            public static void PrimitiveBoundingBoxARB(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) => GLPointers.glPrimitiveBoundingBoxARB_Lazy(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> <b>[entry point: <c>glProgramBinary</c>]</b><br/> Load a program object with a program binary. </summary>
            /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
            /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
            /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
            /// <param name="length"> Specifies the number of bytes contained in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_program_binary.txt"/></remarks>
            public static void ProgramBinary(int program, All binaryFormat, void* binary, int length) => GLPointers.glProgramBinary_Lazy(program, (uint)binaryFormat, binary, length);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramEnvParameter4dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void ProgramEnvParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers.glProgramEnvParameter4dARB_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramEnvParameter4dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, double* parameters) => GLPointers.glProgramEnvParameter4dvARB_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramEnvParameter4fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void ProgramEnvParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers.glProgramEnvParameter4fARB_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramEnvParameter4fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, float* parameters) => GLPointers.glProgramEnvParameter4fvARB_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramLocalParameter4dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void ProgramLocalParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers.glProgramLocalParameter4dARB_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramLocalParameter4dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, double* parameters) => GLPointers.glProgramLocalParameter4dvARB_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramLocalParameter4fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void ProgramLocalParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers.glProgramLocalParameter4fARB_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramLocalParameter4fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, float* parameters) => GLPointers.glProgramLocalParameter4fvARB_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramParameteri</c>]</b><br/> Specify a parameter for a program object. </summary>
            /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the name of the parameter to modify. </param>
            /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_get_program_binary.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramParameteri(int program, ProgramParameterPName pname, int value) => GLPointers.glProgramParameteri_Lazy(program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b> <b>[entry point: <c>glProgramParameteriARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_geometry_shader4.txt"/></remarks>
            public static void ProgramParameteriARB(int program, ProgramParameterPName pname, int value) => GLPointers.glProgramParameteriARB_Lazy(program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramStringARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/></remarks>
            public static void ProgramStringARB(ProgramTarget target, ProgramFormat format, int len, void* str) => GLPointers.glProgramStringARB_Lazy((uint)target, (uint)format, len, str);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1d</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1d(int program, int location, double v0) => GLPointers.glProgramUniform1d_Lazy(program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1dv(int program, int location, int count, double* value) => GLPointers.glProgramUniform1dv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1f(int program, int location, float v0) => GLPointers.glProgramUniform1f_Lazy(program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1fv(int program, int location, int count, float* value) => GLPointers.glProgramUniform1fv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1i(int program, int location, int v0) => GLPointers.glProgramUniform1i_Lazy(program, location, v0);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform1i64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform1i64ARB(int program, int location, long x) => GLPointers.glProgramUniform1i64ARB_Lazy(program, location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform1i64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform1i64vARB(int program, int location, int count, long* value) => GLPointers.glProgramUniform1i64vARB_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1iv(int program, int location, int count, int* value) => GLPointers.glProgramUniform1iv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1ui(int program, int location, uint v0) => GLPointers.glProgramUniform1ui_Lazy(program, location, v0);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform1ui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform1ui64ARB(int program, int location, ulong x) => GLPointers.glProgramUniform1ui64ARB_Lazy(program, location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform1ui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform1ui64vARB(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform1ui64vARB_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1uiv(int program, int location, int count, uint* value) => GLPointers.glProgramUniform1uiv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2d</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2d(int program, int location, double v0, double v1) => GLPointers.glProgramUniform2d_Lazy(program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2dv(int program, int location, int count, double* value) => GLPointers.glProgramUniform2dv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2f(int program, int location, float v0, float v1) => GLPointers.glProgramUniform2f_Lazy(program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2fv(int program, int location, int count, float* value) => GLPointers.glProgramUniform2fv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2i(int program, int location, int v0, int v1) => GLPointers.glProgramUniform2i_Lazy(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform2i64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform2i64ARB(int program, int location, long x, long y) => GLPointers.glProgramUniform2i64ARB_Lazy(program, location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform2i64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform2i64vARB(int program, int location, int count, long* value) => GLPointers.glProgramUniform2i64vARB_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2iv(int program, int location, int count, int* value) => GLPointers.glProgramUniform2iv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2ui(int program, int location, uint v0, uint v1) => GLPointers.glProgramUniform2ui_Lazy(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform2ui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform2ui64ARB(int program, int location, ulong x, ulong y) => GLPointers.glProgramUniform2ui64ARB_Lazy(program, location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform2ui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform2ui64vARB(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform2ui64vARB_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2uiv(int program, int location, int count, uint* value) => GLPointers.glProgramUniform2uiv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3d</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3d(int program, int location, double v0, double v1, double v2) => GLPointers.glProgramUniform3d_Lazy(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3dv(int program, int location, int count, double* value) => GLPointers.glProgramUniform3dv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3f(int program, int location, float v0, float v1, float v2) => GLPointers.glProgramUniform3f_Lazy(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3fv(int program, int location, int count, float* value) => GLPointers.glProgramUniform3fv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3i(int program, int location, int v0, int v1, int v2) => GLPointers.glProgramUniform3i_Lazy(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform3i64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform3i64ARB(int program, int location, long x, long y, long z) => GLPointers.glProgramUniform3i64ARB_Lazy(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform3i64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform3i64vARB(int program, int location, int count, long* value) => GLPointers.glProgramUniform3i64vARB_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3iv(int program, int location, int count, int* value) => GLPointers.glProgramUniform3iv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3ui(int program, int location, uint v0, uint v1, uint v2) => GLPointers.glProgramUniform3ui_Lazy(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform3ui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform3ui64ARB(int program, int location, ulong x, ulong y, ulong z) => GLPointers.glProgramUniform3ui64ARB_Lazy(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform3ui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform3ui64vARB(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform3ui64vARB_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3uiv(int program, int location, int count, uint* value) => GLPointers.glProgramUniform3uiv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4d</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4d(int program, int location, double v0, double v1, double v2, double v3) => GLPointers.glProgramUniform4d_Lazy(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4dv(int program, int location, int count, double* value) => GLPointers.glProgramUniform4dv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3) => GLPointers.glProgramUniform4f_Lazy(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4fv(int program, int location, int count, float* value) => GLPointers.glProgramUniform4fv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3) => GLPointers.glProgramUniform4i_Lazy(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform4i64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform4i64ARB(int program, int location, long x, long y, long z, long w) => GLPointers.glProgramUniform4i64ARB_Lazy(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform4i64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform4i64vARB(int program, int location, int count, long* value) => GLPointers.glProgramUniform4i64vARB_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4iv(int program, int location, int count, int* value) => GLPointers.glProgramUniform4iv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4ui(int program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers.glProgramUniform4ui_Lazy(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform4ui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform4ui64ARB(int program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers.glProgramUniform4ui64ARB_Lazy(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform4ui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void ProgramUniform4ui64vARB(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform4ui64vARB_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4uiv(int program, int location, int count, uint* value) => GLPointers.glProgramUniform4uiv_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glProgramUniformHandleui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void ProgramUniformHandleui64ARB(int program, int location, ulong value) => GLPointers.glProgramUniformHandleui64ARB_Lazy(program, location, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glProgramUniformHandleui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void ProgramUniformHandleui64vARB(int program, int location, int count, ulong* values) => GLPointers.glProgramUniformHandleui64vARB_Lazy(program, location, count, values);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix2dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix2dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix2fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix2fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix2x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix2x3dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix2x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix2x3fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix2x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix2x4dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix2x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix2x4fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix3dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix3dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix3fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix3fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix3x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix3x2dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix3x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix3x2fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix3x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix3x4dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix3x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix3x4fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix4dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix4dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix4fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix4fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix4x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix4x2dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix4x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix4x2fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix4x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix4x3dv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix4x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix4x3fv_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex]</b> <b>[entry point: <c>glProvokingVertex</c>]</b><br/> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
            /// <param name="mode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_provoking_vertex.txt"/></remarks>
            public static void ProvokingVertex(VertexProvokingMode mode) => GLPointers.glProvokingVertex_Lazy((uint)mode);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glQueryCounter</c>]</b><br/> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
            /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
            /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_timer_query.txt"/></remarks>
            public static void QueryCounter(int id, QueryCounterTarget target) => GLPointers.glQueryCounter_Lazy(id, (uint)target);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glReadnPixelsARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_robustness.txt"/></remarks>
            public static void ReadnPixelsARB(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers.glReadnPixelsARB_Lazy(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glReleaseShaderCompiler</c>]</b><br/> Release resources consumed by the implementation&apos;s shader compiler. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
            public static void ReleaseShaderCompiler() => GLPointers.glReleaseShaderCompiler_Lazy();
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorage</c>]</b><br/> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers.glRenderbufferStorage_Lazy((uint)target, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorageMultisample</c>]</b><br/> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_framebuffer_object.txt"/></remarks>
            public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers.glRenderbufferStorageMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glResetHistogram</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ResetHistogram(HistogramTargetEXT target) => GLPointers.glResetHistogram_Lazy((uint)target);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glResetMinmax</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void ResetMinmax(MinmaxTargetEXT target) => GLPointers.glResetMinmax_Lazy((uint)target);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glResumeTransformFeedback</c>]</b><br/> Resume transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_transform_feedback2.txt"/></remarks>
            public static void ResumeTransformFeedback() => GLPointers.glResumeTransformFeedback_Lazy();
            
            /// <summary> <b>[requires: GL_ARB_multisample]</b> <b>[entry point: <c>glSampleCoverageARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multisample.txt"/></remarks>
            public static void SampleCoverageARB(float value, bool invert) => GLPointers.glSampleCoverageARB_Lazy(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glSampleMaski</c>]</b><br/> Set the value of a sub-word of the sample mask. </summary>
            /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
            /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_multisample.txt"/></remarks>
            public static void SampleMaski(uint maskNumber, uint mask) => GLPointers.glSampleMaski_Lazy(maskNumber, mask);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterf</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void SamplerParameterf(int sampler, SamplerParameterF pname, float param) => GLPointers.glSamplerParameterf_Lazy(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterfv</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void SamplerParameterfv(int sampler, SamplerParameterF pname, float* param) => GLPointers.glSamplerParameterfv_Lazy(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameteri</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void SamplerParameteri(int sampler, SamplerParameterI pname, int param) => GLPointers.glSamplerParameteri_Lazy(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterIiv</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void SamplerParameterIiv(int sampler, SamplerParameterI pname, int* param) => GLPointers.glSamplerParameterIiv_Lazy(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterIuiv</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void SamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* param) => GLPointers.glSamplerParameterIuiv_Lazy(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameteriv</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sampler_objects.txt"/></remarks>
            public static void SamplerParameteriv(int sampler, SamplerParameterI pname, int* param) => GLPointers.glSamplerParameteriv_Lazy(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorArrayv</c>]</b><br/> Define the scissor box for multiple viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
            /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
            /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void ScissorArrayv(uint first, int count, int* v) => GLPointers.glScissorArrayv_Lazy(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorIndexed</c>]</b><br/> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => GLPointers.glScissorIndexed_Lazy(index, left, bottom, width, height);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorIndexedv</c>]</b><br/> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void ScissorIndexedv(uint index, int* v) => GLPointers.glScissorIndexedv_Lazy(index, v);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glSecondaryColorP3ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void SecondaryColorP3ui(ColorPointerType type, uint color) => GLPointers.glSecondaryColorP3ui_Lazy((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glSecondaryColorP3uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void SecondaryColorP3uiv(ColorPointerType type, uint* color) => GLPointers.glSecondaryColorP3uiv_Lazy((uint)type, color);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glSeparableFilter2D</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_imaging.txt"/></remarks>
            public static void SeparableFilter2D(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column) => GLPointers.glSeparableFilter2D_Lazy((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, row, column);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glShaderBinary</c>]</b><br/> Load pre-compiled shader binaries. </summary>
            /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
            /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
            /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
            /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
            /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_ES2_compatibility.txt"/></remarks>
            public static void ShaderBinary(int count, int* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => GLPointers.glShaderBinary_Lazy(count, shaders, (uint)binaryFormat, binary, length);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glShaderSourceARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void ShaderSourceARB(GLHandleARB shaderObj, int count, byte** str, int* length) => GLPointers.glShaderSourceARB_Lazy((IntPtr)shaderObj, count, str, length);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object]</b> <b>[entry point: <c>glShaderStorageBlockBinding</c>]</b><br/> Change an active shader storage block binding. </summary>
            /// <param name="program"> The name of the program containing the block whose binding to change. </param>
            /// <param name="storageBlockIndex"> The index storage block within the program. </param>
            /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_storage_buffer_object.txt"/></remarks>
            public static void ShaderStorageBlockBinding(int program, uint storageBlockIndex, uint storageBlockBinding) => GLPointers.glShaderStorageBlockBinding_Lazy(program, storageBlockIndex, storageBlockBinding);
            
            /// <summary> <b>[requires: GL_ARB_gl_spirv]</b> <b>[entry point: <c>glSpecializeShaderARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gl_spirv.txt"/></remarks>
            public static void SpecializeShaderARB(int shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => GLPointers.glSpecializeShaderARB_Lazy(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
            
            /// <summary> <b>[requires: GL_ARB_texture_buffer_object]</b> <b>[entry point: <c>glTexBufferARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_buffer_object.txt"/></remarks>
            public static void TexBufferARB(TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers.glTexBufferARB_Lazy((uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range]</b> <b>[entry point: <c>glTexBufferRange</c>]</b><br/> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_buffer_range.txt"/></remarks>
            public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers.glTexBufferRange_Lazy((uint)target, (uint)internalformat, buffer, offset, size);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP1ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void TexCoordP1ui(TexCoordPointerType type, uint coords) => GLPointers.glTexCoordP1ui_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP1uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void TexCoordP1uiv(TexCoordPointerType type, uint* coords) => GLPointers.glTexCoordP1uiv_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP2ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void TexCoordP2ui(TexCoordPointerType type, uint coords) => GLPointers.glTexCoordP2ui_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP2uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void TexCoordP2uiv(TexCoordPointerType type, uint* coords) => GLPointers.glTexCoordP2uiv_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP3ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void TexCoordP3ui(TexCoordPointerType type, uint coords) => GLPointers.glTexCoordP3ui_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP3uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void TexCoordP3uiv(TexCoordPointerType type, uint* coords) => GLPointers.glTexCoordP3uiv_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP4ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void TexCoordP4ui(TexCoordPointerType type, uint coords) => GLPointers.glTexCoordP4ui_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP4uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void TexCoordP4uiv(TexCoordPointerType type, uint* coords) => GLPointers.glTexCoordP4uiv_Lazy((uint)type, coords);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glTexImage2DMultisample</c>]</b><br/> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
            /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_multisample.txt"/></remarks>
            public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers.glTexImage2DMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glTexImage3DMultisample</c>]</b><br/> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
            /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
            /// <param name="depth">!!missing documentation!!</param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_multisample.txt"/></remarks>
            public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers.glTexImage3DMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_texture]</b> <b>[entry point: <c>glTexPageCommitmentARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sparse_texture.txt"/></remarks>
            public static void TexPageCommitmentARB(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => GLPointers.glTexPageCommitmentARB_Lazy((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage1D</c>]</b><br/> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage.txt"/></remarks>
            public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers.glTexStorage1D_Lazy((uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage2D</c>]</b><br/> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage.txt"/></remarks>
            public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers.glTexStorage2D_Lazy((uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> <b>[entry point: <c>glTexStorage2DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage_multisample.txt"/></remarks>
            public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers.glTexStorage2DMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage3D</c>]</b><br/> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage.txt"/></remarks>
            public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers.glTexStorage3D_Lazy((uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> <b>[entry point: <c>glTexStorage3DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_storage_multisample.txt"/></remarks>
            public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers.glTexStorage3DMultisample_Lazy((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier]</b> <b>[entry point: <c>glTextureBarrier</c>]</b><br/> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_barrier.txt"/></remarks>
            public static void TextureBarrier() => GLPointers.glTextureBarrier_Lazy();
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureBuffer</c>]</b><br/> Attach a buffer object&apos;s data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureBuffer(int texture, SizedInternalFormat internalformat, int buffer) => GLPointers.glTextureBuffer_Lazy(texture, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureBufferRange</c>]</b><br/> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureBufferRange(int texture, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers.glTextureBufferRange_Lazy(texture, (uint)internalformat, buffer, offset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterf</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureParameterf(int texture, TextureParameterName pname, float param) => GLPointers.glTextureParameterf_Lazy(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterfv</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureParameterfv(int texture, TextureParameterName pname, float* param) => GLPointers.glTextureParameterfv_Lazy(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameteri</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureParameteri(int texture, TextureParameterName pname, int param) => GLPointers.glTextureParameteri_Lazy(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIiv</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureParameterIiv(int texture, TextureParameterName pname, int* parameters) => GLPointers.glTextureParameterIiv_Lazy(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIuiv</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureParameterIuiv(int texture, TextureParameterName pname, uint* parameters) => GLPointers.glTextureParameterIuiv_Lazy(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameteriv</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureParameteriv(int texture, TextureParameterName pname, int* param) => GLPointers.glTextureParameteriv_Lazy(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage1D</c>]</b><br/> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureStorage1D(int texture, int levels, SizedInternalFormat internalformat, int width) => GLPointers.glTextureStorage1D_Lazy(texture, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2D</c>]</b><br/> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureStorage2D(int texture, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers.glTextureStorage2D_Lazy(texture, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureStorage2DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers.glTextureStorage2DMultisample_Lazy(texture, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3D</c>]</b><br/> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureStorage3D(int texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers.glTextureStorage3D_Lazy(texture, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureStorage3DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers.glTextureStorage3DMultisample_Lazy(texture, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureSubImage1D(int texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureSubImage1D_Lazy(texture, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureSubImage2D_Lazy(texture, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="depth"> Specifies the depth of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureSubImage3D_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view]</b> <b>[entry point: <c>glTextureView</c>]</b><br/> Initialize a texture as a data alias of another texture&apos;s data store. </summary>
            /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
            /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
            /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
            /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
            /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
            /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
            /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
            /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_texture_view.txt"/></remarks>
            public static void TextureView(int texture, TextureTarget target, int origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => GLPointers.glTextureView_Lazy(texture, (uint)target, origtexture, (uint)internalformat, minlevel, numlevels, minlayer, numlayers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTransformFeedbackBufferBase</c>]</b><br/> Bind a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TransformFeedbackBufferBase(int xfb, uint index, int buffer) => GLPointers.glTransformFeedbackBufferBase_Lazy(xfb, index, buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTransformFeedbackBufferRange</c>]</b><br/> Bind a range within a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
            /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void TransformFeedbackBufferRange(int xfb, uint index, int buffer, IntPtr offset, nint size) => GLPointers.glTransformFeedbackBufferRange_Lazy(xfb, index, buffer, offset, size);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform1d</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void Uniform1d(int location, double x) => GLPointers.glUniform1d_Lazy(location, x);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform1dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void Uniform1dv(int location, int count, double* value) => GLPointers.glUniform1dv_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform1fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform1fARB(int location, float v0) => GLPointers.glUniform1fARB_Lazy(location, v0);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform1fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform1fvARB(int location, int count, float* value) => GLPointers.glUniform1fvARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform1i64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform1i64ARB(int location, long x) => GLPointers.glUniform1i64ARB_Lazy(location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform1i64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform1i64vARB(int location, int count, long* value) => GLPointers.glUniform1i64vARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform1iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform1iARB(int location, int v0) => GLPointers.glUniform1iARB_Lazy(location, v0);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform1ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform1ivARB(int location, int count, int* value) => GLPointers.glUniform1ivARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform1ui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform1ui64ARB(int location, ulong x) => GLPointers.glUniform1ui64ARB_Lazy(location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform1ui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform1ui64vARB(int location, int count, ulong* value) => GLPointers.glUniform1ui64vARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform2d</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void Uniform2d(int location, double x, double y) => GLPointers.glUniform2d_Lazy(location, x, y);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform2dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void Uniform2dv(int location, int count, double* value) => GLPointers.glUniform2dv_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform2fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform2fARB(int location, float v0, float v1) => GLPointers.glUniform2fARB_Lazy(location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform2fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform2fvARB(int location, int count, float* value) => GLPointers.glUniform2fvARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform2i64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform2i64ARB(int location, long x, long y) => GLPointers.glUniform2i64ARB_Lazy(location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform2i64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform2i64vARB(int location, int count, long* value) => GLPointers.glUniform2i64vARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform2iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform2iARB(int location, int v0, int v1) => GLPointers.glUniform2iARB_Lazy(location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform2ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform2ivARB(int location, int count, int* value) => GLPointers.glUniform2ivARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform2ui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform2ui64ARB(int location, ulong x, ulong y) => GLPointers.glUniform2ui64ARB_Lazy(location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform2ui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform2ui64vARB(int location, int count, ulong* value) => GLPointers.glUniform2ui64vARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform3d</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void Uniform3d(int location, double x, double y, double z) => GLPointers.glUniform3d_Lazy(location, x, y, z);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform3dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void Uniform3dv(int location, int count, double* value) => GLPointers.glUniform3dv_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform3fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform3fARB(int location, float v0, float v1, float v2) => GLPointers.glUniform3fARB_Lazy(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform3fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform3fvARB(int location, int count, float* value) => GLPointers.glUniform3fvARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform3i64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform3i64ARB(int location, long x, long y, long z) => GLPointers.glUniform3i64ARB_Lazy(location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform3i64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform3i64vARB(int location, int count, long* value) => GLPointers.glUniform3i64vARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform3iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform3iARB(int location, int v0, int v1, int v2) => GLPointers.glUniform3iARB_Lazy(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform3ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform3ivARB(int location, int count, int* value) => GLPointers.glUniform3ivARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform3ui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform3ui64ARB(int location, ulong x, ulong y, ulong z) => GLPointers.glUniform3ui64ARB_Lazy(location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform3ui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform3ui64vARB(int location, int count, ulong* value) => GLPointers.glUniform3ui64vARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform4d</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void Uniform4d(int location, double x, double y, double z, double w) => GLPointers.glUniform4d_Lazy(location, x, y, z, w);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform4dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void Uniform4dv(int location, int count, double* value) => GLPointers.glUniform4dv_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform4fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform4fARB(int location, float v0, float v1, float v2, float v3) => GLPointers.glUniform4fARB_Lazy(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform4fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform4fvARB(int location, int count, float* value) => GLPointers.glUniform4fvARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform4i64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform4i64ARB(int location, long x, long y, long z, long w) => GLPointers.glUniform4i64ARB_Lazy(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform4i64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform4i64vARB(int location, int count, long* value) => GLPointers.glUniform4i64vARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform4iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform4iARB(int location, int v0, int v1, int v2, int v3) => GLPointers.glUniform4iARB_Lazy(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform4ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void Uniform4ivARB(int location, int count, int* value) => GLPointers.glUniform4ivARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform4ui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform4ui64ARB(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers.glUniform4ui64ARB_Lazy(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform4ui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt"/></remarks>
            public static void Uniform4ui64vARB(int location, int count, ulong* value) => GLPointers.glUniform4ui64vARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glUniformBlockBinding</c>]</b><br/> Assign a binding point to an active uniform block. </summary>
            /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
            /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
            /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt"/></remarks>
            public static void UniformBlockBinding(int program, uint uniformBlockIndex, uint uniformBlockBinding) => GLPointers.glUniformBlockBinding_Lazy(program, uniformBlockIndex, uniformBlockBinding);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glUniformHandleui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void UniformHandleui64ARB(int location, ulong value) => GLPointers.glUniformHandleui64ARB_Lazy(location, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glUniformHandleui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void UniformHandleui64vARB(int location, int count, ulong* value) => GLPointers.glUniformHandleui64vARB_Lazy(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void UniformMatrix2dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix2dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniformMatrix2fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void UniformMatrix2fvARB(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix2fvARB_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2x3dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void UniformMatrix2x3dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix2x3dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2x4dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void UniformMatrix2x4dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix2x4dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void UniformMatrix3dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix3dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniformMatrix3fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void UniformMatrix3fvARB(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix3fvARB_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3x2dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void UniformMatrix3x2dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix3x2dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3x4dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void UniformMatrix3x4dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix3x4dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void UniformMatrix4dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix4dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniformMatrix4fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void UniformMatrix4fvARB(int location, int count, bool transpose, float* value) => GLPointers.glUniformMatrix4fvARB_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4x2dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void UniformMatrix4x2dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix4x2dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4x3dv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt"/></remarks>
            public static void UniformMatrix4x3dv(int location, int count, bool transpose, double* value) => GLPointers.glUniformMatrix4x3dv_Lazy(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glUniformSubroutinesuiv</c>]</b><br/> Load active subroutine uniforms. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
            /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_subroutine.txt"/></remarks>
            public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => GLPointers.glUniformSubroutinesuiv_Lazy((uint)shadertype, count, indices);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glUnmapBufferARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt"/></remarks>
            public static bool UnmapBufferARB(BufferTarget target) => GLPointers.glUnmapBufferARB_Lazy((uint)target) != 0;
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glUnmapNamedBuffer</c>]</b><br/> Release the mapping of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static bool UnmapNamedBuffer(int buffer) => GLPointers.glUnmapNamedBuffer_Lazy(buffer) != 0;
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUseProgramObjectARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void UseProgramObjectARB(GLHandleARB programObj) => GLPointers.glUseProgramObjectARB_Lazy((IntPtr)programObj);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glUseProgramStages</c>]</b><br/> Bind stages of a program object to a program pipeline. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
            /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
            /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void UseProgramStages(int pipeline, UseProgramStageMask stages, int program) => GLPointers.glUseProgramStages_Lazy(pipeline, (uint)stages, program);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glValidateProgramARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_objects.txt"/></remarks>
            public static void ValidateProgramARB(GLHandleARB programObj) => GLPointers.glValidateProgramARB_Lazy((IntPtr)programObj);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glValidateProgramPipeline</c>]</b><br/> Validate a program pipeline object against current GL state. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"/></remarks>
            public static void ValidateProgramPipeline(int pipeline) => GLPointers.glValidateProgramPipeline_Lazy(pipeline);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribBinding</c>]</b><br/> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void VertexArrayAttribBinding(int vaobj, uint attribindex, uint bindingindex) => GLPointers.glVertexArrayAttribBinding_Lazy(vaobj, attribindex, bindingindex);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void VertexArrayAttribFormat(int vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers.glVertexArrayAttribFormat_Lazy(vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribIFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void VertexArrayAttribIFormat(int vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers.glVertexArrayAttribIFormat_Lazy(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribLFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void VertexArrayAttribLFormat(int vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers.glVertexArrayAttribLFormat_Lazy(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayBindingDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void VertexArrayBindingDivisor(int vaobj, uint bindingindex, uint divisor) => GLPointers.glVertexArrayBindingDivisor_Lazy(vaobj, bindingindex, divisor);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayElementBuffer</c>]</b><br/> Configures element array buffer binding of a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
            /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void VertexArrayElementBuffer(int vaobj, int buffer) => GLPointers.glVertexArrayElementBuffer_Lazy(vaobj, buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBuffer</c>]</b><br/> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexBuffer(int vaobj, uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers.glVertexArrayVertexBuffer_Lazy(vaobj, bindingindex, buffer, offset, stride);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBuffers</c>]</b><br/> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexBuffers(int vaobj, uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers.glVertexArrayVertexBuffers_Lazy(vaobj, first, count, buffers, offsets, strides);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib1dARB(uint index, double x) => GLPointers.glVertexAttrib1dARB_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib1dvARB(uint index, double* v) => GLPointers.glVertexAttrib1dvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib1fARB(uint index, float x) => GLPointers.glVertexAttrib1fARB_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib1fvARB(uint index, float* v) => GLPointers.glVertexAttrib1fvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib1sARB(uint index, short x) => GLPointers.glVertexAttrib1sARB_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib1svARB(uint index, short* v) => GLPointers.glVertexAttrib1svARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib2dARB(uint index, double x, double y) => GLPointers.glVertexAttrib2dARB_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib2dvARB(uint index, double* v) => GLPointers.glVertexAttrib2dvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib2fARB(uint index, float x, float y) => GLPointers.glVertexAttrib2fARB_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib2fvARB(uint index, float* v) => GLPointers.glVertexAttrib2fvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib2sARB(uint index, short x, short y) => GLPointers.glVertexAttrib2sARB_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib2svARB(uint index, short* v) => GLPointers.glVertexAttrib2svARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib3dARB(uint index, double x, double y, double z) => GLPointers.glVertexAttrib3dARB_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib3dvARB(uint index, double* v) => GLPointers.glVertexAttrib3dvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib3fARB(uint index, float x, float y, float z) => GLPointers.glVertexAttrib3fARB_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib3fvARB(uint index, float* v) => GLPointers.glVertexAttrib3fvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib3sARB(uint index, short x, short y, short z) => GLPointers.glVertexAttrib3sARB_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib3svARB(uint index, short* v) => GLPointers.glVertexAttrib3svARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4bvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4bvARB(uint index, sbyte* v) => GLPointers.glVertexAttrib4bvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4dARB(uint index, double x, double y, double z, double w) => GLPointers.glVertexAttrib4dARB_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4dvARB(uint index, double* v) => GLPointers.glVertexAttrib4dvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4fARB(uint index, float x, float y, float z, float w) => GLPointers.glVertexAttrib4fARB_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4fvARB(uint index, float* v) => GLPointers.glVertexAttrib4fvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4ivARB(uint index, int* v) => GLPointers.glVertexAttrib4ivARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NbvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4NbvARB(uint index, sbyte* v) => GLPointers.glVertexAttrib4NbvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4NivARB(uint index, int* v) => GLPointers.glVertexAttrib4NivARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NsvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4NsvARB(uint index, short* v) => GLPointers.glVertexAttrib4NsvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NubARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4NubARB(uint index, byte x, byte y, byte z, byte w) => GLPointers.glVertexAttrib4NubARB_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NubvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4NubvARB(uint index, byte* v) => GLPointers.glVertexAttrib4NubvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NuivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4NuivARB(uint index, uint* v) => GLPointers.glVertexAttrib4NuivARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NusvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4NusvARB(uint index, ushort* v) => GLPointers.glVertexAttrib4NusvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4sARB(uint index, short x, short y, short z, short w) => GLPointers.glVertexAttrib4sARB_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4svARB(uint index, short* v) => GLPointers.glVertexAttrib4svARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4ubvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4ubvARB(uint index, byte* v) => GLPointers.glVertexAttrib4ubvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4uivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4uivARB(uint index, uint* v) => GLPointers.glVertexAttrib4uivARB_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4usvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttrib4usvARB(uint index, ushort* v) => GLPointers.glVertexAttrib4usvARB_Lazy(index, v);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribBinding</c>]</b><br/> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
            public static void VertexAttribBinding(uint attribindex, uint bindingindex) => GLPointers.glVertexAttribBinding_Lazy(attribindex, bindingindex);
            
            /// <summary> <b>[requires: GL_ARB_instanced_arrays]</b> <b>[entry point: <c>glVertexAttribDivisorARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_instanced_arrays.txt"/></remarks>
            public static void VertexAttribDivisorARB(uint index, uint divisor) => GLPointers.glVertexAttribDivisorARB_Lazy(index, divisor);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
            public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers.glVertexAttribFormat_Lazy(attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribIFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
            public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers.glVertexAttribIFormat_Lazy(attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL1d(uint index, double x) => GLPointers.glVertexAttribL1d_Lazy(index, x);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL1dv(uint index, double* v) => GLPointers.glVertexAttribL1dv_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glVertexAttribL1ui64ARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void VertexAttribL1ui64ARB(uint index, ulong x) => GLPointers.glVertexAttribL1ui64ARB_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glVertexAttribL1ui64vARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_bindless_texture.txt"/></remarks>
            public static void VertexAttribL1ui64vARB(uint index, ulong* v) => GLPointers.glVertexAttribL1ui64vARB_Lazy(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL2d(uint index, double x, double y) => GLPointers.glVertexAttribL2d_Lazy(index, x, y);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL2dv(uint index, double* v) => GLPointers.glVertexAttribL2dv_Lazy(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL3d(uint index, double x, double y, double z) => GLPointers.glVertexAttribL3d_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL3dv(uint index, double* v) => GLPointers.glVertexAttribL3dv_Lazy(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="x"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="y"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="z"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="w"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => GLPointers.glVertexAttribL4d_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL4dv(uint index, double* v) => GLPointers.glVertexAttribL4dv_Lazy(index, v);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribLFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
            public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers.glVertexAttribLFormat_Lazy(attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribLPointer</c>]</b><br/> Define an array of generic vertex attribute data. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
            /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
            /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
            /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers.glVertexAttribLPointer_Lazy(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP1ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers.glVertexAttribP1ui_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP1uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers.glVertexAttribP1uiv_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP2ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers.glVertexAttribP2ui_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP2uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers.glVertexAttribP2uiv_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP3ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers.glVertexAttribP3ui_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP3uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers.glVertexAttribP3uiv_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP4ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers.glVertexAttribP4ui_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP4uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers.glVertexAttribP4uiv_Lazy(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttribPointerARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_program.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_shader.txt"/></remarks>
            public static void VertexAttribPointerARB(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, void* pointer) => GLPointers.glVertexAttribPointerARB_Lazy(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, pointer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexBindingDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_attrib_binding.txt"/></remarks>
            public static void VertexBindingDivisor(uint bindingindex, uint divisor) => GLPointers.glVertexBindingDivisor_Lazy(bindingindex, divisor);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glVertexBlendARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void VertexBlendARB(int count) => GLPointers.glVertexBlendARB_Lazy(count);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP2ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexP2ui(VertexPointerType type, uint value) => GLPointers.glVertexP2ui_Lazy((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP2uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexP2uiv(VertexPointerType type, uint* value) => GLPointers.glVertexP2uiv_Lazy((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP3ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexP3ui(VertexPointerType type, uint value) => GLPointers.glVertexP3ui_Lazy((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP3uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexP3uiv(VertexPointerType type, uint* value) => GLPointers.glVertexP3uiv_Lazy((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP4ui</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexP4ui(VertexPointerType type, uint value) => GLPointers.glVertexP4ui_Lazy((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP4uiv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt"/></remarks>
            public static void VertexP4uiv(VertexPointerType type, uint* value) => GLPointers.glVertexP4uiv_Lazy((uint)type, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportArrayv</c>]</b><br/> Set multiple viewports. </summary>
            /// <param name="first"> Specify the first viewport to set. </param>
            /// <param name="count"> Specify the number of viewports to set. </param>
            /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void ViewportArrayv(uint first, int count, float* v) => GLPointers.glViewportArrayv_Lazy(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportIndexedf</c>]</b><br/> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => GLPointers.glViewportIndexedf_Lazy(index, x, y, w, h);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportIndexedfv</c>]</b><br/> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_viewport_array.txt"/></remarks>
            public static void ViewportIndexedfv(uint index, float* v) => GLPointers.glViewportIndexedfv_Lazy(index, v);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glWaitSync</c>]</b><br/> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
            /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
            /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_sync.txt"/></remarks>
            public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => GLPointers.glWaitSync_Lazy((IntPtr)sync, (uint)flags, timeout);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightbvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void WeightbvARB(int size, sbyte* weights) => GLPointers.glWeightbvARB_Lazy(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightdvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void WeightdvARB(int size, double* weights) => GLPointers.glWeightdvARB_Lazy(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightfvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void WeightfvARB(int size, float* weights) => GLPointers.glWeightfvARB_Lazy(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void WeightivARB(int size, int* weights) => GLPointers.glWeightivARB_Lazy(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightPointerARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void WeightPointerARB(int size, WeightPointerTypeARB type, int stride, void* pointer) => GLPointers.glWeightPointerARB_Lazy(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightsvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void WeightsvARB(int size, short* weights) => GLPointers.glWeightsvARB_Lazy(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightubvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void WeightubvARB(int size, byte* weights) => GLPointers.glWeightubvARB_Lazy(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightuivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void WeightuivARB(int size, uint* weights) => GLPointers.glWeightuivARB_Lazy(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightusvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_vertex_blend.txt"/></remarks>
            public static void WeightusvARB(int size, ushort* weights) => GLPointers.glWeightusvARB_Lazy(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos2dARB(double x, double y) => GLPointers.glWindowPos2dARB_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos2dvARB(double* v) => GLPointers.glWindowPos2dvARB_Lazy(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos2fARB(float x, float y) => GLPointers.glWindowPos2fARB_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos2fvARB(float* v) => GLPointers.glWindowPos2fvARB_Lazy(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos2iARB(int x, int y) => GLPointers.glWindowPos2iARB_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos2ivARB(int* v) => GLPointers.glWindowPos2ivARB_Lazy(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos2sARB(short x, short y) => GLPointers.glWindowPos2sARB_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos2svARB(short* v) => GLPointers.glWindowPos2svARB_Lazy(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3dARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos3dARB(double x, double y, double z) => GLPointers.glWindowPos3dARB_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3dvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos3dvARB(double* v) => GLPointers.glWindowPos3dvARB_Lazy(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3fARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos3fARB(float x, float y, float z) => GLPointers.glWindowPos3fARB_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3fvARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos3fvARB(float* v) => GLPointers.glWindowPos3fvARB_Lazy(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3iARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos3iARB(int x, int y, int z) => GLPointers.glWindowPos3iARB_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3ivARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos3ivARB(int* v) => GLPointers.glWindowPos3ivARB_Lazy(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3sARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos3sARB(short x, short y, short z) => GLPointers.glWindowPos3sARB_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3svARB</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_window_pos.txt"/></remarks>
            public static void WindowPos3svARB(short* v) => GLPointers.glWindowPos3svARB_Lazy(v);
            
        }
        /// <summary>ATI extensions.</summary>
        public static unsafe partial class ATI
        {
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glAlphaFragmentOp1ATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void AlphaFragmentOp1ATI(FragmentOp1ATI op, FragmentShaderRegATI dst, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod) => GLPointers.glAlphaFragmentOp1ATI_Lazy((uint)op, (uint)dst, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glAlphaFragmentOp2ATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void AlphaFragmentOp2ATI(FragmentOp2ATI op, FragmentShaderRegATI dst, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod) => GLPointers.glAlphaFragmentOp2ATI_Lazy((uint)op, (uint)dst, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glAlphaFragmentOp3ATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void AlphaFragmentOp3ATI(FragmentOp3ATI op, FragmentShaderRegATI dst, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod, FragmentShaderGenericSourceATI arg3, FragmentShaderValueRepATI arg3Rep, FragmentShaderColorModMaskATI arg3Mod) => GLPointers.glAlphaFragmentOp3ATI_Lazy((uint)op, (uint)dst, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod, (uint)arg3, (uint)arg3Rep, (uint)arg3Mod);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glArrayObjectATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void ArrayObjectATI(EnableCap array, int size, ScalarType type, int stride, int buffer, uint offset) => GLPointers.glArrayObjectATI_Lazy((uint)array, size, (uint)type, stride, buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glBeginFragmentShaderATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void BeginFragmentShaderATI() => GLPointers.glBeginFragmentShaderATI_Lazy();
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glBindFragmentShaderATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void BindFragmentShaderATI(uint id) => GLPointers.glBindFragmentShaderATI_Lazy(id);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glClientActiveVertexStreamATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void ClientActiveVertexStreamATI(VertexStreamATI stream) => GLPointers.glClientActiveVertexStreamATI_Lazy((uint)stream);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glColorFragmentOp1ATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void ColorFragmentOp1ATI(FragmentOp1ATI op, FragmentShaderRegATI dst, FragmentShaderDestMaskATI dstMask, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod) => GLPointers.glColorFragmentOp1ATI_Lazy((uint)op, (uint)dst, (uint)dstMask, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glColorFragmentOp2ATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void ColorFragmentOp2ATI(FragmentOp2ATI op, FragmentShaderRegATI dst, FragmentShaderDestMaskATI dstMask, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod) => GLPointers.glColorFragmentOp2ATI_Lazy((uint)op, (uint)dst, (uint)dstMask, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glColorFragmentOp3ATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void ColorFragmentOp3ATI(FragmentOp3ATI op, FragmentShaderRegATI dst, FragmentShaderDestMaskATI dstMask, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod, FragmentShaderGenericSourceATI arg3, FragmentShaderValueRepATI arg3Rep, FragmentShaderColorModMaskATI arg3Mod) => GLPointers.glColorFragmentOp3ATI_Lazy((uint)op, (uint)dst, (uint)dstMask, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod, (uint)arg3, (uint)arg3Rep, (uint)arg3Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glDeleteFragmentShaderATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void DeleteFragmentShaderATI(uint id) => GLPointers.glDeleteFragmentShaderATI_Lazy(id);
            
            /// <summary> <b>[requires: GL_ATI_draw_buffers]</b> <b>[entry point: <c>glDrawBuffersATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_draw_buffers.txt"/></remarks>
            public static void DrawBuffersATI(int n, DrawBufferMode* bufs) => GLPointers.glDrawBuffersATI_Lazy(n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_ATI_element_array]</b> <b>[entry point: <c>glDrawElementArrayATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_element_array.txt"/></remarks>
            public static void DrawElementArrayATI(PrimitiveType mode, int count) => GLPointers.glDrawElementArrayATI_Lazy((uint)mode, count);
            
            /// <summary> <b>[requires: GL_ATI_element_array]</b> <b>[entry point: <c>glDrawRangeElementArrayATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_element_array.txt"/></remarks>
            public static void DrawRangeElementArrayATI(PrimitiveType mode, uint start, uint end, int count) => GLPointers.glDrawRangeElementArrayATI_Lazy((uint)mode, start, end, count);
            
            /// <summary> <b>[requires: GL_ATI_element_array]</b> <b>[entry point: <c>glElementPointerATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_element_array.txt"/></remarks>
            public static void ElementPointerATI(ElementPointerTypeATI type, void* pointer) => GLPointers.glElementPointerATI_Lazy((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glEndFragmentShaderATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void EndFragmentShaderATI() => GLPointers.glEndFragmentShaderATI_Lazy();
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glFreeObjectBufferATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void FreeObjectBufferATI(int buffer) => GLPointers.glFreeObjectBufferATI_Lazy(buffer);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glGenFragmentShadersATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static uint GenFragmentShadersATI(uint range) => GLPointers.glGenFragmentShadersATI_Lazy(range);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetArrayObjectfvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void GetArrayObjectfvATI(EnableCap array, ArrayObjectPNameATI pname, float* parameters) => GLPointers.glGetArrayObjectfvATI_Lazy((uint)array, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetArrayObjectivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void GetArrayObjectivATI(EnableCap array, ArrayObjectPNameATI pname, int* parameters) => GLPointers.glGetArrayObjectivATI_Lazy((uint)array, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetObjectBufferfvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void GetObjectBufferfvATI(int buffer, ArrayObjectPNameATI pname, float* parameters) => GLPointers.glGetObjectBufferfvATI_Lazy(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetObjectBufferivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void GetObjectBufferivATI(int buffer, ArrayObjectPNameATI pname, int* parameters) => GLPointers.glGetObjectBufferivATI_Lazy(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b> <b>[entry point: <c>glGetTexBumpParameterfvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_envmap_bumpmap.txt"/></remarks>
            public static void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, float* param) => GLPointers.glGetTexBumpParameterfvATI_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b> <b>[entry point: <c>glGetTexBumpParameterivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_envmap_bumpmap.txt"/></remarks>
            public static void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, int* param) => GLPointers.glGetTexBumpParameterivATI_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetVariantArrayObjectfvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void GetVariantArrayObjectfvATI(uint id, ArrayObjectPNameATI pname, float* parameters) => GLPointers.glGetVariantArrayObjectfvATI_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetVariantArrayObjectivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void GetVariantArrayObjectivATI(uint id, ArrayObjectPNameATI pname, int* parameters) => GLPointers.glGetVariantArrayObjectivATI_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b> <b>[entry point: <c>glGetVertexAttribArrayObjectfvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_attrib_array_object.txt"/></remarks>
            public static void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, float* parameters) => GLPointers.glGetVertexAttribArrayObjectfvATI_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b> <b>[entry point: <c>glGetVertexAttribArrayObjectivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_attrib_array_object.txt"/></remarks>
            public static void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, int* parameters) => GLPointers.glGetVertexAttribArrayObjectivATI_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glIsObjectBufferATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static bool IsObjectBufferATI(int buffer) => GLPointers.glIsObjectBufferATI_Lazy(buffer) != 0;
            
            /// <summary> <b>[requires: GL_ATI_map_object_buffer]</b> <b>[entry point: <c>glMapObjectBufferATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_map_object_buffer.txt"/></remarks>
            public static void* MapObjectBufferATI(int buffer) => GLPointers.glMapObjectBufferATI_Lazy(buffer);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glNewObjectBufferATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static uint NewObjectBufferATI(int size, void* pointer, ArrayObjectUsageATI usage) => GLPointers.glNewObjectBufferATI_Lazy(size, pointer, (uint)usage);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3bATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3bATI(VertexStreamATI stream, sbyte nx, sbyte ny, sbyte nz) => GLPointers.glNormalStream3bATI_Lazy((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3bvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3bvATI(VertexStreamATI stream, sbyte* coords) => GLPointers.glNormalStream3bvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3dATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3dATI(VertexStreamATI stream, double nx, double ny, double nz) => GLPointers.glNormalStream3dATI_Lazy((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3dvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3dvATI(VertexStreamATI stream, double* coords) => GLPointers.glNormalStream3dvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3fATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3fATI(VertexStreamATI stream, float nx, float ny, float nz) => GLPointers.glNormalStream3fATI_Lazy((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3fvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3fvATI(VertexStreamATI stream, float* coords) => GLPointers.glNormalStream3fvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3iATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3iATI(VertexStreamATI stream, int nx, int ny, int nz) => GLPointers.glNormalStream3iATI_Lazy((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3ivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3ivATI(VertexStreamATI stream, int* coords) => GLPointers.glNormalStream3ivATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3sATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3sATI(VertexStreamATI stream, short nx, short ny, short nz) => GLPointers.glNormalStream3sATI_Lazy((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3svATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void NormalStream3svATI(VertexStreamATI stream, short* coords) => GLPointers.glNormalStream3svATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glPassTexCoordATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void PassTexCoordATI(FragmentShaderRegATI dst, FragmentShaderTextureSourceATI coord, SwizzleOpATI swizzle) => GLPointers.glPassTexCoordATI_Lazy((uint)dst, (uint)coord, (uint)swizzle);
            
            /// <summary> <b>[requires: GL_ATI_pn_triangles]</b> <b>[entry point: <c>glPNTrianglesfATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_pn_triangles.txt"/></remarks>
            public static void PNTrianglesfATI(PNTrianglesPNameATI pname, float param) => GLPointers.glPNTrianglesfATI_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_pn_triangles]</b> <b>[entry point: <c>glPNTrianglesiATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_pn_triangles.txt"/></remarks>
            public static void PNTrianglesiATI(PNTrianglesPNameATI pname, int param) => GLPointers.glPNTrianglesiATI_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glSampleMapATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void SampleMapATI(FragmentShaderRegATI dst, FragmentShaderTextureSourceATI interp, SwizzleOpATI swizzle) => GLPointers.glSampleMapATI_Lazy((uint)dst, (uint)interp, (uint)swizzle);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glSetFragmentShaderConstantATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_fragment_shader.txt"/></remarks>
            public static void SetFragmentShaderConstantATI(FragmentShaderConATI dst, float* value) => GLPointers.glSetFragmentShaderConstantATI_Lazy((uint)dst, value);
            
            /// <summary> <b>[requires: GL_ATI_separate_stencil]</b> <b>[entry point: <c>glStencilFuncSeparateATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_separate_stencil.txt"/></remarks>
            public static void StencilFuncSeparateATI(StencilFunction frontfunc, StencilFunction backfunc, int reference, uint mask) => GLPointers.glStencilFuncSeparateATI_Lazy((uint)frontfunc, (uint)backfunc, reference, mask);
            
            /// <summary> <b>[requires: GL_ATI_separate_stencil]</b> <b>[entry point: <c>glStencilOpSeparateATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_separate_stencil.txt"/></remarks>
            public static void StencilOpSeparateATI(TriangleFace face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => GLPointers.glStencilOpSeparateATI_Lazy((uint)face, (uint)sfail, (uint)dpfail, (uint)dppass);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b> <b>[entry point: <c>glTexBumpParameterfvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_envmap_bumpmap.txt"/></remarks>
            public static void TexBumpParameterfvATI(TexBumpParameterATI pname, float* param) => GLPointers.glTexBumpParameterfvATI_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b> <b>[entry point: <c>glTexBumpParameterivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_envmap_bumpmap.txt"/></remarks>
            public static void TexBumpParameterivATI(TexBumpParameterATI pname, int* param) => GLPointers.glTexBumpParameterivATI_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_map_object_buffer]</b> <b>[entry point: <c>glUnmapObjectBufferATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_map_object_buffer.txt"/></remarks>
            public static void UnmapObjectBufferATI(int buffer) => GLPointers.glUnmapObjectBufferATI_Lazy(buffer);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glUpdateObjectBufferATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void UpdateObjectBufferATI(int buffer, uint offset, int size, void* pointer, PreserveModeATI preserve) => GLPointers.glUpdateObjectBufferATI_Lazy(buffer, offset, size, pointer, (uint)preserve);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glVariantArrayObjectATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_array_object.txt"/></remarks>
            public static void VariantArrayObjectATI(uint id, ScalarType type, int stride, int buffer, uint offset) => GLPointers.glVariantArrayObjectATI_Lazy(id, (uint)type, stride, buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b> <b>[entry point: <c>glVertexAttribArrayObjectATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_attrib_array_object.txt"/></remarks>
            public static void VertexAttribArrayObjectATI(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, int buffer, uint offset) => GLPointers.glVertexAttribArrayObjectATI_Lazy(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexBlendEnvfATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexBlendEnvfATI(VertexStreamATI pname, float param) => GLPointers.glVertexBlendEnvfATI_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexBlendEnviATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexBlendEnviATI(VertexStreamATI pname, int param) => GLPointers.glVertexBlendEnviATI_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1dATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream1dATI(VertexStreamATI stream, double x) => GLPointers.glVertexStream1dATI_Lazy((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1dvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream1dvATI(VertexStreamATI stream, double* coords) => GLPointers.glVertexStream1dvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1fATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream1fATI(VertexStreamATI stream, float x) => GLPointers.glVertexStream1fATI_Lazy((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1fvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream1fvATI(VertexStreamATI stream, float* coords) => GLPointers.glVertexStream1fvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1iATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream1iATI(VertexStreamATI stream, int x) => GLPointers.glVertexStream1iATI_Lazy((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1ivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream1ivATI(VertexStreamATI stream, int* coords) => GLPointers.glVertexStream1ivATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1sATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream1sATI(VertexStreamATI stream, short x) => GLPointers.glVertexStream1sATI_Lazy((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1svATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream1svATI(VertexStreamATI stream, short* coords) => GLPointers.glVertexStream1svATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2dATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream2dATI(VertexStreamATI stream, double x, double y) => GLPointers.glVertexStream2dATI_Lazy((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2dvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream2dvATI(VertexStreamATI stream, double* coords) => GLPointers.glVertexStream2dvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2fATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream2fATI(VertexStreamATI stream, float x, float y) => GLPointers.glVertexStream2fATI_Lazy((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2fvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream2fvATI(VertexStreamATI stream, float* coords) => GLPointers.glVertexStream2fvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2iATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream2iATI(VertexStreamATI stream, int x, int y) => GLPointers.glVertexStream2iATI_Lazy((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2ivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream2ivATI(VertexStreamATI stream, int* coords) => GLPointers.glVertexStream2ivATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2sATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream2sATI(VertexStreamATI stream, short x, short y) => GLPointers.glVertexStream2sATI_Lazy((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2svATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream2svATI(VertexStreamATI stream, short* coords) => GLPointers.glVertexStream2svATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3dATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream3dATI(VertexStreamATI stream, double x, double y, double z) => GLPointers.glVertexStream3dATI_Lazy((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3dvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream3dvATI(VertexStreamATI stream, double* coords) => GLPointers.glVertexStream3dvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3fATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream3fATI(VertexStreamATI stream, float x, float y, float z) => GLPointers.glVertexStream3fATI_Lazy((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3fvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream3fvATI(VertexStreamATI stream, float* coords) => GLPointers.glVertexStream3fvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3iATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream3iATI(VertexStreamATI stream, int x, int y, int z) => GLPointers.glVertexStream3iATI_Lazy((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3ivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream3ivATI(VertexStreamATI stream, int* coords) => GLPointers.glVertexStream3ivATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3sATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream3sATI(VertexStreamATI stream, short x, short y, short z) => GLPointers.glVertexStream3sATI_Lazy((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3svATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream3svATI(VertexStreamATI stream, short* coords) => GLPointers.glVertexStream3svATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4dATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream4dATI(VertexStreamATI stream, double x, double y, double z, double w) => GLPointers.glVertexStream4dATI_Lazy((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4dvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream4dvATI(VertexStreamATI stream, double* coords) => GLPointers.glVertexStream4dvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4fATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream4fATI(VertexStreamATI stream, float x, float y, float z, float w) => GLPointers.glVertexStream4fATI_Lazy((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4fvATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream4fvATI(VertexStreamATI stream, float* coords) => GLPointers.glVertexStream4fvATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4iATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream4iATI(VertexStreamATI stream, int x, int y, int z, int w) => GLPointers.glVertexStream4iATI_Lazy((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4ivATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream4ivATI(VertexStreamATI stream, int* coords) => GLPointers.glVertexStream4ivATI_Lazy((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4sATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream4sATI(VertexStreamATI stream, short x, short y, short z, short w) => GLPointers.glVertexStream4sATI_Lazy((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4svATI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/ATI/ATI_vertex_streams.txt"/></remarks>
            public static void VertexStream4svATI(VertexStreamATI stream, short* coords) => GLPointers.glVertexStream4svATI_Lazy((uint)stream, coords);
            
        }
        /// <summary>EXT extensions.</summary>
        public static unsafe partial class EXT
        {
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex]</b> <b>[entry point: <c>glAcquireKeyedMutexWin32EXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_win32_keyed_mutex.txt"/></remarks>
            public static bool AcquireKeyedMutexWin32EXT(uint memory, ulong key, uint timeout) => GLPointers.glAcquireKeyedMutexWin32EXT_Lazy(memory, key, timeout) != 0;
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glActiveProgramEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ActiveProgramEXT(int program) => GLPointers.glActiveProgramEXT_Lazy(program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glActiveShaderProgramEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ActiveShaderProgramEXT(int pipeline, int program) => GLPointers.glActiveShaderProgramEXT_Lazy(pipeline, program);
            
            /// <summary> <b>[requires: GL_EXT_stencil_two_side]</b> <b>[entry point: <c>glActiveStencilFaceEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_stencil_two_side.txt"/></remarks>
            public static void ActiveStencilFaceEXT(TriangleFace face) => GLPointers.glActiveStencilFaceEXT_Lazy((uint)face);
            
            /// <summary> <b>[requires: GL_EXT_light_texture]</b> <b>[entry point: <c>glApplyTextureEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_light_texture.txt"/></remarks>
            public static void ApplyTextureEXT(LightTextureModeEXT mode) => GLPointers.glApplyTextureEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glAreTexturesResidentEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_object.txt"/></remarks>
            public static bool AreTexturesResidentEXT(int n, int* textures, bool* residences) => GLPointers.glAreTexturesResidentEXT_Lazy(n, textures, (byte*)residences) != 0;
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glArrayElementEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_array.txt"/></remarks>
            public static void ArrayElementEXT(int i) => GLPointers.glArrayElementEXT_Lazy(i);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glBeginTransformFeedbackEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_transform_feedback.txt"/></remarks>
            public static void BeginTransformFeedbackEXT(PrimitiveType primitiveMode) => GLPointers.glBeginTransformFeedbackEXT_Lazy((uint)primitiveMode);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBeginVertexShaderEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void BeginVertexShaderEXT() => GLPointers.glBeginVertexShaderEXT_Lazy();
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glBindBufferBaseEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_transform_feedback.txt"/></remarks>
            public static void BindBufferBaseEXT(BufferTarget target, uint index, int buffer) => GLPointers.glBindBufferBaseEXT_Lazy((uint)target, index, buffer);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glBindBufferOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_transform_feedback.txt"/></remarks>
            public static void BindBufferOffsetEXT(BufferTarget target, uint index, int buffer, IntPtr offset) => GLPointers.glBindBufferOffsetEXT_Lazy((uint)target, index, buffer, offset);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glBindBufferRangeEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_transform_feedback.txt"/></remarks>
            public static void BindBufferRangeEXT(BufferTarget target, uint index, int buffer, IntPtr offset, nint size) => GLPointers.glBindBufferRangeEXT_Lazy((uint)target, index, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glBindFragDataLocationEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void BindFragDataLocationEXT(int program, uint color, byte* name) => GLPointers.glBindFragDataLocationEXT_Lazy(program, color, name);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glBindFramebufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void BindFramebufferEXT(FramebufferTarget target, int framebuffer) => GLPointers.glBindFramebufferEXT_Lazy((uint)target, framebuffer);
            
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store]</b> <b>[entry point: <c>glBindImageTextureEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_shader_image_load_store.txt"/></remarks>
            public static void BindImageTextureEXT(uint index, int texture, int level, bool layered, int layer, BufferAccess access, int format) => GLPointers.glBindImageTextureEXT_Lazy(index, texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, format);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindLightParameterEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static uint BindLightParameterEXT(LightName light, LightParameter value) => GLPointers.glBindLightParameterEXT_Lazy((uint)light, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindMaterialParameterEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static uint BindMaterialParameterEXT(TriangleFace face, MaterialParameter value) => GLPointers.glBindMaterialParameterEXT_Lazy((uint)face, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glBindMultiTextureEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void BindMultiTextureEXT(TextureUnit texunit, TextureTarget target, int texture) => GLPointers.glBindMultiTextureEXT_Lazy((uint)texunit, (uint)target, texture);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindParameterEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static uint BindParameterEXT(VertexShaderParameterEXT value) => GLPointers.glBindParameterEXT_Lazy((uint)value);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glBindProgramPipelineEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void BindProgramPipelineEXT(int pipeline) => GLPointers.glBindProgramPipelineEXT_Lazy(pipeline);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glBindRenderbufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void BindRenderbufferEXT(RenderbufferTarget target, int renderbuffer) => GLPointers.glBindRenderbufferEXT_Lazy((uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindTexGenParameterEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static uint BindTexGenParameterEXT(TextureUnit unit, TextureCoordName coord, TextureGenParameter value) => GLPointers.glBindTexGenParameterEXT_Lazy((uint)unit, (uint)coord, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glBindTextureEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_object.txt"/></remarks>
            public static void BindTextureEXT(TextureTarget target, int texture) => GLPointers.glBindTextureEXT_Lazy((uint)target, texture);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindTextureUnitParameterEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static uint BindTextureUnitParameterEXT(TextureUnit unit, VertexShaderTextureUnitParameter value) => GLPointers.glBindTextureUnitParameterEXT_Lazy((uint)unit, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindVertexShaderEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void BindVertexShaderEXT(uint id) => GLPointers.glBindVertexShaderEXT_Lazy(id);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3bEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3bEXT(sbyte bx, sbyte by, sbyte bz) => GLPointers.glBinormal3bEXT_Lazy(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3bvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3bvEXT(sbyte* v) => GLPointers.glBinormal3bvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3dEXT(double bx, double by, double bz) => GLPointers.glBinormal3dEXT_Lazy(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3dvEXT(double* v) => GLPointers.glBinormal3dvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3fEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3fEXT(float bx, float by, float bz) => GLPointers.glBinormal3fEXT_Lazy(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3fvEXT(float* v) => GLPointers.glBinormal3fvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3iEXT(int bx, int by, int bz) => GLPointers.glBinormal3iEXT_Lazy(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3ivEXT(int* v) => GLPointers.glBinormal3ivEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3sEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3sEXT(short bx, short by, short bz) => GLPointers.glBinormal3sEXT_Lazy(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3svEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Binormal3svEXT(short* v) => GLPointers.glBinormal3svEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormalPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void BinormalPointerEXT(BinormalPointerTypeEXT type, int stride, void* pointer) => GLPointers.glBinormalPointerEXT_Lazy((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_blend_color]</b> <b>[entry point: <c>glBlendColorEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_blend_color.txt"/></remarks>
            public static void BlendColorEXT(float red, float green, float blue, float alpha) => GLPointers.glBlendColorEXT_Lazy(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_minmax]</b> <b>[entry point: <c>glBlendEquationEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_blend_minmax.txt"/></remarks>
            public static void BlendEquationEXT(BlendEquationMode mode) => GLPointers.glBlendEquationEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_blend_equation_separate]</b> <b>[entry point: <c>glBlendEquationSeparateEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_blend_equation_separate.txt"/></remarks>
            public static void BlendEquationSeparateEXT(BlendEquationMode modeRGB, BlendEquationMode modeAlpha) => GLPointers.glBlendEquationSeparateEXT_Lazy((uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_func_separate]</b> <b>[entry point: <c>glBlendFuncSeparateEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_blend_func_separate.txt"/></remarks>
            public static void BlendFuncSeparateEXT(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers.glBlendFuncSeparateEXT_Lazy((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit]</b> <b>[entry point: <c>glBlitFramebufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_blit.txt"/></remarks>
            public static void BlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers.glBlitFramebufferEXT_Lazy(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit_layers]</b> <b>[entry point: <c>glBlitFramebufferLayerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_blit_layers.txt"/></remarks>
            public static void BlitFramebufferLayerEXT(int srcX0, int srcY0, int srcX1, int srcY1, int srcLayer, int dstX0, int dstY0, int dstX1, int dstY1, int dstLayer, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers.glBlitFramebufferLayerEXT_Lazy(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit_layers]</b> <b>[entry point: <c>glBlitFramebufferLayersEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_blit_layers.txt"/></remarks>
            public static void BlitFramebufferLayersEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers.glBlitFramebufferLayersEXT_Lazy(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_external_buffer]</b> <b>[entry point: <c>glBufferStorageExternalEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_external_buffer.txt"/></remarks>
            public static void BufferStorageExternalEXT(All target, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => GLPointers.glBufferStorageExternalEXT_Lazy((uint)target, offset, size, clientBuffer, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glBufferStorageMemEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void BufferStorageMemEXT(BufferTarget target, nint size, uint memory, ulong offset) => GLPointers.glBufferStorageMemEXT_Lazy((uint)target, size, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glCheckFramebufferStatusEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static FramebufferStatus CheckFramebufferStatusEXT(FramebufferTarget target) => (FramebufferStatus) GLPointers.glCheckFramebufferStatusEXT_Lazy((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCheckNamedFramebufferStatusEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static FramebufferStatus CheckNamedFramebufferStatusEXT(int framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers.glCheckNamedFramebufferStatusEXT_Lazy(framebuffer, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glClearColorIiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_integer.txt"/></remarks>
            public static void ClearColorIiEXT(int red, int green, int blue, int alpha) => GLPointers.glClearColorIiEXT_Lazy(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glClearColorIuiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_integer.txt"/></remarks>
            public static void ClearColorIuiEXT(uint red, uint green, uint blue, uint alpha) => GLPointers.glClearColorIuiEXT_Lazy(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferDataEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ClearNamedBufferDataEXT(int buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers.glClearNamedBufferDataEXT_Lazy(buffer, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferSubDataEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ClearNamedBufferSubDataEXT(int buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers.glClearNamedBufferSubDataEXT_Lazy(buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glClientAttribDefaultEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ClientAttribDefaultEXT(ClientAttribMask mask) => GLPointers.glClientAttribDefaultEXT_Lazy((uint)mask);
            
            /// <summary> <b>[requires: GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glColorMaskIndexedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_draw_buffers2.txt"/></remarks>
            public static void ColorMaskIndexedEXT(uint index, bool r, bool g, bool b, bool a) => GLPointers.glColorMaskIndexedEXT_Lazy(index, (byte)(r ? 1 : 0), (byte)(g ? 1 : 0), (byte)(b ? 1 : 0), (byte)(a ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glColorPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_array.txt"/></remarks>
            public static void ColorPointerEXT(int size, ColorPointerType type, int stride, int count, void* pointer) => GLPointers.glColorPointerEXT_Lazy(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_color_subtable]</b> <b>[entry point: <c>glColorSubTableEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_color_subtable.txt"/></remarks>
            public static void ColorSubTableEXT(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data) => GLPointers.glColorSubTableEXT_Lazy((uint)target, start, count, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b> <b>[entry point: <c>glColorTableEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_paletted_texture.txt"/></remarks>
            public static void ColorTableEXT(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, void* table) => GLPointers.glColorTableEXT_Lazy((uint)target, (uint)internalFormat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => GLPointers.glCompressedMultiTexImage1DEXT_Lazy((uint)texunit, (uint)target, level, (uint)internalformat, width, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => GLPointers.glCompressedMultiTexImage2DEXT_Lazy((uint)texunit, (uint)target, level, (uint)internalformat, width, height, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedMultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => GLPointers.glCompressedMultiTexImage3DEXT_Lazy((uint)texunit, (uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexSubImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => GLPointers.glCompressedMultiTexSubImage1DEXT_Lazy((uint)texunit, (uint)target, level, xoffset, width, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexSubImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => GLPointers.glCompressedMultiTexSubImage2DEXT_Lazy((uint)texunit, (uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexSubImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => GLPointers.glCompressedMultiTexSubImage3DEXT_Lazy((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedTextureImage1DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => GLPointers.glCompressedTextureImage1DEXT_Lazy(texture, (uint)target, level, (uint)internalformat, width, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedTextureImage2DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => GLPointers.glCompressedTextureImage2DEXT_Lazy(texture, (uint)target, level, (uint)internalformat, width, height, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedTextureImage3DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => GLPointers.glCompressedTextureImage3DEXT_Lazy(texture, (uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedTextureSubImage1DEXT(int texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => GLPointers.glCompressedTextureSubImage1DEXT_Lazy(texture, (uint)target, level, xoffset, width, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedTextureSubImage2DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => GLPointers.glCompressedTextureSubImage2DEXT_Lazy(texture, (uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CompressedTextureSubImage3DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => GLPointers.glCompressedTextureSubImage3DEXT_Lazy(texture, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionFilter1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void ConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image) => GLPointers.glConvolutionFilter1DEXT_Lazy((uint)target, (uint)internalformat, width, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionFilter2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void ConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image) => GLPointers.glConvolutionFilter2DEXT_Lazy((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionParameterfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void ConvolutionParameterfEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, float parameters) => GLPointers.glConvolutionParameterfEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, float* parameters) => GLPointers.glConvolutionParameterfvEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionParameteriEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void ConvolutionParameteriEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, int parameters) => GLPointers.glConvolutionParameteriEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, int* parameters) => GLPointers.glConvolutionParameterivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_color_subtable]</b> <b>[entry point: <c>glCopyColorSubTableEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_color_subtable.txt"/></remarks>
            public static void CopyColorSubTableEXT(ColorTableTarget target, int start, int x, int y, int width) => GLPointers.glCopyColorSubTableEXT_Lazy((uint)target, start, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glCopyConvolutionFilter1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void CopyConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width) => GLPointers.glCopyConvolutionFilter1DEXT_Lazy((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glCopyConvolutionFilter2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void CopyConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width, int height) => GLPointers.glCopyConvolutionFilter2DEXT_Lazy((uint)target, (uint)internalformat, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers.glCopyMultiTexImage1DEXT_Lazy((uint)texunit, (uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers.glCopyMultiTexImage2DEXT_Lazy((uint)texunit, (uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexSubImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers.glCopyMultiTexSubImage1DEXT_Lazy((uint)texunit, (uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexSubImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers.glCopyMultiTexSubImage2DEXT_Lazy((uint)texunit, (uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexSubImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers.glCopyMultiTexSubImage3DEXT_Lazy((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_copy_texture.txt"/></remarks>
            public static void CopyTexImage1DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers.glCopyTexImage1DEXT_Lazy((uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_copy_texture.txt"/></remarks>
            public static void CopyTexImage2DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers.glCopyTexImage2DEXT_Lazy((uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexSubImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_copy_texture.txt"/></remarks>
            public static void CopyTexSubImage1DEXT(TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers.glCopyTexSubImage1DEXT_Lazy((uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexSubImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_copy_texture.txt"/></remarks>
            public static void CopyTexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers.glCopyTexSubImage2DEXT_Lazy((uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexSubImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_copy_texture.txt"/></remarks>
            public static void CopyTexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers.glCopyTexSubImage3DEXT_Lazy((uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyTextureImage1DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers.glCopyTextureImage1DEXT_Lazy(texture, (uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyTextureImage2DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers.glCopyTextureImage2DEXT_Lazy(texture, (uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyTextureSubImage1DEXT(int texture, TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers.glCopyTextureSubImage1DEXT_Lazy(texture, (uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyTextureSubImage2DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers.glCopyTextureSubImage2DEXT_Lazy(texture, (uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void CopyTextureSubImage3DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers.glCopyTextureSubImage3DEXT_Lazy(texture, (uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glCreateMemoryObjectsEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void CreateMemoryObjectsEXT(int n, uint* memoryObjects) => GLPointers.glCreateMemoryObjectsEXT_Lazy(n, memoryObjects);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glCreateShaderProgramEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static int CreateShaderProgramEXT(ShaderType type, byte* str) => GLPointers.glCreateShaderProgramEXT_Lazy((uint)type, str);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glCreateShaderProgramvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static int CreateShaderProgramvEXT(ShaderType type, int count, byte** strings) => GLPointers.glCreateShaderProgramvEXT_Lazy((uint)type, count, strings);
            
            /// <summary> <b>[requires: GL_EXT_cull_vertex]</b> <b>[entry point: <c>glCullParameterdvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_cull_vertex.txt"/></remarks>
            public static void CullParameterdvEXT(CullParameterEXT pname, double* parameters) => GLPointers.glCullParameterdvEXT_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_cull_vertex]</b> <b>[entry point: <c>glCullParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_cull_vertex.txt"/></remarks>
            public static void CullParameterfvEXT(CullParameterEXT pname, float* parameters) => GLPointers.glCullParameterfvEXT_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glDeleteFramebuffersEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void DeleteFramebuffersEXT(int n, int* framebuffers) => GLPointers.glDeleteFramebuffersEXT_Lazy(n, framebuffers);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glDeleteMemoryObjectsEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void DeleteMemoryObjectsEXT(int n, uint* memoryObjects) => GLPointers.glDeleteMemoryObjectsEXT_Lazy(n, memoryObjects);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glDeleteProgramPipelinesEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void DeleteProgramPipelinesEXT(int n, int* pipelines) => GLPointers.glDeleteProgramPipelinesEXT_Lazy(n, pipelines);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glDeleteRenderbuffersEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void DeleteRenderbuffersEXT(int n, int* renderbuffers) => GLPointers.glDeleteRenderbuffersEXT_Lazy(n, renderbuffers);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glDeleteSemaphoresEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore.txt"/></remarks>
            public static void DeleteSemaphoresEXT(int n, uint* semaphores) => GLPointers.glDeleteSemaphoresEXT_Lazy(n, semaphores);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glDeleteTexturesEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_object.txt"/></remarks>
            public static void DeleteTexturesEXT(int n, int* textures) => GLPointers.glDeleteTexturesEXT_Lazy(n, textures);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glDeleteVertexShaderEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void DeleteVertexShaderEXT(uint id) => GLPointers.glDeleteVertexShaderEXT_Lazy(id);
            
            /// <summary> <b>[requires: GL_EXT_depth_bounds_test]</b> <b>[entry point: <c>glDepthBoundsEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_depth_bounds_test.txt"/></remarks>
            public static void DepthBoundsEXT(double zmin, double zmax) => GLPointers.glDepthBoundsEXT_Lazy(zmin, zmax);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glDisableClientStateiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void DisableClientStateiEXT(EnableCap array, uint index) => GLPointers.glDisableClientStateiEXT_Lazy((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glDisableClientStateIndexedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void DisableClientStateIndexedEXT(EnableCap array, uint index) => GLPointers.glDisableClientStateIndexedEXT_Lazy((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glDisableIndexedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_draw_buffers2.txt"/></remarks>
            public static void DisableIndexedEXT(EnableCap target, uint index) => GLPointers.glDisableIndexedEXT_Lazy((uint)target, index);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glDisableVariantClientStateEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void DisableVariantClientStateEXT(uint id) => GLPointers.glDisableVariantClientStateEXT_Lazy(id);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glDisableVertexArrayAttribEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void DisableVertexArrayAttribEXT(int vaobj, uint index) => GLPointers.glDisableVertexArrayAttribEXT_Lazy(vaobj, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glDisableVertexArrayEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void DisableVertexArrayEXT(int vaobj, EnableCap array) => GLPointers.glDisableVertexArrayEXT_Lazy(vaobj, (uint)array);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glDrawArraysEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_array.txt"/></remarks>
            public static void DrawArraysEXT(PrimitiveType mode, int first, int count) => GLPointers.glDrawArraysEXT_Lazy((uint)mode, first, count);
            
            /// <summary> <b>[requires: GL_EXT_draw_instanced]</b> <b>[entry point: <c>glDrawArraysInstancedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_draw_instanced.txt"/></remarks>
            public static void DrawArraysInstancedEXT(PrimitiveType mode, int start, int count, int primcount) => GLPointers.glDrawArraysInstancedEXT_Lazy((uint)mode, start, count, primcount);
            
            /// <summary> <b>[requires: GL_EXT_draw_instanced]</b> <b>[entry point: <c>glDrawElementsInstancedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_draw_instanced.txt"/></remarks>
            public static void DrawElementsInstancedEXT(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => GLPointers.glDrawElementsInstancedEXT_Lazy((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_EXT_draw_range_elements]</b> <b>[entry point: <c>glDrawRangeElementsEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_draw_range_elements.txt"/></remarks>
            public static void DrawRangeElementsEXT(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => GLPointers.glDrawRangeElementsEXT_Lazy((uint)mode, start, end, count, (uint)type, indices);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glEdgeFlagPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_array.txt"/></remarks>
            public static void EdgeFlagPointerEXT(int stride, int count, bool* pointer) => GLPointers.glEdgeFlagPointerEXT_Lazy(stride, count, (byte*)pointer);
            
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage]</b> <b>[entry point: <c>glEGLImageTargetTexStorageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_EGL_image_storage.txt"/></remarks>
            public static void EGLImageTargetTexStorageEXT(All target, void* image, int* attrib_list) => GLPointers.glEGLImageTargetTexStorageEXT_Lazy((uint)target, image, attrib_list);
            
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage]</b> <b>[entry point: <c>glEGLImageTargetTextureStorageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_EGL_image_storage.txt"/></remarks>
            public static void EGLImageTargetTextureStorageEXT(int texture, void* image, int* attrib_list) => GLPointers.glEGLImageTargetTextureStorageEXT_Lazy(texture, image, attrib_list);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glEnableClientStateiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void EnableClientStateiEXT(EnableCap array, uint index) => GLPointers.glEnableClientStateiEXT_Lazy((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glEnableClientStateIndexedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void EnableClientStateIndexedEXT(EnableCap array, uint index) => GLPointers.glEnableClientStateIndexedEXT_Lazy((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glEnableIndexedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_draw_buffers2.txt"/></remarks>
            public static void EnableIndexedEXT(EnableCap target, uint index) => GLPointers.glEnableIndexedEXT_Lazy((uint)target, index);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glEnableVariantClientStateEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void EnableVariantClientStateEXT(uint id) => GLPointers.glEnableVariantClientStateEXT_Lazy(id);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glEnableVertexArrayAttribEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void EnableVertexArrayAttribEXT(int vaobj, uint index) => GLPointers.glEnableVertexArrayAttribEXT_Lazy(vaobj, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glEnableVertexArrayEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void EnableVertexArrayEXT(int vaobj, EnableCap array) => GLPointers.glEnableVertexArrayEXT_Lazy(vaobj, (uint)array);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glEndTransformFeedbackEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_transform_feedback.txt"/></remarks>
            public static void EndTransformFeedbackEXT() => GLPointers.glEndTransformFeedbackEXT_Lazy();
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glEndVertexShaderEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void EndVertexShaderEXT() => GLPointers.glEndVertexShaderEXT_Lazy();
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glExtractComponentEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void ExtractComponentEXT(uint res, uint src, uint num) => GLPointers.glExtractComponentEXT_Lazy(res, src, num);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glFlushMappedNamedBufferRangeEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void FlushMappedNamedBufferRangeEXT(int buffer, IntPtr offset, nint length) => GLPointers.glFlushMappedNamedBufferRangeEXT_Lazy(buffer, offset, length);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoorddEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_fog_coord.txt"/></remarks>
            public static void FogCoorddEXT(double coord) => GLPointers.glFogCoorddEXT_Lazy(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoorddvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_fog_coord.txt"/></remarks>
            public static void FogCoorddvEXT(double* coord) => GLPointers.glFogCoorddvEXT_Lazy(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoordfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_fog_coord.txt"/></remarks>
            public static void FogCoordfEXT(float coord) => GLPointers.glFogCoordfEXT_Lazy(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoordfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_fog_coord.txt"/></remarks>
            public static void FogCoordfvEXT(float* coord) => GLPointers.glFogCoordfvEXT_Lazy(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoordPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_fog_coord.txt"/></remarks>
            public static void FogCoordPointerEXT(FogPointerTypeEXT type, int stride, void* pointer) => GLPointers.glFogCoordPointerEXT_Lazy((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glFramebufferDrawBufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void FramebufferDrawBufferEXT(int framebuffer, DrawBufferMode mode) => GLPointers.glFramebufferDrawBufferEXT_Lazy(framebuffer, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glFramebufferDrawBuffersEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void FramebufferDrawBuffersEXT(int framebuffer, int n, DrawBufferMode* bufs) => GLPointers.glFramebufferDrawBuffersEXT_Lazy(framebuffer, n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_EXT_shader_framebuffer_fetch_non_coherent]</b> <b>[entry point: <c>glFramebufferFetchBarrierEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_shader_framebuffer_fetch_non_coherent.txt"/></remarks>
            public static void FramebufferFetchBarrierEXT() => GLPointers.glFramebufferFetchBarrierEXT_Lazy();
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glFramebufferReadBufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void FramebufferReadBufferEXT(int framebuffer, ReadBufferMode mode) => GLPointers.glFramebufferReadBufferEXT_Lazy(framebuffer, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glFramebufferRenderbufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void FramebufferRenderbufferEXT(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers.glFramebufferRenderbufferEXT_Lazy((uint)target, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void FramebufferTexture1DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers.glFramebufferTexture1DEXT_Lazy((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void FramebufferTexture2DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers.glFramebufferTexture2DEXT_Lazy((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void FramebufferTexture3DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers.glFramebufferTexture3DEXT_Lazy((uint)target, (uint)attachment, (uint)textarget, texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4]</b> <b>[entry point: <c>glFramebufferTextureLayerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_array.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_geometry_program4.txt"/></remarks>
            public static void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers.glFramebufferTextureLayerEXT_Lazy((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGenerateMipmapEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void GenerateMipmapEXT(TextureTarget target) => GLPointers.glGenerateMipmapEXT_Lazy((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGenerateMultiTexMipmapEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GenerateMultiTexMipmapEXT(TextureUnit texunit, TextureTarget target) => GLPointers.glGenerateMultiTexMipmapEXT_Lazy((uint)texunit, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGenerateTextureMipmapEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GenerateTextureMipmapEXT(int texture, TextureTarget target) => GLPointers.glGenerateTextureMipmapEXT_Lazy(texture, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGenFramebuffersEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void GenFramebuffersEXT(int n, int* framebuffers) => GLPointers.glGenFramebuffersEXT_Lazy(n, framebuffers);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glGenProgramPipelinesEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void GenProgramPipelinesEXT(int n, int* pipelines) => GLPointers.glGenProgramPipelinesEXT_Lazy(n, pipelines);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGenRenderbuffersEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void GenRenderbuffersEXT(int n, int* renderbuffers) => GLPointers.glGenRenderbuffersEXT_Lazy(n, renderbuffers);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glGenSemaphoresEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore.txt"/></remarks>
            public static void GenSemaphoresEXT(int n, uint* semaphores) => GLPointers.glGenSemaphoresEXT_Lazy(n, semaphores);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGenSymbolsEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static uint GenSymbolsEXT(DataTypeEXT datatype, VertexShaderStorageTypeEXT storagetype, ParameterRangeEXT range, uint components) => GLPointers.glGenSymbolsEXT_Lazy((uint)datatype, (uint)storagetype, (uint)range, components);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glGenTexturesEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_object.txt"/></remarks>
            public static void GenTexturesEXT(int n, int* textures) => GLPointers.glGenTexturesEXT_Lazy(n, textures);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGenVertexShadersEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static uint GenVertexShadersEXT(uint range) => GLPointers.glGenVertexShadersEXT_Lazy(range);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glGetBooleanIndexedvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_draw_buffers2.txt"/></remarks>
            public static void GetBooleanIndexedvEXT(BufferTarget target, uint index, bool* data) => GLPointers.glGetBooleanIndexedvEXT_Lazy((uint)target, index, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b> <b>[entry point: <c>glGetColorTableEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_paletted_texture.txt"/></remarks>
            public static void GetColorTableEXT(ColorTableTarget target, PixelFormat format, PixelType type, void* data) => GLPointers.glGetColorTableEXT_Lazy((uint)target, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b> <b>[entry point: <c>glGetColorTableParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_paletted_texture.txt"/></remarks>
            public static void GetColorTableParameterfvEXT(ColorTableTarget target, ColorTableParameterPName pname, float* parameters) => GLPointers.glGetColorTableParameterfvEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b> <b>[entry point: <c>glGetColorTableParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_paletted_texture.txt"/></remarks>
            public static void GetColorTableParameterivEXT(ColorTableTarget target, ColorTableParameterPName pname, int* parameters) => GLPointers.glGetColorTableParameterivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetCompressedMultiTexImageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetCompressedMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int lod, void* img) => GLPointers.glGetCompressedMultiTexImageEXT_Lazy((uint)texunit, (uint)target, lod, img);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetCompressedTextureImageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetCompressedTextureImageEXT(int texture, TextureTarget target, int lod, void* img) => GLPointers.glGetCompressedTextureImageEXT_Lazy(texture, (uint)target, lod, img);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glGetConvolutionFilterEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void GetConvolutionFilterEXT(ConvolutionTargetEXT target, PixelFormat format, PixelType type, void* image) => GLPointers.glGetConvolutionFilterEXT_Lazy((uint)target, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glGetConvolutionParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, float* parameters) => GLPointers.glGetConvolutionParameterfvEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glGetConvolutionParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, int* parameters) => GLPointers.glGetConvolutionParameterivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetDoublei_vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetDoublei_vEXT(GetPName pname, uint index, double* parameters) => GLPointers.glGetDoublei_vEXT_Lazy((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetDoubleIndexedvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetDoubleIndexedvEXT(GetPName target, uint index, double* data) => GLPointers.glGetDoubleIndexedvEXT_Lazy((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetFloati_vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetFloati_vEXT(GetPName pname, uint index, float* parameters) => GLPointers.glGetFloati_vEXT_Lazy((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetFloatIndexedvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetFloatIndexedvEXT(GetPName target, uint index, float* data) => GLPointers.glGetFloatIndexedvEXT_Lazy((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glGetFragDataLocationEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static int GetFragDataLocationEXT(int program, byte* name) => GLPointers.glGetFragDataLocationEXT_Lazy(program, name);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGetFramebufferAttachmentParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers.glGetFramebufferAttachmentParameterivEXT_Lazy((uint)target, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetFramebufferParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetFramebufferParameterivEXT(int framebuffer, GetFramebufferParameter pname, int* parameters) => GLPointers.glGetFramebufferParameterivEXT_Lazy(framebuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetHistogramEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void GetHistogramEXT(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers.glGetHistogramEXT_Lazy((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetHistogramParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters) => GLPointers.glGetHistogramParameterfvEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetHistogramParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers.glGetHistogramParameterivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glGetIntegerIndexedvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_draw_buffers2.txt"/></remarks>
            public static void GetIntegerIndexedvEXT(GetPName target, uint index, int* data) => GLPointers.glGetIntegerIndexedvEXT_Lazy((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetInvariantBooleanvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, bool* data) => GLPointers.glGetInvariantBooleanvEXT_Lazy(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetInvariantFloatvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => GLPointers.glGetInvariantFloatvEXT_Lazy(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetInvariantIntegervEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => GLPointers.glGetInvariantIntegervEXT_Lazy(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetLocalConstantBooleanvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, bool* data) => GLPointers.glGetLocalConstantBooleanvEXT_Lazy(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetLocalConstantFloatvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => GLPointers.glGetLocalConstantFloatvEXT_Lazy(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetLocalConstantIntegervEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => GLPointers.glGetLocalConstantIntegervEXT_Lazy(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glGetMemoryObjectParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void GetMemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => GLPointers.glGetMemoryObjectParameterivEXT_Lazy(memoryObject, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetMinmaxEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void GetMinmaxEXT(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers.glGetMinmaxEXT_Lazy((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetMinmaxParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters) => GLPointers.glGetMinmaxParameterfvEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetMinmaxParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters) => GLPointers.glGetMinmaxParameterivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexEnvfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers.glGetMultiTexEnvfvEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexEnvivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers.glGetMultiTexEnvivEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexGendvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers.glGetMultiTexGendvEXT_Lazy((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexGenfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers.glGetMultiTexGenfvEXT_Lazy((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexGenivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers.glGetMultiTexGenivEXT_Lazy((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexImageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers.glGetMultiTexImageEXT_Lazy((uint)texunit, (uint)target, level, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexLevelParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers.glGetMultiTexLevelParameterfvEXT_Lazy((uint)texunit, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexLevelParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers.glGetMultiTexLevelParameterivEXT_Lazy((uint)texunit, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers.glGetMultiTexParameterfvEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexParameterIivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers.glGetMultiTexParameterIivEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexParameterIuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers.glGetMultiTexParameterIuivEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers.glGetMultiTexParameterivEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedBufferParameterivEXT(int buffer, BufferPName pname, int* parameters) => GLPointers.glGetNamedBufferParameterivEXT_Lazy(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferPointervEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedBufferPointervEXT(int buffer, BufferPointerNameARB pname, void** parameters) => GLPointers.glGetNamedBufferPointervEXT_Lazy(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferSubDataEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedBufferSubDataEXT(int buffer, IntPtr offset, nint size, void* data) => GLPointers.glGetNamedBufferSubDataEXT_Lazy(buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferAttachmentParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedFramebufferAttachmentParameterivEXT(int framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers.glGetNamedFramebufferAttachmentParameterivEXT_Lazy(framebuffer, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedFramebufferParameterivEXT(int framebuffer, GetFramebufferParameter pname, int* parameters) => GLPointers.glGetNamedFramebufferParameterivEXT_Lazy(framebuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedProgramivEXT(int program, ProgramTarget target, ProgramProperty pname, int* parameters) => GLPointers.glGetNamedProgramivEXT_Lazy(program, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramLocalParameterdvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedProgramLocalParameterdvEXT(int program, ProgramTarget target, uint index, double* parameters) => GLPointers.glGetNamedProgramLocalParameterdvEXT_Lazy(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramLocalParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedProgramLocalParameterfvEXT(int program, ProgramTarget target, uint index, float* parameters) => GLPointers.glGetNamedProgramLocalParameterfvEXT_Lazy(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramLocalParameterIivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedProgramLocalParameterIivEXT(int program, ProgramTarget target, uint index, int* parameters) => GLPointers.glGetNamedProgramLocalParameterIivEXT_Lazy(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramLocalParameterIuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedProgramLocalParameterIuivEXT(int program, ProgramTarget target, uint index, uint* parameters) => GLPointers.glGetNamedProgramLocalParameterIuivEXT_Lazy(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramStringEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedProgramStringEXT(int program, ProgramTarget target, ProgramStringProperty pname, void* str) => GLPointers.glGetNamedProgramStringEXT_Lazy(program, (uint)target, (uint)pname, str);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedRenderbufferParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetNamedRenderbufferParameterivEXT(int renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers.glGetNamedRenderbufferParameterivEXT_Lazy(renderbuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_debug_label]</b> <b>[entry point: <c>glGetObjectLabelEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_debug_label.txt"/></remarks>
            public static void GetObjectLabelEXT(All type, uint obj, int bufSize, int* length, byte* label) => GLPointers.glGetObjectLabelEXT_Lazy((uint)type, obj, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glGetPixelTransformParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_pixel_transform.txt"/></remarks>
            public static void GetPixelTransformParameterfvEXT(All target, All pname, float* parameters) => GLPointers.glGetPixelTransformParameterfvEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glGetPixelTransformParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_pixel_transform.txt"/></remarks>
            public static void GetPixelTransformParameterivEXT(All target, All pname, int* parameters) => GLPointers.glGetPixelTransformParameterivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetPointeri_vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetPointeri_vEXT(All pname, uint index, void** parameters) => GLPointers.glGetPointeri_vEXT_Lazy((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetPointerIndexedvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetPointerIndexedvEXT(All target, uint index, void** data) => GLPointers.glGetPointerIndexedvEXT_Lazy((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glGetPointervEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_array.txt"/></remarks>
            public static void GetPointervEXT(GetPointervPName pname, void** parameters) => GLPointers.glGetPointervEXT_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineInfoLogEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void GetProgramPipelineInfoLogEXT(int pipeline, int bufSize, int* length, byte* infoLog) => GLPointers.glGetProgramPipelineInfoLogEXT_Lazy(pipeline, bufSize, length, infoLog);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void GetProgramPipelineivEXT(int pipeline, PipelineParameterName pname, int* parameters) => GLPointers.glGetProgramPipelineivEXT_Lazy(pipeline, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_timer_query]</b> <b>[entry point: <c>glGetQueryObjecti64vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_timer_query.txt"/></remarks>
            public static void GetQueryObjecti64vEXT(int id, QueryObjectParameterName pname, long* parameters) => GLPointers.glGetQueryObjecti64vEXT_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_timer_query]</b> <b>[entry point: <c>glGetQueryObjectui64vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_timer_query.txt"/></remarks>
            public static void GetQueryObjectui64vEXT(int id, QueryObjectParameterName pname, ulong* parameters) => GLPointers.glGetQueryObjectui64vEXT_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGetRenderbufferParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers.glGetRenderbufferParameterivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glGetSemaphoreParameterui64vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore.txt"/></remarks>
            public static void GetSemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => GLPointers.glGetSemaphoreParameterui64vEXT_Lazy(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glGetSeparableFilterEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void GetSeparableFilterEXT(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span) => GLPointers.glGetSeparableFilterEXT_Lazy((uint)target, (uint)format, (uint)type, row, column, span);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glGetTexParameterIivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_integer.txt"/></remarks>
            public static void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers.glGetTexParameterIivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glGetTexParameterIuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_integer.txt"/></remarks>
            public static void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers.glGetTexParameterIuivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureImageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetTextureImageEXT(int texture, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers.glGetTextureImageEXT_Lazy(texture, (uint)target, level, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetTextureLevelParameterfvEXT(int texture, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers.glGetTextureLevelParameterfvEXT_Lazy(texture, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetTextureLevelParameterivEXT(int texture, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers.glGetTextureLevelParameterivEXT_Lazy(texture, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetTextureParameterfvEXT(int texture, TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers.glGetTextureParameterfvEXT_Lazy(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetTextureParameterIivEXT(int texture, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers.glGetTextureParameterIivEXT_Lazy(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetTextureParameterIuivEXT(int texture, TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers.glGetTextureParameterIuivEXT_Lazy(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetTextureParameterivEXT(int texture, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers.glGetTextureParameterivEXT_Lazy(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glGetTransformFeedbackVaryingEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_transform_feedback.txt"/></remarks>
            public static void GetTransformFeedbackVaryingEXT(int program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers.glGetTransformFeedbackVaryingEXT_Lazy(program, index, bufSize, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b> <b>[entry point: <c>glGetUniformBufferSizeEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_bindable_uniform.txt"/></remarks>
            public static int GetUniformBufferSizeEXT(int program, int location) => GLPointers.glGetUniformBufferSizeEXT_Lazy(program, location);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b> <b>[entry point: <c>glGetUniformOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_bindable_uniform.txt"/></remarks>
            public static IntPtr GetUniformOffsetEXT(int program, int location) => GLPointers.glGetUniformOffsetEXT_Lazy(program, location);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glGetUniformuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void GetUniformuivEXT(int program, int location, uint* parameters) => GLPointers.glGetUniformuivEXT_Lazy(program, location, parameters);
            
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore]</b> <b>[entry point: <c>glGetUnsignedBytei_vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore.txt"/></remarks>
            public static void GetUnsignedBytei_vEXT(All target, uint index, byte* data) => GLPointers.glGetUnsignedBytei_vEXT_Lazy((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore]</b> <b>[entry point: <c>glGetUnsignedBytevEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore.txt"/></remarks>
            public static void GetUnsignedBytevEXT(GetPName pname, byte* data) => GLPointers.glGetUnsignedBytevEXT_Lazy((uint)pname, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetVariantBooleanvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, bool* data) => GLPointers.glGetVariantBooleanvEXT_Lazy(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetVariantFloatvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => GLPointers.glGetVariantFloatvEXT_Lazy(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetVariantIntegervEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => GLPointers.glGetVariantIntegervEXT_Lazy(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetVariantPointervEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void GetVariantPointervEXT(uint id, GetVariantValueEXT value, void** data) => GLPointers.glGetVariantPointervEXT_Lazy(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIntegeri_vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetVertexArrayIntegeri_vEXT(int vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers.glGetVertexArrayIntegeri_vEXT_Lazy(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIntegervEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetVertexArrayIntegervEXT(int vaobj, VertexArrayPName pname, int* param) => GLPointers.glGetVertexArrayIntegervEXT_Lazy(vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayPointeri_vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetVertexArrayPointeri_vEXT(int vaobj, uint index, VertexArrayPName pname, void** param) => GLPointers.glGetVertexArrayPointeri_vEXT_Lazy(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayPointervEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void GetVertexArrayPointervEXT(int vaobj, VertexArrayPName pname, void** param) => GLPointers.glGetVertexArrayPointervEXT_Lazy(vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glGetVertexAttribIivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int* parameters) => GLPointers.glGetVertexAttribIivEXT_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glGetVertexAttribIuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers.glGetVertexAttribIuivEXT_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glGetVertexAttribLdvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, double* parameters) => GLPointers.glGetVertexAttribLdvEXT_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glHistogramEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void HistogramEXT(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink) => GLPointers.glHistogramEXT_Lazy((uint)target, width, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_memory_object_fd]</b> <b>[entry point: <c>glImportMemoryFdEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object_fd.txt"/></remarks>
            public static void ImportMemoryFdEXT(uint memory, ulong size, ExternalHandleType handleType, int fd) => GLPointers.glImportMemoryFdEXT_Lazy(memory, size, (uint)handleType, fd);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_win32]</b> <b>[entry point: <c>glImportMemoryWin32HandleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object_win32.txt"/></remarks>
            public static void ImportMemoryWin32HandleEXT(uint memory, ulong size, ExternalHandleType handleType, void* handle) => GLPointers.glImportMemoryWin32HandleEXT_Lazy(memory, size, (uint)handleType, handle);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_win32]</b> <b>[entry point: <c>glImportMemoryWin32NameEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object_win32.txt"/></remarks>
            public static void ImportMemoryWin32NameEXT(uint memory, ulong size, ExternalHandleType handleType, void* name) => GLPointers.glImportMemoryWin32NameEXT_Lazy(memory, size, (uint)handleType, name);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_fd]</b> <b>[entry point: <c>glImportSemaphoreFdEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore_fd.txt"/></remarks>
            public static void ImportSemaphoreFdEXT(uint semaphore, ExternalHandleType handleType, int fd) => GLPointers.glImportSemaphoreFdEXT_Lazy(semaphore, (uint)handleType, fd);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_win32]</b> <b>[entry point: <c>glImportSemaphoreWin32HandleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore_win32.txt"/></remarks>
            public static void ImportSemaphoreWin32HandleEXT(uint semaphore, ExternalHandleType handleType, void* handle) => GLPointers.glImportSemaphoreWin32HandleEXT_Lazy(semaphore, (uint)handleType, handle);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_win32]</b> <b>[entry point: <c>glImportSemaphoreWin32NameEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore_win32.txt"/></remarks>
            public static void ImportSemaphoreWin32NameEXT(uint semaphore, ExternalHandleType handleType, void* name) => GLPointers.glImportSemaphoreWin32NameEXT_Lazy(semaphore, (uint)handleType, name);
            
            /// <summary> <b>[requires: GL_EXT_x11_sync_object]</b> <b>[entry point: <c>glImportSyncEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_x11_sync_object.txt"/></remarks>
            public static GLSync ImportSyncEXT(All external_sync_type, IntPtr external_sync, uint flags) => (GLSync) GLPointers.glImportSyncEXT_Lazy((uint)external_sync_type, external_sync, flags);
            
            /// <summary> <b>[requires: GL_EXT_index_func]</b> <b>[entry point: <c>glIndexFuncEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_index_func.txt"/></remarks>
            public static void IndexFuncEXT(IndexFunctionEXT func, float reference) => GLPointers.glIndexFuncEXT_Lazy((uint)func, reference);
            
            /// <summary> <b>[requires: GL_EXT_index_material]</b> <b>[entry point: <c>glIndexMaterialEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_index_material.txt"/></remarks>
            public static void IndexMaterialEXT(TriangleFace face, IndexMaterialParameterEXT mode) => GLPointers.glIndexMaterialEXT_Lazy((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glIndexPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_array.txt"/></remarks>
            public static void IndexPointerEXT(IndexPointerType type, int stride, int count, void* pointer) => GLPointers.glIndexPointerEXT_Lazy((uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glInsertComponentEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void InsertComponentEXT(uint res, uint src, uint num) => GLPointers.glInsertComponentEXT_Lazy(res, src, num);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b> <b>[entry point: <c>glInsertEventMarkerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_debug_marker.txt"/></remarks>
            public static void InsertEventMarkerEXT(int length, byte* marker) => GLPointers.glInsertEventMarkerEXT_Lazy(length, marker);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glIsEnabledIndexedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_draw_buffers2.txt"/></remarks>
            public static bool IsEnabledIndexedEXT(EnableCap target, uint index) => GLPointers.glIsEnabledIndexedEXT_Lazy((uint)target, index) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glIsFramebufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static bool IsFramebufferEXT(int framebuffer) => GLPointers.glIsFramebufferEXT_Lazy(framebuffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glIsMemoryObjectEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static bool IsMemoryObjectEXT(uint memoryObject) => GLPointers.glIsMemoryObjectEXT_Lazy(memoryObject) != 0;
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glIsProgramPipelineEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static bool IsProgramPipelineEXT(int pipeline) => GLPointers.glIsProgramPipelineEXT_Lazy(pipeline) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glIsRenderbufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static bool IsRenderbufferEXT(int renderbuffer) => GLPointers.glIsRenderbufferEXT_Lazy(renderbuffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glIsSemaphoreEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore.txt"/></remarks>
            public static bool IsSemaphoreEXT(uint semaphore) => GLPointers.glIsSemaphoreEXT_Lazy(semaphore) != 0;
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glIsTextureEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_object.txt"/></remarks>
            public static bool IsTextureEXT(int texture) => GLPointers.glIsTextureEXT_Lazy(texture) != 0;
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glIsVariantEnabledEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static bool IsVariantEnabledEXT(uint id, VariantCapEXT cap) => GLPointers.glIsVariantEnabledEXT_Lazy(id, (uint)cap) != 0;
            
            /// <summary> <b>[requires: GL_EXT_debug_label]</b> <b>[entry point: <c>glLabelObjectEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_debug_label.txt"/></remarks>
            public static void LabelObjectEXT(All type, uint obj, int length, byte* label) => GLPointers.glLabelObjectEXT_Lazy((uint)type, obj, length, label);
            
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array]</b> <b>[entry point: <c>glLockArraysEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_compiled_vertex_array.txt"/></remarks>
            public static void LockArraysEXT(int first, int count) => GLPointers.glLockArraysEXT_Lazy(first, count);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMapNamedBufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void* MapNamedBufferEXT(int buffer, BufferAccess access) => GLPointers.glMapNamedBufferEXT_Lazy(buffer, (uint)access);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMapNamedBufferRangeEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void* MapNamedBufferRangeEXT(int buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers.glMapNamedBufferRangeEXT_Lazy(buffer, offset, length, (uint)access);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixFrustumEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers.glMatrixFrustumEXT_Lazy((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoaddEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoaddEXT(MatrixMode mode, double* m) => GLPointers.glMatrixLoaddEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoadfEXT(MatrixMode mode, float* m) => GLPointers.glMatrixLoadfEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadIdentityEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoadIdentityEXT(MatrixMode mode) => GLPointers.glMatrixLoadIdentityEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTransposedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoadTransposedEXT(MatrixMode mode, double* m) => GLPointers.glMatrixLoadTransposedEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTransposefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoadTransposefEXT(MatrixMode mode, float* m) => GLPointers.glMatrixLoadTransposefEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultdEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixMultdEXT(MatrixMode mode, double* m) => GLPointers.glMatrixMultdEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixMultfEXT(MatrixMode mode, float* m) => GLPointers.glMatrixMultfEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTransposedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixMultTransposedEXT(MatrixMode mode, double* m) => GLPointers.glMatrixMultTransposedEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTransposefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixMultTransposefEXT(MatrixMode mode, float* m) => GLPointers.glMatrixMultTransposefEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixOrthoEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers.glMatrixOrthoEXT_Lazy((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixPopEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixPopEXT(MatrixMode mode) => GLPointers.glMatrixPopEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixPushEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixPushEXT(MatrixMode mode) => GLPointers.glMatrixPushEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixRotatedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => GLPointers.glMatrixRotatedEXT_Lazy((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixRotatefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => GLPointers.glMatrixRotatefEXT_Lazy((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixScaledEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => GLPointers.glMatrixScaledEXT_Lazy((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixScalefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => GLPointers.glMatrixScalefEXT_Lazy((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixTranslatedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => GLPointers.glMatrixTranslatedEXT_Lazy((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixTranslatefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => GLPointers.glMatrixTranslatefEXT_Lazy((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store]</b> <b>[entry point: <c>glMemoryBarrierEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_shader_image_load_store.txt"/></remarks>
            public static void MemoryBarrierEXT(MemoryBarrierMask barriers) => GLPointers.glMemoryBarrierEXT_Lazy((uint)barriers);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glMemoryObjectParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void MemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => GLPointers.glMemoryObjectParameterivEXT_Lazy(memoryObject, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glMinmaxEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void MinmaxEXT(MinmaxTargetEXT target, InternalFormat internalformat, bool sink) => GLPointers.glMinmaxEXT_Lazy((uint)target, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays]</b> <b>[entry point: <c>glMultiDrawArraysEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_multi_draw_arrays.txt"/></remarks>
            public static void MultiDrawArraysEXT(PrimitiveType mode, int* first, int* count, int primcount) => GLPointers.glMultiDrawArraysEXT_Lazy((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays]</b> <b>[entry point: <c>glMultiDrawElementsEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_multi_draw_arrays.txt"/></remarks>
            public static void MultiDrawElementsEXT(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int primcount) => GLPointers.glMultiDrawElementsEXT_Lazy((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexBufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexBufferEXT(TextureUnit texunit, TextureTarget target, InternalFormat internalformat, int buffer) => GLPointers.glMultiTexBufferEXT_Lazy((uint)texunit, (uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexCoordPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexCoordPointerEXT(TextureUnit texunit, int size, TexCoordPointerType type, int stride, void* pointer) => GLPointers.glMultiTexCoordPointerEXT_Lazy((uint)texunit, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexEnvfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexEnvfEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float param) => GLPointers.glMultiTexEnvfEXT_Lazy((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexEnvfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers.glMultiTexEnvfvEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexEnviEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexEnviEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers.glMultiTexEnviEXT_Lazy((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexEnvivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers.glMultiTexEnvivEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGendEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexGendEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double param) => GLPointers.glMultiTexGendEXT_Lazy((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGendvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers.glMultiTexGendvEXT_Lazy((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGenfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexGenfEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float param) => GLPointers.glMultiTexGenfEXT_Lazy((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGenfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers.glMultiTexGenfvEXT_Lazy((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGeniEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexGeniEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers.glMultiTexGeniEXT_Lazy((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGenivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers.glMultiTexGenivEXT_Lazy((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glMultiTexImage1DEXT_Lazy((uint)texunit, (uint)target, level, (int)internalformat, width, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glMultiTexImage2DEXT_Lazy((uint)texunit, (uint)target, level, (int)internalformat, width, height, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glMultiTexImage3DEXT_Lazy((uint)texunit, (uint)target, level, (int)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexParameterfEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float param) => GLPointers.glMultiTexParameterfEXT_Lazy((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers.glMultiTexParameterfvEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameteriEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexParameteriEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int param) => GLPointers.glMultiTexParameteriEXT_Lazy((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterIivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers.glMultiTexParameterIivEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterIuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers.glMultiTexParameterIuivEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers.glMultiTexParameterivEXT_Lazy((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexRenderbufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexRenderbufferEXT(TextureUnit texunit, TextureTarget target, int renderbuffer) => GLPointers.glMultiTexRenderbufferEXT_Lazy((uint)texunit, (uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexSubImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers.glMultiTexSubImage1DEXT_Lazy((uint)texunit, (uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexSubImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers.glMultiTexSubImage2DEXT_Lazy((uint)texunit, (uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexSubImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void MultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers.glMultiTexSubImage3DEXT_Lazy((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedBufferDataEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedBufferDataEXT(int buffer, nint size, void* data, BufferUsage usage) => GLPointers.glNamedBufferDataEXT_Lazy(buffer, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedBufferStorageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedBufferStorageEXT(int buffer, nint size, void* data, BufferStorageMask flags) => GLPointers.glNamedBufferStorageEXT_Lazy(buffer, size, data, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_external_buffer]</b> <b>[entry point: <c>glNamedBufferStorageExternalEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_external_buffer.txt"/></remarks>
            public static void NamedBufferStorageExternalEXT(int buffer, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => GLPointers.glNamedBufferStorageExternalEXT_Lazy(buffer, offset, size, clientBuffer, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glNamedBufferStorageMemEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void NamedBufferStorageMemEXT(int buffer, nint size, uint memory, ulong offset) => GLPointers.glNamedBufferStorageMemEXT_Lazy(buffer, size, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedBufferSubDataEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedBufferSubDataEXT(int buffer, IntPtr offset, nint size, void* data) => GLPointers.glNamedBufferSubDataEXT_Lazy(buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedCopyBufferSubDataEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedCopyBufferSubDataEXT(int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers.glNamedCopyBufferSubDataEXT_Lazy(readBuffer, writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferParameteriEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferParameteriEXT(int framebuffer, FramebufferParameterName pname, int param) => GLPointers.glNamedFramebufferParameteriEXT_Lazy(framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferRenderbufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferRenderbufferEXT(int framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers.glNamedFramebufferRenderbufferEXT_Lazy(framebuffer, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferTexture1DEXT(int framebuffer, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers.glNamedFramebufferTexture1DEXT_Lazy(framebuffer, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferTexture2DEXT(int framebuffer, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers.glNamedFramebufferTexture2DEXT_Lazy(framebuffer, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferTexture3DEXT(int framebuffer, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers.glNamedFramebufferTexture3DEXT_Lazy(framebuffer, (uint)attachment, (uint)textarget, texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferTextureEXT(int framebuffer, FramebufferAttachment attachment, int texture, int level) => GLPointers.glNamedFramebufferTextureEXT_Lazy(framebuffer, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureFaceEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferTextureFaceEXT(int framebuffer, FramebufferAttachment attachment, int texture, int level, TextureTarget face) => GLPointers.glNamedFramebufferTextureFaceEXT_Lazy(framebuffer, (uint)attachment, texture, level, (uint)face);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureLayerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedFramebufferTextureLayerEXT(int framebuffer, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers.glNamedFramebufferTextureLayerEXT_Lazy(framebuffer, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameter4dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParameter4dEXT(int program, ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers.glNamedProgramLocalParameter4dEXT_Lazy(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameter4dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParameter4dvEXT(int program, ProgramTarget target, uint index, double* parameters) => GLPointers.glNamedProgramLocalParameter4dvEXT_Lazy(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameter4fEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParameter4fEXT(int program, ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers.glNamedProgramLocalParameter4fEXT_Lazy(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameter4fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParameter4fvEXT(int program, ProgramTarget target, uint index, float* parameters) => GLPointers.glNamedProgramLocalParameter4fvEXT_Lazy(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameterI4iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParameterI4iEXT(int program, ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers.glNamedProgramLocalParameterI4iEXT_Lazy(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameterI4ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParameterI4ivEXT(int program, ProgramTarget target, uint index, int* parameters) => GLPointers.glNamedProgramLocalParameterI4ivEXT_Lazy(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameterI4uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParameterI4uiEXT(int program, ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers.glNamedProgramLocalParameterI4uiEXT_Lazy(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameterI4uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParameterI4uivEXT(int program, ProgramTarget target, uint index, uint* parameters) => GLPointers.glNamedProgramLocalParameterI4uivEXT_Lazy(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameters4fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParameters4fvEXT(int program, ProgramTarget target, uint index, int count, float* parameters) => GLPointers.glNamedProgramLocalParameters4fvEXT_Lazy(program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParametersI4ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParametersI4ivEXT(int program, ProgramTarget target, uint index, int count, int* parameters) => GLPointers.glNamedProgramLocalParametersI4ivEXT_Lazy(program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParametersI4uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramLocalParametersI4uivEXT(int program, ProgramTarget target, uint index, int count, uint* parameters) => GLPointers.glNamedProgramLocalParametersI4uivEXT_Lazy(program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramStringEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedProgramStringEXT(int program, ProgramTarget target, ProgramFormat format, int len, void* str) => GLPointers.glNamedProgramStringEXT_Lazy(program, (uint)target, (uint)format, len, str);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedRenderbufferStorageEXT(int renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers.glNamedRenderbufferStorageEXT_Lazy(renderbuffer, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisampleCoverageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedRenderbufferStorageMultisampleCoverageEXT(int renderbuffer, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => GLPointers.glNamedRenderbufferStorageMultisampleCoverageEXT_Lazy(renderbuffer, coverageSamples, colorSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisampleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void NamedRenderbufferStorageMultisampleEXT(int renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers.glNamedRenderbufferStorageMultisampleEXT_Lazy(renderbuffer, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glNormalPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_array.txt"/></remarks>
            public static void NormalPointerEXT(NormalPointerType type, int stride, int count, void* pointer) => GLPointers.glNormalPointerEXT_Lazy((uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glPixelTransformParameterfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_pixel_transform.txt"/></remarks>
            public static void PixelTransformParameterfEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float param) => GLPointers.glPixelTransformParameterfEXT_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glPixelTransformParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_pixel_transform.txt"/></remarks>
            public static void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float* parameters) => GLPointers.glPixelTransformParameterfvEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glPixelTransformParameteriEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_pixel_transform.txt"/></remarks>
            public static void PixelTransformParameteriEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int param) => GLPointers.glPixelTransformParameteriEXT_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glPixelTransformParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_pixel_transform.txt"/></remarks>
            public static void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int* parameters) => GLPointers.glPixelTransformParameterivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_point_parameters]</b> <b>[entry point: <c>glPointParameterfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_point_parameters.txt"/></remarks>
            public static void PointParameterfEXT(PointParameterNameARB pname, float param) => GLPointers.glPointParameterfEXT_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_point_parameters]</b> <b>[entry point: <c>glPointParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_point_parameters.txt"/></remarks>
            public static void PointParameterfvEXT(PointParameterNameARB pname, float* parameters) => GLPointers.glPointParameterfvEXT_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_polygon_offset_clamp]</b> <b>[entry point: <c>glPolygonOffsetClampEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_polygon_offset_clamp.txt"/></remarks>
            public static void PolygonOffsetClampEXT(float factor, float units, float clamp) => GLPointers.glPolygonOffsetClampEXT_Lazy(factor, units, clamp);
            
            /// <summary> <b>[requires: GL_EXT_polygon_offset]</b> <b>[entry point: <c>glPolygonOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_polygon_offset.txt"/></remarks>
            public static void PolygonOffsetEXT(float factor, float bias) => GLPointers.glPolygonOffsetEXT_Lazy(factor, bias);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b> <b>[entry point: <c>glPopGroupMarkerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_debug_marker.txt"/></remarks>
            public static void PopGroupMarkerEXT() => GLPointers.glPopGroupMarkerEXT_Lazy();
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glPrioritizeTexturesEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_object.txt"/></remarks>
            public static void PrioritizeTexturesEXT(int n, int* textures, float* priorities) => GLPointers.glPrioritizeTexturesEXT_Lazy(n, textures, priorities);
            
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters]</b> <b>[entry point: <c>glProgramEnvParameters4fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_program_parameters.txt"/></remarks>
            public static void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, int count, float* parameters) => GLPointers.glProgramEnvParameters4fvEXT_Lazy((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters]</b> <b>[entry point: <c>glProgramLocalParameters4fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_program_parameters.txt"/></remarks>
            public static void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, int count, float* parameters) => GLPointers.glProgramLocalParameters4fvEXT_Lazy((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_geometry_shader4 | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramParameteriEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_geometry_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramParameteriEXT(int program, ProgramParameterPName pname, int value) => GLPointers.glProgramParameteriEXT_Lazy(program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform1dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniform1dEXT(int program, int location, double x) => GLPointers.glProgramUniform1dEXT_Lazy(program, location, x);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform1dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniform1dvEXT(int program, int location, int count, double* value) => GLPointers.glProgramUniform1dvEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1fEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1fEXT(int program, int location, float v0) => GLPointers.glProgramUniform1fEXT_Lazy(program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1fvEXT(int program, int location, int count, float* value) => GLPointers.glProgramUniform1fvEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1iEXT(int program, int location, int v0) => GLPointers.glProgramUniform1iEXT_Lazy(program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1ivEXT(int program, int location, int count, int* value) => GLPointers.glProgramUniform1ivEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1uiEXT(int program, int location, uint v0) => GLPointers.glProgramUniform1uiEXT_Lazy(program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform1uivEXT(int program, int location, int count, uint* value) => GLPointers.glProgramUniform1uivEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform2dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniform2dEXT(int program, int location, double x, double y) => GLPointers.glProgramUniform2dEXT_Lazy(program, location, x, y);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform2dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniform2dvEXT(int program, int location, int count, double* value) => GLPointers.glProgramUniform2dvEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2fEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2fEXT(int program, int location, float v0, float v1) => GLPointers.glProgramUniform2fEXT_Lazy(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2fvEXT(int program, int location, int count, float* value) => GLPointers.glProgramUniform2fvEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2iEXT(int program, int location, int v0, int v1) => GLPointers.glProgramUniform2iEXT_Lazy(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2ivEXT(int program, int location, int count, int* value) => GLPointers.glProgramUniform2ivEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2uiEXT(int program, int location, uint v0, uint v1) => GLPointers.glProgramUniform2uiEXT_Lazy(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform2uivEXT(int program, int location, int count, uint* value) => GLPointers.glProgramUniform2uivEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform3dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniform3dEXT(int program, int location, double x, double y, double z) => GLPointers.glProgramUniform3dEXT_Lazy(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform3dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniform3dvEXT(int program, int location, int count, double* value) => GLPointers.glProgramUniform3dvEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3fEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3fEXT(int program, int location, float v0, float v1, float v2) => GLPointers.glProgramUniform3fEXT_Lazy(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3fvEXT(int program, int location, int count, float* value) => GLPointers.glProgramUniform3fvEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3iEXT(int program, int location, int v0, int v1, int v2) => GLPointers.glProgramUniform3iEXT_Lazy(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3ivEXT(int program, int location, int count, int* value) => GLPointers.glProgramUniform3ivEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3uiEXT(int program, int location, uint v0, uint v1, uint v2) => GLPointers.glProgramUniform3uiEXT_Lazy(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform3uivEXT(int program, int location, int count, uint* value) => GLPointers.glProgramUniform3uivEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform4dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniform4dEXT(int program, int location, double x, double y, double z, double w) => GLPointers.glProgramUniform4dEXT_Lazy(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform4dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniform4dvEXT(int program, int location, int count, double* value) => GLPointers.glProgramUniform4dvEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4fEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4fEXT(int program, int location, float v0, float v1, float v2, float v3) => GLPointers.glProgramUniform4fEXT_Lazy(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4fvEXT(int program, int location, int count, float* value) => GLPointers.glProgramUniform4fvEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4iEXT(int program, int location, int v0, int v1, int v2, int v3) => GLPointers.glProgramUniform4iEXT_Lazy(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4ivEXT(int program, int location, int count, int* value) => GLPointers.glProgramUniform4ivEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4uiEXT(int program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers.glProgramUniform4uiEXT_Lazy(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniform4uivEXT(int program, int location, int count, uint* value) => GLPointers.glProgramUniform4uivEXT_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix2dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniformMatrix2dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix2dvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix2fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix2fvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix2x3dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniformMatrix2x3dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix2x3dvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix2x3fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix2x3fvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix2x4dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniformMatrix2x4dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix2x4dvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix2x4fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix2x4fvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix3dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniformMatrix3dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix3dvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix3fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix3fvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix3x2dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniformMatrix3x2dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix3x2dvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix3x2fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix3x2fvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix3x4dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniformMatrix3x4dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix3x4dvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix3x4fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix3x4fvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix4dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniformMatrix4dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix4dvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix4fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix4fvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix4x2dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniformMatrix4x2dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix4x2dvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix4x2fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix4x2fvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix4x3dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void ProgramUniformMatrix4x3dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers.glProgramUniformMatrix4x3dvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ProgramUniformMatrix4x3fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers.glProgramUniformMatrix4x3fvEXT_Lazy(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_provoking_vertex]</b> <b>[entry point: <c>glProvokingVertexEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_provoking_vertex.txt"/></remarks>
            public static void ProvokingVertexEXT(VertexProvokingMode mode) => GLPointers.glProvokingVertexEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glPushClientAttribDefaultEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void PushClientAttribDefaultEXT(ClientAttribMask mask) => GLPointers.glPushClientAttribDefaultEXT_Lazy((uint)mask);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b> <b>[entry point: <c>glPushGroupMarkerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_debug_marker.txt"/></remarks>
            public static void PushGroupMarkerEXT(int length, byte* marker) => GLPointers.glPushGroupMarkerEXT_Lazy(length, marker);
            
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glRasterSamplesEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_raster_multisample.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_framebuffer_mixed_samples.txt"/></remarks>
            public static void RasterSamplesEXT(uint samples, bool fixedsamplelocations) => GLPointers.glRasterSamplesEXT_Lazy(samples, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex]</b> <b>[entry point: <c>glReleaseKeyedMutexWin32EXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_win32_keyed_mutex.txt"/></remarks>
            public static bool ReleaseKeyedMutexWin32EXT(uint memory, ulong key) => GLPointers.glReleaseKeyedMutexWin32EXT_Lazy(memory, key) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorageEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_object.txt"/></remarks>
            public static void RenderbufferStorageEXT(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers.glRenderbufferStorageEXT_Lazy((uint)target, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_multisample]</b> <b>[entry point: <c>glRenderbufferStorageMultisampleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_multisample.txt"/></remarks>
            public static void RenderbufferStorageMultisampleEXT(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers.glRenderbufferStorageMultisampleEXT_Lazy((uint)target, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glResetHistogramEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void ResetHistogramEXT(HistogramTargetEXT target) => GLPointers.glResetHistogramEXT_Lazy((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glResetMinmaxEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_histogram.txt"/></remarks>
            public static void ResetMinmaxEXT(MinmaxTargetEXT target) => GLPointers.glResetMinmaxEXT_Lazy((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_multisample]</b> <b>[entry point: <c>glSampleMaskEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_multisample.txt"/></remarks>
            public static void SampleMaskEXT(float value, bool invert) => GLPointers.glSampleMaskEXT_Lazy(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_multisample]</b> <b>[entry point: <c>glSamplePatternEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_multisample.txt"/></remarks>
            public static void SamplePatternEXT(SamplePatternEXT pattern) => GLPointers.glSamplePatternEXT_Lazy((uint)pattern);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3bEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3bEXT(sbyte red, sbyte green, sbyte blue) => GLPointers.glSecondaryColor3bEXT_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3bvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3bvEXT(sbyte* v) => GLPointers.glSecondaryColor3bvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3dEXT(double red, double green, double blue) => GLPointers.glSecondaryColor3dEXT_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3dvEXT(double* v) => GLPointers.glSecondaryColor3dvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3fEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3fEXT(float red, float green, float blue) => GLPointers.glSecondaryColor3fEXT_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3fvEXT(float* v) => GLPointers.glSecondaryColor3fvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3iEXT(int red, int green, int blue) => GLPointers.glSecondaryColor3iEXT_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3ivEXT(int* v) => GLPointers.glSecondaryColor3ivEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3sEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3sEXT(short red, short green, short blue) => GLPointers.glSecondaryColor3sEXT_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3svEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3svEXT(short* v) => GLPointers.glSecondaryColor3svEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3ubEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3ubEXT(byte red, byte green, byte blue) => GLPointers.glSecondaryColor3ubEXT_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3ubvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3ubvEXT(byte* v) => GLPointers.glSecondaryColor3ubvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3uiEXT(uint red, uint green, uint blue) => GLPointers.glSecondaryColor3uiEXT_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3uivEXT(uint* v) => GLPointers.glSecondaryColor3uivEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3usEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3usEXT(ushort red, ushort green, ushort blue) => GLPointers.glSecondaryColor3usEXT_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3usvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColor3usvEXT(ushort* v) => GLPointers.glSecondaryColor3usvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColorPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_secondary_color.txt"/></remarks>
            public static void SecondaryColorPointerEXT(int size, ColorPointerType type, int stride, void* pointer) => GLPointers.glSecondaryColorPointerEXT_Lazy(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glSemaphoreParameterui64vEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore.txt"/></remarks>
            public static void SemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => GLPointers.glSemaphoreParameterui64vEXT_Lazy(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glSeparableFilter2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_convolution.txt"/></remarks>
            public static void SeparableFilter2DEXT(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column) => GLPointers.glSeparableFilter2DEXT_Lazy((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, row, column);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glSetInvariantEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void SetInvariantEXT(uint id, ScalarType type, void* addr) => GLPointers.glSetInvariantEXT_Lazy(id, (uint)type, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glSetLocalConstantEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void SetLocalConstantEXT(uint id, ScalarType type, void* addr) => GLPointers.glSetLocalConstantEXT_Lazy(id, (uint)type, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glShaderOp1EXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void ShaderOp1EXT(VertexShaderOpEXT op, uint res, uint arg1) => GLPointers.glShaderOp1EXT_Lazy((uint)op, res, arg1);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glShaderOp2EXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void ShaderOp2EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2) => GLPointers.glShaderOp2EXT_Lazy((uint)op, res, arg1, arg2);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glShaderOp3EXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void ShaderOp3EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2, uint arg3) => GLPointers.glShaderOp3EXT_Lazy((uint)op, res, arg1, arg2, arg3);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glSignalSemaphoreEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore.txt"/></remarks>
            public static void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, int* buffers, uint numTextureBarriers, int* textures, TextureLayout* dstLayouts) => GLPointers.glSignalSemaphoreEXT_Lazy(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, (uint*)dstLayouts);
            
            /// <summary> <b>[requires: GL_EXT_stencil_clear_tag]</b> <b>[entry point: <c>glStencilClearTagEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_stencil_clear_tag.txt"/></remarks>
            public static void StencilClearTagEXT(int stencilTagBits, uint stencilClearTag) => GLPointers.glStencilClearTagEXT_Lazy(stencilTagBits, stencilClearTag);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glSwizzleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void SwizzleEXT(uint res, uint input, VertexShaderCoordOutEXT outX, VertexShaderCoordOutEXT outY, VertexShaderCoordOutEXT outZ, VertexShaderCoordOutEXT outW) => GLPointers.glSwizzleEXT_Lazy(res, input, (uint)outX, (uint)outY, (uint)outZ, (uint)outW);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3bEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3bEXT(sbyte tx, sbyte ty, sbyte tz) => GLPointers.glTangent3bEXT_Lazy(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3bvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3bvEXT(sbyte* v) => GLPointers.glTangent3bvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3dEXT(double tx, double ty, double tz) => GLPointers.glTangent3dEXT_Lazy(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3dvEXT(double* v) => GLPointers.glTangent3dvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3fEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3fEXT(float tx, float ty, float tz) => GLPointers.glTangent3fEXT_Lazy(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3fvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3fvEXT(float* v) => GLPointers.glTangent3fvEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3iEXT(int tx, int ty, int tz) => GLPointers.glTangent3iEXT_Lazy(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3ivEXT(int* v) => GLPointers.glTangent3ivEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3sEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3sEXT(short tx, short ty, short tz) => GLPointers.glTangent3sEXT_Lazy(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3svEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void Tangent3svEXT(short* v) => GLPointers.glTangent3svEXT_Lazy(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangentPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_coordinate_frame.txt"/></remarks>
            public static void TangentPointerEXT(TangentPointerTypeEXT type, int stride, void* pointer) => GLPointers.glTangentPointerEXT_Lazy((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_texture_buffer_object]</b> <b>[entry point: <c>glTexBufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_buffer_object.txt"/></remarks>
            public static void TexBufferEXT(TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers.glTexBufferEXT_Lazy((uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glTexCoordPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_array.txt"/></remarks>
            public static void TexCoordPointerEXT(int size, TexCoordPointerType type, int stride, int count, void* pointer) => GLPointers.glTexCoordPointerEXT_Lazy(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_texture3D]</b> <b>[entry point: <c>glTexImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture3D.txt"/></remarks>
            public static void TexImage3DEXT(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexImage3DEXT_Lazy((uint)target, level, (uint)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glTexParameterIivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_integer.txt"/></remarks>
            public static void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers.glTexParameterIivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glTexParameterIuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_integer.txt"/></remarks>
            public static void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers.glTexParameterIuivEXT_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b> <b>[entry point: <c>glTexStorage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_storage.txt"/></remarks>
            public static void TexStorage1DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers.glTexStorage1DEXT_Lazy((uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b> <b>[entry point: <c>glTexStorage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_storage.txt"/></remarks>
            public static void TexStorage2DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers.glTexStorage2DEXT_Lazy((uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b> <b>[entry point: <c>glTexStorage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_storage.txt"/></remarks>
            public static void TexStorage3DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers.glTexStorage3DEXT_Lazy((uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TexStorageMem1DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => GLPointers.glTexStorageMem1DEXT_Lazy((uint)target, levels, (uint)internalFormat, width, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TexStorageMem2DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => GLPointers.glTexStorageMem2DEXT_Lazy((uint)target, levels, (uint)internalFormat, width, height, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem2DMultisampleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TexStorageMem2DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers.glTexStorageMem2DMultisampleEXT_Lazy((uint)target, samples, (uint)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TexStorageMem3DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => GLPointers.glTexStorageMem3DEXT_Lazy((uint)target, levels, (uint)internalFormat, width, height, depth, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem3DMultisampleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TexStorageMem3DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers.glTexStorageMem3DMultisampleEXT_Lazy((uint)target, samples, (uint)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_subtexture]</b> <b>[entry point: <c>glTexSubImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_subtexture.txt"/></remarks>
            public static void TexSubImage1DEXT(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexSubImage1DEXT_Lazy((uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_subtexture]</b> <b>[entry point: <c>glTexSubImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_subtexture.txt"/></remarks>
            public static void TexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexSubImage2DEXT_Lazy((uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture3D]</b> <b>[entry point: <c>glTexSubImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture3D.txt"/></remarks>
            public static void TexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexSubImage3DEXT_Lazy((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureBufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureBufferEXT(int texture, TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers.glTextureBufferEXT_Lazy(texture, (uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureBufferRangeEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureBufferRangeEXT(int texture, TextureTarget target, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers.glTextureBufferRangeEXT_Lazy(texture, (uint)target, (uint)internalformat, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureImage1DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureImage1DEXT_Lazy(texture, (uint)target, level, (int)internalformat, width, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureImage2DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureImage2DEXT_Lazy(texture, (uint)target, level, (int)internalformat, width, height, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureImage3DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureImage3DEXT_Lazy(texture, (uint)target, level, (int)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_light_texture]</b> <b>[entry point: <c>glTextureLightEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_light_texture.txt"/></remarks>
            public static void TextureLightEXT(LightTexturePNameEXT pname) => GLPointers.glTextureLightEXT_Lazy((uint)pname);
            
            /// <summary> <b>[requires: GL_EXT_light_texture]</b> <b>[entry point: <c>glTextureMaterialEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_light_texture.txt"/></remarks>
            public static void TextureMaterialEXT(TriangleFace face, MaterialParameter mode) => GLPointers.glTextureMaterialEXT_Lazy((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_texture_perturb_normal]</b> <b>[entry point: <c>glTextureNormalEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_perturb_normal.txt"/></remarks>
            public static void TextureNormalEXT(TextureNormalModeEXT mode) => GLPointers.glTextureNormalEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTexturePageCommitmentEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TexturePageCommitmentEXT(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => GLPointers.glTexturePageCommitmentEXT_Lazy(texture, level, xoffset, yoffset, zoffset, width, height, depth, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureParameterfEXT(int texture, TextureTarget target, TextureParameterName pname, float param) => GLPointers.glTextureParameterfEXT_Lazy(texture, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureParameterfvEXT(int texture, TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers.glTextureParameterfvEXT_Lazy(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameteriEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureParameteriEXT(int texture, TextureTarget target, TextureParameterName pname, int param) => GLPointers.glTextureParameteriEXT_Lazy(texture, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureParameterIivEXT(int texture, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers.glTextureParameterIivEXT_Lazy(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureParameterIuivEXT(int texture, TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers.glTextureParameterIuivEXT_Lazy(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureParameterivEXT(int texture, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers.glTextureParameterivEXT_Lazy(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureRenderbufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureRenderbufferEXT(int texture, TextureTarget target, int renderbuffer) => GLPointers.glTextureRenderbufferEXT_Lazy(texture, (uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b> <b>[entry point: <c>glTextureStorage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_storage.txt"/></remarks>
            public static void TextureStorage1DEXT(int texture, TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers.glTextureStorage1DEXT_Lazy(texture, (uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b> <b>[entry point: <c>glTextureStorage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_storage.txt"/></remarks>
            public static void TextureStorage2DEXT(int texture, All target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers.glTextureStorage2DEXT_Lazy(texture, (uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2DMultisampleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureStorage2DMultisampleEXT(int texture, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers.glTextureStorage2DMultisampleEXT_Lazy(texture, (uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b> <b>[entry point: <c>glTextureStorage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_storage.txt"/></remarks>
            public static void TextureStorage3DEXT(int texture, All target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers.glTextureStorage3DEXT_Lazy(texture, (uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3DMultisampleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureStorage3DMultisampleEXT(int texture, All target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers.glTextureStorage3DMultisampleEXT_Lazy(texture, (uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TextureStorageMem1DEXT(int texture, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => GLPointers.glTextureStorageMem1DEXT_Lazy(texture, levels, (uint)internalFormat, width, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TextureStorageMem2DEXT(int texture, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => GLPointers.glTextureStorageMem2DEXT_Lazy(texture, levels, (uint)internalFormat, width, height, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem2DMultisampleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TextureStorageMem2DMultisampleEXT(int texture, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers.glTextureStorageMem2DMultisampleEXT_Lazy(texture, samples, (uint)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TextureStorageMem3DEXT(int texture, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => GLPointers.glTextureStorageMem3DEXT_Lazy(texture, levels, (uint)internalFormat, width, height, depth, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem3DMultisampleEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_memory_object.txt"/></remarks>
            public static void TextureStorageMem3DMultisampleEXT(int texture, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers.glTextureStorageMem3DMultisampleEXT_Lazy(texture, samples, (uint)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage1DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureSubImage1DEXT(int texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureSubImage1DEXT_Lazy(texture, (uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage2DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureSubImage2DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureSubImage2DEXT_Lazy(texture, (uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage3DEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void TextureSubImage3DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTextureSubImage3DEXT_Lazy(texture, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glTransformFeedbackVaryingsEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_transform_feedback.txt"/></remarks>
            public static void TransformFeedbackVaryingsEXT(int program, int count, byte** varyings, TransformFeedbackBufferMode bufferMode) => GLPointers.glTransformFeedbackVaryingsEXT_Lazy(program, count, varyings, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform1uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void Uniform1uiEXT(int location, uint v0) => GLPointers.glUniform1uiEXT_Lazy(location, v0);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform1uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void Uniform1uivEXT(int location, int count, uint* value) => GLPointers.glUniform1uivEXT_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform2uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void Uniform2uiEXT(int location, uint v0, uint v1) => GLPointers.glUniform2uiEXT_Lazy(location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform2uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void Uniform2uivEXT(int location, int count, uint* value) => GLPointers.glUniform2uivEXT_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform3uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void Uniform3uiEXT(int location, uint v0, uint v1, uint v2) => GLPointers.glUniform3uiEXT_Lazy(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform3uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void Uniform3uivEXT(int location, int count, uint* value) => GLPointers.glUniform3uivEXT_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform4uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void Uniform4uiEXT(int location, uint v0, uint v1, uint v2, uint v3) => GLPointers.glUniform4uiEXT_Lazy(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform4uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/></remarks>
            public static void Uniform4uivEXT(int location, int count, uint* value) => GLPointers.glUniform4uivEXT_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b> <b>[entry point: <c>glUniformBufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_bindable_uniform.txt"/></remarks>
            public static void UniformBufferEXT(int program, int location, int buffer) => GLPointers.glUniformBufferEXT_Lazy(program, location, buffer);
            
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array]</b> <b>[entry point: <c>glUnlockArraysEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_compiled_vertex_array.txt"/></remarks>
            public static void UnlockArraysEXT() => GLPointers.glUnlockArraysEXT_Lazy();
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glUnmapNamedBufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static bool UnmapNamedBufferEXT(int buffer) => GLPointers.glUnmapNamedBufferEXT_Lazy(buffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glUseProgramStagesEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void UseProgramStagesEXT(int pipeline, UseProgramStageMask stages, int program) => GLPointers.glUseProgramStagesEXT_Lazy(pipeline, (uint)stages, program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glUseShaderProgramEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void UseShaderProgramEXT(All type, int program) => GLPointers.glUseShaderProgramEXT_Lazy((uint)type, program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glValidateProgramPipelineEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_separate_shader_objects.txt"/></remarks>
            public static void ValidateProgramPipelineEXT(int pipeline) => GLPointers.glValidateProgramPipelineEXT_Lazy(pipeline);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantbvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void VariantbvEXT(uint id, sbyte* addr) => GLPointers.glVariantbvEXT_Lazy(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantdvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void VariantdvEXT(uint id, double* addr) => GLPointers.glVariantdvEXT_Lazy(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void VariantfvEXT(uint id, float* addr) => GLPointers.glVariantfvEXT_Lazy(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void VariantivEXT(uint id, int* addr) => GLPointers.glVariantivEXT_Lazy(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void VariantPointerEXT(uint id, ScalarType type, uint stride, void* addr) => GLPointers.glVariantPointerEXT_Lazy(id, (uint)type, stride, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantsvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void VariantsvEXT(uint id, short* addr) => GLPointers.glVariantsvEXT_Lazy(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantubvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void VariantubvEXT(uint id, byte* addr) => GLPointers.glVariantubvEXT_Lazy(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void VariantuivEXT(uint id, uint* addr) => GLPointers.glVariantuivEXT_Lazy(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantusvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void VariantusvEXT(uint id, ushort* addr) => GLPointers.glVariantusvEXT_Lazy(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayBindVertexBufferEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayBindVertexBufferEXT(int vaobj, uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers.glVertexArrayBindVertexBufferEXT_Lazy(vaobj, bindingindex, buffer, offset, stride);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayColorOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayColorOffsetEXT(int vaobj, int buffer, int size, ColorPointerType type, int stride, IntPtr offset) => GLPointers.glVertexArrayColorOffsetEXT_Lazy(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayEdgeFlagOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayEdgeFlagOffsetEXT(int vaobj, int buffer, int stride, IntPtr offset) => GLPointers.glVertexArrayEdgeFlagOffsetEXT_Lazy(vaobj, buffer, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayFogCoordOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayFogCoordOffsetEXT(int vaobj, int buffer, FogCoordinatePointerType type, int stride, IntPtr offset) => GLPointers.glVertexArrayFogCoordOffsetEXT_Lazy(vaobj, buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayIndexOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayIndexOffsetEXT(int vaobj, int buffer, IndexPointerType type, int stride, IntPtr offset) => GLPointers.glVertexArrayIndexOffsetEXT_Lazy(vaobj, buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayMultiTexCoordOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayMultiTexCoordOffsetEXT(int vaobj, int buffer, All texunit, int size, TexCoordPointerType type, int stride, IntPtr offset) => GLPointers.glVertexArrayMultiTexCoordOffsetEXT_Lazy(vaobj, buffer, (uint)texunit, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayNormalOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayNormalOffsetEXT(int vaobj, int buffer, NormalPointerType type, int stride, IntPtr offset) => GLPointers.glVertexArrayNormalOffsetEXT_Lazy(vaobj, buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArraySecondaryColorOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArraySecondaryColorOffsetEXT(int vaobj, int buffer, int size, ColorPointerType type, int stride, IntPtr offset) => GLPointers.glVertexArraySecondaryColorOffsetEXT_Lazy(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayTexCoordOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayTexCoordOffsetEXT(int vaobj, int buffer, int size, TexCoordPointerType type, int stride, IntPtr offset) => GLPointers.glVertexArrayTexCoordOffsetEXT_Lazy(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribBindingEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexAttribBindingEXT(int vaobj, uint attribindex, uint bindingindex) => GLPointers.glVertexArrayVertexAttribBindingEXT_Lazy(vaobj, attribindex, bindingindex);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribDivisorEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexAttribDivisorEXT(int vaobj, uint index, uint divisor) => GLPointers.glVertexArrayVertexAttribDivisorEXT_Lazy(vaobj, index, divisor);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribFormatEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexAttribFormatEXT(int vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers.glVertexArrayVertexAttribFormatEXT_Lazy(vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribIFormatEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexAttribIFormatEXT(int vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers.glVertexArrayVertexAttribIFormatEXT_Lazy(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribIOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexAttribIOffsetEXT(int vaobj, int buffer, uint index, int size, VertexAttribType type, int stride, IntPtr offset) => GLPointers.glVertexArrayVertexAttribIOffsetEXT_Lazy(vaobj, buffer, index, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribLFormatEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexAttribLFormatEXT(int vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers.glVertexArrayVertexAttribLFormatEXT_Lazy(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribLOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexAttribLOffsetEXT(int vaobj, int buffer, uint index, int size, VertexAttribLType type, int stride, IntPtr offset) => GLPointers.glVertexArrayVertexAttribLOffsetEXT_Lazy(vaobj, buffer, index, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexAttribOffsetEXT(int vaobj, int buffer, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr offset) => GLPointers.glVertexArrayVertexAttribOffsetEXT_Lazy(vaobj, buffer, index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBindingDivisorEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexBindingDivisorEXT(int vaobj, uint bindingindex, uint divisor) => GLPointers.glVertexArrayVertexBindingDivisorEXT_Lazy(vaobj, bindingindex, divisor);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexOffsetEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/></remarks>
            public static void VertexArrayVertexOffsetEXT(int vaobj, int buffer, int size, VertexPointerType type, int stride, IntPtr offset) => GLPointers.glVertexArrayVertexOffsetEXT_Lazy(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI1iEXT(uint index, int x) => GLPointers.glVertexAttribI1iEXT_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI1ivEXT(uint index, int* v) => GLPointers.glVertexAttribI1ivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI1uiEXT(uint index, uint x) => GLPointers.glVertexAttribI1uiEXT_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI1uivEXT(uint index, uint* v) => GLPointers.glVertexAttribI1uivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI2iEXT(uint index, int x, int y) => GLPointers.glVertexAttribI2iEXT_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI2ivEXT(uint index, int* v) => GLPointers.glVertexAttribI2ivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI2uiEXT(uint index, uint x, uint y) => GLPointers.glVertexAttribI2uiEXT_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI2uivEXT(uint index, uint* v) => GLPointers.glVertexAttribI2uivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI3iEXT(uint index, int x, int y, int z) => GLPointers.glVertexAttribI3iEXT_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI3ivEXT(uint index, int* v) => GLPointers.glVertexAttribI3ivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => GLPointers.glVertexAttribI3uiEXT_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI3uivEXT(uint index, uint* v) => GLPointers.glVertexAttribI3uivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4bvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4bvEXT(uint index, sbyte* v) => GLPointers.glVertexAttribI4bvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => GLPointers.glVertexAttribI4iEXT_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4ivEXT(uint index, int* v) => GLPointers.glVertexAttribI4ivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4svEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4svEXT(uint index, short* v) => GLPointers.glVertexAttribI4svEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4ubvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4ubvEXT(uint index, byte* v) => GLPointers.glVertexAttribI4ubvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => GLPointers.glVertexAttribI4uiEXT_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4uivEXT(uint index, uint* v) => GLPointers.glVertexAttribI4uivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4usvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4usvEXT(uint index, ushort* v) => GLPointers.glVertexAttribI4usvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribIPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers.glVertexAttribIPointerEXT_Lazy(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL1dEXT(uint index, double x) => GLPointers.glVertexAttribL1dEXT_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL1dvEXT(uint index, double* v) => GLPointers.glVertexAttribL1dvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL2dEXT(uint index, double x, double y) => GLPointers.glVertexAttribL2dEXT_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL2dvEXT(uint index, double* v) => GLPointers.glVertexAttribL2dvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL3dEXT(uint index, double x, double y, double z) => GLPointers.glVertexAttribL3dEXT_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL3dvEXT(uint index, double* v) => GLPointers.glVertexAttribL3dvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4dEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL4dEXT(uint index, double x, double y, double z, double w) => GLPointers.glVertexAttribL4dEXT_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4dvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribL4dvEXT(uint index, double* v) => GLPointers.glVertexAttribL4dvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribLPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_attrib_64bit.txt"/></remarks>
            public static void VertexAttribLPointerEXT(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers.glVertexAttribLPointerEXT_Lazy(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glVertexPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_array.txt"/></remarks>
            public static void VertexPointerEXT(int size, VertexPointerType type, int stride, int count, void* pointer) => GLPointers.glVertexPointerEXT_Lazy(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b> <b>[entry point: <c>glVertexWeightfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_weighting.txt"/></remarks>
            public static void VertexWeightfEXT(float weight) => GLPointers.glVertexWeightfEXT_Lazy(weight);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b> <b>[entry point: <c>glVertexWeightfvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_weighting.txt"/></remarks>
            public static void VertexWeightfvEXT(float* weight) => GLPointers.glVertexWeightfvEXT_Lazy(weight);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b> <b>[entry point: <c>glVertexWeightPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_weighting.txt"/></remarks>
            public static void VertexWeightPointerEXT(int size, VertexWeightPointerTypeEXT type, int stride, void* pointer) => GLPointers.glVertexWeightPointerEXT_Lazy(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glWaitSemaphoreEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_semaphore.txt"/></remarks>
            public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, int* buffers, uint numTextureBarriers, int* textures, TextureLayout* srcLayouts) => GLPointers.glWaitSemaphoreEXT_Lazy(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, (uint*)srcLayouts);
            
            /// <summary> <b>[requires: GL_EXT_window_rectangles]</b> <b>[entry point: <c>glWindowRectanglesEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_window_rectangles.txt"/></remarks>
            public static void WindowRectanglesEXT(All mode, int count, int* box) => GLPointers.glWindowRectanglesEXT_Lazy((uint)mode, count, box);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glWriteMaskEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_vertex_shader.txt"/></remarks>
            public static void WriteMaskEXT(uint res, uint input, VertexShaderWriteMaskEXT outX, VertexShaderWriteMaskEXT outY, VertexShaderWriteMaskEXT outZ, VertexShaderWriteMaskEXT outW) => GLPointers.glWriteMaskEXT_Lazy(res, input, (uint)outX, (uint)outY, (uint)outZ, (uint)outW);
            
        }
        /// <summary>GREMEDY extensions.</summary>
        public static unsafe partial class GREMEDY
        {
            /// <summary> <b>[requires: GL_GREMEDY_frame_terminator]</b> <b>[entry point: <c>glFrameTerminatorGREMEDY</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/GREMEDY/GREMEDY_frame_terminator.txt"/></remarks>
            public static void FrameTerminatorGREMEDY() => GLPointers.glFrameTerminatorGREMEDY_Lazy();
            
            /// <summary> <b>[requires: GL_GREMEDY_string_marker]</b> <b>[entry point: <c>glStringMarkerGREMEDY</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/GREMEDY/GREMEDY_string_marker.txt"/></remarks>
            public static void StringMarkerGREMEDY(int len, void* str) => GLPointers.glStringMarkerGREMEDY_Lazy(len, str);
            
        }
        /// <summary>HP extensions.</summary>
        public static unsafe partial class HP
        {
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glGetImageTransformParameterfvHP</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/HP/HP_image_transform.txt"/></remarks>
            public static void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => GLPointers.glGetImageTransformParameterfvHP_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glGetImageTransformParameterivHP</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/HP/HP_image_transform.txt"/></remarks>
            public static void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => GLPointers.glGetImageTransformParameterivHP_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glImageTransformParameterfHP</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/HP/HP_image_transform.txt"/></remarks>
            public static void ImageTransformParameterfHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float param) => GLPointers.glImageTransformParameterfHP_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glImageTransformParameterfvHP</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/HP/HP_image_transform.txt"/></remarks>
            public static void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => GLPointers.glImageTransformParameterfvHP_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glImageTransformParameteriHP</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/HP/HP_image_transform.txt"/></remarks>
            public static void ImageTransformParameteriHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int param) => GLPointers.glImageTransformParameteriHP_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glImageTransformParameterivHP</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/HP/HP_image_transform.txt"/></remarks>
            public static void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => GLPointers.glImageTransformParameterivHP_Lazy((uint)target, (uint)pname, parameters);
            
        }
        /// <summary>IBM extensions.</summary>
        public static unsafe partial class IBM
        {
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glColorPointerListIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_vertex_array_lists.txt"/></remarks>
            public static void ColorPointerListIBM(int size, ColorPointerType type, int stride, void** pointer, int ptrstride) => GLPointers.glColorPointerListIBM_Lazy(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glEdgeFlagPointerListIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_vertex_array_lists.txt"/></remarks>
            public static void EdgeFlagPointerListIBM(int stride, bool** pointer, int ptrstride) => GLPointers.glEdgeFlagPointerListIBM_Lazy(stride, (byte**)pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_static_data]</b> <b>[entry point: <c>glFlushStaticDataIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_static_data.txt"/></remarks>
            public static void FlushStaticDataIBM(All target) => GLPointers.glFlushStaticDataIBM_Lazy((uint)target);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glFogCoordPointerListIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_vertex_array_lists.txt"/></remarks>
            public static void FogCoordPointerListIBM(FogPointerTypeIBM type, int stride, void** pointer, int ptrstride) => GLPointers.glFogCoordPointerListIBM_Lazy((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glIndexPointerListIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_vertex_array_lists.txt"/></remarks>
            public static void IndexPointerListIBM(IndexPointerType type, int stride, void** pointer, int ptrstride) => GLPointers.glIndexPointerListIBM_Lazy((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays]</b> <b>[entry point: <c>glMultiModeDrawArraysIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_multimode_draw_arrays.txt"/></remarks>
            public static void MultiModeDrawArraysIBM(PrimitiveType* mode, int* first, int* count, int primcount, int modestride) => GLPointers.glMultiModeDrawArraysIBM_Lazy((uint*)mode, first, count, primcount, modestride);
            
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays]</b> <b>[entry point: <c>glMultiModeDrawElementsIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_multimode_draw_arrays.txt"/></remarks>
            public static void MultiModeDrawElementsIBM(PrimitiveType* mode, int* count, DrawElementsType type, void** indices, int primcount, int modestride) => GLPointers.glMultiModeDrawElementsIBM_Lazy((uint*)mode, count, (uint)type, indices, primcount, modestride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glNormalPointerListIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_vertex_array_lists.txt"/></remarks>
            public static void NormalPointerListIBM(NormalPointerType type, int stride, void** pointer, int ptrstride) => GLPointers.glNormalPointerListIBM_Lazy((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glSecondaryColorPointerListIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_vertex_array_lists.txt"/></remarks>
            public static void SecondaryColorPointerListIBM(int size, SecondaryColorPointerTypeIBM type, int stride, void** pointer, int ptrstride) => GLPointers.glSecondaryColorPointerListIBM_Lazy(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glTexCoordPointerListIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_vertex_array_lists.txt"/></remarks>
            public static void TexCoordPointerListIBM(int size, TexCoordPointerType type, int stride, void** pointer, int ptrstride) => GLPointers.glTexCoordPointerListIBM_Lazy(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glVertexPointerListIBM</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/IBM/IBM_vertex_array_lists.txt"/></remarks>
            public static void VertexPointerListIBM(int size, VertexPointerType type, int stride, void** pointer, int ptrstride) => GLPointers.glVertexPointerListIBM_Lazy(size, (uint)type, stride, pointer, ptrstride);
            
        }
        /// <summary>INGR extensions.</summary>
        public static unsafe partial class INGR
        {
            /// <summary> <b>[requires: GL_INGR_blend_func_separate]</b> <b>[entry point: <c>glBlendFuncSeparateINGR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INGR/INGR_blend_func_separate.txt"/></remarks>
            public static void BlendFuncSeparateINGR(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers.glBlendFuncSeparateINGR_Lazy((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
            
        }
        /// <summary>INTEL extensions.</summary>
        public static unsafe partial class INTEL
        {
            /// <summary> <b>[requires: GL_INTEL_framebuffer_CMAA]</b> <b>[entry point: <c>glApplyFramebufferAttachmentCMAAINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_framebuffer_CMAA.txt"/></remarks>
            public static void ApplyFramebufferAttachmentCMAAINTEL() => GLPointers.glApplyFramebufferAttachmentCMAAINTEL_Lazy();
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glBeginPerfQueryINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void BeginPerfQueryINTEL(int queryHandle) => GLPointers.glBeginPerfQueryINTEL_Lazy(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b> <b>[entry point: <c>glColorPointervINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_parallel_arrays.txt"/></remarks>
            public static void ColorPointervINTEL(int size, VertexPointerType type, void** pointer) => GLPointers.glColorPointervINTEL_Lazy(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glCreatePerfQueryINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void CreatePerfQueryINTEL(uint queryId, int* queryHandle) => GLPointers.glCreatePerfQueryINTEL_Lazy(queryId, queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glDeletePerfQueryINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void DeletePerfQueryINTEL(int queryHandle) => GLPointers.glDeletePerfQueryINTEL_Lazy(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glEndPerfQueryINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void EndPerfQueryINTEL(int queryHandle) => GLPointers.glEndPerfQueryINTEL_Lazy(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetFirstPerfQueryIdINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void GetFirstPerfQueryIdINTEL(uint* queryId) => GLPointers.glGetFirstPerfQueryIdINTEL_Lazy(queryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetNextPerfQueryIdINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void GetNextPerfQueryIdINTEL(uint queryId, uint* nextQueryId) => GLPointers.glGetNextPerfQueryIdINTEL_Lazy(queryId, nextQueryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetPerfCounterInfoINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void GetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, byte* counterName, uint counterDescLength, byte* counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) => GLPointers.glGetPerfCounterInfoINTEL_Lazy(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetPerfQueryDataINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void GetPerfQueryDataINTEL(int queryHandle, PerfQueryDataFlags flags, int dataSize, void* data, uint* bytesWritten) => GLPointers.glGetPerfQueryDataINTEL_Lazy(queryHandle, (uint)flags, dataSize, data, bytesWritten);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetPerfQueryIdByNameINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void GetPerfQueryIdByNameINTEL(byte* queryName, uint* queryId) => GLPointers.glGetPerfQueryIdByNameINTEL_Lazy(queryName, queryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetPerfQueryInfoINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_performance_query.txt"/></remarks>
            public static void GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, byte* queryName, uint* dataSize, uint* noCounters, uint* noInstances, PerformanceQueryCapsMaskINTEL* capsMask) => GLPointers.glGetPerfQueryInfoINTEL_Lazy(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, (uint*)capsMask);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b> <b>[entry point: <c>glMapTexture2DINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_map_texture.txt"/></remarks>
            public static void* MapTexture2DINTEL(int texture, int level, uint access, int* stride, All* layout) => GLPointers.glMapTexture2DINTEL_Lazy(texture, level, access, stride, (uint*)layout);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b> <b>[entry point: <c>glNormalPointervINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_parallel_arrays.txt"/></remarks>
            public static void NormalPointervINTEL(NormalPointerType type, void** pointer) => GLPointers.glNormalPointervINTEL_Lazy((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b> <b>[entry point: <c>glSyncTextureINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_map_texture.txt"/></remarks>
            public static void SyncTextureINTEL(int texture) => GLPointers.glSyncTextureINTEL_Lazy(texture);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b> <b>[entry point: <c>glTexCoordPointervINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_parallel_arrays.txt"/></remarks>
            public static void TexCoordPointervINTEL(int size, VertexPointerType type, void** pointer) => GLPointers.glTexCoordPointervINTEL_Lazy(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b> <b>[entry point: <c>glUnmapTexture2DINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_map_texture.txt"/></remarks>
            public static void UnmapTexture2DINTEL(int texture, int level) => GLPointers.glUnmapTexture2DINTEL_Lazy(texture, level);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b> <b>[entry point: <c>glVertexPointervINTEL</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_parallel_arrays.txt"/></remarks>
            public static void VertexPointervINTEL(int size, VertexPointerType type, void** pointer) => GLPointers.glVertexPointervINTEL_Lazy(size, (uint)type, pointer);
            
        }
        /// <summary>KHR extensions.</summary>
        public static unsafe partial class KHR
        {
            /// <summary> <b>[requires: GL_KHR_blend_equation_advanced]</b> <b>[entry point: <c>glBlendBarrierKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_blend_equation_advanced.txt"/></remarks>
            public static void BlendBarrierKHR() => GLPointers.glBlendBarrierKHR_Lazy();
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageCallback</c>]</b><br/> Specify a callback to receive debugging messages from the GL. </summary>
            /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
            /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers.glDebugMessageCallback_Lazy(callback, userParam);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageCallbackKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void DebugMessageCallbackKHR(IntPtr callback, void* userParam) => GLPointers.glDebugMessageCallbackKHR_Lazy(callback, userParam);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageControl</c>]</b><br/> Control the reporting of debug messages in a debug context. </summary>
            /// <param name="source"> The source of debug messages to enable or disable. </param>
            /// <param name="type"> The type of debug messages to enable or disable. </param>
            /// <param name="severity"> The severity of debug messages to enable or disable. </param>
            /// <param name="count"> The length of the array ids. </param>
            /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
            /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers.glDebugMessageControl_Lazy((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageControlKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void DebugMessageControlKHR(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers.glDebugMessageControlKHR_Lazy((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageInsert</c>]</b><br/> Inject an application-supplied message into the debug message queue. </summary>
            /// <param name="source"> The source of the debug message to insert. </param>
            /// <param name="type"> The type of the debug message insert. </param>
            /// <param name="id"> The user-supplied identifier of the message to insert. </param>
            /// <param name="severity"> The severity of the debug messages to insert. </param>
            /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
            /// <param name="buf"> The address of a character array containing the message to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers.glDebugMessageInsert_Lazy((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageInsertKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void DebugMessageInsertKHR(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers.glDebugMessageInsertKHR_Lazy((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetDebugMessageLog</c>]</b><br/> Retrieve messages from the debug message log. </summary>
            /// <param name="count"> The number of debug messages to retrieve from the log. </param>
            /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
            /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
            /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
            /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
            /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
            /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
            /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers.glGetDebugMessageLog_Lazy(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glGetDebugMessageLogKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static uint GetDebugMessageLogKHR(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers.glGetDebugMessageLogKHR_Lazy(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetGraphicsResetStatus</c>]</b><br/> Check if the rendering context has not been lost due to software or hardware issues. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatus() => (GraphicsResetStatus) GLPointers.glGetGraphicsResetStatus_Lazy();
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glGetGraphicsResetStatusKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatusKHR() => (GraphicsResetStatus) GLPointers.glGetGraphicsResetStatusKHR_Lazy();
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformfv</c>]</b><br/> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static void GetnUniformfv(int program, int location, int bufSize, float* parameters) => GLPointers.glGetnUniformfv_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformfvKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static void GetnUniformfvKHR(int program, int location, int bufSize, float* parameters) => GLPointers.glGetnUniformfvKHR_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static void GetnUniformiv(int program, int location, int bufSize, int* parameters) => GLPointers.glGetnUniformiv_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformivKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static void GetnUniformivKHR(int program, int location, int bufSize, int* parameters) => GLPointers.glGetnUniformivKHR_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformuiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static void GetnUniformuiv(int program, int location, int bufSize, uint* parameters) => GLPointers.glGetnUniformuiv_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformuivKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static void GetnUniformuivKHR(int program, int location, int bufSize, uint* parameters) => GLPointers.glGetnUniformuivKHR_Lazy(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectLabel</c>]</b><br/> Retrieve the label of a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => GLPointers.glGetObjectLabel_Lazy((uint)identifier, name, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectLabelKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void GetObjectLabelKHR(All identifier, uint name, int bufSize, int* length, byte* label) => GLPointers.glGetObjectLabelKHR_Lazy((uint)identifier, name, bufSize, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectPtrLabel</c>]</b><br/> Retrieve the label of a sync object identified by a pointer. </summary>
            /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => GLPointers.glGetObjectPtrLabel_Lazy(ptr, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectPtrLabelKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void GetObjectPtrLabelKHR(void* ptr, int bufSize, int* length, byte* label) => GLPointers.glGetObjectPtrLabelKHR_Lazy(ptr, bufSize, length, label);
            
            /// <summary> <b>[requires: v1.1 | GL_KHR_debug]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetPointerv</c>]</b><br/> Return the address of the specified pointer. </summary>
            /// <param name="pname"> Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or GL_DEBUG_CALLBACK_USER_PARAM. </param>
            /// <param name="parameters"> Returns the pointer value specified by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void GetPointerv(GetPointervPName pname, void** parameters) => GLPointers.glGetPointerv_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glGetPointervKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void GetPointervKHR(All pname, void** parameters) => GLPointers.glGetPointervKHR_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_KHR_parallel_shader_compile]</b> <b>[entry point: <c>glMaxShaderCompilerThreadsKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_parallel_shader_compile.txt"/></remarks>
            public static void MaxShaderCompilerThreadsKHR(uint count) => GLPointers.glMaxShaderCompilerThreadsKHR_Lazy(count);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glObjectLabel</c>]</b><br/> Label a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object to label. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers.glObjectLabel_Lazy((uint)identifier, name, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glObjectLabelKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void ObjectLabelKHR(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers.glObjectLabelKHR_Lazy((uint)identifier, name, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glObjectPtrLabel</c>]</b><br/> Label a sync object identified by a pointer. </summary>
            /// <param name="ptr"> A pointer identifying a sync object. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void ObjectPtrLabel(void* ptr, int length, byte* label) => GLPointers.glObjectPtrLabel_Lazy(ptr, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glObjectPtrLabelKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void ObjectPtrLabelKHR(void* ptr, int length, byte* label) => GLPointers.glObjectPtrLabelKHR_Lazy(ptr, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glPopDebugGroup</c>]</b><br/> Pop the active debug group. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void PopDebugGroup() => GLPointers.glPopDebugGroup_Lazy();
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glPopDebugGroupKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void PopDebugGroupKHR() => GLPointers.glPopDebugGroupKHR_Lazy();
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glPushDebugGroup</c>]</b><br/> Push a named debug group into the command stream. </summary>
            /// <param name="source"> The source of the debug message. </param>
            /// <param name="id"> The identifier of the message. </param>
            /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
            /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => GLPointers.glPushDebugGroup_Lazy((uint)source, id, length, message);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glPushDebugGroupKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt"/></remarks>
            public static void PushDebugGroupKHR(DebugSource source, uint id, int length, byte* message) => GLPointers.glPushDebugGroupKHR_Lazy((uint)source, id, length, message);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glReadnPixels</c>]</b><br/> Read a block of pixels from the frame buffer. </summary>
            /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
            /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
            /// <param name="data">Returns the pixel data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers.glReadnPixels_Lazy(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glReadnPixelsKHR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_robustness.txt"/></remarks>
            public static void ReadnPixelsKHR(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers.glReadnPixelsKHR_Lazy(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
        }
        /// <summary>MESA extensions.</summary>
        public static unsafe partial class MESA
        {
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y]</b> <b>[entry point: <c>glFramebufferParameteriMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_framebuffer_flip_y.txt"/></remarks>
            public static void FramebufferParameteriMESA(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers.glFramebufferParameteriMESA_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y]</b> <b>[entry point: <c>glGetFramebufferParameterivMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_framebuffer_flip_y.txt"/></remarks>
            public static void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers.glGetFramebufferParameterivMESA_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_MESA_resize_buffers]</b> <b>[entry point: <c>glResizeBuffersMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_resize_buffers.txt"/></remarks>
            public static void ResizeBuffersMESA() => GLPointers.glResizeBuffersMESA_Lazy();
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2dMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos2dMESA(double x, double y) => GLPointers.glWindowPos2dMESA_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2dvMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos2dvMESA(double* v) => GLPointers.glWindowPos2dvMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2fMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos2fMESA(float x, float y) => GLPointers.glWindowPos2fMESA_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2fvMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos2fvMESA(float* v) => GLPointers.glWindowPos2fvMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2iMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos2iMESA(int x, int y) => GLPointers.glWindowPos2iMESA_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2ivMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos2ivMESA(int* v) => GLPointers.glWindowPos2ivMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2sMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos2sMESA(short x, short y) => GLPointers.glWindowPos2sMESA_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2svMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos2svMESA(short* v) => GLPointers.glWindowPos2svMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3dMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos3dMESA(double x, double y, double z) => GLPointers.glWindowPos3dMESA_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3dvMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos3dvMESA(double* v) => GLPointers.glWindowPos3dvMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3fMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos3fMESA(float x, float y, float z) => GLPointers.glWindowPos3fMESA_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3fvMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos3fvMESA(float* v) => GLPointers.glWindowPos3fvMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3iMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos3iMESA(int x, int y, int z) => GLPointers.glWindowPos3iMESA_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3ivMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos3ivMESA(int* v) => GLPointers.glWindowPos3ivMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3sMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos3sMESA(short x, short y, short z) => GLPointers.glWindowPos3sMESA_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3svMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos3svMESA(short* v) => GLPointers.glWindowPos3svMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4dMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos4dMESA(double x, double y, double z, double w) => GLPointers.glWindowPos4dMESA_Lazy(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4dvMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos4dvMESA(double* v) => GLPointers.glWindowPos4dvMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4fMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos4fMESA(float x, float y, float z, float w) => GLPointers.glWindowPos4fMESA_Lazy(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4fvMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos4fvMESA(float* v) => GLPointers.glWindowPos4fvMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4iMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos4iMESA(int x, int y, int z, int w) => GLPointers.glWindowPos4iMESA_Lazy(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4ivMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos4ivMESA(int* v) => GLPointers.glWindowPos4ivMESA_Lazy(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4sMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos4sMESA(short x, short y, short z, short w) => GLPointers.glWindowPos4sMESA_Lazy(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4svMESA</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/MESA/MESA_window_pos.txt"/></remarks>
            public static void WindowPos4svMESA(short* v) => GLPointers.glWindowPos4svMESA_Lazy(v);
            
        }
        /// <summary>NV extensions.</summary>
        public static unsafe partial class NV
        {
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glActiveVaryingNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void ActiveVaryingNV(int program, byte* name) => GLPointers.glActiveVaryingNV_Lazy(program, name);
            
            /// <summary> <b>[requires: GL_NV_alpha_to_coverage_dither_control]</b> <b>[entry point: <c>glAlphaToCoverageDitherControlNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_alpha_to_coverage_dither_control.txt"/></remarks>
            public static void AlphaToCoverageDitherControlNV(All mode) => GLPointers.glAlphaToCoverageDitherControlNV_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glAreProgramsResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static bool AreProgramsResidentNV(int n, int* programs, bool* residences) => GLPointers.glAreProgramsResidentNV_Lazy(n, programs, (byte*)residences) != 0;
            
            /// <summary> <b>[requires: GL_NV_conditional_render]</b> <b>[entry point: <c>glBeginConditionalRenderNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_conditional_render.txt"/></remarks>
            public static void BeginConditionalRenderNV(uint id, ConditionalRenderMode mode) => GLPointers.glBeginConditionalRenderNV_Lazy(id, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glBeginOcclusionQueryNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_occlusion_query.txt"/></remarks>
            public static void BeginOcclusionQueryNV(uint id) => GLPointers.glBeginOcclusionQueryNV_Lazy(id);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glBeginTransformFeedbackNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void BeginTransformFeedbackNV(PrimitiveType primitiveMode) => GLPointers.glBeginTransformFeedbackNV_Lazy((uint)primitiveMode);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glBeginVideoCaptureNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void BeginVideoCaptureNV(uint video_capture_slot) => GLPointers.glBeginVideoCaptureNV_Lazy(video_capture_slot);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glBindBufferBaseNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void BindBufferBaseNV(BufferTarget target, uint index, int buffer) => GLPointers.glBindBufferBaseNV_Lazy((uint)target, index, buffer);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glBindBufferOffsetNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void BindBufferOffsetNV(BufferTarget target, uint index, int buffer, IntPtr offset) => GLPointers.glBindBufferOffsetNV_Lazy((uint)target, index, buffer, offset);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glBindBufferRangeNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void BindBufferRangeNV(BufferTarget target, uint index, int buffer, IntPtr offset, nint size) => GLPointers.glBindBufferRangeNV_Lazy((uint)target, index, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glBindProgramNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void BindProgramNV(VertexAttribEnumNV target, int id) => GLPointers.glBindProgramNV_Lazy((uint)target, id);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glBindShadingRateImageNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shading_rate_image.txt"/></remarks>
            public static void BindShadingRateImageNV(int texture) => GLPointers.glBindShadingRateImageNV_Lazy(texture);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glBindTransformFeedbackNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback2.txt"/></remarks>
            public static void BindTransformFeedbackNV(BufferTarget target, int id) => GLPointers.glBindTransformFeedbackNV_Lazy((uint)target, id);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glBindVideoCaptureStreamBufferNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void BindVideoCaptureStreamBufferNV(uint video_capture_slot, uint stream, All frame_region, IntPtr offset) => GLPointers.glBindVideoCaptureStreamBufferNV_Lazy(video_capture_slot, stream, (uint)frame_region, offset);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glBindVideoCaptureStreamTextureNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void BindVideoCaptureStreamTextureNV(uint video_capture_slot, uint stream, All frame_region, All target, int texture) => GLPointers.glBindVideoCaptureStreamTextureNV_Lazy(video_capture_slot, stream, (uint)frame_region, (uint)target, texture);
            
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced]</b> <b>[entry point: <c>glBlendBarrierNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_blend_equation_advanced.txt"/></remarks>
            public static void BlendBarrierNV() => GLPointers.glBlendBarrierNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced]</b> <b>[entry point: <c>glBlendParameteriNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_blend_equation_advanced.txt"/></remarks>
            public static void BlendParameteriNV(All pname, int value) => GLPointers.glBlendParameteriNV_Lazy((uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glBufferAddressRangeNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void BufferAddressRangeNV(All pname, uint index, ulong address, nint length) => GLPointers.glBufferAddressRangeNV_Lazy((uint)pname, index, address, length);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glBufferAttachMemoryNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_attachment.txt"/></remarks>
            public static void BufferAttachMemoryNV(BufferTarget target, uint memory, ulong offset) => GLPointers.glBufferAttachMemoryNV_Lazy((uint)target, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b> <b>[entry point: <c>glBufferPageCommitmentMemNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_object_sparse.txt"/></remarks>
            public static void BufferPageCommitmentMemNV(BufferStorageTarget target, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit) => GLPointers.glBufferPageCommitmentMemNV_Lazy((uint)target, offset, size, memory, memOffset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCallCommandListNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void CallCommandListNV(uint list) => GLPointers.glCallCommandListNV_Lazy(list);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b> <b>[entry point: <c>glClearDepthdNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_depth_buffer_float.txt"/></remarks>
            public static void ClearDepthdNV(double depth) => GLPointers.glClearDepthdNV_Lazy(depth);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glColor3hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Color3hNV(Half red, Half green, Half blue) => GLPointers.glColor3hNV_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glColor3hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Color3hvNV(Half* v) => GLPointers.glColor3hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glColor4hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Color4hNV(Half red, Half green, Half blue, Half alpha) => GLPointers.glColor4hNV_Lazy(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glColor4hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Color4hvNV(Half* v) => GLPointers.glColor4hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glColorFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void ColorFormatNV(int size, ColorPointerType type, int stride) => GLPointers.glColorFormatNV_Lazy(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerInputNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void CombinerInputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => GLPointers.glCombinerInputNV_Lazy((uint)stage, (uint)portion, (uint)variable, (uint)input, (uint)mapping, (uint)componentUsage);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerOutputNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void CombinerOutputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerRegisterNV abOutput, CombinerRegisterNV cdOutput, CombinerRegisterNV sumOutput, CombinerScaleNV scale, CombinerBiasNV bias, bool abDotProduct, bool cdDotProduct, bool muxSum) => GLPointers.glCombinerOutputNV_Lazy((uint)stage, (uint)portion, (uint)abOutput, (uint)cdOutput, (uint)sumOutput, (uint)scale, (uint)bias, (byte)(abDotProduct ? 1 : 0), (byte)(cdDotProduct ? 1 : 0), (byte)(muxSum ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerParameterfNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void CombinerParameterfNV(CombinerParameterNV pname, float param) => GLPointers.glCombinerParameterfNV_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void CombinerParameterfvNV(CombinerParameterNV pname, float* parameters) => GLPointers.glCombinerParameterfvNV_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerParameteriNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void CombinerParameteriNV(CombinerParameterNV pname, int param) => GLPointers.glCombinerParameteriNV_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void CombinerParameterivNV(CombinerParameterNV pname, int* parameters) => GLPointers.glCombinerParameterivNV_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners2]</b> <b>[entry point: <c>glCombinerStageParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners2.txt"/></remarks>
            public static void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => GLPointers.glCombinerStageParameterfvNV_Lazy((uint)stage, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCommandListSegmentsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void CommandListSegmentsNV(uint list, uint segments) => GLPointers.glCommandListSegmentsNV_Lazy(list, segments);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCompileCommandListNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void CompileCommandListNV(uint list) => GLPointers.glCompileCommandListNV_Lazy(list);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster_dilate]</b> <b>[entry point: <c>glConservativeRasterParameterfNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_conservative_raster_dilate.txt"/></remarks>
            public static void ConservativeRasterParameterfNV(All pname, float value) => GLPointers.glConservativeRasterParameterfNV_Lazy((uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster_pre_snap_triangles]</b> <b>[entry point: <c>glConservativeRasterParameteriNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_conservative_raster_pre_snap_triangles.txt"/></remarks>
            public static void ConservativeRasterParameteriNV(All pname, int param) => GLPointers.glConservativeRasterParameteriNV_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_copy_image]</b> <b>[entry point: <c>glCopyImageSubDataNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_copy_image.txt"/></remarks>
            public static void CopyImageSubDataNV(uint srcName, CopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => GLPointers.glCopyImageSubDataNV_Lazy(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCopyPathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void CopyPathNV(uint resultPath, uint srcPath) => GLPointers.glCopyPathNV_Lazy(resultPath, srcPath);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glCoverageModulationNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_framebuffer_mixed_samples.txt"/></remarks>
            public static void CoverageModulationNV(All components) => GLPointers.glCoverageModulationNV_Lazy((uint)components);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glCoverageModulationTableNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_framebuffer_mixed_samples.txt"/></remarks>
            public static void CoverageModulationTableNV(int n, float* v) => GLPointers.glCoverageModulationTableNV_Lazy(n, v);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCoverFillPathInstancedNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers.glCoverFillPathInstancedNV_Lazy(numPaths, (uint)pathNameType, paths, pathBase, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCoverFillPathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void CoverFillPathNV(uint path, PathCoverMode coverMode) => GLPointers.glCoverFillPathNV_Lazy(path, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCoverStrokePathInstancedNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers.glCoverStrokePathInstancedNV_Lazy(numPaths, (uint)pathNameType, paths, pathBase, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCoverStrokePathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void CoverStrokePathNV(uint path, PathCoverMode coverMode) => GLPointers.glCoverStrokePathNV_Lazy(path, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCreateCommandListsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void CreateCommandListsNV(int n, uint* lists) => GLPointers.glCreateCommandListsNV_Lazy(n, lists);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b> <b>[entry point: <c>glCreateSemaphoresNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_timeline_semaphore.txt"/></remarks>
            public static void CreateSemaphoresNV(int n, uint* semaphores) => GLPointers.glCreateSemaphoresNV_Lazy(n, semaphores);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCreateStatesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void CreateStatesNV(int n, uint* states) => GLPointers.glCreateStatesNV_Lazy(n, states);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDeleteCommandListsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void DeleteCommandListsNV(int n, uint* lists) => GLPointers.glDeleteCommandListsNV_Lazy(n, lists);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glDeleteFencesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fence.txt"/></remarks>
            public static void DeleteFencesNV(int n, uint* fences) => GLPointers.glDeleteFencesNV_Lazy(n, fences);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glDeleteOcclusionQueriesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_occlusion_query.txt"/></remarks>
            public static void DeleteOcclusionQueriesNV(int n, uint* ids) => GLPointers.glDeleteOcclusionQueriesNV_Lazy(n, ids);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glDeletePathsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void DeletePathsNV(uint path, int range) => GLPointers.glDeletePathsNV_Lazy(path, range);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glDeleteProgramsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void DeleteProgramsNV(int n, int* programs) => GLPointers.glDeleteProgramsNV_Lazy(n, programs);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b> <b>[entry point: <c>glDeleteQueryResourceTagNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_query_resource_tag.txt"/></remarks>
            public static void DeleteQueryResourceTagNV(int n, int* tagIds) => GLPointers.glDeleteQueryResourceTagNV_Lazy(n, tagIds);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDeleteStatesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void DeleteStatesNV(int n, uint* states) => GLPointers.glDeleteStatesNV_Lazy(n, states);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glDeleteTransformFeedbacksNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback2.txt"/></remarks>
            public static void DeleteTransformFeedbacksNV(int n, int* ids) => GLPointers.glDeleteTransformFeedbacksNV_Lazy(n, ids);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b> <b>[entry point: <c>glDepthBoundsdNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_depth_buffer_float.txt"/></remarks>
            public static void DepthBoundsdNV(double zmin, double zmax) => GLPointers.glDepthBoundsdNV_Lazy(zmin, zmax);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b> <b>[entry point: <c>glDepthRangedNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_depth_buffer_float.txt"/></remarks>
            public static void DepthRangedNV(double zNear, double zFar) => GLPointers.glDepthRangedNV_Lazy(zNear, zFar);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDrawCommandsAddressNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void DrawCommandsAddressNV(All primitiveMode, ulong* indirects, int* sizes, uint count) => GLPointers.glDrawCommandsAddressNV_Lazy((uint)primitiveMode, indirects, sizes, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDrawCommandsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void DrawCommandsNV(All primitiveMode, uint buffer, IntPtr* indirects, int* sizes, uint count) => GLPointers.glDrawCommandsNV_Lazy((uint)primitiveMode, buffer, indirects, sizes, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDrawCommandsStatesAddressNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers.glDrawCommandsStatesAddressNV_Lazy(indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDrawCommandsStatesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void DrawCommandsStatesNV(int buffer, IntPtr* indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers.glDrawCommandsStatesNV_Lazy(buffer, indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b> <b>[entry point: <c>glDrawMeshTasksIndirectNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_mesh_shader.txt"/></remarks>
            public static void DrawMeshTasksIndirectNV(IntPtr indirect) => GLPointers.glDrawMeshTasksIndirectNV_Lazy(indirect);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b> <b>[entry point: <c>glDrawMeshTasksNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_mesh_shader.txt"/></remarks>
            public static void DrawMeshTasksNV(uint first, uint count) => GLPointers.glDrawMeshTasksNV_Lazy(first, count);
            
            /// <summary> <b>[requires: GL_NV_draw_texture]</b> <b>[entry point: <c>glDrawTextureNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_draw_texture.txt"/></remarks>
            public static void DrawTextureNV(int texture, int sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => GLPointers.glDrawTextureNV_Lazy(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glDrawTransformFeedbackNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback2.txt"/></remarks>
            public static void DrawTransformFeedbackNV(PrimitiveType mode, int id) => GLPointers.glDrawTransformFeedbackNV_Lazy((uint)mode, id);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glDrawVkImageNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_draw_vulkan_image.txt"/></remarks>
            public static void DrawVkImageNV(ulong vkImage, int sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => GLPointers.glDrawVkImageNV_Lazy(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glEdgeFlagFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void EdgeFlagFormatNV(int stride) => GLPointers.glEdgeFlagFormatNV_Lazy(stride);
            
            /// <summary> <b>[requires: GL_NV_conditional_render]</b> <b>[entry point: <c>glEndConditionalRenderNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_conditional_render.txt"/></remarks>
            public static void EndConditionalRenderNV() => GLPointers.glEndConditionalRenderNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glEndOcclusionQueryNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_occlusion_query.txt"/></remarks>
            public static void EndOcclusionQueryNV() => GLPointers.glEndOcclusionQueryNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glEndTransformFeedbackNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void EndTransformFeedbackNV() => GLPointers.glEndTransformFeedbackNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glEndVideoCaptureNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void EndVideoCaptureNV(uint video_capture_slot) => GLPointers.glEndVideoCaptureNV_Lazy(video_capture_slot);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glEvalMapsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_evaluators.txt"/></remarks>
            public static void EvalMapsNV(EvalTargetNV target, EvalMapsModeNV mode) => GLPointers.glEvalMapsNV_Lazy((uint)target, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glExecuteProgramNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void ExecuteProgramNV(VertexAttribEnumNV target, uint id, float* parameters) => GLPointers.glExecuteProgramNV_Lazy((uint)target, id, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glFinalCombinerInputNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void FinalCombinerInputNV(CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => GLPointers.glFinalCombinerInputNV_Lazy((uint)variable, (uint)input, (uint)mapping, (uint)componentUsage);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glFinishFenceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fence.txt"/></remarks>
            public static void FinishFenceNV(uint fence) => GLPointers.glFinishFenceNV_Lazy(fence);
            
            /// <summary> <b>[requires: GL_NV_pixel_data_range]</b> <b>[entry point: <c>glFlushPixelDataRangeNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_pixel_data_range.txt"/></remarks>
            public static void FlushPixelDataRangeNV(PixelDataRangeTargetNV target) => GLPointers.glFlushPixelDataRangeNV_Lazy((uint)target);
            
            /// <summary> <b>[requires: GL_NV_vertex_array_range]</b> <b>[entry point: <c>glFlushVertexArrayRangeNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_array_range.txt"/></remarks>
            public static void FlushVertexArrayRangeNV() => GLPointers.glFlushVertexArrayRangeNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glFogCoordFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void FogCoordFormatNV(All type, int stride) => GLPointers.glFogCoordFormatNV_Lazy((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glFogCoordhNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void FogCoordhNV(Half fog) => GLPointers.glFogCoordhNV_Lazy(fog);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glFogCoordhvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void FogCoordhvNV(Half* fog) => GLPointers.glFogCoordhvNV_Lazy(fog);
            
            /// <summary> <b>[requires: GL_NV_fragment_coverage_to_color]</b> <b>[entry point: <c>glFragmentCoverageColorNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fragment_coverage_to_color.txt"/></remarks>
            public static void FragmentCoverageColorNV(uint color) => GLPointers.glFragmentCoverageColorNV_Lazy(color);
            
            /// <summary> <b>[requires: GL_NV_sample_locations]</b> <b>[entry point: <c>glFramebufferSampleLocationsfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_sample_locations.txt"/></remarks>
            public static void FramebufferSampleLocationsfvNV(FramebufferTarget target, uint start, int count, float* v) => GLPointers.glFramebufferSampleLocationsfvNV_Lazy((uint)target, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b> <b>[entry point: <c>glFramebufferTextureEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_geometry_program4.txt"/></remarks>
            public static void FramebufferTextureEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level) => GLPointers.glFramebufferTextureEXT_Lazy((uint)target, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b> <b>[entry point: <c>glFramebufferTextureFaceEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_geometry_program4.txt"/></remarks>
            public static void FramebufferTextureFaceEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, TextureTarget face) => GLPointers.glFramebufferTextureFaceEXT_Lazy((uint)target, (uint)attachment, texture, level, (uint)face);
            
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4]</b> <b>[entry point: <c>glFramebufferTextureLayerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_array.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_geometry_program4.txt"/></remarks>
            public static void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers.glFramebufferTextureLayerEXT_Lazy((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glGenFencesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fence.txt"/></remarks>
            public static void GenFencesNV(int n, uint* fences) => GLPointers.glGenFencesNV_Lazy(n, fences);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glGenOcclusionQueriesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_occlusion_query.txt"/></remarks>
            public static void GenOcclusionQueriesNV(int n, uint* ids) => GLPointers.glGenOcclusionQueriesNV_Lazy(n, ids);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGenPathsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static uint GenPathsNV(int range) => GLPointers.glGenPathsNV_Lazy(range);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGenProgramsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GenProgramsNV(int n, int* programs) => GLPointers.glGenProgramsNV_Lazy(n, programs);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b> <b>[entry point: <c>glGenQueryResourceTagNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_query_resource_tag.txt"/></remarks>
            public static void GenQueryResourceTagNV(int n, int* tagIds) => GLPointers.glGenQueryResourceTagNV_Lazy(n, tagIds);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glGenTransformFeedbacksNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback2.txt"/></remarks>
            public static void GenTransformFeedbacksNV(int n, int* ids) => GLPointers.glGenTransformFeedbacksNV_Lazy(n, ids);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glGetActiveVaryingNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void GetActiveVaryingNV(int program, uint index, int bufSize, int* length, int* size, All* type, byte* name) => GLPointers.glGetActiveVaryingNV_Lazy(program, index, bufSize, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetBufferParameterui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void GetBufferParameterui64vNV(BufferTarget target, All pname, ulong* parameters) => GLPointers.glGetBufferParameterui64vNV_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetCombinerInputParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => GLPointers.glGetCombinerInputParameterfvNV_Lazy((uint)stage, (uint)portion, (uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetCombinerInputParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => GLPointers.glGetCombinerInputParameterivNV_Lazy((uint)stage, (uint)portion, (uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetCombinerOutputParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, float* parameters) => GLPointers.glGetCombinerOutputParameterfvNV_Lazy((uint)stage, (uint)portion, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetCombinerOutputParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, int* parameters) => GLPointers.glGetCombinerOutputParameterivNV_Lazy((uint)stage, (uint)portion, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners2]</b> <b>[entry point: <c>glGetCombinerStageParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners2.txt"/></remarks>
            public static void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => GLPointers.glGetCombinerStageParameterfvNV_Lazy((uint)stage, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glGetCommandHeaderNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static uint GetCommandHeaderNV(CommandOpcodesNV tokenID, uint size) => GLPointers.glGetCommandHeaderNV_Lazy((uint)tokenID, size);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glGetCoverageModulationTableNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_framebuffer_mixed_samples.txt"/></remarks>
            public static void GetCoverageModulationTableNV(int bufSize, float* v) => GLPointers.glGetCoverageModulationTableNV_Lazy(bufSize, v);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glGetFenceivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fence.txt"/></remarks>
            public static void GetFenceivNV(uint fence, FenceParameterNameNV pname, int* parameters) => GLPointers.glGetFenceivNV_Lazy(fence, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetFinalCombinerInputParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => GLPointers.glGetFinalCombinerInputParameterfvNV_Lazy((uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetFinalCombinerInputParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_register_combiners.txt"/></remarks>
            public static void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => GLPointers.glGetFinalCombinerInputParameterivNV_Lazy((uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glGetImageHandleNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static ulong GetImageHandleNV(int texture, int level, bool layered, int layer, PixelFormat format) => GLPointers.glGetImageHandleNV_Lazy(texture, level, (byte)(layered ? 1 : 0), layer, (uint)format);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glGetIntegerui64i_vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void GetIntegerui64i_vNV(All value, uint index, ulong* result) => GLPointers.glGetIntegerui64i_vNV_Lazy((uint)value, index, result);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetIntegerui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void GetIntegerui64vNV(All value, ulong* result) => GLPointers.glGetIntegerui64vNV_Lazy((uint)value, result);
            
            /// <summary> <b>[requires: GL_NV_internalformat_sample_query]</b> <b>[entry point: <c>glGetInternalformatSampleivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_internalformat_sample_query.txt"/></remarks>
            public static void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, int* parameters) => GLPointers.glGetInternalformatSampleivNV_Lazy((uint)target, (uint)internalformat, samples, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapAttribParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_evaluators.txt"/></remarks>
            public static void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, float* parameters) => GLPointers.glGetMapAttribParameterfvNV_Lazy((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapAttribParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_evaluators.txt"/></remarks>
            public static void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, int* parameters) => GLPointers.glGetMapAttribParameterivNV_Lazy((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapControlPointsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_evaluators.txt"/></remarks>
            public static void GetMapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, bool packed, void* points) => GLPointers.glGetMapControlPointsNV_Lazy((uint)target, index, (uint)type, ustride, vstride, (byte)(packed ? 1 : 0), points);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_evaluators.txt"/></remarks>
            public static void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float* parameters) => GLPointers.glGetMapParameterfvNV_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_evaluators.txt"/></remarks>
            public static void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, int* parameters) => GLPointers.glGetMapParameterivNV_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glGetMemoryObjectDetachedResourcesuivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_attachment.txt"/></remarks>
            public static void GetMemoryObjectDetachedResourcesuivNV(uint memory, All pname, int first, int count, uint* parameters) => GLPointers.glGetMemoryObjectDetachedResourcesuivNV_Lazy(memory, (uint)pname, first, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b> <b>[entry point: <c>glGetMultisamplefvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_explicit_multisample.txt"/></remarks>
            public static void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers.glGetMultisamplefvNV_Lazy((uint)pname, index, val);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetNamedBufferParameterui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void GetNamedBufferParameterui64vNV(int buffer, BufferPName pname, ulong* parameters) => GLPointers.glGetNamedBufferParameterui64vNV_Lazy(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glGetOcclusionQueryivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_occlusion_query.txt"/></remarks>
            public static void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, int* parameters) => GLPointers.glGetOcclusionQueryivNV_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glGetOcclusionQueryuivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_occlusion_query.txt"/></remarks>
            public static void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, uint* parameters) => GLPointers.glGetOcclusionQueryuivNV_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathColorGenfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathColorGenfvNV(PathColor color, PathGenMode pname, float* value) => GLPointers.glGetPathColorGenfvNV_Lazy((uint)color, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathColorGenivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathColorGenivNV(PathColor color, PathGenMode pname, int* value) => GLPointers.glGetPathColorGenivNV_Lazy((uint)color, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathCommandsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathCommandsNV(uint path, byte* commands) => GLPointers.glGetPathCommandsNV_Lazy(path, commands);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathCoordsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathCoordsNV(uint path, float* coords) => GLPointers.glGetPathCoordsNV_Lazy(path, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathDashArrayNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathDashArrayNV(uint path, float* dashArray) => GLPointers.glGetPathDashArrayNV_Lazy(path, dashArray);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathLengthNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static float GetPathLengthNV(uint path, int startSegment, int numSegments) => GLPointers.glGetPathLengthNV_Lazy(path, startSegment, numSegments);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathMetricRangeNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathMetricRangeNV(PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics) => GLPointers.glGetPathMetricRangeNV_Lazy((uint)metricQueryMask, firstPathName, numPaths, stride, metrics);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathMetricsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathMetricsNV(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics) => GLPointers.glGetPathMetricsNV_Lazy((uint)metricQueryMask, numPaths, (uint)pathNameType, paths, pathBase, stride, metrics);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathParameterfvNV(uint path, PathParameter pname, float* value) => GLPointers.glGetPathParameterfvNV_Lazy(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathParameterivNV(uint path, PathParameter pname, int* value) => GLPointers.glGetPathParameterivNV_Lazy(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathSpacingNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float* returnedSpacing) => GLPointers.glGetPathSpacingNV_Lazy((uint)pathListMode, numPaths, (uint)pathNameType, paths, pathBase, advanceScale, kerningScale, (uint)transformType, returnedSpacing);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathTexGenfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathTexGenfvNV(TextureUnit texCoordSet, PathGenMode pname, float* value) => GLPointers.glGetPathTexGenfvNV_Lazy((uint)texCoordSet, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathTexGenivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetPathTexGenivNV(TextureUnit texCoordSet, PathGenMode pname, int* value) => GLPointers.glGetPathTexGenivNV_Lazy((uint)texCoordSet, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glGetProgramEnvParameterIivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, int* parameters) => GLPointers.glGetProgramEnvParameterIivNV_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glGetProgramEnvParameterIuivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers.glGetProgramEnvParameterIuivNV_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetProgramivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GetProgramivNV(int id, VertexAttribEnumNV pname, int* parameters) => GLPointers.glGetProgramivNV_Lazy(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glGetProgramLocalParameterIivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, int* parameters) => GLPointers.glGetProgramLocalParameterIivNV_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glGetProgramLocalParameterIuivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers.glGetProgramLocalParameterIuivNV_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glGetProgramNamedParameterdvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fragment_program.txt"/></remarks>
            public static void GetProgramNamedParameterdvNV(int id, int len, byte* name, double* parameters) => GLPointers.glGetProgramNamedParameterdvNV_Lazy(id, len, name, parameters);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glGetProgramNamedParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fragment_program.txt"/></remarks>
            public static void GetProgramNamedParameterfvNV(int id, int len, byte* name, float* parameters) => GLPointers.glGetProgramNamedParameterfvNV_Lazy(id, len, name, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetProgramParameterdvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, double* parameters) => GLPointers.glGetProgramParameterdvNV_Lazy((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetProgramParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, float* parameters) => GLPointers.glGetProgramParameterfvNV_Lazy((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetProgramResourcefvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void GetProgramResourcefvNV(int program, ProgramInterface programInterface, uint index, int propCount, All* props, int count, int* length, float* parameters) => GLPointers.glGetProgramResourcefvNV_Lazy(program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetProgramStringNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GetProgramStringNV(int id, VertexAttribEnumNV pname, byte* program) => GLPointers.glGetProgramStringNV_Lazy(id, (uint)pname, program);
            
            /// <summary> <b>[requires: GL_NV_gpu_program5]</b> <b>[entry point: <c>glGetProgramSubroutineParameteruivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program5.txt"/></remarks>
            public static void GetProgramSubroutineParameteruivNV(All target, uint index, uint* param) => GLPointers.glGetProgramSubroutineParameteruivNV_Lazy((uint)target, index, param);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b> <b>[entry point: <c>glGetSemaphoreParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_timeline_semaphore.txt"/></remarks>
            public static void GetSemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, int* parameters) => GLPointers.glGetSemaphoreParameterivNV_Lazy(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glGetShadingRateImagePaletteNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shading_rate_image.txt"/></remarks>
            public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, All* rate) => GLPointers.glGetShadingRateImagePaletteNV_Lazy(viewport, entry, (uint*)rate);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glGetShadingRateSampleLocationivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shading_rate_image.txt"/></remarks>
            public static void GetShadingRateSampleLocationivNV(All rate, uint samples, uint index, int* location) => GLPointers.glGetShadingRateSampleLocationivNV_Lazy((uint)rate, samples, index, location);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glGetStageIndexNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static ushort GetStageIndexNV(ShaderType shadertype) => GLPointers.glGetStageIndexNV_Lazy((uint)shadertype);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glGetTextureHandleNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static ulong GetTextureHandleNV(int texture) => GLPointers.glGetTextureHandleNV_Lazy(texture);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glGetTextureSamplerHandleNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static ulong GetTextureSamplerHandleNV(int texture, int sampler) => GLPointers.glGetTextureSamplerHandleNV_Lazy(texture, sampler);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetTrackMatrixivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GetTrackMatrixivNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, int* parameters) => GLPointers.glGetTrackMatrixivNV_Lazy((uint)target, address, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glGetTransformFeedbackVaryingNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void GetTransformFeedbackVaryingNV(int program, uint index, int* location) => GLPointers.glGetTransformFeedbackVaryingNV_Lazy(program, index, location);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glGetUniformi64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void GetUniformi64vNV(int program, int location, long* parameters) => GLPointers.glGetUniformi64vNV_Lazy(program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetUniformui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void GetUniformui64vNV(int program, int location, ulong* parameters) => GLPointers.glGetUniformui64vNV_Lazy(program, location, parameters);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glGetVaryingLocationNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static int GetVaryingLocationNV(int program, byte* name) => GLPointers.glGetVaryingLocationNV_Lazy(program, name);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetVertexAttribdvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GetVertexAttribdvNV(uint index, VertexAttribEnumNV pname, double* parameters) => GLPointers.glGetVertexAttribdvNV_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetVertexAttribfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GetVertexAttribfvNV(uint index, VertexAttribEnumNV pname, float* parameters) => GLPointers.glGetVertexAttribfvNV_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glGetVertexAttribIivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int* parameters) => GLPointers.glGetVertexAttribIivEXT_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glGetVertexAttribIuivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers.glGetVertexAttribIuivEXT_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetVertexAttribivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GetVertexAttribivNV(uint index, VertexAttribEnumNV pname, int* parameters) => GLPointers.glGetVertexAttribivNV_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glGetVertexAttribLi64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, long* parameters) => GLPointers.glGetVertexAttribLi64vNV_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glGetVertexAttribLui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, ulong* parameters) => GLPointers.glGetVertexAttribLui64vNV_Lazy(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetVertexAttribPointervNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void GetVertexAttribPointervNV(uint index, VertexAttribEnumNV pname, void** pointer) => GLPointers.glGetVertexAttribPointervNV_Lazy(index, (uint)pname, pointer);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glGetVideoCaptureivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void GetVideoCaptureivNV(uint video_capture_slot, All pname, int* parameters) => GLPointers.glGetVideoCaptureivNV_Lazy(video_capture_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glGetVideoCaptureStreamdvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, All pname, double* parameters) => GLPointers.glGetVideoCaptureStreamdvNV_Lazy(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glGetVideoCaptureStreamfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, All pname, float* parameters) => GLPointers.glGetVideoCaptureStreamfvNV_Lazy(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glGetVideoCaptureStreamivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, All pname, int* parameters) => GLPointers.glGetVideoCaptureStreamivNV_Lazy(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glGetVideoi64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_present_video.txt"/></remarks>
            public static void GetVideoi64vNV(uint video_slot, All pname, long* parameters) => GLPointers.glGetVideoi64vNV_Lazy(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glGetVideoivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_present_video.txt"/></remarks>
            public static void GetVideoivNV(uint video_slot, All pname, int* parameters) => GLPointers.glGetVideoivNV_Lazy(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glGetVideoui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_present_video.txt"/></remarks>
            public static void GetVideoui64vNV(uint video_slot, All pname, ulong* parameters) => GLPointers.glGetVideoui64vNV_Lazy(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glGetVideouivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_present_video.txt"/></remarks>
            public static void GetVideouivNV(uint video_slot, All pname, uint* parameters) => GLPointers.glGetVideouivNV_Lazy(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glGetVkProcAddrNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_draw_vulkan_image.txt"/></remarks>
            public static IntPtr GetVkProcAddrNV(byte* name) => GLPointers.glGetVkProcAddrNV_Lazy(name);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glIndexFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void IndexFormatNV(All type, int stride) => GLPointers.glIndexFormatNV_Lazy((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glInterpolatePathsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void InterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight) => GLPointers.glInterpolatePathsNV_Lazy(resultPath, pathA, pathB, weight);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glIsBufferResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static bool IsBufferResidentNV(All target) => GLPointers.glIsBufferResidentNV_Lazy((uint)target) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glIsCommandListNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static bool IsCommandListNV(uint list) => GLPointers.glIsCommandListNV_Lazy(list) != 0;
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glIsFenceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fence.txt"/></remarks>
            public static bool IsFenceNV(uint fence) => GLPointers.glIsFenceNV_Lazy(fence) != 0;
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glIsImageHandleResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static bool IsImageHandleResidentNV(ulong handle) => GLPointers.glIsImageHandleResidentNV_Lazy(handle) != 0;
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glIsNamedBufferResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static bool IsNamedBufferResidentNV(int buffer) => GLPointers.glIsNamedBufferResidentNV_Lazy(buffer) != 0;
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glIsOcclusionQueryNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_occlusion_query.txt"/></remarks>
            public static bool IsOcclusionQueryNV(uint id) => GLPointers.glIsOcclusionQueryNV_Lazy(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glIsPathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static bool IsPathNV(uint path) => GLPointers.glIsPathNV_Lazy(path) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glIsPointInFillPathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static bool IsPointInFillPathNV(uint path, uint mask, float x, float y) => GLPointers.glIsPointInFillPathNV_Lazy(path, mask, x, y) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glIsPointInStrokePathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static bool IsPointInStrokePathNV(uint path, float x, float y) => GLPointers.glIsPointInStrokePathNV_Lazy(path, x, y) != 0;
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glIsProgramNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static bool IsProgramNV(int id) => GLPointers.glIsProgramNV_Lazy(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glIsStateNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static bool IsStateNV(uint state) => GLPointers.glIsStateNV_Lazy(state) != 0;
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glIsTextureHandleResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static bool IsTextureHandleResidentNV(ulong handle) => GLPointers.glIsTextureHandleResidentNV_Lazy(handle) != 0;
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glIsTransformFeedbackNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback2.txt"/></remarks>
            public static bool IsTransformFeedbackNV(int id) => GLPointers.glIsTransformFeedbackNV_Lazy(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glListDrawCommandsStatesClientNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers.glListDrawCommandsStatesClientNV_Lazy(list, segment, indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glLoadProgramNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void LoadProgramNV(VertexAttribEnumNV target, uint id, int len, byte* program) => GLPointers.glLoadProgramNV_Lazy((uint)target, id, len, program);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glMakeBufferNonResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void MakeBufferNonResidentNV(All target) => GLPointers.glMakeBufferNonResidentNV_Lazy((uint)target);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glMakeBufferResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void MakeBufferResidentNV(All target, All access) => GLPointers.glMakeBufferResidentNV_Lazy((uint)target, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glMakeImageHandleNonResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static void MakeImageHandleNonResidentNV(ulong handle) => GLPointers.glMakeImageHandleNonResidentNV_Lazy(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glMakeImageHandleResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static void MakeImageHandleResidentNV(ulong handle, All access) => GLPointers.glMakeImageHandleResidentNV_Lazy(handle, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glMakeNamedBufferNonResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void MakeNamedBufferNonResidentNV(int buffer) => GLPointers.glMakeNamedBufferNonResidentNV_Lazy(buffer);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glMakeNamedBufferResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void MakeNamedBufferResidentNV(int buffer, All access) => GLPointers.glMakeNamedBufferResidentNV_Lazy(buffer, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glMakeTextureHandleNonResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static void MakeTextureHandleNonResidentNV(ulong handle) => GLPointers.glMakeTextureHandleNonResidentNV_Lazy(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glMakeTextureHandleResidentNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static void MakeTextureHandleResidentNV(ulong handle) => GLPointers.glMakeTextureHandleResidentNV_Lazy(handle);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glMapControlPointsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_evaluators.txt"/></remarks>
            public static void MapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, bool packed, void* points) => GLPointers.glMapControlPointsNV_Lazy((uint)target, index, (uint)type, ustride, vstride, uorder, vorder, (byte)(packed ? 1 : 0), points);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glMapParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_evaluators.txt"/></remarks>
            public static void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float* parameters) => GLPointers.glMapParameterfvNV_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glMapParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_evaluators.txt"/></remarks>
            public static void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, int* parameters) => GLPointers.glMapParameterivNV_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixFrustumEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers.glMatrixFrustumEXT_Lazy((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoad3x2fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoad3x2fNV(All matrixMode, float* m) => GLPointers.glMatrixLoad3x2fNV_Lazy((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoad3x3fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoad3x3fNV(All matrixMode, float* m) => GLPointers.glMatrixLoad3x3fNV_Lazy((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoaddEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoaddEXT(MatrixMode mode, double* m) => GLPointers.glMatrixLoaddEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoadfEXT(MatrixMode mode, float* m) => GLPointers.glMatrixLoadfEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadIdentityEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoadIdentityEXT(MatrixMode mode) => GLPointers.glMatrixLoadIdentityEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTranspose3x3fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoadTranspose3x3fNV(All matrixMode, float* m) => GLPointers.glMatrixLoadTranspose3x3fNV_Lazy((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTransposedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoadTransposedEXT(MatrixMode mode, double* m) => GLPointers.glMatrixLoadTransposedEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTransposefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixLoadTransposefEXT(MatrixMode mode, float* m) => GLPointers.glMatrixLoadTransposefEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMult3x2fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void MatrixMult3x2fNV(All matrixMode, float* m) => GLPointers.glMatrixMult3x2fNV_Lazy((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMult3x3fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void MatrixMult3x3fNV(All matrixMode, float* m) => GLPointers.glMatrixMult3x3fNV_Lazy((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultdEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixMultdEXT(MatrixMode mode, double* m) => GLPointers.glMatrixMultdEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultfEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixMultfEXT(MatrixMode mode, float* m) => GLPointers.glMatrixMultfEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTranspose3x3fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void MatrixMultTranspose3x3fNV(All matrixMode, float* m) => GLPointers.glMatrixMultTranspose3x3fNV_Lazy((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTransposedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixMultTransposedEXT(MatrixMode mode, double* m) => GLPointers.glMatrixMultTransposedEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTransposefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixMultTransposefEXT(MatrixMode mode, float* m) => GLPointers.glMatrixMultTransposefEXT_Lazy((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixOrthoEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers.glMatrixOrthoEXT_Lazy((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixPopEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixPopEXT(MatrixMode mode) => GLPointers.glMatrixPopEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixPushEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixPushEXT(MatrixMode mode) => GLPointers.glMatrixPushEXT_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixRotatedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => GLPointers.glMatrixRotatedEXT_Lazy((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixRotatefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => GLPointers.glMatrixRotatefEXT_Lazy((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixScaledEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => GLPointers.glMatrixScaledEXT_Lazy((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixScalefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => GLPointers.glMatrixScalefEXT_Lazy((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixTranslatedEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => GLPointers.glMatrixTranslatedEXT_Lazy((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixTranslatefEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_direct_state_access.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_path_rendering.txt"/></remarks>
            public static void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => GLPointers.glMatrixTranslatefEXT_Lazy((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastBarrierNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastBarrierNV() => GLPointers.glMulticastBarrierNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastBlitFramebufferNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, All filter) => GLPointers.glMulticastBlitFramebufferNV_Lazy(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastBufferSubDataNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastBufferSubDataNV(uint gpuMask, int buffer, IntPtr offset, nint size, void* data) => GLPointers.glMulticastBufferSubDataNV_Lazy(gpuMask, buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastCopyBufferSubDataNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastCopyBufferSubDataNV(uint readGpu, uint writeGpuMask, int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers.glMulticastCopyBufferSubDataNV_Lazy(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastCopyImageSubDataNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastCopyImageSubDataNV(uint srcGpu, uint dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers.glMulticastCopyImageSubDataNV_Lazy(srcGpu, dstGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastFramebufferSampleLocationsfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastFramebufferSampleLocationsfvNV(uint gpu, int framebuffer, uint start, int count, float* v) => GLPointers.glMulticastFramebufferSampleLocationsfvNV_Lazy(gpu, framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastGetQueryObjecti64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastGetQueryObjecti64vNV(uint gpu, uint id, All pname, long* parameters) => GLPointers.glMulticastGetQueryObjecti64vNV_Lazy(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastGetQueryObjectivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastGetQueryObjectivNV(uint gpu, uint id, All pname, int* parameters) => GLPointers.glMulticastGetQueryObjectivNV_Lazy(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastGetQueryObjectui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastGetQueryObjectui64vNV(uint gpu, uint id, All pname, ulong* parameters) => GLPointers.glMulticastGetQueryObjectui64vNV_Lazy(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastGetQueryObjectuivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastGetQueryObjectuivNV(uint gpu, uint id, All pname, uint* parameters) => GLPointers.glMulticastGetQueryObjectuivNV_Lazy(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastWaitSyncNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void MulticastWaitSyncNV(uint signalGpu, uint waitGpuMask) => GLPointers.glMulticastWaitSyncNV_Lazy(signalGpu, waitGpuMask);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count]</b> <b>[entry point: <c>glMultiDrawArraysIndirectBindlessCountNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_multi_draw_indirect_count.txt"/></remarks>
            public static void MultiDrawArraysIndirectBindlessCountNV(PrimitiveType mode, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => GLPointers.glMultiDrawArraysIndirectBindlessCountNV_Lazy((uint)mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawArraysIndirectBindlessNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_multi_draw_indirect.txt"/></remarks>
            public static void MultiDrawArraysIndirectBindlessNV(PrimitiveType mode, void* indirect, int drawCount, int stride, int vertexBufferCount) => GLPointers.glMultiDrawArraysIndirectBindlessNV_Lazy((uint)mode, indirect, drawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count]</b> <b>[entry point: <c>glMultiDrawElementsIndirectBindlessCountNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_multi_draw_indirect_count.txt"/></remarks>
            public static void MultiDrawElementsIndirectBindlessCountNV(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => GLPointers.glMultiDrawElementsIndirectBindlessCountNV_Lazy((uint)mode, (uint)type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawElementsIndirectBindlessNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_multi_draw_indirect.txt"/></remarks>
            public static void MultiDrawElementsIndirectBindlessNV(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int stride, int vertexBufferCount) => GLPointers.glMultiDrawElementsIndirectBindlessNV_Lazy((uint)mode, (uint)type, indirect, drawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b> <b>[entry point: <c>glMultiDrawMeshTasksIndirectCountNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_mesh_shader.txt"/></remarks>
            public static void MultiDrawMeshTasksIndirectCountNV(IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers.glMultiDrawMeshTasksIndirectCountNV_Lazy(indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b> <b>[entry point: <c>glMultiDrawMeshTasksIndirectNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_mesh_shader.txt"/></remarks>
            public static void MultiDrawMeshTasksIndirectNV(IntPtr indirect, int drawcount, int stride) => GLPointers.glMultiDrawMeshTasksIndirectNV_Lazy(indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord1hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void MultiTexCoord1hNV(TextureUnit target, Half s) => GLPointers.glMultiTexCoord1hNV_Lazy((uint)target, s);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord1hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void MultiTexCoord1hvNV(TextureUnit target, Half* v) => GLPointers.glMultiTexCoord1hvNV_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord2hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void MultiTexCoord2hNV(TextureUnit target, Half s, Half t) => GLPointers.glMultiTexCoord2hNV_Lazy((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord2hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void MultiTexCoord2hvNV(TextureUnit target, Half* v) => GLPointers.glMultiTexCoord2hvNV_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord3hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void MultiTexCoord3hNV(TextureUnit target, Half s, Half t, Half r) => GLPointers.glMultiTexCoord3hNV_Lazy((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord3hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void MultiTexCoord3hvNV(TextureUnit target, Half* v) => GLPointers.glMultiTexCoord3hvNV_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord4hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void MultiTexCoord4hNV(TextureUnit target, Half s, Half t, Half r, Half q) => GLPointers.glMultiTexCoord4hNV_Lazy((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord4hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void MultiTexCoord4hvNV(TextureUnit target, Half* v) => GLPointers.glMultiTexCoord4hvNV_Lazy((uint)target, v);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glNamedBufferAttachMemoryNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_attachment.txt"/></remarks>
            public static void NamedBufferAttachMemoryNV(int buffer, uint memory, ulong offset) => GLPointers.glNamedBufferAttachMemoryNV_Lazy(buffer, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b> <b>[entry point: <c>glNamedBufferPageCommitmentMemNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_object_sparse.txt"/></remarks>
            public static void NamedBufferPageCommitmentMemNV(int buffer, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit) => GLPointers.glNamedBufferPageCommitmentMemNV_Lazy(buffer, offset, size, memory, memOffset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_sample_locations]</b> <b>[entry point: <c>glNamedFramebufferSampleLocationsfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_sample_locations.txt"/></remarks>
            public static void NamedFramebufferSampleLocationsfvNV(int framebuffer, uint start, int count, float* v) => GLPointers.glNamedFramebufferSampleLocationsfvNV_Lazy(framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glNormal3hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Normal3hNV(Half nx, Half ny, Half nz) => GLPointers.glNormal3hNV_Lazy(nx, ny, nz);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glNormal3hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Normal3hvNV(Half* v) => GLPointers.glNormal3hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glNormalFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void NormalFormatNV(All type, int stride) => GLPointers.glNormalFormatNV_Lazy((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathColorGenNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathColorGenNV(PathColor color, PathGenMode genMode, PathColorFormat colorFormat, float* coeffs) => GLPointers.glPathColorGenNV_Lazy((uint)color, (uint)genMode, (uint)colorFormat, coeffs);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathCommandsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathCommandsNV(uint path, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => GLPointers.glPathCommandsNV_Lazy(path, numCommands, commands, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathCoordsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathCoordsNV(uint path, int numCoords, PathCoordType coordType, void* coords) => GLPointers.glPathCoordsNV_Lazy(path, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathCoverDepthFuncNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathCoverDepthFuncNV(DepthFunction func) => GLPointers.glPathCoverDepthFuncNV_Lazy((uint)func);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathDashArrayNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathDashArrayNV(uint path, int dashCount, float* dashArray) => GLPointers.glPathDashArrayNV_Lazy(path, dashCount, dashArray);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathFogGenNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathFogGenNV(PathGenMode genMode) => GLPointers.glPathFogGenNV_Lazy((uint)genMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathGlyphIndexArrayNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static All PathGlyphIndexArrayNV(uint firstPathName, All fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => (All) GLPointers.glPathGlyphIndexArrayNV_Lazy(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathGlyphIndexRangeNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static All PathGlyphIndexRangeNV(All fontTarget, void* fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount) => (All) GLPointers.glPathGlyphIndexRangeNV_Lazy((uint)fontTarget, fontName, (uint)fontStyle, pathParameterTemplate, emScale, baseAndCount);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathGlyphRangeNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathGlyphRangeNV(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => GLPointers.glPathGlyphRangeNV_Lazy(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, firstGlyph, numGlyphs, (uint)handleMissingGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathGlyphsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathGlyphsNV(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, void* charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => GLPointers.glPathGlyphsNV_Lazy(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, numGlyphs, (uint)type, charcodes, (uint)handleMissingGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathMemoryGlyphIndexArrayNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static All PathMemoryGlyphIndexArrayNV(uint firstPathName, All fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => (All) GLPointers.glPathMemoryGlyphIndexArrayNV_Lazy(firstPathName, (uint)fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathParameterfNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathParameterfNV(uint path, PathParameter pname, float value) => GLPointers.glPathParameterfNV_Lazy(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathParameterfvNV(uint path, PathParameter pname, float* value) => GLPointers.glPathParameterfvNV_Lazy(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathParameteriNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathParameteriNV(uint path, PathParameter pname, int value) => GLPointers.glPathParameteriNV_Lazy(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathParameterivNV(uint path, PathParameter pname, int* value) => GLPointers.glPathParameterivNV_Lazy(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathStencilDepthOffsetNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathStencilDepthOffsetNV(float factor, float units) => GLPointers.glPathStencilDepthOffsetNV_Lazy(factor, units);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathStencilFuncNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathStencilFuncNV(StencilFunction func, int reference, uint mask) => GLPointers.glPathStencilFuncNV_Lazy((uint)func, reference, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathStringNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathStringNV(uint path, PathStringFormat format, int length, void* pathString) => GLPointers.glPathStringNV_Lazy(path, (uint)format, length, pathString);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathSubCommandsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => GLPointers.glPathSubCommandsNV_Lazy(path, commandStart, commandsToDelete, numCommands, commands, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathSubCoordsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathSubCoordsNV(uint path, int coordStart, int numCoords, PathCoordType coordType, void* coords) => GLPointers.glPathSubCoordsNV_Lazy(path, coordStart, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathTexGenNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void PathTexGenNV(PathColor texCoordSet, PathGenMode genMode, int components, float* coeffs) => GLPointers.glPathTexGenNV_Lazy((uint)texCoordSet, (uint)genMode, components, coeffs);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glPauseTransformFeedbackNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback2.txt"/></remarks>
            public static void PauseTransformFeedbackNV() => GLPointers.glPauseTransformFeedbackNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_pixel_data_range]</b> <b>[entry point: <c>glPixelDataRangeNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_pixel_data_range.txt"/></remarks>
            public static void PixelDataRangeNV(PixelDataRangeTargetNV target, int length, void* pointer) => GLPointers.glPixelDataRangeNV_Lazy((uint)target, length, pointer);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPointAlongPathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY) => GLPointers.glPointAlongPathNV_Lazy(path, startSegment, numSegments, distance, x, y, tangentX, tangentY) != 0;
            
            /// <summary> <b>[requires: GL_NV_point_sprite]</b> <b>[entry point: <c>glPointParameteriNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_point_sprite.txt"/></remarks>
            public static void PointParameteriNV(PointParameterNameARB pname, int param) => GLPointers.glPointParameteriNV_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_point_sprite]</b> <b>[entry point: <c>glPointParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_point_sprite.txt"/></remarks>
            public static void PointParameterivNV(PointParameterNameARB pname, int* parameters) => GLPointers.glPointParameterivNV_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glPresentFrameDualFillNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_present_video.txt"/></remarks>
            public static void PresentFrameDualFillNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, All target1, uint fill1, All target2, uint fill2, All target3, uint fill3) => GLPointers.glPresentFrameDualFillNV_Lazy(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, (uint)type, (uint)target0, fill0, (uint)target1, fill1, (uint)target2, fill2, (uint)target3, fill3);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glPresentFrameKeyedNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_present_video.txt"/></remarks>
            public static void PresentFrameKeyedNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, uint key0, All target1, uint fill1, uint key1) => GLPointers.glPresentFrameKeyedNV_Lazy(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, (uint)type, (uint)target0, fill0, key0, (uint)target1, fill1, key1);
            
            /// <summary> <b>[requires: GL_NV_primitive_restart]</b> <b>[entry point: <c>glPrimitiveRestartIndexNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_primitive_restart.txt"/></remarks>
            public static void PrimitiveRestartIndexNV(uint index) => GLPointers.glPrimitiveRestartIndexNV_Lazy(index);
            
            /// <summary> <b>[requires: GL_NV_primitive_restart]</b> <b>[entry point: <c>glPrimitiveRestartNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_primitive_restart.txt"/></remarks>
            public static void PrimitiveRestartNV() => GLPointers.glPrimitiveRestartNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b> <b>[entry point: <c>glProgramBufferParametersfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_parameter_buffer_object.txt"/></remarks>
            public static void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, float* parameters) => GLPointers.glProgramBufferParametersfvNV_Lazy((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b> <b>[entry point: <c>glProgramBufferParametersIivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_parameter_buffer_object.txt"/></remarks>
            public static void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, int* parameters) => GLPointers.glProgramBufferParametersIivNV_Lazy((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b> <b>[entry point: <c>glProgramBufferParametersIuivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_parameter_buffer_object.txt"/></remarks>
            public static void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, uint* parameters) => GLPointers.glProgramBufferParametersIuivNV_Lazy((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParameterI4iNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramEnvParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers.glProgramEnvParameterI4iNV_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParameterI4ivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, int* parameters) => GLPointers.glProgramEnvParameterI4ivNV_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParameterI4uiNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramEnvParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers.glProgramEnvParameterI4uiNV_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParameterI4uivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers.glProgramEnvParameterI4uivNV_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParametersI4ivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, int count, int* parameters) => GLPointers.glProgramEnvParametersI4ivNV_Lazy((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParametersI4uivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, int count, uint* parameters) => GLPointers.glProgramEnvParametersI4uivNV_Lazy((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParameterI4iNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramLocalParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers.glProgramLocalParameterI4iNV_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParameterI4ivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, int* parameters) => GLPointers.glProgramLocalParameterI4ivNV_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParameterI4uiNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramLocalParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers.glProgramLocalParameterI4uiNV_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParameterI4uivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers.glProgramLocalParameterI4uivNV_Lazy((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParametersI4ivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, int count, int* parameters) => GLPointers.glProgramLocalParametersI4ivNV_Lazy((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParametersI4uivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program4.txt"/></remarks>
            public static void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, int count, uint* parameters) => GLPointers.glProgramLocalParametersI4uivNV_Lazy((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glProgramNamedParameter4dNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fragment_program.txt"/></remarks>
            public static void ProgramNamedParameter4dNV(int id, int len, byte* name, double x, double y, double z, double w) => GLPointers.glProgramNamedParameter4dNV_Lazy(id, len, name, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glProgramNamedParameter4dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fragment_program.txt"/></remarks>
            public static void ProgramNamedParameter4dvNV(int id, int len, byte* name, double* v) => GLPointers.glProgramNamedParameter4dvNV_Lazy(id, len, name, v);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glProgramNamedParameter4fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fragment_program.txt"/></remarks>
            public static void ProgramNamedParameter4fNV(int id, int len, byte* name, float x, float y, float z, float w) => GLPointers.glProgramNamedParameter4fNV_Lazy(id, len, name, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glProgramNamedParameter4fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fragment_program.txt"/></remarks>
            public static void ProgramNamedParameter4fvNV(int id, int len, byte* name, float* v) => GLPointers.glProgramNamedParameter4fvNV_Lazy(id, len, name, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameter4dNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void ProgramParameter4dNV(VertexAttribEnumNV target, uint index, double x, double y, double z, double w) => GLPointers.glProgramParameter4dNV_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameter4dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, double* v) => GLPointers.glProgramParameter4dvNV_Lazy((uint)target, index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameter4fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void ProgramParameter4fNV(VertexAttribEnumNV target, uint index, float x, float y, float z, float w) => GLPointers.glProgramParameter4fNV_Lazy((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameter4fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, float* v) => GLPointers.glProgramParameter4fvNV_Lazy((uint)target, index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameters4dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, int count, double* v) => GLPointers.glProgramParameters4dvNV_Lazy((uint)target, index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameters4fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, int count, float* v) => GLPointers.glProgramParameters4fvNV_Lazy((uint)target, index, count, v);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glProgramPathFragmentInputGenNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void ProgramPathFragmentInputGenNV(int program, int location, All genMode, int components, float* coeffs) => GLPointers.glProgramPathFragmentInputGenNV_Lazy(program, location, (uint)genMode, components, coeffs);
            
            /// <summary> <b>[requires: GL_NV_gpu_program5]</b> <b>[entry point: <c>glProgramSubroutineParametersuivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_program5.txt"/></remarks>
            public static void ProgramSubroutineParametersuivNV(All target, int count, uint* parameters) => GLPointers.glProgramSubroutineParametersuivNV_Lazy((uint)target, count, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform1i64NV(int program, int location, long x) => GLPointers.glProgramUniform1i64NV_Lazy(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform1i64vNV(int program, int location, int count, long* value) => GLPointers.glProgramUniform1i64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform1ui64NV(int program, int location, ulong x) => GLPointers.glProgramUniform1ui64NV_Lazy(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform1ui64vNV(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform1ui64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform2i64NV(int program, int location, long x, long y) => GLPointers.glProgramUniform2i64NV_Lazy(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform2i64vNV(int program, int location, int count, long* value) => GLPointers.glProgramUniform2i64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform2ui64NV(int program, int location, ulong x, ulong y) => GLPointers.glProgramUniform2ui64NV_Lazy(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform2ui64vNV(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform2ui64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform3i64NV(int program, int location, long x, long y, long z) => GLPointers.glProgramUniform3i64NV_Lazy(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform3i64vNV(int program, int location, int count, long* value) => GLPointers.glProgramUniform3i64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform3ui64NV(int program, int location, ulong x, ulong y, ulong z) => GLPointers.glProgramUniform3ui64NV_Lazy(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform3ui64vNV(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform3ui64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform4i64NV(int program, int location, long x, long y, long z, long w) => GLPointers.glProgramUniform4i64NV_Lazy(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform4i64vNV(int program, int location, int count, long* value) => GLPointers.glProgramUniform4i64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform4ui64NV(int program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers.glProgramUniform4ui64NV_Lazy(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void ProgramUniform4ui64vNV(int program, int location, int count, ulong* value) => GLPointers.glProgramUniform4ui64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glProgramUniformHandleui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static void ProgramUniformHandleui64NV(int program, int location, ulong value) => GLPointers.glProgramUniformHandleui64NV_Lazy(program, location, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glProgramUniformHandleui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static void ProgramUniformHandleui64vNV(int program, int location, int count, ulong* values) => GLPointers.glProgramUniformHandleui64vNV_Lazy(program, location, count, values);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glProgramUniformui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void ProgramUniformui64NV(int program, int location, ulong value) => GLPointers.glProgramUniformui64NV_Lazy(program, location, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glProgramUniformui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void ProgramUniformui64vNV(int program, int location, int count, ulong* value) => GLPointers.glProgramUniformui64vNV_Lazy(program, location, count, value);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b> <b>[entry point: <c>glProgramVertexLimitNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_geometry_program4.txt"/></remarks>
            public static void ProgramVertexLimitNV(ProgramTarget target, int limit) => GLPointers.glProgramVertexLimitNV_Lazy((uint)target, limit);
            
            /// <summary> <b>[requires: GL_NV_query_resource]</b> <b>[entry point: <c>glQueryResourceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_query_resource.txt"/></remarks>
            public static int QueryResourceNV(All queryType, int tagId, uint count, int* buffer) => GLPointers.glQueryResourceNV_Lazy((uint)queryType, tagId, count, buffer);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b> <b>[entry point: <c>glQueryResourceTagNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_query_resource_tag.txt"/></remarks>
            public static void QueryResourceTagNV(int tagId, byte* tagString) => GLPointers.glQueryResourceTagNV_Lazy(tagId, tagString);
            
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glRasterSamplesEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_raster_multisample.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_framebuffer_mixed_samples.txt"/></remarks>
            public static void RasterSamplesEXT(uint samples, bool fixedsamplelocations) => GLPointers.glRasterSamplesEXT_Lazy(samples, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_framebuffer_multisample_coverage]</b> <b>[entry point: <c>glRenderbufferStorageMultisampleCoverageNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_framebuffer_multisample_coverage.txt"/></remarks>
            public static void RenderbufferStorageMultisampleCoverageNV(RenderbufferTarget target, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => GLPointers.glRenderbufferStorageMultisampleCoverageNV_Lazy((uint)target, coverageSamples, colorSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glRenderGpuMaskNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_multicast.txt"/></remarks>
            public static void RenderGpuMaskNV(uint mask) => GLPointers.glRenderGpuMaskNV_Lazy(mask);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glRequestResidentProgramsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void RequestResidentProgramsNV(int n, int* programs) => GLPointers.glRequestResidentProgramsNV_Lazy(n, programs);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glResetMemoryObjectParameterNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_attachment.txt"/></remarks>
            public static void ResetMemoryObjectParameterNV(uint memory, All pname) => GLPointers.glResetMemoryObjectParameterNV_Lazy(memory, (uint)pname);
            
            /// <summary> <b>[requires: GL_NV_sample_locations]</b> <b>[entry point: <c>glResolveDepthValuesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_sample_locations.txt"/></remarks>
            public static void ResolveDepthValuesNV() => GLPointers.glResolveDepthValuesNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glResumeTransformFeedbackNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback2.txt"/></remarks>
            public static void ResumeTransformFeedbackNV() => GLPointers.glResumeTransformFeedbackNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b> <b>[entry point: <c>glSampleMaskIndexedNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_explicit_multisample.txt"/></remarks>
            public static void SampleMaskIndexedNV(uint index, uint mask) => GLPointers.glSampleMaskIndexedNV_Lazy(index, mask);
            
            /// <summary> <b>[requires: GL_NV_scissor_exclusive]</b> <b>[entry point: <c>glScissorExclusiveArrayvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_scissor_exclusive.txt"/></remarks>
            public static void ScissorExclusiveArrayvNV(uint first, int count, int* v) => GLPointers.glScissorExclusiveArrayvNV_Lazy(first, count, v);
            
            /// <summary> <b>[requires: GL_NV_scissor_exclusive]</b> <b>[entry point: <c>glScissorExclusiveNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_scissor_exclusive.txt"/></remarks>
            public static void ScissorExclusiveNV(int x, int y, int width, int height) => GLPointers.glScissorExclusiveNV_Lazy(x, y, width, height);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glSecondaryColor3hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void SecondaryColor3hNV(Half red, Half green, Half blue) => GLPointers.glSecondaryColor3hNV_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glSecondaryColor3hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void SecondaryColor3hvNV(Half* v) => GLPointers.glSecondaryColor3hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glSecondaryColorFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void SecondaryColorFormatNV(int size, ColorPointerType type, int stride) => GLPointers.glSecondaryColorFormatNV_Lazy(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b> <b>[entry point: <c>glSemaphoreParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_timeline_semaphore.txt"/></remarks>
            public static void SemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, int* parameters) => GLPointers.glSemaphoreParameterivNV_Lazy(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glSetFenceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fence.txt"/></remarks>
            public static void SetFenceNV(uint fence, FenceConditionNV condition) => GLPointers.glSetFenceNV_Lazy(fence, (uint)condition);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glShadingRateImageBarrierNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shading_rate_image.txt"/></remarks>
            public static void ShadingRateImageBarrierNV(bool synchronize) => GLPointers.glShadingRateImageBarrierNV_Lazy((byte)(synchronize ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glShadingRateImagePaletteNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shading_rate_image.txt"/></remarks>
            public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, All* rates) => GLPointers.glShadingRateImagePaletteNV_Lazy(viewport, first, count, (uint*)rates);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glShadingRateSampleOrderCustomNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shading_rate_image.txt"/></remarks>
            public static void ShadingRateSampleOrderCustomNV(All rate, uint samples, int* locations) => GLPointers.glShadingRateSampleOrderCustomNV_Lazy((uint)rate, samples, locations);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glShadingRateSampleOrderNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shading_rate_image.txt"/></remarks>
            public static void ShadingRateSampleOrderNV(All order) => GLPointers.glShadingRateSampleOrderNV_Lazy((uint)order);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glSignalVkFenceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_draw_vulkan_image.txt"/></remarks>
            public static void SignalVkFenceNV(ulong vkFence) => GLPointers.glSignalVkFenceNV_Lazy(vkFence);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glSignalVkSemaphoreNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_draw_vulkan_image.txt"/></remarks>
            public static void SignalVkSemaphoreNV(ulong vkSemaphore) => GLPointers.glSignalVkSemaphoreNV_Lazy(vkSemaphore);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glStateCaptureNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_command_list.txt"/></remarks>
            public static void StateCaptureNV(uint state, All mode) => GLPointers.glStateCaptureNV_Lazy(state, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilFillPathInstancedNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float* transformValues) => GLPointers.glStencilFillPathInstancedNV_Lazy(numPaths, (uint)pathNameType, paths, pathBase, (uint)fillMode, mask, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilFillPathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void StencilFillPathNV(uint path, PathFillMode fillMode, uint mask) => GLPointers.glStencilFillPathNV_Lazy(path, (uint)fillMode, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilStrokePathInstancedNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float* transformValues) => GLPointers.glStencilStrokePathInstancedNV_Lazy(numPaths, (uint)pathNameType, paths, pathBase, reference, mask, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilStrokePathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void StencilStrokePathNV(uint path, int reference, uint mask) => GLPointers.glStencilStrokePathNV_Lazy(path, reference, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilThenCoverFillPathInstancedNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void StencilThenCoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathFillMode fillMode, uint mask, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers.glStencilThenCoverFillPathInstancedNV_Lazy(numPaths, (uint)pathNameType, paths, pathBase, (uint)fillMode, mask, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilThenCoverFillPathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void StencilThenCoverFillPathNV(uint path, PathFillMode fillMode, uint mask, PathCoverMode coverMode) => GLPointers.glStencilThenCoverFillPathNV_Lazy(path, (uint)fillMode, mask, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilThenCoverStrokePathInstancedNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void StencilThenCoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers.glStencilThenCoverStrokePathInstancedNV_Lazy(numPaths, (uint)pathNameType, paths, pathBase, reference, mask, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilThenCoverStrokePathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void StencilThenCoverStrokePathNV(uint path, int reference, uint mask, PathCoverMode coverMode) => GLPointers.glStencilThenCoverStrokePathNV_Lazy(path, reference, mask, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster]</b> <b>[entry point: <c>glSubpixelPrecisionBiasNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_conservative_raster.txt"/></remarks>
            public static void SubpixelPrecisionBiasNV(uint xbits, uint ybits) => GLPointers.glSubpixelPrecisionBiasNV_Lazy(xbits, ybits);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glTestFenceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_fence.txt"/></remarks>
            public static bool TestFenceNV(uint fence) => GLPointers.glTestFenceNV_Lazy(fence) != 0;
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glTexAttachMemoryNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_attachment.txt"/></remarks>
            public static void TexAttachMemoryNV(TextureTarget target, uint memory, ulong offset) => GLPointers.glTexAttachMemoryNV_Lazy((uint)target, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord1hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void TexCoord1hNV(Half s) => GLPointers.glTexCoord1hNV_Lazy(s);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord1hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void TexCoord1hvNV(Half* v) => GLPointers.glTexCoord1hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord2hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void TexCoord2hNV(Half s, Half t) => GLPointers.glTexCoord2hNV_Lazy(s, t);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord2hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void TexCoord2hvNV(Half* v) => GLPointers.glTexCoord2hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord3hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void TexCoord3hNV(Half s, Half t, Half r) => GLPointers.glTexCoord3hNV_Lazy(s, t, r);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord3hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void TexCoord3hvNV(Half* v) => GLPointers.glTexCoord3hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord4hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void TexCoord4hNV(Half s, Half t, Half r, Half q) => GLPointers.glTexCoord4hNV_Lazy(s, t, r, q);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord4hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void TexCoord4hvNV(Half* v) => GLPointers.glTexCoord4hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glTexCoordFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void TexCoordFormatNV(int size, All type, int stride) => GLPointers.glTexCoordFormatNV_Lazy(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTexImage2DMultisampleCoverageNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_texture_multisample.txt"/></remarks>
            public static void TexImage2DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers.glTexImage2DMultisampleCoverageNV_Lazy((uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTexImage3DMultisampleCoverageNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_texture_multisample.txt"/></remarks>
            public static void TexImage3DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers.glTexImage3DMultisampleCoverageNV_Lazy((uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b> <b>[entry point: <c>glTexPageCommitmentMemNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_object_sparse.txt"/></remarks>
            public static void TexPageCommitmentMemNV(TextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit) => GLPointers.glTexPageCommitmentMemNV_Lazy((uint)target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b> <b>[entry point: <c>glTexRenderbufferNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_explicit_multisample.txt"/></remarks>
            public static void TexRenderbufferNV(TextureTarget target, int renderbuffer) => GLPointers.glTexRenderbufferNV_Lazy((uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glTextureAttachMemoryNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_attachment.txt"/></remarks>
            public static void TextureAttachMemoryNV(int texture, uint memory, ulong offset) => GLPointers.glTextureAttachMemoryNV_Lazy(texture, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_texture_barrier]</b> <b>[entry point: <c>glTextureBarrierNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_texture_barrier.txt"/></remarks>
            public static void TextureBarrierNV() => GLPointers.glTextureBarrierNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTextureImage2DMultisampleCoverageNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_texture_multisample.txt"/></remarks>
            public static void TextureImage2DMultisampleCoverageNV(int texture, TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers.glTextureImage2DMultisampleCoverageNV_Lazy(texture, (uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTextureImage2DMultisampleNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_texture_multisample.txt"/></remarks>
            public static void TextureImage2DMultisampleNV(int texture, TextureTarget target, int samples, InternalFormat internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers.glTextureImage2DMultisampleNV_Lazy(texture, (uint)target, samples, (int)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTextureImage3DMultisampleCoverageNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_texture_multisample.txt"/></remarks>
            public static void TextureImage3DMultisampleCoverageNV(int texture, TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers.glTextureImage3DMultisampleCoverageNV_Lazy(texture, (uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTextureImage3DMultisampleNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_texture_multisample.txt"/></remarks>
            public static void TextureImage3DMultisampleNV(int texture, TextureTarget target, int samples, InternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers.glTextureImage3DMultisampleNV_Lazy(texture, (uint)target, samples, (int)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b> <b>[entry point: <c>glTexturePageCommitmentMemNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_memory_object_sparse.txt"/></remarks>
            public static void TexturePageCommitmentMemNV(int texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit) => GLPointers.glTexturePageCommitmentMemNV_Lazy(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glTrackMatrixNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void TrackMatrixNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV matrix, VertexAttribEnumNV transform) => GLPointers.glTrackMatrixNV_Lazy((uint)target, address, (uint)matrix, (uint)transform);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glTransformFeedbackAttribsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void TransformFeedbackAttribsNV(int count, int* attribs, All bufferMode) => GLPointers.glTransformFeedbackAttribsNV_Lazy(count, attribs, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glTransformFeedbackStreamAttribsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void TransformFeedbackStreamAttribsNV(int count, int* attribs, int nbuffers, int* bufstreams, All bufferMode) => GLPointers.glTransformFeedbackStreamAttribsNV_Lazy(count, attribs, nbuffers, bufstreams, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glTransformFeedbackVaryingsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_transform_feedback.txt"/></remarks>
            public static void TransformFeedbackVaryingsNV(int program, int count, TransformFeedbackTokenNV* locations, TransformFeedbackBufferMode bufferMode) => GLPointers.glTransformFeedbackVaryingsNV_Lazy(program, count, (int*)locations, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glTransformPathNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, float* transformValues) => GLPointers.glTransformPathNV_Lazy(resultPath, srcPath, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform1i64NV(int location, long x) => GLPointers.glUniform1i64NV_Lazy(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform1i64vNV(int location, int count, long* value) => GLPointers.glUniform1i64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform1ui64NV(int location, ulong x) => GLPointers.glUniform1ui64NV_Lazy(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform1ui64vNV(int location, int count, ulong* value) => GLPointers.glUniform1ui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform2i64NV(int location, long x, long y) => GLPointers.glUniform2i64NV_Lazy(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform2i64vNV(int location, int count, long* value) => GLPointers.glUniform2i64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform2ui64NV(int location, ulong x, ulong y) => GLPointers.glUniform2ui64NV_Lazy(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform2ui64vNV(int location, int count, ulong* value) => GLPointers.glUniform2ui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform3i64NV(int location, long x, long y, long z) => GLPointers.glUniform3i64NV_Lazy(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform3i64vNV(int location, int count, long* value) => GLPointers.glUniform3i64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z) => GLPointers.glUniform3ui64NV_Lazy(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform3ui64vNV(int location, int count, ulong* value) => GLPointers.glUniform3ui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform4i64NV(int location, long x, long y, long z, long w) => GLPointers.glUniform4i64NV_Lazy(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform4i64vNV(int location, int count, long* value) => GLPointers.glUniform4i64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers.glUniform4ui64NV_Lazy(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/AMD_gpu_shader_int64.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_gpu_shader5.txt"/></remarks>
            public static void Uniform4ui64vNV(int location, int count, ulong* value) => GLPointers.glUniform4ui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glUniformHandleui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static void UniformHandleui64NV(int location, ulong value) => GLPointers.glUniformHandleui64NV_Lazy(location, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glUniformHandleui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_bindless_texture.txt"/></remarks>
            public static void UniformHandleui64vNV(int location, int count, ulong* value) => GLPointers.glUniformHandleui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glUniformui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void Uniformui64NV(int location, ulong value) => GLPointers.glUniformui64NV_Lazy(location, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glUniformui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_buffer_load.txt"/></remarks>
            public static void Uniformui64vNV(int location, int count, ulong* value) => GLPointers.glUniformui64vNV_Lazy(location, count, value);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUFiniNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static void VDPAUFiniNV() => GLPointers.glVDPAUFiniNV_Lazy();
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUGetSurfaceivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static void VDPAUGetSurfaceivNV(IntPtr surface, All pname, int count, int* length, int* values) => GLPointers.glVDPAUGetSurfaceivNV_Lazy(surface, (uint)pname, count, length, values);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUInitNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static void VDPAUInitNV(void* vdpDevice, void* getProcAddress) => GLPointers.glVDPAUInitNV_Lazy(vdpDevice, getProcAddress);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUIsSurfaceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static bool VDPAUIsSurfaceNV(IntPtr surface) => GLPointers.glVDPAUIsSurfaceNV_Lazy(surface) != 0;
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUMapSurfacesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static void VDPAUMapSurfacesNV(int numSurfaces, IntPtr* surfaces) => GLPointers.glVDPAUMapSurfacesNV_Lazy(numSurfaces, surfaces);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAURegisterOutputSurfaceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static IntPtr VDPAURegisterOutputSurfaceNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => GLPointers.glVDPAURegisterOutputSurfaceNV_Lazy(vdpSurface, (uint)target, numTextureNames, textureNames);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAURegisterVideoSurfaceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static IntPtr VDPAURegisterVideoSurfaceNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => GLPointers.glVDPAURegisterVideoSurfaceNV_Lazy(vdpSurface, (uint)target, numTextureNames, textureNames);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop2]</b> <b>[entry point: <c>glVDPAURegisterVideoSurfaceWithPictureStructureNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop2.txt"/></remarks>
            public static IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames, bool isFrameStructure) => GLPointers.glVDPAURegisterVideoSurfaceWithPictureStructureNV_Lazy(vdpSurface, (uint)target, numTextureNames, textureNames, (byte)(isFrameStructure ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUSurfaceAccessNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static void VDPAUSurfaceAccessNV(IntPtr surface, All access) => GLPointers.glVDPAUSurfaceAccessNV_Lazy(surface, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUUnmapSurfacesNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static void VDPAUUnmapSurfacesNV(int numSurface, IntPtr* surfaces) => GLPointers.glVDPAUUnmapSurfacesNV_Lazy(numSurface, surfaces);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUUnregisterSurfaceNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vdpau_interop.txt"/></remarks>
            public static void VDPAUUnregisterSurfaceNV(IntPtr surface) => GLPointers.glVDPAUUnregisterSurfaceNV_Lazy(surface);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex2hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Vertex2hNV(Half x, Half y) => GLPointers.glVertex2hNV_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex2hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Vertex2hvNV(Half* v) => GLPointers.glVertex2hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex3hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Vertex3hNV(Half x, Half y, Half z) => GLPointers.glVertex3hNV_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex3hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Vertex3hvNV(Half* v) => GLPointers.glVertex3hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex4hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Vertex4hNV(Half x, Half y, Half z, Half w) => GLPointers.glVertex4hNV_Lazy(x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex4hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void Vertex4hvNV(Half* v) => GLPointers.glVertex4hvNV_Lazy(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_array_range]</b> <b>[entry point: <c>glVertexArrayRangeNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_array_range.txt"/></remarks>
            public static void VertexArrayRangeNV(int length, void* pointer) => GLPointers.glVertexArrayRangeNV_Lazy(length, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1dNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib1dNV(uint index, double x) => GLPointers.glVertexAttrib1dNV_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib1dvNV(uint index, double* v) => GLPointers.glVertexAttrib1dvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib1fNV(uint index, float x) => GLPointers.glVertexAttrib1fNV_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib1fvNV(uint index, float* v) => GLPointers.glVertexAttrib1fvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib1hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttrib1hNV(uint index, Half x) => GLPointers.glVertexAttrib1hNV_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib1hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttrib1hvNV(uint index, Half* v) => GLPointers.glVertexAttrib1hvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1sNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib1sNV(uint index, short x) => GLPointers.glVertexAttrib1sNV_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1svNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib1svNV(uint index, short* v) => GLPointers.glVertexAttrib1svNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2dNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib2dNV(uint index, double x, double y) => GLPointers.glVertexAttrib2dNV_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib2dvNV(uint index, double* v) => GLPointers.glVertexAttrib2dvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib2fNV(uint index, float x, float y) => GLPointers.glVertexAttrib2fNV_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib2fvNV(uint index, float* v) => GLPointers.glVertexAttrib2fvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib2hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttrib2hNV(uint index, Half x, Half y) => GLPointers.glVertexAttrib2hNV_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib2hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttrib2hvNV(uint index, Half* v) => GLPointers.glVertexAttrib2hvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2sNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib2sNV(uint index, short x, short y) => GLPointers.glVertexAttrib2sNV_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2svNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib2svNV(uint index, short* v) => GLPointers.glVertexAttrib2svNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3dNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib3dNV(uint index, double x, double y, double z) => GLPointers.glVertexAttrib3dNV_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib3dvNV(uint index, double* v) => GLPointers.glVertexAttrib3dvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib3fNV(uint index, float x, float y, float z) => GLPointers.glVertexAttrib3fNV_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib3fvNV(uint index, float* v) => GLPointers.glVertexAttrib3fvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib3hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttrib3hNV(uint index, Half x, Half y, Half z) => GLPointers.glVertexAttrib3hNV_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib3hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttrib3hvNV(uint index, Half* v) => GLPointers.glVertexAttrib3hvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3sNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib3sNV(uint index, short x, short y, short z) => GLPointers.glVertexAttrib3sNV_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3svNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib3svNV(uint index, short* v) => GLPointers.glVertexAttrib3svNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4dNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib4dNV(uint index, double x, double y, double z, double w) => GLPointers.glVertexAttrib4dNV_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib4dvNV(uint index, double* v) => GLPointers.glVertexAttrib4dvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4fNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib4fNV(uint index, float x, float y, float z, float w) => GLPointers.glVertexAttrib4fNV_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib4fvNV(uint index, float* v) => GLPointers.glVertexAttrib4fvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib4hNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttrib4hNV(uint index, Half x, Half y, Half z, Half w) => GLPointers.glVertexAttrib4hNV_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib4hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttrib4hvNV(uint index, Half* v) => GLPointers.glVertexAttrib4hvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4sNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib4sNV(uint index, short x, short y, short z, short w) => GLPointers.glVertexAttrib4sNV_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4svNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib4svNV(uint index, short* v) => GLPointers.glVertexAttrib4svNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4ubNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib4ubNV(uint index, byte x, byte y, byte z, byte w) => GLPointers.glVertexAttrib4ubNV_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4ubvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttrib4ubvNV(uint index, byte* v) => GLPointers.glVertexAttrib4ubvNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glVertexAttribFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void VertexAttribFormatNV(uint index, int size, VertexAttribType type, bool normalized, int stride) => GLPointers.glVertexAttribFormatNV_Lazy(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI1iEXT(uint index, int x) => GLPointers.glVertexAttribI1iEXT_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI1ivEXT(uint index, int* v) => GLPointers.glVertexAttribI1ivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI1uiEXT(uint index, uint x) => GLPointers.glVertexAttribI1uiEXT_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI1uivEXT(uint index, uint* v) => GLPointers.glVertexAttribI1uivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI2iEXT(uint index, int x, int y) => GLPointers.glVertexAttribI2iEXT_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI2ivEXT(uint index, int* v) => GLPointers.glVertexAttribI2ivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI2uiEXT(uint index, uint x, uint y) => GLPointers.glVertexAttribI2uiEXT_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI2uivEXT(uint index, uint* v) => GLPointers.glVertexAttribI2uivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI3iEXT(uint index, int x, int y, int z) => GLPointers.glVertexAttribI3iEXT_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI3ivEXT(uint index, int* v) => GLPointers.glVertexAttribI3ivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => GLPointers.glVertexAttribI3uiEXT_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI3uivEXT(uint index, uint* v) => GLPointers.glVertexAttribI3uivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4bvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4bvEXT(uint index, sbyte* v) => GLPointers.glVertexAttribI4bvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4iEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => GLPointers.glVertexAttribI4iEXT_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4ivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4ivEXT(uint index, int* v) => GLPointers.glVertexAttribI4ivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4svEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4svEXT(uint index, short* v) => GLPointers.glVertexAttribI4svEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4ubvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4ubvEXT(uint index, byte* v) => GLPointers.glVertexAttribI4ubvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4uiEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => GLPointers.glVertexAttribI4uiEXT_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4uivEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4uivEXT(uint index, uint* v) => GLPointers.glVertexAttribI4uivEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4usvEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribI4usvEXT(uint index, ushort* v) => GLPointers.glVertexAttribI4usvEXT_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glVertexAttribIFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void VertexAttribIFormatNV(uint index, int size, VertexAttribIType type, int stride) => GLPointers.glVertexAttribIFormatNV_Lazy(index, size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribIPointerEXT</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_gpu_shader4.txt"/><br/><see href="https://registry.khronos.org/OpenGL/extensions/EXT/NV_vertex_program4.txt"/></remarks>
            public static void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers.glVertexAttribIPointerEXT_Lazy(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL1i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL1i64NV(uint index, long x) => GLPointers.glVertexAttribL1i64NV_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL1i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL1i64vNV(uint index, long* v) => GLPointers.glVertexAttribL1i64vNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL1ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL1ui64NV(uint index, ulong x) => GLPointers.glVertexAttribL1ui64NV_Lazy(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL1ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL1ui64vNV(uint index, ulong* v) => GLPointers.glVertexAttribL1ui64vNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL2i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL2i64NV(uint index, long x, long y) => GLPointers.glVertexAttribL2i64NV_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL2i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL2i64vNV(uint index, long* v) => GLPointers.glVertexAttribL2i64vNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL2ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL2ui64NV(uint index, ulong x, ulong y) => GLPointers.glVertexAttribL2ui64NV_Lazy(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL2ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL2ui64vNV(uint index, ulong* v) => GLPointers.glVertexAttribL2ui64vNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL3i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL3i64NV(uint index, long x, long y, long z) => GLPointers.glVertexAttribL3i64NV_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL3i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL3i64vNV(uint index, long* v) => GLPointers.glVertexAttribL3i64vNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL3ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL3ui64NV(uint index, ulong x, ulong y, ulong z) => GLPointers.glVertexAttribL3ui64NV_Lazy(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL3ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL3ui64vNV(uint index, ulong* v) => GLPointers.glVertexAttribL3ui64vNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL4i64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL4i64NV(uint index, long x, long y, long z, long w) => GLPointers.glVertexAttribL4i64NV_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL4i64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL4i64vNV(uint index, long* v) => GLPointers.glVertexAttribL4i64vNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL4ui64NV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL4ui64NV(uint index, ulong x, ulong y, ulong z, ulong w) => GLPointers.glVertexAttribL4ui64NV_Lazy(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL4ui64vNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribL4ui64vNV(uint index, ulong* v) => GLPointers.glVertexAttribL4ui64vNV_Lazy(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribLFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_attrib_integer_64bit.txt"/></remarks>
            public static void VertexAttribLFormatNV(uint index, int size, VertexAttribLType type, int stride) => GLPointers.glVertexAttribLFormatNV_Lazy(index, size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribPointerNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribPointerNV(uint index, int fsize, VertexAttribEnumNV type, int stride, void* pointer) => GLPointers.glVertexAttribPointerNV_Lazy(index, fsize, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs1dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs1dvNV(uint index, int count, double* v) => GLPointers.glVertexAttribs1dvNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs1fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs1fvNV(uint index, int count, float* v) => GLPointers.glVertexAttribs1fvNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttribs1hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttribs1hvNV(uint index, int n, Half* v) => GLPointers.glVertexAttribs1hvNV_Lazy(index, n, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs1svNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs1svNV(uint index, int count, short* v) => GLPointers.glVertexAttribs1svNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs2dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs2dvNV(uint index, int count, double* v) => GLPointers.glVertexAttribs2dvNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs2fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs2fvNV(uint index, int count, float* v) => GLPointers.glVertexAttribs2fvNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttribs2hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttribs2hvNV(uint index, int n, Half* v) => GLPointers.glVertexAttribs2hvNV_Lazy(index, n, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs2svNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs2svNV(uint index, int count, short* v) => GLPointers.glVertexAttribs2svNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs3dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs3dvNV(uint index, int count, double* v) => GLPointers.glVertexAttribs3dvNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs3fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs3fvNV(uint index, int count, float* v) => GLPointers.glVertexAttribs3fvNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttribs3hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttribs3hvNV(uint index, int n, Half* v) => GLPointers.glVertexAttribs3hvNV_Lazy(index, n, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs3svNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs3svNV(uint index, int count, short* v) => GLPointers.glVertexAttribs3svNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs4dvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs4dvNV(uint index, int count, double* v) => GLPointers.glVertexAttribs4dvNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs4fvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs4fvNV(uint index, int count, float* v) => GLPointers.glVertexAttribs4fvNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttribs4hvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexAttribs4hvNV(uint index, int n, Half* v) => GLPointers.glVertexAttribs4hvNV_Lazy(index, n, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs4svNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs4svNV(uint index, int count, short* v) => GLPointers.glVertexAttribs4svNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs4ubvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_program.txt"/></remarks>
            public static void VertexAttribs4ubvNV(uint index, int count, byte* v) => GLPointers.glVertexAttribs4ubvNV_Lazy(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glVertexFormatNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_vertex_buffer_unified_memory.txt"/></remarks>
            public static void VertexFormatNV(int size, VertexPointerType type, int stride) => GLPointers.glVertexFormatNV_Lazy(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexWeighthNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexWeighthNV(Half weight) => GLPointers.glVertexWeighthNV_Lazy(weight);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexWeighthvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_half_float.txt"/></remarks>
            public static void VertexWeighthvNV(Half* weight) => GLPointers.glVertexWeighthvNV_Lazy(weight);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glVideoCaptureNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static All VideoCaptureNV(uint video_capture_slot, uint* sequence_num, ulong* capture_time) => (All) GLPointers.glVideoCaptureNV_Lazy(video_capture_slot, sequence_num, capture_time);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glVideoCaptureStreamParameterdvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, All pname, double* parameters) => GLPointers.glVideoCaptureStreamParameterdvNV_Lazy(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glVideoCaptureStreamParameterfvNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, All pname, float* parameters) => GLPointers.glVideoCaptureStreamParameterfvNV_Lazy(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glVideoCaptureStreamParameterivNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_video_capture.txt"/></remarks>
            public static void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, All pname, int* parameters) => GLPointers.glVideoCaptureStreamParameterivNV_Lazy(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_clip_space_w_scaling]</b> <b>[entry point: <c>glViewportPositionWScaleNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_clip_space_w_scaling.txt"/></remarks>
            public static void ViewportPositionWScaleNV(uint index, float xcoeff, float ycoeff) => GLPointers.glViewportPositionWScaleNV_Lazy(index, xcoeff, ycoeff);
            
            /// <summary> <b>[requires: GL_NV_viewport_swizzle]</b> <b>[entry point: <c>glViewportSwizzleNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_viewport_swizzle.txt"/></remarks>
            public static void ViewportSwizzleNV(uint index, All swizzlex, All swizzley, All swizzlez, All swizzlew) => GLPointers.glViewportSwizzleNV_Lazy(index, (uint)swizzlex, (uint)swizzley, (uint)swizzlez, (uint)swizzlew);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glWaitVkSemaphoreNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_draw_vulkan_image.txt"/></remarks>
            public static void WaitVkSemaphoreNV(ulong vkSemaphore) => GLPointers.glWaitVkSemaphoreNV_Lazy(vkSemaphore);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glWeightPathsNV</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NV/NV_path_rendering.txt"/></remarks>
            public static void WeightPathsNV(uint resultPath, int numPaths, uint* paths, float* weights) => GLPointers.glWeightPathsNV_Lazy(resultPath, numPaths, paths, weights);
            
        }
        /// <summary>NVX extensions.</summary>
        public static unsafe partial class NVX
        {
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glAsyncCopyBufferSubDataNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_gpu_multicast2.txt"/></remarks>
            public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => GLPointers.glAsyncCopyBufferSubDataNVX_Lazy(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glAsyncCopyImageSubDataNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_gpu_multicast2.txt"/></remarks>
            public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => GLPointers.glAsyncCopyImageSubDataNVX_Lazy(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            
            /// <summary> <b>[requires: GL_NVX_conditional_render]</b> <b>[entry point: <c>glBeginConditionalRenderNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_conditional_render.txt"/></remarks>
            public static void BeginConditionalRenderNVX(uint id) => GLPointers.glBeginConditionalRenderNVX_Lazy(id);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b> <b>[entry point: <c>glClientWaitSemaphoreui64NVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_progress_fence.txt"/></remarks>
            public static void ClientWaitSemaphoreui64NVX(int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers.glClientWaitSemaphoreui64NVX_Lazy(fenceObjectCount, semaphoreArray, fenceValueArray);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b> <b>[entry point: <c>glCreateProgressFenceNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_progress_fence.txt"/></remarks>
            public static uint CreateProgressFenceNVX() => GLPointers.glCreateProgressFenceNVX_Lazy();
            
            /// <summary> <b>[requires: GL_NVX_conditional_render]</b> <b>[entry point: <c>glEndConditionalRenderNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_conditional_render.txt"/></remarks>
            public static void EndConditionalRenderNVX() => GLPointers.glEndConditionalRenderNVX_Lazy();
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b> <b>[entry point: <c>glLGPUCopyImageSubDataNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_linked_gpu_multicast.txt"/></remarks>
            public static void LGPUCopyImageSubDataNVX(uint sourceGpu, uint destinationGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => GLPointers.glLGPUCopyImageSubDataNVX_Lazy(sourceGpu, destinationGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srxY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b> <b>[entry point: <c>glLGPUInterlockNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_linked_gpu_multicast.txt"/></remarks>
            public static void LGPUInterlockNVX() => GLPointers.glLGPUInterlockNVX_Lazy();
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b> <b>[entry point: <c>glLGPUNamedBufferSubDataNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_linked_gpu_multicast.txt"/></remarks>
            public static void LGPUNamedBufferSubDataNVX(uint gpuMask, int buffer, IntPtr offset, nint size, void* data) => GLPointers.glLGPUNamedBufferSubDataNVX_Lazy(gpuMask, buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glMulticastScissorArrayvNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_gpu_multicast2.txt"/></remarks>
            public static void MulticastScissorArrayvNVX(uint gpu, uint first, int count, int* v) => GLPointers.glMulticastScissorArrayvNVX_Lazy(gpu, first, count, v);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glMulticastViewportArrayvNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_gpu_multicast2.txt"/></remarks>
            public static void MulticastViewportArrayvNVX(uint gpu, uint first, int count, float* v) => GLPointers.glMulticastViewportArrayvNVX_Lazy(gpu, first, count, v);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glMulticastViewportPositionWScaleNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_gpu_multicast2.txt"/></remarks>
            public static void MulticastViewportPositionWScaleNVX(uint gpu, uint index, float xcoeff, float ycoeff) => GLPointers.glMulticastViewportPositionWScaleNVX_Lazy(gpu, index, xcoeff, ycoeff);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b> <b>[entry point: <c>glSignalSemaphoreui64NVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_progress_fence.txt"/></remarks>
            public static void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers.glSignalSemaphoreui64NVX_Lazy(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glUploadGpuMaskNVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_gpu_multicast2.txt"/></remarks>
            public static void UploadGpuMaskNVX(uint mask) => GLPointers.glUploadGpuMaskNVX_Lazy(mask);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b> <b>[entry point: <c>glWaitSemaphoreui64NVX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/NVX/NVX_progress_fence.txt"/></remarks>
            public static void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers.glWaitSemaphoreui64NVX_Lazy(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            
        }
        /// <summary>OES extensions.</summary>
        public static unsafe partial class OES
        {
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glAccumxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void AccumxOES(All op, int value) => GLPointers.glAccumxOES_Lazy((uint)op, value);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glAlphaFuncxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void AlphaFuncxOES(AlphaFunction func, int reference) => GLPointers.glAlphaFuncxOES_Lazy((uint)func, reference);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glBitmapxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, byte* bitmap) => GLPointers.glBitmapxOES_Lazy(width, height, xorig, yorig, xmove, ymove, bitmap);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glBlendColorxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void BlendColorxOES(int red, int green, int blue, int alpha) => GLPointers.glBlendColorxOES_Lazy(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glClearAccumxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void ClearAccumxOES(int red, int green, int blue, int alpha) => GLPointers.glClearAccumxOES_Lazy(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glClearColorxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void ClearColorxOES(int red, int green, int blue, int alpha) => GLPointers.glClearColorxOES_Lazy(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glClearDepthfOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_single_precision.txt"/></remarks>
            public static void ClearDepthfOES(float depth) => GLPointers.glClearDepthfOES_Lazy(depth);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glClearDepthxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void ClearDepthxOES(int depth) => GLPointers.glClearDepthxOES_Lazy(depth);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glClipPlanefOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_single_precision.txt"/></remarks>
            public static void ClipPlanefOES(ClipPlaneName plane, float* equation) => GLPointers.glClipPlanefOES_Lazy((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glClipPlanexOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void ClipPlanexOES(ClipPlaneName plane, int* equation) => GLPointers.glClipPlanexOES_Lazy((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glColor3xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Color3xOES(int red, int green, int blue) => GLPointers.glColor3xOES_Lazy(red, green, blue);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glColor3xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Color3xvOES(int* components) => GLPointers.glColor3xvOES_Lazy(components);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glColor4xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Color4xOES(int red, int green, int blue, int alpha) => GLPointers.glColor4xOES_Lazy(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glColor4xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Color4xvOES(int* components) => GLPointers.glColor4xvOES_Lazy(components);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glConvolutionParameterxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void ConvolutionParameterxOES(ConvolutionTargetEXT target, ConvolutionParameter pname, int param) => GLPointers.glConvolutionParameterxOES_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glConvolutionParameterxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameter pname, int* parameters) => GLPointers.glConvolutionParameterxvOES_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glDepthRangefOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_single_precision.txt"/></remarks>
            public static void DepthRangefOES(float n, float f) => GLPointers.glDepthRangefOES_Lazy(n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glDepthRangexOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void DepthRangexOES(int n, int f) => GLPointers.glDepthRangexOES_Lazy(n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glEvalCoord1xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void EvalCoord1xOES(int u) => GLPointers.glEvalCoord1xOES_Lazy(u);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glEvalCoord1xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void EvalCoord1xvOES(int* coords) => GLPointers.glEvalCoord1xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glEvalCoord2xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void EvalCoord2xOES(int u, int v) => GLPointers.glEvalCoord2xOES_Lazy(u, v);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glEvalCoord2xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void EvalCoord2xvOES(int* coords) => GLPointers.glEvalCoord2xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glFeedbackBufferxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void FeedbackBufferxOES(int n, All type, int* buffer) => GLPointers.glFeedbackBufferxOES_Lazy(n, (uint)type, buffer);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glFogxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void FogxOES(FogPName pname, int param) => GLPointers.glFogxOES_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glFogxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void FogxvOES(FogPName pname, int* param) => GLPointers.glFogxvOES_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glFrustumfOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_single_precision.txt"/></remarks>
            public static void FrustumfOES(float l, float r, float b, float t, float n, float f) => GLPointers.glFrustumfOES_Lazy(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glFrustumxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void FrustumxOES(int l, int r, int b, int t, int n, int f) => GLPointers.glFrustumxOES_Lazy(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glGetClipPlanefOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_single_precision.txt"/></remarks>
            public static void GetClipPlanefOES(ClipPlaneName plane, float* equation) => GLPointers.glGetClipPlanefOES_Lazy((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetClipPlanexOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetClipPlanexOES(ClipPlaneName plane, int* equation) => GLPointers.glGetClipPlanexOES_Lazy((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetConvolutionParameterxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetConvolutionParameterxvOES(All target, All pname, int* parameters) => GLPointers.glGetConvolutionParameterxvOES_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetFixedvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetFixedvOES(GetPName pname, int* parameters) => GLPointers.glGetFixedvOES_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetHistogramParameterxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers.glGetHistogramParameterxvOES_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetLightxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetLightxOES(LightName light, LightParameter pname, int* parameters) => GLPointers.glGetLightxOES_Lazy((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetLightxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetLightxvOES(LightName light, LightParameter pname, int* parameters) => GLPointers.glGetLightxvOES_Lazy((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetMapxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetMapxvOES(MapTarget target, GetMapQuery query, int* v) => GLPointers.glGetMapxvOES_Lazy((uint)target, (uint)query, v);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetMaterialxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetMaterialxOES(TriangleFace face, MaterialParameter pname, int param) => GLPointers.glGetMaterialxOES_Lazy((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetMaterialxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetMaterialxvOES(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers.glGetMaterialxvOES_Lazy((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetPixelMapxv</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetPixelMapxv(PixelMap map, int size, int* values) => GLPointers.glGetPixelMapxv_Lazy((uint)map, size, values);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetTexEnvxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers.glGetTexEnvxvOES_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetTexGenxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers.glGetTexGenxvOES_Lazy((uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetTexLevelParameterxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers.glGetTexLevelParameterxvOES_Lazy((uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetTexParameterxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers.glGetTexParameterxvOES_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glIndexxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void IndexxOES(int component) => GLPointers.glIndexxOES_Lazy(component);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glIndexxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void IndexxvOES(int* component) => GLPointers.glIndexxvOES_Lazy(component);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLightModelxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void LightModelxOES(LightModelParameter pname, int param) => GLPointers.glLightModelxOES_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLightModelxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void LightModelxvOES(LightModelParameter pname, int* param) => GLPointers.glLightModelxvOES_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLightxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void LightxOES(LightName light, LightParameter pname, int param) => GLPointers.glLightxOES_Lazy((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLightxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void LightxvOES(LightName light, LightParameter pname, int* parameters) => GLPointers.glLightxvOES_Lazy((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLineWidthxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void LineWidthxOES(int width) => GLPointers.glLineWidthxOES_Lazy(width);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLoadMatrixxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void LoadMatrixxOES(int* m) => GLPointers.glLoadMatrixxOES_Lazy(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLoadTransposeMatrixxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void LoadTransposeMatrixxOES(int* m) => GLPointers.glLoadTransposeMatrixxOES_Lazy(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMap1xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Map1xOES(MapTarget target, int u1, int u2, int stride, int order, int points) => GLPointers.glMap1xOES_Lazy((uint)target, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMap2xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Map2xOES(MapTarget target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points) => GLPointers.glMap2xOES_Lazy((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMapGrid1xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MapGrid1xOES(int n, int u1, int u2) => GLPointers.glMapGrid1xOES_Lazy(n, u1, u2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMapGrid2xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MapGrid2xOES(int n, int u1, int u2, int v1, int v2) => GLPointers.glMapGrid2xOES_Lazy(n, u1, u2, v1, v2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMaterialxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MaterialxOES(TriangleFace face, MaterialParameter pname, int param) => GLPointers.glMaterialxOES_Lazy((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMaterialxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MaterialxvOES(TriangleFace face, MaterialParameter pname, int* param) => GLPointers.glMaterialxvOES_Lazy((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord1bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void MultiTexCoord1bOES(TextureUnit texture, sbyte s) => GLPointers.glMultiTexCoord1bOES_Lazy((uint)texture, s);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord1bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void MultiTexCoord1bvOES(TextureUnit texture, sbyte* coords) => GLPointers.glMultiTexCoord1bvOES_Lazy((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord1xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultiTexCoord1xOES(TextureUnit texture, int s) => GLPointers.glMultiTexCoord1xOES_Lazy((uint)texture, s);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord1xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultiTexCoord1xvOES(TextureUnit texture, int* coords) => GLPointers.glMultiTexCoord1xvOES_Lazy((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord2bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void MultiTexCoord2bOES(TextureUnit texture, sbyte s, sbyte t) => GLPointers.glMultiTexCoord2bOES_Lazy((uint)texture, s, t);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord2bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void MultiTexCoord2bvOES(TextureUnit texture, sbyte* coords) => GLPointers.glMultiTexCoord2bvOES_Lazy((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord2xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultiTexCoord2xOES(TextureUnit texture, int s, int t) => GLPointers.glMultiTexCoord2xOES_Lazy((uint)texture, s, t);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord2xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultiTexCoord2xvOES(TextureUnit texture, int* coords) => GLPointers.glMultiTexCoord2xvOES_Lazy((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord3bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void MultiTexCoord3bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r) => GLPointers.glMultiTexCoord3bOES_Lazy((uint)texture, s, t, r);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord3bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void MultiTexCoord3bvOES(TextureUnit texture, sbyte* coords) => GLPointers.glMultiTexCoord3bvOES_Lazy((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord3xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultiTexCoord3xOES(TextureUnit texture, int s, int t, int r) => GLPointers.glMultiTexCoord3xOES_Lazy((uint)texture, s, t, r);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord3xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultiTexCoord3xvOES(TextureUnit texture, int* coords) => GLPointers.glMultiTexCoord3xvOES_Lazy((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord4bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void MultiTexCoord4bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r, sbyte q) => GLPointers.glMultiTexCoord4bOES_Lazy((uint)texture, s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord4bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void MultiTexCoord4bvOES(TextureUnit texture, sbyte* coords) => GLPointers.glMultiTexCoord4bvOES_Lazy((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord4xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultiTexCoord4xOES(TextureUnit texture, int s, int t, int r, int q) => GLPointers.glMultiTexCoord4xOES_Lazy((uint)texture, s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord4xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultiTexCoord4xvOES(TextureUnit texture, int* coords) => GLPointers.glMultiTexCoord4xvOES_Lazy((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultMatrixxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultMatrixxOES(int* m) => GLPointers.glMultMatrixxOES_Lazy(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultTransposeMatrixxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void MultTransposeMatrixxOES(int* m) => GLPointers.glMultTransposeMatrixxOES_Lazy(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glNormal3xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Normal3xOES(int nx, int ny, int nz) => GLPointers.glNormal3xOES_Lazy(nx, ny, nz);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glNormal3xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Normal3xvOES(int* coords) => GLPointers.glNormal3xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glOrthofOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_single_precision.txt"/></remarks>
            public static void OrthofOES(float l, float r, float b, float t, float n, float f) => GLPointers.glOrthofOES_Lazy(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glOrthoxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void OrthoxOES(int l, int r, int b, int t, int n, int f) => GLPointers.glOrthoxOES_Lazy(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPassThroughxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PassThroughxOES(int token) => GLPointers.glPassThroughxOES_Lazy(token);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPixelMapx</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PixelMapx(PixelMap map, int size, int* values) => GLPointers.glPixelMapx_Lazy((uint)map, size, values);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPixelStorex</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PixelStorex(PixelStoreParameter pname, int param) => GLPointers.glPixelStorex_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPixelTransferxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PixelTransferxOES(PixelTransferParameter pname, int param) => GLPointers.glPixelTransferxOES_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPixelZoomxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PixelZoomxOES(int xfactor, int yfactor) => GLPointers.glPixelZoomxOES_Lazy(xfactor, yfactor);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPointParameterxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PointParameterxOES(PointParameterNameARB pname, int param) => GLPointers.glPointParameterxOES_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPointParameterxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PointParameterxvOES(PointParameterNameARB pname, int* parameters) => GLPointers.glPointParameterxvOES_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPointSizexOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PointSizexOES(int size) => GLPointers.glPointSizexOES_Lazy(size);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPolygonOffsetxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PolygonOffsetxOES(int factor, int units) => GLPointers.glPolygonOffsetxOES_Lazy(factor, units);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPrioritizeTexturesxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void PrioritizeTexturesxOES(int n, int* textures, int* priorities) => GLPointers.glPrioritizeTexturesxOES_Lazy(n, textures, priorities);
            
            /// <summary> <b>[requires: GL_OES_query_matrix]</b> <b>[entry point: <c>glQueryMatrixxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_query_matrix.txt"/></remarks>
            public static uint QueryMatrixxOES(int* mantissa, int* exponent) => GLPointers.glQueryMatrixxOES_Lazy(mantissa, exponent);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos2xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void RasterPos2xOES(int x, int y) => GLPointers.glRasterPos2xOES_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos2xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void RasterPos2xvOES(int* coords) => GLPointers.glRasterPos2xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos3xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void RasterPos3xOES(int x, int y, int z) => GLPointers.glRasterPos3xOES_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos3xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void RasterPos3xvOES(int* coords) => GLPointers.glRasterPos3xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos4xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void RasterPos4xOES(int x, int y, int z, int w) => GLPointers.glRasterPos4xOES_Lazy(x, y, z, w);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos4xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void RasterPos4xvOES(int* coords) => GLPointers.glRasterPos4xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRectxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void RectxOES(int x1, int y1, int x2, int y2) => GLPointers.glRectxOES_Lazy(x1, y1, x2, y2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRectxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void RectxvOES(int* v1, int* v2) => GLPointers.glRectxvOES_Lazy(v1, v2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRotatexOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void RotatexOES(int angle, int x, int y, int z) => GLPointers.glRotatexOES_Lazy(angle, x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glSampleCoveragexOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void SampleCoveragexOES(int value, bool invert) => GLPointers.glSampleCoveragexOES_Lazy(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glScalexOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void ScalexOES(int x, int y, int z) => GLPointers.glScalexOES_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord1bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void TexCoord1bOES(sbyte s) => GLPointers.glTexCoord1bOES_Lazy(s);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord1bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void TexCoord1bvOES(sbyte* coords) => GLPointers.glTexCoord1bvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord1xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexCoord1xOES(int s) => GLPointers.glTexCoord1xOES_Lazy(s);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord1xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexCoord1xvOES(int* coords) => GLPointers.glTexCoord1xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord2bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void TexCoord2bOES(sbyte s, sbyte t) => GLPointers.glTexCoord2bOES_Lazy(s, t);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord2bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void TexCoord2bvOES(sbyte* coords) => GLPointers.glTexCoord2bvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord2xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexCoord2xOES(int s, int t) => GLPointers.glTexCoord2xOES_Lazy(s, t);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord2xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexCoord2xvOES(int* coords) => GLPointers.glTexCoord2xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord3bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void TexCoord3bOES(sbyte s, sbyte t, sbyte r) => GLPointers.glTexCoord3bOES_Lazy(s, t, r);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord3bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void TexCoord3bvOES(sbyte* coords) => GLPointers.glTexCoord3bvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord3xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexCoord3xOES(int s, int t, int r) => GLPointers.glTexCoord3xOES_Lazy(s, t, r);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord3xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexCoord3xvOES(int* coords) => GLPointers.glTexCoord3xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord4bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void TexCoord4bOES(sbyte s, sbyte t, sbyte r, sbyte q) => GLPointers.glTexCoord4bOES_Lazy(s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord4bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void TexCoord4bvOES(sbyte* coords) => GLPointers.glTexCoord4bvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord4xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexCoord4xOES(int s, int t, int r, int q) => GLPointers.glTexCoord4xOES_Lazy(s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord4xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexCoord4xvOES(int* coords) => GLPointers.glTexCoord4xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexEnvxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexEnvxOES(TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers.glTexEnvxOES_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexEnvxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers.glTexEnvxvOES_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexGenxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexGenxOES(TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers.glTexGenxOES_Lazy((uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexGenxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers.glTexGenxvOES_Lazy((uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexParameterxOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexParameterxOES(TextureTarget target, GetTextureParameter pname, int param) => GLPointers.glTexParameterxOES_Lazy((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexParameterxvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers.glTexParameterxvOES_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTranslatexOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void TranslatexOES(int x, int y, int z) => GLPointers.glTranslatexOES_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex2bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void Vertex2bOES(sbyte x, sbyte y) => GLPointers.glVertex2bOES_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex2bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void Vertex2bvOES(sbyte* coords) => GLPointers.glVertex2bvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex2xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Vertex2xOES(int x) => GLPointers.glVertex2xOES_Lazy(x);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex2xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Vertex2xvOES(int* coords) => GLPointers.glVertex2xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex3bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void Vertex3bOES(sbyte x, sbyte y, sbyte z) => GLPointers.glVertex3bOES_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex3bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void Vertex3bvOES(sbyte* coords) => GLPointers.glVertex3bvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex3xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Vertex3xOES(int x, int y) => GLPointers.glVertex3xOES_Lazy(x, y);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex3xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Vertex3xvOES(int* coords) => GLPointers.glVertex3xvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex4bOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void Vertex4bOES(sbyte x, sbyte y, sbyte z, sbyte w) => GLPointers.glVertex4bOES_Lazy(x, y, z, w);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex4bvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_byte_coordinates.txt"/></remarks>
            public static void Vertex4bvOES(sbyte* coords) => GLPointers.glVertex4bvOES_Lazy(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex4xOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Vertex4xOES(int x, int y, int z) => GLPointers.glVertex4xOES_Lazy(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex4xvOES</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OES/OES_fixed_point.txt"/></remarks>
            public static void Vertex4xvOES(int* coords) => GLPointers.glVertex4xvOES_Lazy(coords);
            
        }
        /// <summary>OVR extensions.</summary>
        public static unsafe partial class OVR
        {
            /// <summary> <b>[requires: GL_OVR_multiview]</b> <b>[entry point: <c>glFramebufferTextureMultiviewOVR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OVR/OVR_multiview.txt"/></remarks>
            public static void FramebufferTextureMultiviewOVR(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int baseViewIndex, int numViews) => GLPointers.glFramebufferTextureMultiviewOVR_Lazy((uint)target, (uint)attachment, texture, level, baseViewIndex, numViews);
            
            /// <summary> <b>[requires: GL_OVR_multiview]</b> <b>[entry point: <c>glNamedFramebufferTextureMultiviewOVR</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/OVR/OVR_multiview.txt"/></remarks>
            public static void NamedFramebufferTextureMultiviewOVR(int framebuffer, FramebufferAttachment attachment, int texture, int level, int baseViewIndex, int numViews) => GLPointers.glNamedFramebufferTextureMultiviewOVR_Lazy(framebuffer, (uint)attachment, texture, level, baseViewIndex, numViews);
            
        }
        /// <summary>PGI extensions.</summary>
        public static unsafe partial class PGI
        {
            /// <summary> <b>[requires: GL_PGI_misc_hints]</b> <b>[entry point: <c>glHintPGI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/PGI/PGI_misc_hints.txt"/></remarks>
            public static void HintPGI(HintTargetPGI target, VertexHintsMaskPGI mode) => GLPointers.glHintPGI_Lazy((uint)target, (int)mode);
            
        }
        /// <summary>SGI extensions.</summary>
        public static unsafe partial class SGI
        {
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glColorTableParameterfvSGI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGI/SGI_color_table.txt"/></remarks>
            public static void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPName pname, float* parameters) => GLPointers.glColorTableParameterfvSGI_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glColorTableParameterivSGI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGI/SGI_color_table.txt"/></remarks>
            public static void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPName pname, int* parameters) => GLPointers.glColorTableParameterivSGI_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glColorTableSGI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGI/SGI_color_table.txt"/></remarks>
            public static void ColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table) => GLPointers.glColorTableSGI_Lazy((uint)target, (uint)internalformat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glCopyColorTableSGI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGI/SGI_color_table.txt"/></remarks>
            public static void CopyColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int x, int y, int width) => GLPointers.glCopyColorTableSGI_Lazy((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glGetColorTableParameterfvSGI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGI/SGI_color_table.txt"/></remarks>
            public static void GetColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPName pname, float* parameters) => GLPointers.glGetColorTableParameterfvSGI_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glGetColorTableParameterivSGI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGI/SGI_color_table.txt"/></remarks>
            public static void GetColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPName pname, int* parameters) => GLPointers.glGetColorTableParameterivSGI_Lazy((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glGetColorTableSGI</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGI/SGI_color_table.txt"/></remarks>
            public static void GetColorTableSGI(ColorTableTargetSGI target, PixelFormat format, PixelType type, void* table) => GLPointers.glGetColorTableSGI_Lazy((uint)target, (uint)format, (uint)type, table);
            
        }
        /// <summary>SGIS extensions.</summary>
        public static unsafe partial class SGIS
        {
            /// <summary> <b>[requires: GL_SGIS_detail_texture]</b> <b>[entry point: <c>glDetailTexFuncSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_detail_texture.txt"/></remarks>
            public static void DetailTexFuncSGIS(TextureTarget target, int n, float* points) => GLPointers.glDetailTexFuncSGIS_Lazy((uint)target, n, points);
            
            /// <summary> <b>[requires: GL_SGIS_fog_function]</b> <b>[entry point: <c>glFogFuncSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_fog_function.txt"/></remarks>
            public static void FogFuncSGIS(int n, float* points) => GLPointers.glFogFuncSGIS_Lazy(n, points);
            
            /// <summary> <b>[requires: GL_SGIS_detail_texture]</b> <b>[entry point: <c>glGetDetailTexFuncSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_detail_texture.txt"/></remarks>
            public static void GetDetailTexFuncSGIS(TextureTarget target, float* points) => GLPointers.glGetDetailTexFuncSGIS_Lazy((uint)target, points);
            
            /// <summary> <b>[requires: GL_SGIS_fog_function]</b> <b>[entry point: <c>glGetFogFuncSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_fog_function.txt"/></remarks>
            public static void GetFogFuncSGIS(float* points) => GLPointers.glGetFogFuncSGIS_Lazy(points);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glGetPixelTexGenParameterfvSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_pixel_texture.txt"/></remarks>
            public static void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float* parameters) => GLPointers.glGetPixelTexGenParameterfvSGIS_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glGetPixelTexGenParameterivSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_pixel_texture.txt"/></remarks>
            public static void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int* parameters) => GLPointers.glGetPixelTexGenParameterivSGIS_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture]</b> <b>[entry point: <c>glGetSharpenTexFuncSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_sharpen_texture.txt"/></remarks>
            public static void GetSharpenTexFuncSGIS(TextureTarget target, float* points) => GLPointers.glGetSharpenTexFuncSGIS_Lazy((uint)target, points);
            
            /// <summary> <b>[requires: GL_SGIS_texture_filter4]</b> <b>[entry point: <c>glGetTexFilterFuncSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_texture_filter4.txt"/></remarks>
            public static void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, float* weights) => GLPointers.glGetTexFilterFuncSGIS_Lazy((uint)target, (uint)filter, weights);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenParameterfSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_pixel_texture.txt"/></remarks>
            public static void PixelTexGenParameterfSGIS(PixelTexGenParameterNameSGIS pname, float param) => GLPointers.glPixelTexGenParameterfSGIS_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenParameterfvSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_pixel_texture.txt"/></remarks>
            public static void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float* parameters) => GLPointers.glPixelTexGenParameterfvSGIS_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenParameteriSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_pixel_texture.txt"/></remarks>
            public static void PixelTexGenParameteriSGIS(PixelTexGenParameterNameSGIS pname, int param) => GLPointers.glPixelTexGenParameteriSGIS_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenParameterivSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_pixel_texture.txt"/></remarks>
            public static void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int* parameters) => GLPointers.glPixelTexGenParameterivSGIS_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_point_parameters]</b> <b>[entry point: <c>glPointParameterfSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_point_parameters.txt"/></remarks>
            public static void PointParameterfSGIS(PointParameterNameARB pname, float param) => GLPointers.glPointParameterfSGIS_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_point_parameters]</b> <b>[entry point: <c>glPointParameterfvSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_point_parameters.txt"/></remarks>
            public static void PointParameterfvSGIS(PointParameterNameARB pname, float* parameters) => GLPointers.glPointParameterfvSGIS_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_multisample]</b> <b>[entry point: <c>glSampleMaskSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_multisample.txt"/></remarks>
            public static void SampleMaskSGIS(float value, bool invert) => GLPointers.glSampleMaskSGIS_Lazy(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_SGIS_multisample]</b> <b>[entry point: <c>glSamplePatternSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_multisample.txt"/></remarks>
            public static void SamplePatternSGIS(SamplePatternSGIS pattern) => GLPointers.glSamplePatternSGIS_Lazy((uint)pattern);
            
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture]</b> <b>[entry point: <c>glSharpenTexFuncSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_sharpen_texture.txt"/></remarks>
            public static void SharpenTexFuncSGIS(TextureTarget target, int n, float* points) => GLPointers.glSharpenTexFuncSGIS_Lazy((uint)target, n, points);
            
            /// <summary> <b>[requires: GL_SGIS_texture_filter4]</b> <b>[entry point: <c>glTexFilterFuncSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_texture_filter4.txt"/></remarks>
            public static void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, int n, float* weights) => GLPointers.glTexFilterFuncSGIS_Lazy((uint)target, (uint)filter, n, weights);
            
            /// <summary> <b>[requires: GL_SGIS_texture4D]</b> <b>[entry point: <c>glTexImage4DSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_texture4D.txt"/></remarks>
            public static void TexImage4DSGIS(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexImage4DSGIS_Lazy((uint)target, level, (uint)internalformat, width, height, depth, size4d, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_SGIS_texture4D]</b> <b>[entry point: <c>glTexSubImage4DSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_texture4D.txt"/></remarks>
            public static void TexSubImage4DSGIS(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, void* pixels) => GLPointers.glTexSubImage4DSGIS_Lazy((uint)target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_SGIS_texture_color_mask]</b> <b>[entry point: <c>glTextureColorMaskSGIS</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIS/SGIS_texture_color_mask.txt"/></remarks>
            public static void TextureColorMaskSGIS(bool red, bool green, bool blue, bool alpha) => GLPointers.glTextureColorMaskSGIS_Lazy((byte)(red ? 1 : 0), (byte)(green ? 1 : 0), (byte)(blue ? 1 : 0), (byte)(alpha ? 1 : 0));
            
        }
        /// <summary>SGIX extensions.</summary>
        public static unsafe partial class SGIX
        {
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glAsyncMarkerSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_async.txt"/></remarks>
            public static void AsyncMarkerSGIX(uint marker) => GLPointers.glAsyncMarkerSGIX_Lazy(marker);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b> <b>[entry point: <c>glDeformationMap3dSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_polynomial_ffd.txt"/></remarks>
            public static void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double* points) => GLPointers.glDeformationMap3dSGIX_Lazy((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b> <b>[entry point: <c>glDeformationMap3fSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_polynomial_ffd.txt"/></remarks>
            public static void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float* points) => GLPointers.glDeformationMap3fSGIX_Lazy((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b> <b>[entry point: <c>glDeformSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_polynomial_ffd.txt"/></remarks>
            public static void DeformSGIX(FfdMaskSGIX mask) => GLPointers.glDeformSGIX_Lazy((uint)mask);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glDeleteAsyncMarkersSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_async.txt"/></remarks>
            public static void DeleteAsyncMarkersSGIX(uint marker, int range) => GLPointers.glDeleteAsyncMarkersSGIX_Lazy(marker, range);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glFinishAsyncSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_async.txt"/></remarks>
            public static int FinishAsyncSGIX(uint* markerp) => GLPointers.glFinishAsyncSGIX_Lazy(markerp);
            
            /// <summary> <b>[requires: GL_SGIX_flush_raster]</b> <b>[entry point: <c>glFlushRasterSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_flush_raster.txt"/></remarks>
            public static void FlushRasterSGIX() => GLPointers.glFlushRasterSGIX_Lazy();
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentColorMaterialSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentColorMaterialSGIX(TriangleFace face, MaterialParameter mode) => GLPointers.glFragmentColorMaterialSGIX_Lazy((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightfSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentLightfSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float param) => GLPointers.glFragmentLightfSGIX_Lazy((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightfvSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => GLPointers.glFragmentLightfvSGIX_Lazy((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightiSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentLightiSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int param) => GLPointers.glFragmentLightiSGIX_Lazy((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightivSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => GLPointers.glFragmentLightivSGIX_Lazy((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightModelfSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentLightModelfSGIX(FragmentLightModelParameterSGIX pname, float param) => GLPointers.glFragmentLightModelfSGIX_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightModelfvSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, float* parameters) => GLPointers.glFragmentLightModelfvSGIX_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightModeliSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentLightModeliSGIX(FragmentLightModelParameterSGIX pname, int param) => GLPointers.glFragmentLightModeliSGIX_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightModelivSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, int* parameters) => GLPointers.glFragmentLightModelivSGIX_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentMaterialfSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentMaterialfSGIX(TriangleFace face, MaterialParameter pname, float param) => GLPointers.glFragmentMaterialfSGIX_Lazy((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentMaterialfvSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentMaterialfvSGIX(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers.glFragmentMaterialfvSGIX_Lazy((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentMaterialiSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentMaterialiSGIX(TriangleFace face, MaterialParameter pname, int param) => GLPointers.glFragmentMaterialiSGIX_Lazy((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentMaterialivSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void FragmentMaterialivSGIX(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers.glFragmentMaterialivSGIX_Lazy((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_framezoom]</b> <b>[entry point: <c>glFrameZoomSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_framezoom.txt"/></remarks>
            public static void FrameZoomSGIX(int factor) => GLPointers.glFrameZoomSGIX_Lazy(factor);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glGenAsyncMarkersSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_async.txt"/></remarks>
            public static uint GenAsyncMarkersSGIX(int range) => GLPointers.glGenAsyncMarkersSGIX_Lazy(range);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glGetFragmentLightfvSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => GLPointers.glGetFragmentLightfvSGIX_Lazy((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glGetFragmentLightivSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => GLPointers.glGetFragmentLightivSGIX_Lazy((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glGetFragmentMaterialfvSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void GetFragmentMaterialfvSGIX(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers.glGetFragmentMaterialfvSGIX_Lazy((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glGetFragmentMaterialivSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void GetFragmentMaterialivSGIX(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers.glGetFragmentMaterialivSGIX_Lazy((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glGetInstrumentsSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_instruments.txt"/></remarks>
            public static int GetInstrumentsSGIX() => GLPointers.glGetInstrumentsSGIX_Lazy();
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glGetListParameterfvSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_list_priority.txt"/></remarks>
            public static void GetListParameterfvSGIX(int list, ListParameterName pname, float* parameters) => GLPointers.glGetListParameterfvSGIX_Lazy(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glGetListParameterivSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_list_priority.txt"/></remarks>
            public static void GetListParameterivSGIX(int list, ListParameterName pname, int* parameters) => GLPointers.glGetListParameterivSGIX_Lazy(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_igloo_interface]</b> <b>[entry point: <c>glIglooInterfaceSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_igloo_interface.txt"/></remarks>
            public static void IglooInterfaceSGIX(All pname, void* parameters) => GLPointers.glIglooInterfaceSGIX_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glInstrumentsBufferSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_instruments.txt"/></remarks>
            public static void InstrumentsBufferSGIX(int size, int* buffer) => GLPointers.glInstrumentsBufferSGIX_Lazy(size, buffer);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glIsAsyncMarkerSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_async.txt"/></remarks>
            public static bool IsAsyncMarkerSGIX(uint marker) => GLPointers.glIsAsyncMarkerSGIX_Lazy(marker) != 0;
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glLightEnviSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_fragment_lighting.txt"/></remarks>
            public static void LightEnviSGIX(LightEnvParameterSGIX pname, LightEnvModeSGIX param) => GLPointers.glLightEnviSGIX_Lazy((uint)pname, (int)param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glListParameterfSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_list_priority.txt"/></remarks>
            public static void ListParameterfSGIX(int list, ListParameterName pname, float param) => GLPointers.glListParameterfSGIX_Lazy(list, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glListParameterfvSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_list_priority.txt"/></remarks>
            public static void ListParameterfvSGIX(int list, ListParameterName pname, float* parameters) => GLPointers.glListParameterfvSGIX_Lazy(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glListParameteriSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_list_priority.txt"/></remarks>
            public static void ListParameteriSGIX(int list, ListParameterName pname, int param) => GLPointers.glListParameteriSGIX_Lazy(list, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glListParameterivSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_list_priority.txt"/></remarks>
            public static void ListParameterivSGIX(int list, ListParameterName pname, int* parameters) => GLPointers.glListParameterivSGIX_Lazy(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b> <b>[entry point: <c>glLoadIdentityDeformationMapSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_polynomial_ffd.txt"/></remarks>
            public static void LoadIdentityDeformationMapSGIX(FfdMaskSGIX mask) => GLPointers.glLoadIdentityDeformationMapSGIX_Lazy((uint)mask);
            
            /// <summary> <b>[requires: GL_SGIX_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_pixel_texture.txt"/></remarks>
            public static void PixelTexGenSGIX(PixelTexGenModeSGIX mode) => GLPointers.glPixelTexGenSGIX_Lazy((uint)mode);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glPollAsyncSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_async.txt"/></remarks>
            public static int PollAsyncSGIX(uint* markerp) => GLPointers.glPollAsyncSGIX_Lazy(markerp);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glPollInstrumentsSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_instruments.txt"/></remarks>
            public static int PollInstrumentsSGIX(int* marker_p) => GLPointers.glPollInstrumentsSGIX_Lazy(marker_p);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glReadInstrumentsSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_instruments.txt"/></remarks>
            public static void ReadInstrumentsSGIX(int marker) => GLPointers.glReadInstrumentsSGIX_Lazy(marker);
            
            /// <summary> <b>[requires: GL_SGIX_reference_plane]</b> <b>[entry point: <c>glReferencePlaneSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_reference_plane.txt"/></remarks>
            public static void ReferencePlaneSGIX(double* equation) => GLPointers.glReferencePlaneSGIX_Lazy(equation);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b> <b>[entry point: <c>glSpriteParameterfSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_sprite.txt"/></remarks>
            public static void SpriteParameterfSGIX(SpriteParameterNameSGIX pname, float param) => GLPointers.glSpriteParameterfSGIX_Lazy((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b> <b>[entry point: <c>glSpriteParameterfvSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_sprite.txt"/></remarks>
            public static void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, float* parameters) => GLPointers.glSpriteParameterfvSGIX_Lazy((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b> <b>[entry point: <c>glSpriteParameteriSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_sprite.txt"/></remarks>
            public static void SpriteParameteriSGIX(SpriteParameterNameSGIX pname, SpriteModeSGIX param) => GLPointers.glSpriteParameteriSGIX_Lazy((uint)pname, (int)param);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b> <b>[entry point: <c>glSpriteParameterivSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_sprite.txt"/></remarks>
            public static void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, SpriteModeSGIX* parameters) => GLPointers.glSpriteParameterivSGIX_Lazy((uint)pname, (int*)parameters);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glStartInstrumentsSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_instruments.txt"/></remarks>
            public static void StartInstrumentsSGIX() => GLPointers.glStartInstrumentsSGIX_Lazy();
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glStopInstrumentsSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_instruments.txt"/></remarks>
            public static void StopInstrumentsSGIX(int marker) => GLPointers.glStopInstrumentsSGIX_Lazy(marker);
            
            /// <summary> <b>[requires: GL_SGIX_tag_sample_buffer]</b> <b>[entry point: <c>glTagSampleBufferSGIX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SGIX/SGIX_tag_sample_buffer.txt"/></remarks>
            public static void TagSampleBufferSGIX() => GLPointers.glTagSampleBufferSGIX_Lazy();
            
        }
        /// <summary>SUN extensions.</summary>
        public static unsafe partial class SUN
        {
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Color3fVertex3fSUN(float r, float g, float b, float x, float y, float z) => GLPointers.glColor3fVertex3fSUN_Lazy(r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Color3fVertex3fvSUN(float* c, float* v) => GLPointers.glColor3fVertex3fvSUN_Lazy(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Color4fNormal3fVertex3fSUN(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers.glColor4fNormal3fVertex3fSUN_Lazy(r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Color4fNormal3fVertex3fvSUN(float* c, float* n, float* v) => GLPointers.glColor4fNormal3fVertex3fvSUN_Lazy(c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4ubVertex2fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Color4ubVertex2fSUN(byte r, byte g, byte b, byte a, float x, float y) => GLPointers.glColor4ubVertex2fSUN_Lazy(r, g, b, a, x, y);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4ubVertex2fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Color4ubVertex2fvSUN(byte* c, float* v) => GLPointers.glColor4ubVertex2fvSUN_Lazy(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4ubVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Color4ubVertex3fSUN(byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers.glColor4ubVertex3fSUN_Lazy(r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4ubVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Color4ubVertex3fvSUN(byte* c, float* v) => GLPointers.glColor4ubVertex3fvSUN_Lazy(c, v);
            
            /// <summary> <b>[requires: GL_SUN_mesh_array]</b> <b>[entry point: <c>glDrawMeshArraysSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_mesh_array.txt"/></remarks>
            public static void DrawMeshArraysSUN(PrimitiveType mode, int first, int count, int width) => GLPointers.glDrawMeshArraysSUN_Lazy((uint)mode, first, count, width);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorbSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_global_alpha.txt"/></remarks>
            public static void GlobalAlphaFactorbSUN(sbyte factor) => GLPointers.glGlobalAlphaFactorbSUN_Lazy(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactordSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_global_alpha.txt"/></remarks>
            public static void GlobalAlphaFactordSUN(double factor) => GLPointers.glGlobalAlphaFactordSUN_Lazy(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorfSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_global_alpha.txt"/></remarks>
            public static void GlobalAlphaFactorfSUN(float factor) => GLPointers.glGlobalAlphaFactorfSUN_Lazy(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactoriSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_global_alpha.txt"/></remarks>
            public static void GlobalAlphaFactoriSUN(int factor) => GLPointers.glGlobalAlphaFactoriSUN_Lazy(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorsSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_global_alpha.txt"/></remarks>
            public static void GlobalAlphaFactorsSUN(short factor) => GLPointers.glGlobalAlphaFactorsSUN_Lazy(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorubSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_global_alpha.txt"/></remarks>
            public static void GlobalAlphaFactorubSUN(byte factor) => GLPointers.glGlobalAlphaFactorubSUN_Lazy(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactoruiSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_global_alpha.txt"/></remarks>
            public static void GlobalAlphaFactoruiSUN(uint factor) => GLPointers.glGlobalAlphaFactoruiSUN_Lazy(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorusSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_global_alpha.txt"/></remarks>
            public static void GlobalAlphaFactorusSUN(ushort factor) => GLPointers.glGlobalAlphaFactorusSUN_Lazy(factor);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Normal3fVertex3fSUN(float nx, float ny, float nz, float x, float y, float z) => GLPointers.glNormal3fVertex3fSUN_Lazy(nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void Normal3fVertex3fvSUN(float* n, float* v) => GLPointers.glNormal3fVertex3fvSUN_Lazy(n, v);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodePointerSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_triangle_list.txt"/></remarks>
            public static void ReplacementCodePointerSUN(ReplacementCodeTypeSUN type, int stride, void** pointer) => GLPointers.glReplacementCodePointerSUN_Lazy((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeubSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_triangle_list.txt"/></remarks>
            public static void ReplacementCodeubSUN(byte code) => GLPointers.glReplacementCodeubSUN_Lazy(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeubvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_triangle_list.txt"/></remarks>
            public static void ReplacementCodeubvSUN(byte* code) => GLPointers.glReplacementCodeubvSUN_Lazy(code);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiColor3fVertex3fSUN(TriangleListSUN rc, float r, float g, float b, float x, float y, float z) => GLPointers.glReplacementCodeuiColor3fVertex3fSUN_Lazy((uint)rc, r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiColor3fVertex3fvSUN(TriangleListSUN* rc, float* c, float* v) => GLPointers.glReplacementCodeuiColor3fVertex3fvSUN_Lazy((uint*)rc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor4fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiColor4fNormal3fVertex3fSUN(TriangleListSUN rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers.glReplacementCodeuiColor4fNormal3fVertex3fSUN_Lazy((uint)rc, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor4fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(TriangleListSUN* rc, float* c, float* n, float* v) => GLPointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN_Lazy((uint*)rc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor4ubVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiColor4ubVertex3fSUN(TriangleListSUN rc, byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers.glReplacementCodeuiColor4ubVertex3fSUN_Lazy((uint)rc, r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor4ubVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiColor4ubVertex3fvSUN(TriangleListSUN* rc, byte* c, float* v) => GLPointers.glReplacementCodeuiColor4ubVertex3fvSUN_Lazy((uint*)rc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiNormal3fVertex3fSUN(TriangleListSUN rc, float nx, float ny, float nz, float x, float y, float z) => GLPointers.glReplacementCodeuiNormal3fVertex3fSUN_Lazy((uint)rc, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiNormal3fVertex3fvSUN(TriangleListSUN* rc, float* n, float* v) => GLPointers.glReplacementCodeuiNormal3fVertex3fvSUN_Lazy((uint*)rc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeuiSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_triangle_list.txt"/></remarks>
            public static void ReplacementCodeuiSUN(TriangleListSUN code) => GLPointers.glReplacementCodeuiSUN_Lazy((uint)code);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(TriangleListSUN rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_Lazy((uint)rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(TriangleListSUN* rc, float* tc, float* c, float* n, float* v) => GLPointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_Lazy((uint*)rc, tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(TriangleListSUN rc, float s, float t, float nx, float ny, float nz, float x, float y, float z) => GLPointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_Lazy((uint)rc, s, t, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(TriangleListSUN* rc, float* tc, float* n, float* v) => GLPointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_Lazy((uint*)rc, tc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiTexCoord2fVertex3fSUN(TriangleListSUN rc, float s, float t, float x, float y, float z) => GLPointers.glReplacementCodeuiTexCoord2fVertex3fSUN_Lazy((uint)rc, s, t, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiTexCoord2fVertex3fvSUN(TriangleListSUN* rc, float* tc, float* v) => GLPointers.glReplacementCodeuiTexCoord2fVertex3fvSUN_Lazy((uint*)rc, tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiVertex3fSUN(TriangleListSUN rc, float x, float y, float z) => GLPointers.glReplacementCodeuiVertex3fSUN_Lazy((uint)rc, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void ReplacementCodeuiVertex3fvSUN(TriangleListSUN* rc, float* v) => GLPointers.glReplacementCodeuiVertex3fvSUN_Lazy((uint*)rc, v);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeuivSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_triangle_list.txt"/></remarks>
            public static void ReplacementCodeuivSUN(TriangleListSUN* code) => GLPointers.glReplacementCodeuivSUN_Lazy((uint*)code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeusSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_triangle_list.txt"/></remarks>
            public static void ReplacementCodeusSUN(ushort code) => GLPointers.glReplacementCodeusSUN_Lazy(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeusvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_triangle_list.txt"/></remarks>
            public static void ReplacementCodeusvSUN(ushort* code) => GLPointers.glReplacementCodeusvSUN_Lazy(code);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fColor3fVertex3fSUN(float s, float t, float r, float g, float b, float x, float y, float z) => GLPointers.glTexCoord2fColor3fVertex3fSUN_Lazy(s, t, r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fColor3fVertex3fvSUN(float* tc, float* c, float* v) => GLPointers.glTexCoord2fColor3fVertex3fvSUN_Lazy(tc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor4fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fColor4fNormal3fVertex3fSUN(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers.glTexCoord2fColor4fNormal3fVertex3fSUN_Lazy(s, t, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor4fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float* c, float* n, float* v) => GLPointers.glTexCoord2fColor4fNormal3fVertex3fvSUN_Lazy(tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor4ubVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fColor4ubVertex3fSUN(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers.glTexCoord2fColor4ubVertex3fSUN_Lazy(s, t, r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor4ubVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fColor4ubVertex3fvSUN(float* tc, byte* c, float* v) => GLPointers.glTexCoord2fColor4ubVertex3fvSUN_Lazy(tc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fNormal3fVertex3fSUN(float s, float t, float nx, float ny, float nz, float x, float y, float z) => GLPointers.glTexCoord2fNormal3fVertex3fSUN_Lazy(s, t, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fNormal3fVertex3fvSUN(float* tc, float* n, float* v) => GLPointers.glTexCoord2fNormal3fVertex3fvSUN_Lazy(tc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fVertex3fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fVertex3fSUN(float s, float t, float x, float y, float z) => GLPointers.glTexCoord2fVertex3fSUN_Lazy(s, t, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fVertex3fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord2fVertex3fvSUN(float* tc, float* v) => GLPointers.glTexCoord2fVertex3fvSUN_Lazy(tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord4fColor4fNormal3fVertex4fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord4fColor4fNormal3fVertex4fSUN(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w) => GLPointers.glTexCoord4fColor4fNormal3fVertex4fSUN_Lazy(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord4fColor4fNormal3fVertex4fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float* c, float* n, float* v) => GLPointers.glTexCoord4fColor4fNormal3fVertex4fvSUN_Lazy(tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord4fVertex4fSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord4fVertex4fSUN(float s, float t, float p, float q, float x, float y, float z, float w) => GLPointers.glTexCoord4fVertex4fSUN_Lazy(s, t, p, q, x, y, z, w);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord4fVertex4fvSUN</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUN/SUN_vertex.txt"/></remarks>
            public static void TexCoord4fVertex4fvSUN(float* tc, float* v) => GLPointers.glTexCoord4fVertex4fvSUN_Lazy(tc, v);
            
        }
        /// <summary>SUNX extensions.</summary>
        public static unsafe partial class SUNX
        {
            /// <summary> <b>[requires: GL_SUNX_constant_data]</b> <b>[entry point: <c>glFinishTextureSUNX</c>]</b><br/>  </summary>
            /// <remarks><see href="https://registry.khronos.org/OpenGL/extensions/SUNX/SUNX_constant_data.txt"/></remarks>
            public static void FinishTextureSUNX() => GLPointers.glFinishTextureSUNX_Lazy();
            
        }
    }
}
