// This file is auto generated, do not edit. Generated: 2023-10-16 17:21:49 GMT+02:00
using System;
using System.Runtime.InteropServices;
using OpenTK.Graphics;
using OpenTK.Graphics.OpenGL;
using OpenTK.Graphics.Wgl;
using OpenTK.Graphics.Glx;

namespace OpenTK.Graphics.OpenGL.Compatibility
{
    public static unsafe partial class GL
    {
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glAccum</c>]</b><br/> Operate on the accumulation buffer. </summary>
        /// <param name="op"> Specifies the accumulation buffer operation. Symbolic constants GL_ACCUM, GL_LOAD, GL_ADD, GL_MULT, and GL_RETURN are accepted. </param>
        /// <param name="value"> Specifies a floating-point value used in the accumulation buffer operation. op determines how value is used. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glAccum.xml" /></remarks>
        public static void Accum(AccumOp op, float value) => GLPointers._glAccum_fnptr((uint)op, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glActiveShaderProgram</c>]</b><br/> Set the active program object for a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
        /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml" /></remarks>
        public static void ActiveShaderProgram(int pipeline, int program) => GLPointers._glActiveShaderProgram_fnptr(pipeline, program);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glActiveTexture</c>]</b><br/> Select active texture unit. </summary>
        /// <param name="texture"> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from zero to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS minus one. The initial value is GL_TEXTURE0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveTexture.xhtml" /></remarks>
        public static void ActiveTexture(TextureUnit texture) => GLPointers._glActiveTexture_fnptr((uint)texture);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glAlphaFunc</c>]</b><br/> Specify the alpha test function. </summary>
        /// <param name="func"> Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range 0 1 , where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glAlphaFunc.xml" /></remarks>
        public static void AlphaFunc(AlphaFunction func, float reference) => GLPointers._glAlphaFunc_fnptr((uint)func, reference);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glAreTexturesResident</c>]</b><br/> Determine if textures are loaded in texture memory. </summary>
        /// <param name="n"> Specifies the number of textures to be queried. </param>
        /// <param name="textures"> Specifies an array containing the names of the textures to be queried. </param>
        /// <param name="residences"> Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glAreTexturesResident.xml" /></remarks>
        public static bool AreTexturesResident(int n, int* textures, bool* residences) => GLPointers._glAreTexturesResident_fnptr(n, textures, (byte*)residences) != 0;
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glArrayElement</c>]</b><br/> Render a vertex using the specified vertex array element. </summary>
        /// <param name="i"> Specifies an index into the enabled vertex data arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glArrayElement.xml" /></remarks>
        public static void ArrayElement(int i) => GLPointers._glArrayElement_fnptr(i);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glAttachShader</c>]</b><br/> Attaches a shader object to a program object. </summary>
        /// <param name="program">Specifies the program object to which a shader object will be attached.</param>
        /// <param name="shader">Specifies the shader object that is to be attached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glAttachShader.xhtml" /></remarks>
        public static void AttachShader(int program, int shader) => GLPointers._glAttachShader_fnptr(program, shader);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glBegin</c>]</b><br/> Delimit the vertices of a primitive or a group of like primitives. </summary>
        /// <param name="mode"> Specifies the primitive or primitives that will be created from vertices presented between glBegin and the subsequent glEnd. Ten symbolic constants are accepted: GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml" /></remarks>
        public static void Begin(PrimitiveType mode) => GLPointers._glBegin_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glBeginConditionalRender</c>]</b><br/> Start conditional rendering. </summary>
        /// <param name="id"> Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded. </param>
        /// <param name="mode"> Specifies how glBeginConditionalRender interprets the results of the occlusion query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml" /></remarks>
        public static void BeginConditionalRender(uint id, ConditionalRenderMode mode) => GLPointers._glBeginConditionalRender_fnptr(id, (uint)mode);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glBeginQuery</c>]</b><br/> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml" /></remarks>
        public static void BeginQuery(QueryTarget target, int id) => GLPointers._glBeginQuery_fnptr((uint)target, id);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glBeginQueryIndexed</c>]</b><br/> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
        public static void BeginQueryIndexed(QueryTarget target, uint index, int id) => GLPointers._glBeginQueryIndexed_fnptr((uint)target, index, id);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glBeginTransformFeedback</c>]</b><br/> Start transform feedback operation. </summary>
        /// <param name="primitiveMode"> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml" /></remarks>
        public static void BeginTransformFeedback(PrimitiveType primitiveMode) => GLPointers._glBeginTransformFeedback_fnptr((uint)primitiveMode);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glBindAttribLocation</c>]</b><br/> Associates a generic vertex attribute index with a named attribute variable. </summary>
        /// <param name="program">Specifies the handle of the program object in which the association is to be made.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be bound.</param>
        /// <param name="name">Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindAttribLocation.xhtml" /></remarks>
        public static void BindAttribLocation(int program, uint index, byte* name) => GLPointers._glBindAttribLocation_fnptr(program, index, name);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glBindBuffer</c>]</b><br/> Bind a named buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml" /></remarks>
        public static void BindBuffer(BufferTargetARB target, int buffer) => GLPointers._glBindBuffer_fnptr((uint)target, buffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glBindBufferBase</c>]</b><br/> Bind a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml" /></remarks>
        public static void BindBufferBase(BufferTargetARB target, uint index, int buffer) => GLPointers._glBindBufferBase_fnptr((uint)target, index, buffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glBindBufferRange</c>]</b><br/> Bind a range within a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
        /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml" /></remarks>
        public static void BindBufferRange(BufferTargetARB target, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glBindBufferRange_fnptr((uint)target, index, buffer, offset, size);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindBuffersBase</c>]</b><br/> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml" /></remarks>
        public static void BindBuffersBase(BufferTargetARB target, uint first, int count, int* buffers) => GLPointers._glBindBuffersBase_fnptr((uint)target, first, count, buffers);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindBuffersRange</c>]</b><br/> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml" /></remarks>
        public static void BindBuffersRange(BufferTargetARB target, uint first, int count, int* buffers, IntPtr* offsets, nint* sizes) => GLPointers._glBindBuffersRange_fnptr((uint)target, first, count, buffers, offsets, sizes);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glBindFragDataLocation</c>]</b><br/> Bind a user-defined varying out variable to a fragment shader color number. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocation.xhtml" /></remarks>
        public static void BindFragDataLocation(int program, uint color, byte* name) => GLPointers._glBindFragDataLocation_fnptr(program, color, name);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> <b>[entry point: <c>glBindFragDataLocationIndexed</c>]</b><br/> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml" /></remarks>
        public static void BindFragDataLocationIndexed(int program, uint colorNumber, uint index, byte* name) => GLPointers._glBindFragDataLocationIndexed_fnptr(program, colorNumber, index, name);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBindFramebuffer</c>]</b><br/> Bind a framebuffer to a framebuffer target. </summary>
        /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml" /></remarks>
        public static void BindFramebuffer(FramebufferTarget target, int framebuffer) => GLPointers._glBindFramebuffer_fnptr((uint)target, framebuffer);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> <b>[entry point: <c>glBindImageTexture</c>]</b><br/> Bind a level of a texture to an image unit. </summary>
        /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
        /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
        /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
        /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
        /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
        /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
        /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml" /></remarks>
        public static void BindImageTexture(uint unit, int texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format) => GLPointers._glBindImageTexture_fnptr(unit, texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, (uint)format);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindImageTextures</c>]</b><br/> Bind one or more named texture images to a sequence of consecutive image units. </summary>
        /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml" /></remarks>
        public static void BindImageTextures(uint first, int count, int* textures) => GLPointers._glBindImageTextures_fnptr(first, count, textures);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glBindProgramPipeline</c>]</b><br/> Bind a program pipeline to the current context. </summary>
        /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml" /></remarks>
        public static void BindProgramPipeline(int pipeline) => GLPointers._glBindProgramPipeline_fnptr(pipeline);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBindRenderbuffer</c>]</b><br/> Bind a renderbuffer to a renderbuffer target. </summary>
        /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml" /></remarks>
        public static void BindRenderbuffer(RenderbufferTarget target, int renderbuffer) => GLPointers._glBindRenderbuffer_fnptr((uint)target, renderbuffer);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glBindSampler</c>]</b><br/> Bind a named sampler to a texturing target. </summary>
        /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
        /// <param name="sampler"> Specifies the name of a sampler. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml" /></remarks>
        public static void BindSampler(uint unit, int sampler) => GLPointers._glBindSampler_fnptr(unit, sampler);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindSamplers</c>]</b><br/> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
        /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
        /// <param name="count"> Specifies the number of samplers to bind. </param>
        /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml" /></remarks>
        public static void BindSamplers(uint first, int count, int* samplers) => GLPointers._glBindSamplers_fnptr(first, count, samplers);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glBindTexture</c>]</b><br/> Bind a named texture to a texturing target. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="texture"> Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTexture.xhtml" /></remarks>
        public static void BindTexture(TextureTarget target, int texture) => GLPointers._glBindTexture_fnptr((uint)target, texture);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindTextures</c>]</b><br/> Bind one or more named textures to a sequence of consecutive texture units. </summary>
        /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml" /></remarks>
        public static void BindTextures(uint first, int count, int* textures) => GLPointers._glBindTextures_fnptr(first, count, textures);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glBindTextureUnit</c>]</b><br/> Bind an existing texture object to the specified texture unit . </summary>
        /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
        /// <param name="texture">Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml" /></remarks>
        public static void BindTextureUnit(uint unit, int texture) => GLPointers._glBindTextureUnit_fnptr(unit, texture);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glBindTransformFeedback</c>]</b><br/> Bind a transform feedback object. </summary>
        /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
        /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml" /></remarks>
        public static void BindTransformFeedback(BindTransformFeedbackTarget target, int id) => GLPointers._glBindTransformFeedback_fnptr((uint)target, id);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glBindVertexArray</c>]</b><br/> Bind a vertex array object. </summary>
        /// <param name="array"> Specifies the name of the vertex array to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" /></remarks>
        public static void BindVertexArray(int array) => GLPointers._glBindVertexArray_fnptr(array);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glBindVertexBuffer</c>]</b><br/> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
        public static void BindVertexBuffer(uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glBindVertexBuffer_fnptr(bindingindex, buffer, offset, stride);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindVertexBuffers</c>]</b><br/> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
        public static void BindVertexBuffers(uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers._glBindVertexBuffers_fnptr(first, count, buffers, offsets, strides);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glBitmap</c>]</b><br/> Draw a bitmap. </summary>
        /// <param name="width"> Specify the pixel width and height of the bitmap image. </param>
        /// <param name="height"> Specify the pixel width and height of the bitmap image. </param>
        /// <param name="xorig"> Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes. </param>
        /// <param name="yorig"> Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes. </param>
        /// <param name="xmove"> Specify the x and y offsets to be added to the current raster position after the bitmap is drawn. </param>
        /// <param name="ymove"> Specify the x and y offsets to be added to the current raster position after the bitmap is drawn. </param>
        /// <param name="bitmap"> Specifies the address of the bitmap image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBitmap.xml" /></remarks>
        public static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte* bitmap) => GLPointers._glBitmap_fnptr(width, height, xorig, yorig, xmove, ymove, bitmap);
        
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> <b>[entry point: <c>glBlendColor</c>]</b><br/> Set the blend color. </summary>
        /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml" /></remarks>
        public static void BlendColor(float red, float green, float blue, float alpha) => GLPointers._glBlendColor_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> <b>[entry point: <c>glBlendEquation</c>]</b><br/> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
        public static void BlendEquation(BlendEquationModeEXT mode) => GLPointers._glBlendEquation_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glBlendEquationi</c>]</b><br/> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="buf"> for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation. </param>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
        public static void BlendEquationi(uint buf, BlendEquationModeEXT mode) => GLPointers._glBlendEquationi_fnptr(buf, (uint)mode);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glBlendEquationSeparate</c>]</b><br/> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml" /></remarks>
        public static void BlendEquationSeparate(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparate_fnptr((uint)modeRGB, (uint)modeAlpha);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glBlendEquationSeparatei</c>]</b><br/> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="buf"> for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations. </param>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml" /></remarks>
        public static void BlendEquationSeparatei(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparatei_fnptr(buf, (uint)modeRGB, (uint)modeAlpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glBlendFunc</c>]</b><br/> Specify pixel arithmetic. </summary>
        /// <param name="sfactor"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactor"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" /></remarks>
        public static void BlendFunc(BlendingFactor sfactor, BlendingFactor dfactor) => GLPointers._glBlendFunc_fnptr((uint)sfactor, (uint)dfactor);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glBlendFunci</c>]</b><br/> Specify pixel arithmetic. </summary>
        /// <param name="buf"> For glBlendFunci, specifies the index of the draw buffer for which to set the blend function. </param>
        /// <param name="sfactor"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactor"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" /></remarks>
        public static void BlendFunci(uint buf, BlendingFactor src, BlendingFactor dst) => GLPointers._glBlendFunci_fnptr(buf, (uint)src, (uint)dst);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glBlendFuncSeparate</c>]</b><br/> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="srcRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dstRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="srcAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dstAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml" /></remarks>
        public static void BlendFuncSeparate(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers._glBlendFuncSeparate_fnptr((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glBlendFuncSeparatei</c>]</b><br/> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="buf"> For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions. </param>
        /// <param name="srcRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dstRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="srcAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dstAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml" /></remarks>
        public static void BlendFuncSeparatei(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers._glBlendFuncSeparatei_fnptr(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBlitFramebuffer</c>]</b><br/> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
        public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glBlitNamedFramebuffer</c>]</b><br/> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
        public static void BlitNamedFramebuffer(int readFramebuffer, int drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitNamedFramebuffer_fnptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glBufferData</c>]</b><br/> Creates and initializes a buffer object&apos;s data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
        public static void BufferData(BufferTargetARB target, nint size, void* data, BufferUsageARB usage) => GLPointers._glBufferData_fnptr((uint)target, size, data, (uint)usage);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage]</b> <b>[entry point: <c>glBufferStorage</c>]</b><br/> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
        public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => GLPointers._glBufferStorage_fnptr((uint)target, size, data, (uint)flags);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glBufferSubData</c>]</b><br/> Updates a subset of a buffer object&apos;s data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
        public static void BufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._glBufferSubData_fnptr((uint)target, offset, size, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glCallList</c>]</b><br/> Execute a display list. </summary>
        /// <param name="list"> Specifies the integer name of the display list to be executed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCallList.xml" /></remarks>
        public static void CallList(int list) => GLPointers._glCallList_fnptr(list);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glCallLists</c>]</b><br/> Execute a list of display lists. </summary>
        /// <param name="n"> Specifies the number of display lists to be executed. </param>
        /// <param name="type"> Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted. </param>
        /// <param name="lists"> Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCallLists.xml" /></remarks>
        public static void CallLists(int n, ListNameType type, void* lists) => GLPointers._glCallLists_fnptr(n, (uint)type, lists);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glCheckFramebufferStatus</c>]</b><br/> Check the completeness status of a framebuffer. </summary>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
        public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckFramebufferStatus_fnptr((uint)target);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCheckNamedFramebufferStatus</c>]</b><br/> Check the completeness status of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
        public static FramebufferStatus CheckNamedFramebufferStatus(int framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckNamedFramebufferStatus_fnptr(framebuffer, (uint)target);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClampColor</c>]</b><br/> Specify whether data read via glReadPixels should be clamped. </summary>
        /// <param name="target"> Target for color clamping. target must be GL_CLAMP_READ_COLOR. </param>
        /// <param name="clamp"> Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClampColor.xhtml" /></remarks>
        public static void ClampColor(ClampColorTargetARB target, ClampColorModeARB clamp) => GLPointers._glClampColor_fnptr((uint)target, (uint)clamp);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glClear</c>]</b><br/> Clear buffers to preset values. </summary>
        /// <param name="mask"> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml" /></remarks>
        public static void Clear(ClearBufferMask mask) => GLPointers._glClear_fnptr((uint)mask);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glClearAccum</c>]</b><br/> Specify clear values for the accumulation buffer. </summary>
        /// <param name="red"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <param name="green"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <param name="blue"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <param name="alpha"> Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearAccum.xml" /></remarks>
        public static void ClearAccum(float red, float green, float blue, float alpha) => GLPointers._glClearAccum_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> <b>[entry point: <c>glClearBufferData</c>]</b><br/> Fill a buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
        public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearBufferData_fnptr((uint)target, (uint)internalformat, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClearBufferfi</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferfi(Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers._glClearBufferfi_fnptr((uint)buffer, drawbuffer, depth, stencil);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClearBufferfv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferfv(Buffer buffer, int drawbuffer, float* value) => GLPointers._glClearBufferfv_fnptr((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClearBufferiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferiv(Buffer buffer, int drawbuffer, int* value) => GLPointers._glClearBufferiv_fnptr((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> <b>[entry point: <c>glClearBufferSubData</c>]</b><br/> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
        public static void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearBufferSubData_fnptr((uint)target, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glClearBufferuiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferuiv(Buffer buffer, int drawbuffer, uint* value) => GLPointers._glClearBufferuiv_fnptr((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glClearColor</c>]</b><br/> Specify clear values for the color buffers. </summary>
        /// <param name="red"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="green"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="blue"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="alpha"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml" /></remarks>
        public static void ClearColor(float red, float green, float blue, float alpha) => GLPointers._glClearColor_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glClearDepth</c>]</b><br/> Specify the clear value for the depth buffer. </summary>
        /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
        public static void ClearDepth(double depth) => GLPointers._glClearDepth_fnptr(depth);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glClearDepthf</c>]</b><br/> Specify the clear value for the depth buffer. </summary>
        /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
        public static void ClearDepthf(float d) => GLPointers._glClearDepthf_fnptr(d);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glClearIndex</c>]</b><br/> Specify the clear value for the color index buffers. </summary>
        /// <param name="c"> Specifies the index used when the color index buffers are cleared. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClearIndex.xml" /></remarks>
        public static void ClearIndex(float c) => GLPointers._glClearIndex_fnptr(c);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferData</c>]</b><br/> Fill a buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
        public static void ClearNamedBufferData(int buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferData_fnptr(buffer, (uint)internalformat, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferSubData</c>]</b><br/> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
        public static void ClearNamedBufferSubData(int buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferSubData_fnptr(buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferfi</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferfi(int framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers._glClearNamedFramebufferfi_fnptr(framebuffer, (uint)buffer, drawbuffer, depth, stencil);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferfv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferfv(int framebuffer, Buffer buffer, int drawbuffer, float* value) => GLPointers._glClearNamedFramebufferfv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferiv(int framebuffer, Buffer buffer, int drawbuffer, int* value) => GLPointers._glClearNamedFramebufferiv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferuiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferuiv(int framebuffer, Buffer buffer, int drawbuffer, uint* value) => GLPointers._glClearNamedFramebufferuiv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glClearStencil</c>]</b><br/> Specify the clear value for the stencil buffer. </summary>
        /// <param name="s"> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearStencil.xhtml" /></remarks>
        public static void ClearStencil(int s) => GLPointers._glClearStencil_fnptr(s);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> <b>[entry point: <c>glClearTexImage</c>]</b><br/> Fills all a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml" /></remarks>
        public static void ClearTexImage(int texture, int level, PixelFormat format, PixelType type, void* data) => GLPointers._glClearTexImage_fnptr(texture, level, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> <b>[entry point: <c>glClearTexSubImage</c>]</b><br/> Fills all or part of a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
        /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
        /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
        /// <param name="width"> The width of the region to be cleared. </param>
        /// <param name="height"> The height of the region to be cleared. </param>
        /// <param name="depth"> The depth of the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml" /></remarks>
        public static void ClearTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => GLPointers._glClearTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glClientActiveTexture</c>]</b><br/> Select active texture unit. </summary>
        /// <param name="texture"> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to the value of GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. The initial value is GL_TEXTURE0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClientActiveTexture.xml" /></remarks>
        public static void ClientActiveTexture(TextureUnit texture) => GLPointers._glClientActiveTexture_fnptr((uint)texture);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glClientWaitSync</c>]</b><br/> Block and wait for a sync object to become signaled. </summary>
        /// <param name="sync"> The sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
        /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml" /></remarks>
        public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => (SyncStatus) GLPointers._glClientWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control]</b> <b>[entry point: <c>glClipControl</c>]</b><br/> Control clip coordinate to window coordinate behavior. </summary>
        /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
        /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml" /></remarks>
        public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => GLPointers._glClipControl_fnptr((uint)origin, (uint)depth);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glClipPlane</c>]</b><br/> Specify a plane against which all geometry is clipped. </summary>
        /// <param name="plane"> Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES -1 , are accepted. </param>
        /// <param name="equation"> Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClipPlane.xml" /></remarks>
        public static void ClipPlane(ClipPlaneName plane, double* equation) => GLPointers._glClipPlane_fnptr((uint)plane, equation);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3b</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3b(sbyte red, sbyte green, sbyte blue) => GLPointers._glColor3b_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3bv</c>]</b><br/>  </summary>
        public static void Color3bv(sbyte* v) => GLPointers._glColor3bv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3d</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3d(double red, double green, double blue) => GLPointers._glColor3d_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3dv</c>]</b><br/>  </summary>
        public static void Color3dv(double* v) => GLPointers._glColor3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3f</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3f(float red, float green, float blue) => GLPointers._glColor3f_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3fv</c>]</b><br/>  </summary>
        public static void Color3fv(float* v) => GLPointers._glColor3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3i</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3i(int red, int green, int blue) => GLPointers._glColor3i_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3iv</c>]</b><br/>  </summary>
        public static void Color3iv(int* v) => GLPointers._glColor3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3s</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3s(short red, short green, short blue) => GLPointers._glColor3s_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3sv</c>]</b><br/>  </summary>
        public static void Color3sv(short* v) => GLPointers._glColor3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3ub</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3ub(byte red, byte green, byte blue) => GLPointers._glColor3ub_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3ubv</c>]</b><br/>  </summary>
        public static void Color3ubv(byte* v) => GLPointers._glColor3ubv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3ui</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3ui(uint red, uint green, uint blue) => GLPointers._glColor3ui_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3uiv</c>]</b><br/>  </summary>
        public static void Color3uiv(uint* v) => GLPointers._glColor3uiv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3us</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color3us(ushort red, ushort green, ushort blue) => GLPointers._glColor3us_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor3usv</c>]</b><br/>  </summary>
        public static void Color3usv(ushort* v) => GLPointers._glColor3usv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4b</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4b(sbyte red, sbyte green, sbyte blue, sbyte alpha) => GLPointers._glColor4b_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4bv</c>]</b><br/>  </summary>
        public static void Color4bv(sbyte* v) => GLPointers._glColor4bv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4d</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4d(double red, double green, double blue, double alpha) => GLPointers._glColor4d_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4dv</c>]</b><br/>  </summary>
        public static void Color4dv(double* v) => GLPointers._glColor4dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4f</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4f(float red, float green, float blue, float alpha) => GLPointers._glColor4f_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4fv</c>]</b><br/>  </summary>
        public static void Color4fv(float* v) => GLPointers._glColor4fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4i</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4i(int red, int green, int blue, int alpha) => GLPointers._glColor4i_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4iv</c>]</b><br/>  </summary>
        public static void Color4iv(int* v) => GLPointers._glColor4iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4s</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4s(short red, short green, short blue, short alpha) => GLPointers._glColor4s_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4sv</c>]</b><br/>  </summary>
        public static void Color4sv(short* v) => GLPointers._glColor4sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4ub</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4ub(byte red, byte green, byte blue, byte alpha) => GLPointers._glColor4ub_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4ubv</c>]</b><br/>  </summary>
        public static void Color4ubv(byte* v) => GLPointers._glColor4ubv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4ui</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4ui(uint red, uint green, uint blue, uint alpha) => GLPointers._glColor4ui_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4uiv</c>]</b><br/>  </summary>
        public static void Color4uiv(uint* v) => GLPointers._glColor4uiv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4us</c>]</b><br/> Set the current color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current color. </param>
        /// <param name="alpha"> Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml" /></remarks>
        public static void Color4us(ushort red, ushort green, ushort blue, ushort alpha) => GLPointers._glColor4us_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColor4usv</c>]</b><br/>  </summary>
        public static void Color4usv(ushort* v) => GLPointers._glColor4usv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glColorMask</c>]</b><br/> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="red"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="green"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="blue"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="alpha"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml" /></remarks>
        public static void ColorMask(bool red, bool green, bool blue, bool alpha) => GLPointers._glColorMask_fnptr((byte)(red ? 1 : 0), (byte)(green ? 1 : 0), (byte)(blue ? 1 : 0), (byte)(alpha ? 1 : 0));
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glColorMaski</c>]</b><br/> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="buf"> For glColorMaski, specifies the index of the draw buffer whose color mask to set. </param>
        /// <param name="red"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="green"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="blue"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="alpha"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml" /></remarks>
        public static void ColorMaski(uint index, bool r, bool g, bool b, bool a) => GLPointers._glColorMaski_fnptr(index, (byte)(r ? 1 : 0), (byte)(g ? 1 : 0), (byte)(b ? 1 : 0), (byte)(a ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColorMaterial</c>]</b><br/> Cause a material color to track the current color. </summary>
        /// <param name="face"> Specifies whether front, back, or both front and back material parameters should track the current color. Accepted values are GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. The initial value is GL_FRONT_AND_BACK. </param>
        /// <param name="mode"> Specifies which of several material parameters track the current color. Accepted values are GL_EMISSION, GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, and GL_AMBIENT_AND_DIFFUSE. The initial value is GL_AMBIENT_AND_DIFFUSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorMaterial.xml" /></remarks>
        public static void ColorMaterial(TriangleFace face, ColorMaterialParameter mode) => GLPointers._glColorMaterial_fnptr((uint)face, (uint)mode);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP3ui</c>]</b><br/>  </summary>
        public static void ColorP3ui(ColorPointerType type, uint color) => GLPointers._glColorP3ui_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP3uiv</c>]</b><br/>  </summary>
        public static void ColorP3uiv(ColorPointerType type, uint* color) => GLPointers._glColorP3uiv_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP4ui</c>]</b><br/>  </summary>
        public static void ColorP4ui(ColorPointerType type, uint color) => GLPointers._glColorP4ui_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP4uiv</c>]</b><br/>  </summary>
        public static void ColorP4uiv(ColorPointerType type, uint* color) => GLPointers._glColorP4uiv_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glColorPointer</c>]</b><br/> Define an array of colors. </summary>
        /// <param name="size"> Specifies the number of components per color. Must be 3 or 4. The initial value is 4. </param>
        /// <param name="type"> Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first component of the first color element in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorPointer.xml" /></remarks>
        public static void ColorPointer(int size, ColorPointerType type, int stride, void* pointer) => GLPointers._glColorPointer_fnptr(size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glCompileShader</c>]</b><br/> Compiles a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be compiled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompileShader.xhtml" /></remarks>
        public static void CompileShader(int shader) => GLPointers._glCompileShader_fnptr(shader);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexImage1D</c>]</b><br/> Specify a one-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage1D.xhtml" /></remarks>
        public static void CompressedTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage1D_fnptr((uint)target, level, (uint)internalformat, width, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexImage2D</c>]</b><br/> Specify a two-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage2D.xhtml" /></remarks>
        public static void CompressedTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage2D_fnptr((uint)target, level, (uint)internalformat, width, height, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexImage3D</c>]</b><br/> Specify a three-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage3D.xhtml" /></remarks>
        public static void CompressedTexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage3D_fnptr((uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="target">Specifies the target, to which the texture is bound, for glCompressedTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
        public static void CompressedTexSubImage1D(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage1D_fnptr((uint)target, level, xoffset, width, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
        public static void CompressedTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage2D_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glCompressedTexSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage3D function. Must be GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
        public static void CompressedTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage3D_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
        public static void CompressedTextureSubImage1D(int texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage1D_fnptr(texture, level, xoffset, width, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
        public static void CompressedTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
        public static void CompressedTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer]</b> <b>[entry point: <c>glCopyBufferSubData</c>]</b><br/> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
        /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
        public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glCopyBufferSubData_fnptr((uint)readTarget, (uint)writeTarget, readOffset, writeOffset, size);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image]</b> <b>[entry point: <c>glCopyImageSubData</c>]</b><br/> Perform a raw data copy between two images. </summary>
        /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
        /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
        /// <param name="srcLevel"> The mipmap level to read from the source. </param>
        /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
        /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
        /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
        /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
        /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
        /// <param name="dstLevel">!!missing documentation!!</param>
        /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
        /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
        /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
        /// <param name="srcWidth"> The width of the region to be copied. </param>
        /// <param name="srcHeight"> The height of the region to be copied. </param>
        /// <param name="srcDepth"> The depth of the region to be copied. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml" /></remarks>
        public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers._glCopyImageSubData_fnptr(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyNamedBufferSubData</c>]</b><br/> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
        public static void CopyNamedBufferSubData(int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glCopyNamedBufferSubData_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glCopyPixels</c>]</b><br/> Copy pixels in the frame buffer. </summary>
        /// <param name="x"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="width"> Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative. </param>
        /// <param name="height"> Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative. </param>
        /// <param name="type"> Specifies whether color values, depth values, or stencil values are to be copied. Symbolic constants GL_COLOR, GL_DEPTH, and GL_STENCIL are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyPixels.xml" /></remarks>
        public static void CopyPixels(int x, int y, int width, int height, PixelCopyType type) => GLPointers._glCopyPixels_fnptr(x, y, width, height, (uint)type);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glCopyTexImage1D</c>]</b><br/> Copy pixels into a 1D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. The height of the texture image is 1. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage1D.xhtml" /></remarks>
        public static void CopyTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._glCopyTexImage1D_fnptr((uint)target, level, (uint)internalformat, x, y, width, border);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glCopyTexImage2D</c>]</b><br/> Copy pixels into a 2D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. </param>
        /// <param name="height"> Specifies the height of the texture image. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage2D.xhtml" /></remarks>
        public static void CopyTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._glCopyTexImage2D_fnptr((uint)target, level, (uint)internalformat, x, y, width, height, border);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glCopyTexSubImage1D</c>]</b><br/> Copy a one-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
        public static void CopyTexSubImage1D(TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTexSubImage1D_fnptr((uint)target, level, xoffset, x, y, width);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glCopyTexSubImage2D</c>]</b><br/> Copy a two-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
        public static void CopyTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTexSubImage2D_fnptr((uint)target, level, xoffset, yoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v1.2]</b> <b>[entry point: <c>glCopyTexSubImage3D</c>]</b><br/> Copy a three-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage3D function. Must be GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
        public static void CopyTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTexSubImage3D_fnptr((uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage1D</c>]</b><br/> Copy a one-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
        public static void CopyTextureSubImage1D(int texture, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTextureSubImage1D_fnptr(texture, level, xoffset, x, y, width);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage2D</c>]</b><br/> Copy a two-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
        public static void CopyTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage3D</c>]</b><br/> Copy a three-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
        public static void CopyTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateBuffers</c>]</b><br/> Create buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to create. </param>
        /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml" /></remarks>
        public static void CreateBuffers(int n, int* buffers) => GLPointers._glCreateBuffers_fnptr(n, buffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateFramebuffers</c>]</b><br/> Create framebuffer objects. </summary>
        /// <param name="n"> Number of framebuffer objects to create. </param>
        /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml" /></remarks>
        public static void CreateFramebuffers(int n, int* framebuffers) => GLPointers._glCreateFramebuffers_fnptr(n, framebuffers);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glCreateProgram</c>]</b><br/> Creates a program object. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml" /></remarks>
        public static int CreateProgram() => GLPointers._glCreateProgram_fnptr();
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateProgramPipelines</c>]</b><br/> Create program pipeline objects. </summary>
        /// <param name="n"> Number of program pipeline objects to create. </param>
        /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml" /></remarks>
        public static void CreateProgramPipelines(int n, int* pipelines) => GLPointers._glCreateProgramPipelines_fnptr(n, pipelines);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateQueries</c>]</b><br/> Create query objects. </summary>
        /// <param name="target"> Specifies the target of each created query object. </param>
        /// <param name="n"> Number of query objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml" /></remarks>
        public static void CreateQueries(QueryTarget target, int n, int* ids) => GLPointers._glCreateQueries_fnptr((uint)target, n, ids);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateRenderbuffers</c>]</b><br/> Create renderbuffer objects. </summary>
        /// <param name="n"> Number of renderbuffer objects to create. </param>
        /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml" /></remarks>
        public static void CreateRenderbuffers(int n, int* renderbuffers) => GLPointers._glCreateRenderbuffers_fnptr(n, renderbuffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateSamplers</c>]</b><br/> Create sampler objects. </summary>
        /// <param name="n"> Number of sampler objects to create. </param>
        /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml" /></remarks>
        public static void CreateSamplers(int n, int* samplers) => GLPointers._glCreateSamplers_fnptr(n, samplers);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glCreateShader</c>]</b><br/> Creates a shader object. </summary>
        /// <param name="shaderType">Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml" /></remarks>
        public static int CreateShader(ShaderType type) => GLPointers._glCreateShader_fnptr((uint)type);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glCreateShaderProgramv</c>]</b><br/> Create a stand-alone program from an array of null-terminated source code strings. </summary>
        /// <param name="type"> Specifies the type of shader to create. </param>
        /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
        /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml" /></remarks>
        public static int CreateShaderProgramv(ShaderType type, int count, byte** strings) => GLPointers._glCreateShaderProgramv_fnptr((uint)type, count, strings);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateTextures</c>]</b><br/> Create texture objects. </summary>
        /// <param name="target"> Specifies the effective texture target of each created texture. </param>
        /// <param name="n"> Number of texture objects to create. </param>
        /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml" /></remarks>
        public static void CreateTextures(TextureTarget target, int n, int* textures) => GLPointers._glCreateTextures_fnptr((uint)target, n, textures);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateTransformFeedbacks</c>]</b><br/> Create transform feedback objects. </summary>
        /// <param name="n"> Number of transform feedback objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml" /></remarks>
        public static void CreateTransformFeedbacks(int n, int* ids) => GLPointers._glCreateTransformFeedbacks_fnptr(n, ids);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateVertexArrays</c>]</b><br/> Create vertex array objects. </summary>
        /// <param name="n"> Number of vertex array objects to create. </param>
        /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml" /></remarks>
        public static void CreateVertexArrays(int n, int* arrays) => GLPointers._glCreateVertexArrays_fnptr(n, arrays);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glCullFace</c>]</b><br/> Specify whether front- or back-facing facets can be culled. </summary>
        /// <param name="mode"> Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCullFace.xhtml" /></remarks>
        public static void CullFace(TriangleFace mode) => GLPointers._glCullFace_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageCallback</c>]</b><br/> Specify a callback to receive debugging messages from the GL. </summary>
        /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
        /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml" /></remarks>
        public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallback_fnptr(callback, userParam);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageControl</c>]</b><br/> Control the reporting of debug messages in a debug context. </summary>
        /// <param name="source"> The source of debug messages to enable or disable. </param>
        /// <param name="type"> The type of debug messages to enable or disable. </param>
        /// <param name="severity"> The severity of debug messages to enable or disable. </param>
        /// <param name="count"> The length of the array ids. </param>
        /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
        /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml" /></remarks>
        public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageControl_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageInsert</c>]</b><br/> Inject an application-supplied message into the debug message queue. </summary>
        /// <param name="source"> The source of the debug message to insert. </param>
        /// <param name="type"> The type of the debug message insert. </param>
        /// <param name="id"> The user-supplied identifier of the message to insert. </param>
        /// <param name="severity"> The severity of the debug messages to insert. </param>
        /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
        /// <param name="message"> The address of a character array containing the message to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml" /></remarks>
        public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._glDebugMessageInsert_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glDeleteBuffers</c>]</b><br/> Delete named buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to be deleted. </param>
        /// <param name="buffers"> Specifies an array of buffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml" /></remarks>
        public static void DeleteBuffers(int n, int* buffers) => GLPointers._glDeleteBuffers_fnptr(n, buffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glDeleteFramebuffers</c>]</b><br/> Delete framebuffer objects. </summary>
        /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
        /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml" /></remarks>
        public static void DeleteFramebuffers(int n, int* framebuffers) => GLPointers._glDeleteFramebuffers_fnptr(n, framebuffers);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glDeleteLists</c>]</b><br/> Delete a contiguous group of display lists. </summary>
        /// <param name="list"> Specifies the integer name of the first display list to delete. </param>
        /// <param name="range"> Specifies the number of display lists to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDeleteLists.xml" /></remarks>
        public static void DeleteLists(int list, int range) => GLPointers._glDeleteLists_fnptr(list, range);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDeleteProgram</c>]</b><br/> Deletes a program object. </summary>
        /// <param name="program">Specifies the program object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml" /></remarks>
        public static void DeleteProgram(int program) => GLPointers._glDeleteProgram_fnptr(program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glDeleteProgramPipelines</c>]</b><br/> Delete program pipeline objects. </summary>
        /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
        /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml" /></remarks>
        public static void DeleteProgramPipelines(int n, int* pipelines) => GLPointers._glDeleteProgramPipelines_fnptr(n, pipelines);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glDeleteQueries</c>]</b><br/> Delete named query objects. </summary>
        /// <param name="n"> Specifies the number of query objects to be deleted. </param>
        /// <param name="ids"> Specifies an array of query objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteQueries.xhtml" /></remarks>
        public static void DeleteQueries(int n, int* ids) => GLPointers._glDeleteQueries_fnptr(n, ids);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glDeleteRenderbuffers</c>]</b><br/> Delete renderbuffer objects. </summary>
        /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
        /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml" /></remarks>
        public static void DeleteRenderbuffers(int n, int* renderbuffers) => GLPointers._glDeleteRenderbuffers_fnptr(n, renderbuffers);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glDeleteSamplers</c>]</b><br/> Delete named sampler objects. </summary>
        /// <param name="n"> Specifies the number of sampler objects to be deleted. </param>
        /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml" /></remarks>
        public static void DeleteSamplers(int count, int* samplers) => GLPointers._glDeleteSamplers_fnptr(count, samplers);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDeleteShader</c>]</b><br/> Deletes a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml" /></remarks>
        public static void DeleteShader(int shader) => GLPointers._glDeleteShader_fnptr(shader);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glDeleteSync</c>]</b><br/> Delete a sync object. </summary>
        /// <param name="sync"> The sync object to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml" /></remarks>
        public static void DeleteSync(GLSync sync) => GLPointers._glDeleteSync_fnptr((IntPtr)sync);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glDeleteTextures</c>]</b><br/> Delete named textures. </summary>
        /// <param name="n"> Specifies the number of textures to be deleted. </param>
        /// <param name="textures"> Specifies an array of textures to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTextures.xhtml" /></remarks>
        public static void DeleteTextures(int n, int* textures) => GLPointers._glDeleteTextures_fnptr(n, textures);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glDeleteTransformFeedbacks</c>]</b><br/> Delete transform feedback objects. </summary>
        /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
        /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml" /></remarks>
        public static void DeleteTransformFeedbacks(int n, int* ids) => GLPointers._glDeleteTransformFeedbacks_fnptr(n, ids);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glDeleteVertexArrays</c>]</b><br/> Delete vertex array objects. </summary>
        /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
        /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml" /></remarks>
        public static void DeleteVertexArrays(int n, int* arrays) => GLPointers._glDeleteVertexArrays_fnptr(n, arrays);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDepthFunc</c>]</b><br/> Specify the value used for depth buffer comparisons. </summary>
        /// <param name="func"> Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml" /></remarks>
        public static void DepthFunc(DepthFunction func) => GLPointers._glDepthFunc_fnptr((uint)func);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDepthMask</c>]</b><br/> Enable or disable writing into the depth buffer. </summary>
        /// <param name="flag"> Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthMask.xhtml" /></remarks>
        public static void DepthMask(bool flag) => GLPointers._glDepthMask_fnptr((byte)(flag ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDepthRange</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
        public static void DepthRange(double n, double f) => GLPointers._glDepthRange_fnptr(n, f);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeArrayv</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
        /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
        /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml" /></remarks>
        public static void DepthRangeArrayv(uint first, int count, double* v) => GLPointers._glDepthRangeArrayv_fnptr(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glDepthRangef</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
        public static void DepthRangef(float n, float f) => GLPointers._glDepthRangef_fnptr(n, f);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeIndexed</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml" /></remarks>
        public static void DepthRangeIndexed(uint index, double n, double f) => GLPointers._glDepthRangeIndexed_fnptr(index, n, f);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDetachShader</c>]</b><br/> Detaches a shader object from a program object to which it is attached. </summary>
        /// <param name="program">Specifies the program object from which to detach the shader object.</param>
        /// <param name="shader">Specifies the shader object to be detached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDetachShader.xhtml" /></remarks>
        public static void DetachShader(int program, int shader) => GLPointers._glDetachShader_fnptr(program, shader);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDisable</c>]</b><br/> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Disable(EnableCap cap) => GLPointers._glDisable_fnptr((uint)cap);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glDisableClientState</c>]</b><br/>  </summary>
        public static void DisableClientState(EnableCap array) => GLPointers._glDisableClientState_fnptr((uint)array);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glDisablei</c>]</b><br/> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Disablei(EnableCap target, uint index) => GLPointers._glDisablei_fnptr((uint)target, index);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glDisableVertexArrayAttrib</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void DisableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glDisableVertexArrayAttrib_fnptr(vaobj, index);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDisableVertexAttribArray</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void DisableVertexAttribArray(uint index) => GLPointers._glDisableVertexAttribArray_fnptr(index);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> <b>[entry point: <c>glDispatchCompute</c>]</b><br/> Launch one or more compute work groups. </summary>
        /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
        /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
        /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml" /></remarks>
        public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => GLPointers._glDispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> <b>[entry point: <c>glDispatchComputeIndirect</c>]</b><br/> Launch one or more compute work groups using parameters stored in a buffer. </summary>
        /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml" /></remarks>
        public static void DispatchComputeIndirect(IntPtr indirect) => GLPointers._glDispatchComputeIndirect_fnptr(indirect);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glDrawArrays</c>]</b><br/> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml" /></remarks>
        public static void DrawArrays(PrimitiveType mode, int first, int count) => GLPointers._glDrawArrays_fnptr((uint)mode, first, count);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> <b>[entry point: <c>glDrawArraysIndirect</c>]</b><br/> Render primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml" /></remarks>
        public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => GLPointers._glDrawArraysIndirect_fnptr((uint)mode, indirect);
        
        /// <summary> <b>[requires: v3.1]</b> <b>[entry point: <c>glDrawArraysInstanced</c>]</b><br/> Draw multiple instances of a range of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstanced.xhtml" /></remarks>
        public static void DrawArraysInstanced(PrimitiveType mode, int first, int count, int instancecount) => GLPointers._glDrawArraysInstanced_fnptr((uint)mode, first, count, instancecount);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawArraysInstancedBaseInstance</c>]</b><br/> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml" /></remarks>
        public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => GLPointers._glDrawArraysInstancedBaseInstance_fnptr((uint)mode, first, count, instancecount, baseinstance);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glDrawBuffer</c>]</b><br/> Specify which color buffers are to be drawn into. </summary>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
        public static void DrawBuffer(DrawBufferMode buf) => GLPointers._glDrawBuffer_fnptr((uint)buf);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glDrawBuffers</c>]</b><br/> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
        public static void DrawBuffers(int n, DrawBufferMode* bufs) => GLPointers._glDrawBuffers_fnptr(n, (uint*)bufs);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glDrawElements</c>]</b><br/> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElements.xhtml" /></remarks>
        public static void DrawElements(PrimitiveType mode, int count, DrawElementsType type, void* indices) => GLPointers._glDrawElements_fnptr((uint)mode, count, (uint)type, indices);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawElementsBaseVertex</c>]</b><br/> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml" /></remarks>
        public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._glDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, basevertex);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> <b>[entry point: <c>glDrawElementsIndirect</c>]</b><br/> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml" /></remarks>
        public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => GLPointers._glDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect);
        
        /// <summary> <b>[requires: v3.1]</b> <b>[entry point: <c>glDrawElementsInstanced</c>]</b><br/> Draw multiple instances of a set of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstanced.xhtml" /></remarks>
        public static void DrawElementsInstanced(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount) => GLPointers._glDrawElementsInstanced_fnptr((uint)mode, count, (uint)type, indices, instancecount);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawElementsInstancedBaseInstance</c>]</b><br/> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, uint baseinstance) => GLPointers._glDrawElementsInstancedBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, baseinstance);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawElementsInstancedBaseVertex</c>]</b><br/> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => GLPointers._glDrawElementsInstancedBaseVertex_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawElementsInstancedBaseVertexBaseInstance</c>]</b><br/> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => GLPointers._glDrawElementsInstancedBaseVertexBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex, baseinstance);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glDrawPixels</c>]</b><br/> Write a block of pixels to the frame buffer. </summary>
        /// <param name="width"> Specify the dimensions of the pixel rectangle to be written into the frame buffer. </param>
        /// <param name="height"> Specify the dimensions of the pixel rectangle to be written into the frame buffer. </param>
        /// <param name="format"> Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted. </param>
        /// <param name="type"> Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
        /// <param name="data"> Specifies a pointer to the pixel data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glDrawPixels.xml" /></remarks>
        public static void DrawPixels(int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glDrawPixels_fnptr(width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.2]</b> <b>[entry point: <c>glDrawRangeElements</c>]</b><br/> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElements.xhtml" /></remarks>
        public static void DrawRangeElements(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => GLPointers._glDrawRangeElements_fnptr((uint)mode, start, end, count, (uint)type, indices);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawRangeElementsBaseVertex</c>]</b><br/> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml" /></remarks>
        public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._glDrawRangeElementsBaseVertex_fnptr((uint)mode, start, end, count, (uint)type, indices, basevertex);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glDrawTransformFeedback</c>]</b><br/> Render primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml" /></remarks>
        public static void DrawTransformFeedback(PrimitiveType mode, int id) => GLPointers._glDrawTransformFeedback_fnptr((uint)mode, id);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> <b>[entry point: <c>glDrawTransformFeedbackInstanced</c>]</b><br/> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml" /></remarks>
        public static void DrawTransformFeedbackInstanced(PrimitiveType mode, int id, int instancecount) => GLPointers._glDrawTransformFeedbackInstanced_fnptr((uint)mode, id, instancecount);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glDrawTransformFeedbackStream</c>]</b><br/> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml" /></remarks>
        public static void DrawTransformFeedbackStream(PrimitiveType mode, int id, uint stream) => GLPointers._glDrawTransformFeedbackStream_fnptr((uint)mode, id, stream);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> <b>[entry point: <c>glDrawTransformFeedbackStreamInstanced</c>]</b><br/> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml" /></remarks>
        public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, int id, uint stream, int instancecount) => GLPointers._glDrawTransformFeedbackStreamInstanced_fnptr((uint)mode, id, stream, instancecount);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEdgeFlag</c>]</b><br/> Flag edges as either boundary or nonboundary. </summary>
        /// <param name="flag"> Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEdgeFlag.xml" /></remarks>
        public static void EdgeFlag(bool flag) => GLPointers._glEdgeFlag_fnptr((byte)(flag ? 1 : 0));
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEdgeFlagPointer</c>]</b><br/> Define an array of edge flags. </summary>
        /// <param name="stride"> Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first edge flag in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEdgeFlagPointer.xml" /></remarks>
        public static void EdgeFlagPointer(int stride, void* pointer) => GLPointers._glEdgeFlagPointer_fnptr(stride, pointer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEdgeFlagv</c>]</b><br/>  </summary>
        public static void EdgeFlagv(bool* flag) => GLPointers._glEdgeFlagv_fnptr((byte*)flag);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glEnable</c>]</b><br/> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Enable(EnableCap cap) => GLPointers._glEnable_fnptr((uint)cap);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEnableClientState</c>]</b><br/> Enable or disable client-side capability. </summary>
        /// <param name="cap"> Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnableClientState.xml" /></remarks>
        public static void EnableClientState(EnableCap array) => GLPointers._glEnableClientState_fnptr((uint)array);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glEnablei</c>]</b><br/> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Enablei(EnableCap target, uint index) => GLPointers._glEnablei_fnptr((uint)target, index);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glEnableVertexArrayAttrib</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void EnableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glEnableVertexArrayAttrib_fnptr(vaobj, index);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glEnableVertexAttribArray</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void EnableVertexAttribArray(uint index) => GLPointers._glEnableVertexAttribArray_fnptr(index);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEnd</c>]</b><br/>  </summary>
        public static void End() => GLPointers._glEnd_fnptr();
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glEndConditionalRender</c>]</b><br/> Start conditional rendering. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml" /></remarks>
        public static void EndConditionalRender() => GLPointers._glEndConditionalRender_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEndList</c>]</b><br/>  </summary>
        public static void EndList() => GLPointers._glEndList_fnptr();
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glEndQuery</c>]</b><br/> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml" /></remarks>
        public static void EndQuery(QueryTarget target) => GLPointers._glEndQuery_fnptr((uint)target);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glEndQueryIndexed</c>]</b><br/> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
        public static void EndQueryIndexed(QueryTarget target, uint index) => GLPointers._glEndQueryIndexed_fnptr((uint)target, index);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glEndTransformFeedback</c>]</b><br/> Start transform feedback operation. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml" /></remarks>
        public static void EndTransformFeedback() => GLPointers._glEndTransformFeedback_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalCoord1d</c>]</b><br/> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord1d(double u) => GLPointers._glEvalCoord1d_fnptr(u);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalCoord1dv</c>]</b><br/>  </summary>
        public static void EvalCoord1dv(double* u) => GLPointers._glEvalCoord1dv_fnptr(u);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalCoord1f</c>]</b><br/> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord1f(float u) => GLPointers._glEvalCoord1f_fnptr(u);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalCoord1fv</c>]</b><br/>  </summary>
        public static void EvalCoord1fv(float* u) => GLPointers._glEvalCoord1fv_fnptr(u);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalCoord2d</c>]</b><br/> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <param name="v"> Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord2d(double u, double v) => GLPointers._glEvalCoord2d_fnptr(u, v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalCoord2dv</c>]</b><br/>  </summary>
        public static void EvalCoord2dv(double* u) => GLPointers._glEvalCoord2dv_fnptr(u);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalCoord2f</c>]</b><br/> Evaluate enabled one- and two-dimensional maps. </summary>
        /// <param name="u"> Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command. </param>
        /// <param name="v"> Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalCoord.xml" /></remarks>
        public static void EvalCoord2f(float u, float v) => GLPointers._glEvalCoord2f_fnptr(u, v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalCoord2fv</c>]</b><br/>  </summary>
        public static void EvalCoord2fv(float* u) => GLPointers._glEvalCoord2fv_fnptr(u);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalMesh1</c>]</b><br/> Compute a one- or two-dimensional grid of points or lines. </summary>
        /// <param name="mode"> In glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants GL_POINT and GL_LINE are accepted. </param>
        /// <param name="i1"> Specify the first and last integer values for grid domain variable i. </param>
        /// <param name="i2"> Specify the first and last integer values for grid domain variable i. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalMesh.xml" /></remarks>
        public static void EvalMesh1(MeshMode1 mode, int i1, int i2) => GLPointers._glEvalMesh1_fnptr((uint)mode, i1, i2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalMesh2</c>]</b><br/>  </summary>
        public static void EvalMesh2(MeshMode2 mode, int i1, int i2, int j1, int j2) => GLPointers._glEvalMesh2_fnptr((uint)mode, i1, i2, j1, j2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalPoint1</c>]</b><br/> Generate and evaluate a single point in a mesh. </summary>
        /// <param name="i"> Specifies the integer value for grid domain variable i. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalPoint.xml" /></remarks>
        public static void EvalPoint1(int i) => GLPointers._glEvalPoint1_fnptr(i);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glEvalPoint2</c>]</b><br/> Generate and evaluate a single point in a mesh. </summary>
        /// <param name="i"> Specifies the integer value for grid domain variable i. </param>
        /// <param name="j"> Specifies the integer value for grid domain variable j (glEvalPoint2 only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEvalPoint.xml" /></remarks>
        public static void EvalPoint2(int i, int j) => GLPointers._glEvalPoint2_fnptr(i, j);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFeedbackBuffer</c>]</b><br/> Controls feedback mode. </summary>
        /// <param name="size"> Specifies the maximum number of values that can be written into buffer. </param>
        /// <param name="type"> Specifies a symbolic constant that describes the information that will be returned for each vertex. GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted. </param>
        /// <param name="buffer"> Returns the feedback data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFeedbackBuffer.xml" /></remarks>
        public static void FeedbackBuffer(int size, FeedbackType type, float* buffer) => GLPointers._glFeedbackBuffer_fnptr(size, (uint)type, buffer);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glFenceSync</c>]</b><br/> Create a new sync object and insert it into the GL command stream. </summary>
        /// <param name="condition"> Specifies the condition that must be met to set the sync object&apos;s state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
        /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml" /></remarks>
        public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) GLPointers._glFenceSync_fnptr((uint)condition, (uint)flags);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glFinish</c>]</b><br/> Block until all GL execution is complete. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFinish.xhtml" /></remarks>
        public static void Finish() => GLPointers._glFinish_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glFlush</c>]</b><br/> Force execution of GL commands in finite time. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlush.xhtml" /></remarks>
        public static void Flush() => GLPointers._glFlush_fnptr();
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> <b>[entry point: <c>glFlushMappedBufferRange</c>]</b><br/> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
        public static void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, nint length) => GLPointers._glFlushMappedBufferRange_fnptr((uint)target, offset, length);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glFlushMappedNamedBufferRange</c>]</b><br/> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
        public static void FlushMappedNamedBufferRange(int buffer, IntPtr offset, nint length) => GLPointers._glFlushMappedNamedBufferRange_fnptr(buffer, offset, length);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFogCoordd</c>]</b><br/> Set the current fog coordinates. </summary>
        /// <param name="coord"> Specify the fog distance. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFogCoord.xml" /></remarks>
        public static void FogCoordd(double coord) => GLPointers._glFogCoordd_fnptr(coord);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFogCoorddv</c>]</b><br/>  </summary>
        public static void FogCoorddv(double* coord) => GLPointers._glFogCoorddv_fnptr(coord);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFogCoordf</c>]</b><br/> Set the current fog coordinates. </summary>
        /// <param name="coord"> Specify the fog distance. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFogCoord.xml" /></remarks>
        public static void FogCoordf(float coord) => GLPointers._glFogCoordf_fnptr(coord);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFogCoordfv</c>]</b><br/>  </summary>
        public static void FogCoordfv(float* coord) => GLPointers._glFogCoordfv_fnptr(coord);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFogCoordPointer</c>]</b><br/> Define an array of fog coordinates. </summary>
        /// <param name="type"> Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFogCoordPointer.xml" /></remarks>
        public static void FogCoordPointer(FogPointerTypeEXT type, int stride, void* pointer) => GLPointers._glFogCoordPointer_fnptr((uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFogf</c>]</b><br/> Specify fog parameters. </summary>
        /// <param name="pname"> Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted. </param>
        /// <param name="param"> Specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFog.xml" /></remarks>
        public static void Fogf(FogParameter pname, float param) => GLPointers._glFogf_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFogfv</c>]</b><br/>  </summary>
        public static void Fogfv(FogParameter pname, float* parameters) => GLPointers._glFogfv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFogi</c>]</b><br/> Specify fog parameters. </summary>
        /// <param name="pname"> Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted. </param>
        /// <param name="param"> Specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFog.xml" /></remarks>
        public static void Fogi(FogParameter pname, int param) => GLPointers._glFogi_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFogiv</c>]</b><br/>  </summary>
        public static void Fogiv(FogParameter pname, int* parameters) => GLPointers._glFogiv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> <b>[entry point: <c>glFramebufferParameteri</c>]</b><br/> Set a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
        public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers._glFramebufferParameteri_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferRenderbuffer</c>]</b><br/> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
        public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glFramebufferRenderbuffer_fnptr((uint)target, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
        
        /// <summary> <b>[requires: v3.2]</b> <b>[entry point: <c>glFramebufferTexture</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level) => GLPointers._glFramebufferTexture_fnptr((uint)target, (uint)attachment, texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture1D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture1D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture2D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture2D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture3D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers._glFramebufferTexture3D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level, zoffset);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTextureLayer</c>]</b><br/> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
        public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayer_fnptr((uint)target, (uint)attachment, texture, level, layer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glFrontFace</c>]</b><br/> Define front- and back-facing polygons. </summary>
        /// <param name="mode"> Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFrontFace.xhtml" /></remarks>
        public static void FrontFace(FrontFaceDirection mode) => GLPointers._glFrontFace_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glFrustum</c>]</b><br/> Multiply the current matrix by a perspective matrix. </summary>
        /// <param name="left"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="right"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="bottom"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="top"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="nearVal"> Specify the distances to the near and far depth clipping planes. Both distances must be positive. </param>
        /// <param name="farVal"> Specify the distances to the near and far depth clipping planes. Both distances must be positive. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml" /></remarks>
        public static void Frustum(double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glFrustum_fnptr(left, right, bottom, top, zNear, zFar);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGenBuffers</c>]</b><br/> Generate buffer object names. </summary>
        /// <param name="n"> Specifies the number of buffer object names to be generated. </param>
        /// <param name="buffers"> Specifies an array in which the generated buffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml" /></remarks>
        public static void GenBuffers(int n, int* buffers) => GLPointers._glGenBuffers_fnptr(n, buffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenerateMipmap</c>]</b><br/> Generate mipmaps for a specified texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
        public static void GenerateMipmap(TextureTarget target) => GLPointers._glGenerateMipmap_fnptr((uint)target);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGenerateTextureMipmap</c>]</b><br/> Generate mipmaps for a specified texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
        public static void GenerateTextureMipmap(int texture) => GLPointers._glGenerateTextureMipmap_fnptr(texture);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenFramebuffers</c>]</b><br/> Generate framebuffer object names. </summary>
        /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
        /// <param name="ids"> Specifies an array in which the generated framebuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml" /></remarks>
        public static void GenFramebuffers(int n, int* framebuffers) => GLPointers._glGenFramebuffers_fnptr(n, framebuffers);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGenLists</c>]</b><br/> Generate a contiguous set of empty display lists. </summary>
        /// <param name="range"> Specifies the number of contiguous empty display lists to be generated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGenLists.xml" /></remarks>
        public static int GenLists(int range) => GLPointers._glGenLists_fnptr(range);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGenProgramPipelines</c>]</b><br/> Reserve program pipeline object names. </summary>
        /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
        /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml" /></remarks>
        public static void GenProgramPipelines(int n, int* pipelines) => GLPointers._glGenProgramPipelines_fnptr(n, pipelines);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGenQueries</c>]</b><br/> Generate query object names. </summary>
        /// <param name="n"> Specifies the number of query object names to be generated. </param>
        /// <param name="ids"> Specifies an array in which the generated query object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenQueries.xhtml" /></remarks>
        public static void GenQueries(int n, int* ids) => GLPointers._glGenQueries_fnptr(n, ids);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenRenderbuffers</c>]</b><br/> Generate renderbuffer object names. </summary>
        /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
        /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml" /></remarks>
        public static void GenRenderbuffers(int n, int* renderbuffers) => GLPointers._glGenRenderbuffers_fnptr(n, renderbuffers);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGenSamplers</c>]</b><br/> Generate sampler object names. </summary>
        /// <param name="n"> Specifies the number of sampler object names to generate. </param>
        /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml" /></remarks>
        public static void GenSamplers(int count, int* samplers) => GLPointers._glGenSamplers_fnptr(count, samplers);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glGenTextures</c>]</b><br/> Generate texture names. </summary>
        /// <param name="n"> Specifies the number of texture names to be generated. </param>
        /// <param name="textures"> Specifies an array in which the generated texture names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTextures.xhtml" /></remarks>
        public static void GenTextures(int n, int* textures) => GLPointers._glGenTextures_fnptr(n, textures);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glGenTransformFeedbacks</c>]</b><br/> Reserve transform feedback object names. </summary>
        /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
        /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml" /></remarks>
        public static void GenTransformFeedbacks(int n, int* ids) => GLPointers._glGenTransformFeedbacks_fnptr(n, ids);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glGenVertexArrays</c>]</b><br/> Generate vertex array object names. </summary>
        /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
        /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" /></remarks>
        public static void GenVertexArrays(int n, int* arrays) => GLPointers._glGenVertexArrays_fnptr(n, arrays);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters]</b> <b>[entry point: <c>glGetActiveAtomicCounterBufferiv</c>]</b><br/> Retrieve information about the set of active atomic counter buffers for a program. </summary>
        /// <param name="program"> The name of a program object from which to retrieve information. </param>
        /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
        /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml" /></remarks>
        public static void GetActiveAtomicCounterBufferiv(int program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => GLPointers._glGetActiveAtomicCounterBufferiv_fnptr(program, bufferIndex, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetActiveAttrib</c>]</b><br/> Returns information about an active attribute variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the attribute variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute variable.</param>
        /// <param name="type">Returns the data type of the attribute variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the attribute variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAttrib.xhtml" /></remarks>
        public static void GetActiveAttrib(int program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers._glGetActiveAttrib_fnptr(program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineName</c>]</b><br/> Query the name of an active shader subroutine. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
        /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml" /></remarks>
        public static void GetActiveSubroutineName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetActiveSubroutineName_fnptr(program, (uint)shadertype, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineUniformiv</c>]</b><br/> Query a property of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
        /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml" /></remarks>
        public static void GetActiveSubroutineUniformiv(int program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => GLPointers._glGetActiveSubroutineUniformiv_fnptr(program, (uint)shadertype, index, (uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineUniformName</c>]</b><br/> Query the name of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
        /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml" /></remarks>
        public static void GetActiveSubroutineUniformName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetActiveSubroutineUniformName_fnptr(program, (uint)shadertype, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetActiveUniform</c>]</b><br/> Returns information about an active uniform variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform variable.</param>
        /// <param name="type">Returns the data type of the uniform variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniform.xhtml" /></remarks>
        public static void GetActiveUniform(int program, uint index, int bufSize, int* length, int* size, UniformType* type, byte* name) => GLPointers._glGetActiveUniform_fnptr(program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformBlockiv</c>]</b><br/> Query information about an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="pname"> Specifies the name of the parameter to query. </param>
        /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml" /></remarks>
        public static void GetActiveUniformBlockiv(int program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => GLPointers._glGetActiveUniformBlockiv_fnptr(program, uniformBlockIndex, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformBlockName</c>]</b><br/> Retrieve the name of an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml" /></remarks>
        public static void GetActiveUniformBlockName(int program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => GLPointers._glGetActiveUniformBlockName_fnptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformName</c>]</b><br/> Query the name of an active uniform. </summary>
        /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
        /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
        /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
        /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
        /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml" /></remarks>
        public static void GetActiveUniformName(int program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => GLPointers._glGetActiveUniformName_fnptr(program, uniformIndex, bufSize, length, uniformName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformsiv</c>]</b><br/> Returns information about several active uniform variables for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
        /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
        /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
        /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml" /></remarks>
        public static void GetActiveUniformsiv(int program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => GLPointers._glGetActiveUniformsiv_fnptr(program, uniformCount, uniformIndices, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetAttachedShaders</c>]</b><br/> Returns the handles of the shader objects attached to a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned in shaders.</param>
        /// <param name="shaders">Specifies an array that is used to return the names of attached shader objects.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml" /></remarks>
        public static void GetAttachedShaders(int program, int maxCount, int* count, int* shaders) => GLPointers._glGetAttachedShaders_fnptr(program, maxCount, count, shaders);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetAttribLocation</c>]</b><br/> Returns the location of an attribute variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttribLocation.xhtml" /></remarks>
        public static int GetAttribLocation(int program, byte* name) => GLPointers._glGetAttribLocation_fnptr(program, name);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetBooleani_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetBooleani_v(BufferTargetARB target, uint index, bool* data) => GLPointers._glGetBooleani_v_fnptr((uint)target, index, (byte*)data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetBooleanv</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetBooleanv(GetPName pname, bool* data) => GLPointers._glGetBooleanv_fnptr((uint)pname, (byte*)data);
        
        /// <summary> <b>[requires: v3.2]</b> <b>[entry point: <c>glGetBufferParameteri64v</c>]</b><br/> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="value"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="data"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetBufferParameteri64v(BufferTargetARB target, BufferPNameARB pname, long* parameters) => GLPointers._glGetBufferParameteri64v_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetBufferParameteriv</c>]</b><br/> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="value"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="data"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetBufferParameteriv(BufferTargetARB target, BufferPNameARB pname, int* parameters) => GLPointers._glGetBufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetBufferPointerv</c>]</b><br/> Return the pointer to a mapped buffer object&apos;s data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
        public static void GetBufferPointerv(BufferTargetARB target, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetBufferPointerv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetBufferSubData</c>]</b><br/> Returns a subset of a buffer object&apos;s data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
        public static void GetBufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._glGetBufferSubData_fnptr((uint)target, offset, size, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetClipPlane</c>]</b><br/> Return the coefficients of the specified clipping plane. </summary>
        /// <param name="plane"> Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE i where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1. </param>
        /// <param name="equation"> Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetClipPlane.xml" /></remarks>
        public static void GetClipPlane(ClipPlaneName plane, double* equation) => GLPointers._glGetClipPlane_fnptr((uint)plane, equation);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glGetCompressedTexImage</c>]</b><br/> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetCompressedTexImage(TextureTarget target, int level, void* img) => GLPointers._glGetCompressedTexImage_fnptr((uint)target, level, img);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetCompressedTextureImage</c>]</b><br/> Return a compressed texture image. </summary>
        /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetCompressedTextureImage(int texture, int level, int bufSize, void* pixels) => GLPointers._glGetCompressedTextureImage_fnptr(texture, level, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> <b>[entry point: <c>glGetCompressedTextureSubImage</c>]</b><br/> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block&apos;s width, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block&apos;s height, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block&apos;s depth, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml" /></remarks>
        public static void GetCompressedTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => GLPointers._glGetCompressedTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetDebugMessageLog</c>]</b><br/> Retrieve messages from the debug message log. </summary>
        /// <param name="count"> The number of debug messages to retrieve from the log. </param>
        /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
        /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
        /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
        /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
        /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
        /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
        /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml" /></remarks>
        public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._glGetDebugMessageLog_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glGetDoublei_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetDoublei_v(GetPName target, uint index, double* data) => GLPointers._glGetDoublei_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetDoublev</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetDoublev(GetPName pname, double* data) => GLPointers._glGetDoublev_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetError</c>]</b><br/> Return error information. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetError.xhtml" /></remarks>
        public static ErrorCode GetError() => (ErrorCode) GLPointers._glGetError_fnptr();
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glGetFloati_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetFloati_v(GetPName target, uint index, float* data) => GLPointers._glGetFloati_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetFloatv</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetFloatv(GetPName pname, float* data) => GLPointers._glGetFloatv_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> <b>[entry point: <c>glGetFragDataIndex</c>]</b><br/> Query the bindings of color indices to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml" /></remarks>
        public static int GetFragDataIndex(int program, byte* name) => GLPointers._glGetFragDataIndex_fnptr(program, name);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetFragDataLocation</c>]</b><br/> Query the bindings of color numbers to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataLocation.xhtml" /></remarks>
        public static int GetFragDataLocation(int program, byte* name) => GLPointers._glGetFragDataLocation_fnptr(program, name);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGetFramebufferAttachmentParameteriv</c>]</b><br/> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
        public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferAttachmentParameteriv_fnptr((uint)target, (uint)attachment, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> <b>[entry point: <c>glGetFramebufferParameteriv</c>]</b><br/> Query a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
        public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetGraphicsResetStatus</c>]</b><br/> Check if the rendering context has not been lost due to software or hardware issues. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml" /></remarks>
        public static GraphicsResetStatus GetGraphicsResetStatus() => (GraphicsResetStatus) GLPointers._glGetGraphicsResetStatus_fnptr();
        
        /// <summary> <b>[requires: v3.2]</b> <b>[entry point: <c>glGetInteger64i_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetInteger64i_v(GetPName target, uint index, long* data) => GLPointers._glGetInteger64i_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glGetInteger64v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetInteger64v(GetPName pname, long* data) => GLPointers._glGetInteger64v_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetIntegeri_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetIntegeri_v(GetPName target, uint index, int* data) => GLPointers._glGetIntegeri_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetIntegerv</c>]</b><br/> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetIntegerv(GetPName pname, int* data) => GLPointers._glGetIntegerv_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2]</b> <b>[entry point: <c>glGetInternalformati64v</c>]</b><br/> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
        public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => GLPointers._glGetInternalformati64v_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query]</b> <b>[entry point: <c>glGetInternalformativ</c>]</b><br/> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
        public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => GLPointers._glGetInternalformativ_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetLightfv</c>]</b><br/> Return light source parameter values. </summary>
        /// <param name="light"> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetLight.xml" /></remarks>
        public static void GetLightfv(LightName light, LightParameter pname, float* parameters) => GLPointers._glGetLightfv_fnptr((uint)light, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetLightiv</c>]</b><br/> Return light source parameter values. </summary>
        /// <param name="light"> Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetLight.xml" /></remarks>
        public static void GetLightiv(LightName light, LightParameter pname, int* parameters) => GLPointers._glGetLightiv_fnptr((uint)light, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetMapdv</c>]</b><br/> Return evaluator parameters. </summary>
        /// <param name="target"> Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4. </param>
        /// <param name="query"> Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted. </param>
        /// <param name="v"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMap.xml" /></remarks>
        public static void GetMapdv(MapTarget target, GetMapQuery query, double* v) => GLPointers._glGetMapdv_fnptr((uint)target, (uint)query, v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetMapfv</c>]</b><br/> Return evaluator parameters. </summary>
        /// <param name="target"> Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4. </param>
        /// <param name="query"> Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted. </param>
        /// <param name="v"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMap.xml" /></remarks>
        public static void GetMapfv(MapTarget target, GetMapQuery query, float* v) => GLPointers._glGetMapfv_fnptr((uint)target, (uint)query, v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetMapiv</c>]</b><br/> Return evaluator parameters. </summary>
        /// <param name="target"> Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4. </param>
        /// <param name="query"> Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted. </param>
        /// <param name="v"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMap.xml" /></remarks>
        public static void GetMapiv(MapTarget target, GetMapQuery query, int* v) => GLPointers._glGetMapiv_fnptr((uint)target, (uint)query, v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetMaterialfv</c>]</b><br/> Return material parameters. </summary>
        /// <param name="face"> Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively. </param>
        /// <param name="pname"> Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMaterial.xml" /></remarks>
        public static void GetMaterialfv(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers._glGetMaterialfv_fnptr((uint)face, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetMaterialiv</c>]</b><br/> Return material parameters. </summary>
        /// <param name="face"> Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively. </param>
        /// <param name="pname"> Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMaterial.xml" /></remarks>
        public static void GetMaterialiv(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glGetMaterialiv_fnptr((uint)face, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glGetMultisamplefv</c>]</b><br/> Retrieve the location of a sample. </summary>
        /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
        /// <param name="index"> Specifies the index of the sample whose position to query. </param>
        /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml" /></remarks>
        public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers._glGetMultisamplefv_fnptr((uint)pname, index, val);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameteri64v</c>]</b><br/> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetNamedBufferParameteri64v(int buffer, BufferPNameARB pname, long* parameters) => GLPointers._glGetNamedBufferParameteri64v_fnptr(buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameteriv</c>]</b><br/> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetNamedBufferParameteriv(int buffer, BufferPNameARB pname, int* parameters) => GLPointers._glGetNamedBufferParameteriv_fnptr(buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferPointerv</c>]</b><br/> Return the pointer to a mapped buffer object&apos;s data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
        public static void GetNamedBufferPointerv(int buffer, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetNamedBufferPointerv_fnptr(buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferSubData</c>]</b><br/> Returns a subset of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
        public static void GetNamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glGetNamedBufferSubData_fnptr(buffer, offset, size, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferAttachmentParameteriv</c>]</b><br/> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
        public static void GetNamedFramebufferAttachmentParameteriv(int framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetNamedFramebufferAttachmentParameteriv_fnptr(framebuffer, (uint)attachment, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferParameteriv</c>]</b><br/> Query a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="param">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
        public static void GetNamedFramebufferParameteriv(int framebuffer, GetFramebufferParameter pname, int* param) => GLPointers._glGetNamedFramebufferParameteriv_fnptr(framebuffer, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedRenderbufferParameteriv</c>]</b><br/> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
        public static void GetNamedRenderbufferParameteriv(int renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetNamedRenderbufferParameteriv_fnptr(renderbuffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnColorTable</c>]</b><br/>  </summary>
        public static void GetnColorTable(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, void* table) => GLPointers._glGetnColorTable_fnptr((uint)target, (uint)format, (uint)type, bufSize, table);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnCompressedTexImage</c>]</b><br/> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetnCompressedTexImage(TextureTarget target, int lod, int bufSize, void* pixels) => GLPointers._glGetnCompressedTexImage_fnptr((uint)target, lod, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnConvolutionFilter</c>]</b><br/>  </summary>
        public static void GetnConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, void* image) => GLPointers._glGetnConvolutionFilter_fnptr((uint)target, (uint)format, (uint)type, bufSize, image);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnHistogram</c>]</b><br/>  </summary>
        public static void GetnHistogram(HistogramTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers._glGetnHistogram_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnMapdv</c>]</b><br/>  </summary>
        public static void GetnMapdv(MapTarget target, MapQuery query, int bufSize, double* v) => GLPointers._glGetnMapdv_fnptr((uint)target, (uint)query, bufSize, v);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnMapfv</c>]</b><br/>  </summary>
        public static void GetnMapfv(MapTarget target, MapQuery query, int bufSize, float* v) => GLPointers._glGetnMapfv_fnptr((uint)target, (uint)query, bufSize, v);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnMapiv</c>]</b><br/>  </summary>
        public static void GetnMapiv(MapTarget target, MapQuery query, int bufSize, int* v) => GLPointers._glGetnMapiv_fnptr((uint)target, (uint)query, bufSize, v);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnMinmax</c>]</b><br/>  </summary>
        public static void GetnMinmax(MinmaxTarget target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers._glGetnMinmax_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnPixelMapfv</c>]</b><br/>  </summary>
        public static void GetnPixelMapfv(PixelMap map, int bufSize, float* values) => GLPointers._glGetnPixelMapfv_fnptr((uint)map, bufSize, values);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnPixelMapuiv</c>]</b><br/>  </summary>
        public static void GetnPixelMapuiv(PixelMap map, int bufSize, uint* values) => GLPointers._glGetnPixelMapuiv_fnptr((uint)map, bufSize, values);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnPixelMapusv</c>]</b><br/>  </summary>
        public static void GetnPixelMapusv(PixelMap map, int bufSize, ushort* values) => GLPointers._glGetnPixelMapusv_fnptr((uint)map, bufSize, values);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnPolygonStipple</c>]</b><br/>  </summary>
        public static void GetnPolygonStipple(int bufSize, byte* pattern) => GLPointers._glGetnPolygonStipple_fnptr(bufSize, pattern);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnSeparableFilter</c>]</b><br/>  </summary>
        public static void GetnSeparableFilter(SeparableTarget target, PixelFormat format, PixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span) => GLPointers._glGetnSeparableFilter_fnptr((uint)target, (uint)format, (uint)type, rowBufSize, row, columnBufSize, column, span);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnTexImage</c>]</b><br/> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetnTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetnTexImage_fnptr((uint)target, level, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5]</b> <b>[entry point: <c>glGetnUniformdv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformdv(int program, int location, int bufSize, double* parameters) => GLPointers._glGetnUniformdv_fnptr(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformfv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformfv(int program, int location, int bufSize, float* parameters) => GLPointers._glGetnUniformfv_fnptr(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformiv(int program, int location, int bufSize, int* parameters) => GLPointers._glGetnUniformiv_fnptr(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformuiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformuiv(int program, int location, int bufSize, uint* parameters) => GLPointers._glGetnUniformuiv_fnptr(program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectLabel</c>]</b><br/> Retrieve the label of a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml" /></remarks>
        public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => GLPointers._glGetObjectLabel_fnptr((uint)identifier, name, bufSize, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectPtrLabel</c>]</b><br/> Retrieve the label of a sync object identified by a pointer. </summary>
        /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml" /></remarks>
        public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => GLPointers._glGetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetPixelMapfv</c>]</b><br/> Return the specified pixel map. </summary>
        /// <param name="map"> Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="data"> Returns the pixel map contents. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPixelMap.xml" /></remarks>
        public static void GetPixelMapfv(PixelMap map, float* values) => GLPointers._glGetPixelMapfv_fnptr((uint)map, values);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetPixelMapuiv</c>]</b><br/> Return the specified pixel map. </summary>
        /// <param name="map"> Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="data"> Returns the pixel map contents. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPixelMap.xml" /></remarks>
        public static void GetPixelMapuiv(PixelMap map, uint* values) => GLPointers._glGetPixelMapuiv_fnptr((uint)map, values);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetPixelMapusv</c>]</b><br/> Return the specified pixel map. </summary>
        /// <param name="map"> Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="data"> Returns the pixel map contents. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPixelMap.xml" /></remarks>
        public static void GetPixelMapusv(PixelMap map, ushort* values) => GLPointers._glGetPixelMapusv_fnptr((uint)map, values);
        
        /// <summary> <b>[requires: v1.1 | GL_KHR_debug]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetPointerv</c>]</b><br/> Return the address of the specified pointer. </summary>
        /// <param name="pname"> Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or GL_DEBUG_CALLBACK_USER_PARAM. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml" /></remarks>
        public static void GetPointerv(GetPointervPName pname, void** parameters) => GLPointers._glGetPointerv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetPolygonStipple</c>]</b><br/> Return the polygon stipple pattern. </summary>
        /// <param name="pattern"> Returns the stipple pattern. The initial value is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetPolygonStipple.xml" /></remarks>
        public static void GetPolygonStipple(byte* mask) => GLPointers._glGetPolygonStipple_fnptr(mask);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> <b>[entry point: <c>glGetProgramBinary</c>]</b><br/> Return a binary representation of a program object&apos;s compiled and linked executable source. </summary>
        /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
        /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
        /// <param name="binary"> Specifies the address an array into which the GL will return program&apos;s binary representation. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml" /></remarks>
        public static void GetProgramBinary(int program, int bufSize, int* length, All* binaryFormat, void* binary) => GLPointers._glGetProgramBinary_fnptr(program, bufSize, length, (uint*)binaryFormat, binary);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetProgramInfoLog</c>]</b><br/> Returns the information log for a program object. </summary>
        /// <param name="program">Specifies the program object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml" /></remarks>
        public static void GetProgramInfoLog(int program, int bufSize, int* length, byte* infoLog) => GLPointers._glGetProgramInfoLog_fnptr(program, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramInterfaceiv</c>]</b><br/> Query a property of an interface in a program. </summary>
        /// <param name="program"> The name of a program object whose interface to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program to query. </param>
        /// <param name="pname"> The name of the parameter within programInterface to query. </param>
        /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml" /></remarks>
        public static void GetProgramInterfaceiv(int program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => GLPointers._glGetProgramInterfaceiv_fnptr(program, (uint)programInterface, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetProgramiv</c>]</b><br/> Returns a parameter from a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgram.xhtml" /></remarks>
        public static void GetProgramiv(int program, ProgramPropertyARB pname, int* parameters) => GLPointers._glGetProgramiv_fnptr(program, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineInfoLog</c>]</b><br/> Retrieve the info log string from a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
        /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
        /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
        /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml" /></remarks>
        public static void GetProgramPipelineInfoLog(int pipeline, int bufSize, int* length, byte* infoLog) => GLPointers._glGetProgramPipelineInfoLog_fnptr(pipeline, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineiv</c>]</b><br/> Retrieve properties of a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
        /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml" /></remarks>
        public static void GetProgramPipelineiv(int pipeline, PipelineParameterName pname, int* parameters) => GLPointers._glGetProgramPipelineiv_fnptr(pipeline, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceIndex</c>]</b><br/> Query the index of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the index of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml" /></remarks>
        public static uint GetProgramResourceIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceIndex_fnptr(program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceiv</c>]</b><br/> Retrieve values for multiple properties of a single active resource within a program object. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="index">!!missing documentation!!</param>
        /// <param name="propCount">!!missing documentation!!</param>
        /// <param name="props">!!missing documentation!!</param>
        /// <param name="bufSize">!!missing documentation!!</param>
        /// <param name="length">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml" /></remarks>
        public static void GetProgramResourceiv(int program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => GLPointers._glGetProgramResourceiv_fnptr(program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceLocation</c>]</b><br/> Query the location of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml" /></remarks>
        public static int GetProgramResourceLocation(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceLocation_fnptr(program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceLocationIndex</c>]</b><br/> Query the fragment color index of a named variable within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml" /></remarks>
        public static int GetProgramResourceLocationIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceLocationIndex_fnptr(program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceName</c>]</b><br/> Query the name of an indexed resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
        /// <param name="index"> The index of the resource within programInterface of program. </param>
        /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
        /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
        /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml" /></remarks>
        public static void GetProgramResourceName(int program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetProgramResourceName_fnptr(program, (uint)programInterface, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetProgramStageiv</c>]</b><br/> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
        /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml" /></remarks>
        public static void GetProgramStageiv(int program, ShaderType shadertype, ProgramStagePName pname, int* values) => GLPointers._glGetProgramStageiv_fnptr(program, (uint)shadertype, (uint)pname, values);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjecti64v</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjecti64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjecti64v_fnptr(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectiv</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectiv_fnptr(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectui64v</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectui64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectui64v_fnptr(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectuiv</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectuiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectuiv_fnptr(id, buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glGetQueryIndexediv</c>]</b><br/> Return parameters of an indexed query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="index"> Specifies the index of the query object target. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml" /></remarks>
        public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => GLPointers._glGetQueryIndexediv_fnptr((uint)target, index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetQueryiv</c>]</b><br/> Return parameters of a query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryiv.xhtml" /></remarks>
        public static void GetQueryiv(QueryTarget target, QueryParameterName pname, int* parameters) => GLPointers._glGetQueryiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glGetQueryObjecti64v</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjecti64v(int id, QueryObjectParameterName pname, long* parameters) => GLPointers._glGetQueryObjecti64v_fnptr(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetQueryObjectiv</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectiv(int id, QueryObjectParameterName pname, int* parameters) => GLPointers._glGetQueryObjectiv_fnptr(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glGetQueryObjectui64v</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectui64v(int id, QueryObjectParameterName pname, ulong* parameters) => GLPointers._glGetQueryObjectui64v_fnptr(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glGetQueryObjectuiv</c>]</b><br/> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectuiv(int id, QueryObjectParameterName pname, uint* parameters) => GLPointers._glGetQueryObjectuiv_fnptr(id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGetRenderbufferParameteriv</c>]</b><br/> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
        public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetRenderbufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterfv</c>]</b><br/> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterfv(int sampler, SamplerParameterF pname, float* parameters) => GLPointers._glGetSamplerParameterfv_fnptr(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterIiv</c>]</b><br/> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterIiv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers._glGetSamplerParameterIiv_fnptr(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterIuiv</c>]</b><br/> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* parameters) => GLPointers._glGetSamplerParameterIuiv_fnptr(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameteriv</c>]</b><br/> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameteriv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers._glGetSamplerParameteriv_fnptr(sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetShaderInfoLog</c>]</b><br/> Returns the information log for a shader object. </summary>
        /// <param name="shader">Specifies the shader object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml" /></remarks>
        public static void GetShaderInfoLog(int shader, int bufSize, int* length, byte* infoLog) => GLPointers._glGetShaderInfoLog_fnptr(shader, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetShaderiv</c>]</b><br/> Returns a parameter from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShader.xhtml" /></remarks>
        public static void GetShaderiv(int shader, ShaderParameterName pname, int* parameters) => GLPointers._glGetShaderiv_fnptr(shader, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glGetShaderPrecisionFormat</c>]</b><br/> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
        /// <param name="shaderType"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="precisionType"> Specifies the numeric format whose precision and range to query. </param>
        /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation&apos;s numeric range are returned. </param>
        /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml" /></remarks>
        public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => GLPointers._glGetShaderPrecisionFormat_fnptr((uint)shadertype, (uint)precisiontype, range, precision);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetShaderSource</c>]</b><br/> Returns the source code string from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in source (excluding the null terminator).</param>
        /// <param name="source">Specifies an array of characters that is used to return the source code string.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderSource.xhtml" /></remarks>
        public static void GetShaderSource(int shader, int bufSize, int* length, byte* source) => GLPointers._glGetShaderSource_fnptr(shader, bufSize, length, source);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetString</c>]</b><br/> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml" /></remarks>
        public static byte* GetString_(StringName name) => GLPointers._glGetString_fnptr((uint)name);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetStringi</c>]</b><br/> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <param name="index"> For glGetStringi, specifies the index of the string to return. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml" /></remarks>
        public static byte* GetStringi_(StringName name, uint index) => GLPointers._glGetStringi_fnptr((uint)name, index);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetSubroutineIndex</c>]</b><br/> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml" /></remarks>
        public static uint GetSubroutineIndex(int program, ShaderType shadertype, byte* name) => GLPointers._glGetSubroutineIndex_fnptr(program, (uint)shadertype, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetSubroutineUniformLocation</c>]</b><br/> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml" /></remarks>
        public static int GetSubroutineUniformLocation(int program, ShaderType shadertype, byte* name) => GLPointers._glGetSubroutineUniformLocation_fnptr(program, (uint)shadertype, name);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glGetSynciv</c>]</b><br/> Query the properties of a sync object. </summary>
        /// <param name="sync"> Specifies the sync object whose properties to query. </param>
        /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in values. </param>
        /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
        /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml" /></remarks>
        public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => GLPointers._glGetSynciv_fnptr((IntPtr)sync, (uint)pname, count, length, values);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetTexEnvfv</c>]</b><br/> Return texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml" /></remarks>
        public static void GetTexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._glGetTexEnvfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetTexEnviv</c>]</b><br/> Return texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml" /></remarks>
        public static void GetTexEnviv(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glGetTexEnviv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetTexGendv</c>]</b><br/> Return texture coordinate generation parameters. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexGen.xml" /></remarks>
        public static void GetTexGendv(TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._glGetTexGendv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetTexGenfv</c>]</b><br/> Return texture coordinate generation parameters. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexGen.xml" /></remarks>
        public static void GetTexGenfv(TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._glGetTexGenfv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetTexGeniv</c>]</b><br/> Return texture coordinate generation parameters. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexGen.xml" /></remarks>
        public static void GetTexGeniv(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glGetTexGeniv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexImage</c>]</b><br/> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers._glGetTexImage_fnptr((uint)target, level, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexLevelParameterfv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTexLevelParameterfv(TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetTexLevelParameterfv_fnptr((uint)target, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexLevelParameteriv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTexLevelParameteriv(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexLevelParameteriv_fnptr((uint)target, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexParameterfv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterfv(TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers._glGetTexParameterfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetTexParameterIiv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterIiv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexParameterIiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetTexParameterIuiv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterIuiv(TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTexParameterIuiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glGetTexParameteriv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameteriv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureImage</c>]</b><br/> Return a texture image. </summary>
        /// <param name="texture"> Specifies the texture object name. </param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetTextureImage(int texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetTextureImage_fnptr(texture, level, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameterfv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTextureLevelParameterfv(int texture, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureLevelParameterfv_fnptr(texture, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameteriv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTextureLevelParameteriv(int texture, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureLevelParameteriv_fnptr(texture, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterfv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterfv(int texture, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureParameterfv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIiv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterIiv(int texture, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameterIiv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIuiv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterIuiv(int texture, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTextureParameterIuiv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameteriv</c>]</b><br/> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameteriv(int texture, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameteriv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> <b>[entry point: <c>glGetTextureSubImage</c>]</b><br/> Retrieve a sub-region of a texture image from a texture    object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml" /></remarks>
        public static void GetTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbacki_v</c>]</b><br/> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbacki_v(int xfb, TransformFeedbackPName pname, uint index, int* param) => GLPointers._glGetTransformFeedbacki_v_fnptr(xfb, (uint)pname, index, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbacki64_v</c>]</b><br/> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbacki64_v(int xfb, TransformFeedbackPName pname, uint index, long* param) => GLPointers._glGetTransformFeedbacki64_v_fnptr(xfb, (uint)pname, index, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbackiv</c>]</b><br/> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbackiv(int xfb, TransformFeedbackPName pname, int* param) => GLPointers._glGetTransformFeedbackiv_fnptr(xfb, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetTransformFeedbackVarying</c>]</b><br/> Retrieve information about varying variables selected for transform feedback. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="index"> The index of the varying variable whose information to retrieve. </param>
        /// <param name="bufSize"> The maximum number of characters, including the null terminator, that may be written into name. </param>
        /// <param name="length"> The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned. </param>
        /// <param name="size"> The address of a variable that will receive the size of the varying. </param>
        /// <param name="type"> The address of a variable that will receive the type of the varying. </param>
        /// <param name="name"> The address of a buffer into which will be written the name of the varying. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedbackVarying.xhtml" /></remarks>
        public static void GetTransformFeedbackVarying(int program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers._glGetTransformFeedbackVarying_fnptr(program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetUniformBlockIndex</c>]</b><br/> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml" /></remarks>
        public static uint GetUniformBlockIndex(int program, byte* uniformBlockName) => GLPointers._glGetUniformBlockIndex_fnptr(program, uniformBlockName);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glGetUniformdv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformdv(int program, int location, double* parameters) => GLPointers._glGetUniformdv_fnptr(program, location, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetUniformfv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformfv(int program, int location, float* parameters) => GLPointers._glGetUniformfv_fnptr(program, location, parameters);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetUniformIndices</c>]</b><br/> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
        /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
        /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
        /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml" /></remarks>
        public static void GetUniformIndices(int program, int uniformCount, byte** uniformNames, uint* uniformIndices) => GLPointers._glGetUniformIndices_fnptr(program, uniformCount, uniformNames, uniformIndices);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetUniformiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformiv(int program, int location, int* parameters) => GLPointers._glGetUniformiv_fnptr(program, location, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetUniformLocation</c>]</b><br/> Returns the location of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml" /></remarks>
        public static int GetUniformLocation(int program, byte* name) => GLPointers._glGetUniformLocation_fnptr(program, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetUniformSubroutineuiv</c>]</b><br/> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="location"> Specifies the location of the subroutine uniform. </param>
        /// <param name="values"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml" /></remarks>
        public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => GLPointers._glGetUniformSubroutineuiv_fnptr((uint)shadertype, location, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetUniformuiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformuiv(int program, int location, uint* parameters) => GLPointers._glGetUniformuiv_fnptr(program, location, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIndexed64iv</c>]</b><br/> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
        public static void GetVertexArrayIndexed64iv(int vaobj, uint index, VertexArrayPName pname, long* param) => GLPointers._glGetVertexArrayIndexed64iv_fnptr(vaobj, index, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIndexediv</c>]</b><br/> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
        public static void GetVertexArrayIndexediv(int vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayIndexediv_fnptr(vaobj, index, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayiv</c>]</b><br/> Retrieve parameters of a vertex array object. </summary>
        /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
        /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml" /></remarks>
        public static void GetVertexArrayiv(int vaobj, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayiv_fnptr(vaobj, (uint)pname, param);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetVertexAttribdv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribdv(uint index, VertexAttribPropertyARB pname, double* parameters) => GLPointers._glGetVertexAttribdv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetVertexAttribfv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribfv(uint index, VertexAttribPropertyARB pname, float* parameters) => GLPointers._glGetVertexAttribfv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetVertexAttribIiv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribIiv(uint index, VertexAttribEnum pname, int* parameters) => GLPointers._glGetVertexAttribIiv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glGetVertexAttribIuiv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribIuiv(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers._glGetVertexAttribIuiv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetVertexAttribiv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribiv(uint index, VertexAttribPropertyARB pname, int* parameters) => GLPointers._glGetVertexAttribiv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glGetVertexAttribLdv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => GLPointers._glGetVertexAttribLdv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glGetVertexAttribPointerv</c>]</b><br/> Return the address of the specified generic vertex attribute pointer. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be returned.</param>
        /// <param name="pname">Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.</param>
        /// <param name="pointer">Returns the pointer value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttribPointerv.xhtml" /></remarks>
        public static void GetVertexAttribPointerv(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => GLPointers._glGetVertexAttribPointerv_fnptr(index, (uint)pname, pointer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glHint</c>]</b><br/> Specify implementation-specific hints. </summary>
        /// <param name="target"> Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted. </param>
        /// <param name="mode"> Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glHint.xhtml" /></remarks>
        public static void Hint(HintTarget target, HintMode mode) => GLPointers._glHint_fnptr((uint)target, (uint)mode);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexd</c>]</b><br/> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexd(double c) => GLPointers._glIndexd_fnptr(c);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexdv</c>]</b><br/>  </summary>
        public static void Indexdv(double* c) => GLPointers._glIndexdv_fnptr(c);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexf</c>]</b><br/> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexf(float c) => GLPointers._glIndexf_fnptr(c);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexfv</c>]</b><br/>  </summary>
        public static void Indexfv(float* c) => GLPointers._glIndexfv_fnptr(c);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexi</c>]</b><br/> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexi(int c) => GLPointers._glIndexi_fnptr(c);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexiv</c>]</b><br/>  </summary>
        public static void Indexiv(int* c) => GLPointers._glIndexiv_fnptr(c);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexMask</c>]</b><br/> Control the writing of individual bits in the color index buffers. </summary>
        /// <param name="mask"> Specifies a bit mask to enable and disable the writing of individual bits in the color index buffers. Initially, the mask is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndexMask.xml" /></remarks>
        public static void IndexMask(uint mask) => GLPointers._glIndexMask_fnptr(mask);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexPointer</c>]</b><br/> Define an array of color indexes. </summary>
        /// <param name="type"> Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first index in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndexPointer.xml" /></remarks>
        public static void IndexPointer(IndexPointerType type, int stride, void* pointer) => GLPointers._glIndexPointer_fnptr((uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexs</c>]</b><br/> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexs(short c) => GLPointers._glIndexs_fnptr(c);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexsv</c>]</b><br/>  </summary>
        public static void Indexsv(short* c) => GLPointers._glIndexsv_fnptr(c);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexub</c>]</b><br/> Set the current color index. </summary>
        /// <param name="c"> Specifies the new value for the current color index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIndex.xml" /></remarks>
        public static void Indexub(byte c) => GLPointers._glIndexub_fnptr(c);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIndexubv</c>]</b><br/>  </summary>
        public static void Indexubv(byte* c) => GLPointers._glIndexubv_fnptr(c);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glInitNames</c>]</b><br/> Initialize the name stack. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glInitNames.xml" /></remarks>
        public static void InitNames() => GLPointers._glInitNames_fnptr();
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glInterleavedArrays</c>]</b><br/> Simultaneously specify and enable several interleaved arrays. </summary>
        /// <param name="format"> Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted. </param>
        /// <param name="stride"> Specifies the offset in bytes between each aggregate array element. </param>
        /// <param name="pointer">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glInterleavedArrays.xml" /></remarks>
        public static void InterleavedArrays(InterleavedArrayFormat format, int stride, void* pointer) => GLPointers._glInterleavedArrays_fnptr((uint)format, stride, pointer);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateBufferData</c>]</b><br/> Invalidate the content of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml" /></remarks>
        public static void InvalidateBufferData(int buffer) => GLPointers._glInvalidateBufferData_fnptr(buffer);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateBufferSubData</c>]</b><br/> Invalidate a region of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
        /// <param name="offset"> The offset within the buffer&apos;s data store of the start of the range to be invalidated. </param>
        /// <param name="length"> The length of the range within the buffer&apos;s data store to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml" /></remarks>
        public static void InvalidateBufferSubData(int buffer, IntPtr offset, nint length) => GLPointers._glInvalidateBufferSubData_fnptr(buffer, offset, length);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateFramebuffer</c>]</b><br/> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
        public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => GLPointers._glInvalidateFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glInvalidateNamedFramebufferData</c>]</b><br/> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
        public static void InvalidateNamedFramebufferData(int framebuffer, int numAttachments, FramebufferAttachment* attachments) => GLPointers._glInvalidateNamedFramebufferData_fnptr(framebuffer, numAttachments, (uint*)attachments);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glInvalidateNamedFramebufferSubData</c>]</b><br/> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
        public static void InvalidateNamedFramebufferSubData(int framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._glInvalidateNamedFramebufferSubData_fnptr(framebuffer, numAttachments, (uint*)attachments, x, y, width, height);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateSubFramebuffer</c>]</b><br/> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
        public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._glInvalidateSubFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments, x, y, width, height);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateTexImage</c>]</b><br/> Invalidate the entirety a texture image. </summary>
        /// <param name="texture"> The name of a texture object to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml" /></remarks>
        public static void InvalidateTexImage(int texture, int level) => GLPointers._glInvalidateTexImage_fnptr(texture, level);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateTexSubImage</c>]</b><br/> Invalidate a region of a texture image. </summary>
        /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
        /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
        /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
        /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
        /// <param name="width"> The width of the region to be invalidated. </param>
        /// <param name="height"> The height of the region to be invalidated. </param>
        /// <param name="depth"> The depth of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml" /></remarks>
        public static void InvalidateTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => GLPointers._glInvalidateTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glIsBuffer</c>]</b><br/> Determine if a name corresponds to a buffer object. </summary>
        /// <param name="buffer"> Specifies a value that may be the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsBuffer.xhtml" /></remarks>
        public static bool IsBuffer(int buffer) => GLPointers._glIsBuffer_fnptr(buffer) != 0;
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glIsEnabled</c>]</b><br/> Test whether a capability is enabled. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml" /></remarks>
        public static bool IsEnabled(EnableCap cap) => GLPointers._glIsEnabled_fnptr((uint)cap) != 0;
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glIsEnabledi</c>]</b><br/> Test whether a capability is enabled. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml" /></remarks>
        public static bool IsEnabledi(EnableCap target, uint index) => GLPointers._glIsEnabledi_fnptr((uint)target, index) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glIsFramebuffer</c>]</b><br/> Determine if a name corresponds to a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml" /></remarks>
        public static bool IsFramebuffer(int framebuffer) => GLPointers._glIsFramebuffer_fnptr(framebuffer) != 0;
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glIsList</c>]</b><br/> Determine if a name corresponds to a display list. </summary>
        /// <param name="list"> Specifies a potential display list name. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glIsList.xml" /></remarks>
        public static bool IsList(int list) => GLPointers._glIsList_fnptr(list) != 0;
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glIsProgram</c>]</b><br/> Determines if a name corresponds to a program object. </summary>
        /// <param name="program">Specifies a potential program object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgram.xhtml" /></remarks>
        public static bool IsProgram(int program) => GLPointers._glIsProgram_fnptr(program) != 0;
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glIsProgramPipeline</c>]</b><br/> Determine if a name corresponds to a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml" /></remarks>
        public static bool IsProgramPipeline(int pipeline) => GLPointers._glIsProgramPipeline_fnptr(pipeline) != 0;
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glIsQuery</c>]</b><br/> Determine if a name corresponds to a query object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsQuery.xhtml" /></remarks>
        public static bool IsQuery(int id) => GLPointers._glIsQuery_fnptr(id) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glIsRenderbuffer</c>]</b><br/> Determine if a name corresponds to a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml" /></remarks>
        public static bool IsRenderbuffer(int renderbuffer) => GLPointers._glIsRenderbuffer_fnptr(renderbuffer) != 0;
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glIsSampler</c>]</b><br/> Determine if a name corresponds to a sampler object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a sampler object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml" /></remarks>
        public static bool IsSampler(int sampler) => GLPointers._glIsSampler_fnptr(sampler) != 0;
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glIsShader</c>]</b><br/> Determines if a name corresponds to a shader object. </summary>
        /// <param name="shader">Specifies a potential shader object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsShader.xhtml" /></remarks>
        public static bool IsShader(int shader) => GLPointers._glIsShader_fnptr(shader) != 0;
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glIsSync</c>]</b><br/> Determine if a name corresponds to a sync object. </summary>
        /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml" /></remarks>
        public static bool IsSync(GLSync sync) => GLPointers._glIsSync_fnptr((IntPtr)sync) != 0;
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glIsTexture</c>]</b><br/> Determine if a name corresponds to a texture. </summary>
        /// <param name="texture"> Specifies a value that may be the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTexture.xhtml" /></remarks>
        public static bool IsTexture(int texture) => GLPointers._glIsTexture_fnptr(texture) != 0;
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glIsTransformFeedback</c>]</b><br/> Determine if a name corresponds to a transform feedback object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml" /></remarks>
        public static bool IsTransformFeedback(int id) => GLPointers._glIsTransformFeedback_fnptr(id) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glIsVertexArray</c>]</b><br/> Determine if a name corresponds to a vertex array object. </summary>
        /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml" /></remarks>
        public static bool IsVertexArray(int array) => GLPointers._glIsVertexArray_fnptr(array) != 0;
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLightf</c>]</b><br/> Set light source parameters. </summary>
        /// <param name="light"> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted. </param>
        /// <param name="param"> Specifies the value that parameter pname of light source light will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLight.xml" /></remarks>
        public static void Lightf(LightName light, LightParameter pname, float param) => GLPointers._glLightf_fnptr((uint)light, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLightfv</c>]</b><br/>  </summary>
        public static void Lightfv(LightName light, LightParameter pname, float* parameters) => GLPointers._glLightfv_fnptr((uint)light, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLighti</c>]</b><br/> Set light source parameters. </summary>
        /// <param name="light"> Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. </param>
        /// <param name="pname"> Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted. </param>
        /// <param name="param"> Specifies the value that parameter pname of light source light will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLight.xml" /></remarks>
        public static void Lighti(LightName light, LightParameter pname, int param) => GLPointers._glLighti_fnptr((uint)light, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLightiv</c>]</b><br/>  </summary>
        public static void Lightiv(LightName light, LightParameter pname, int* parameters) => GLPointers._glLightiv_fnptr((uint)light, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLightModelf</c>]</b><br/> Set the lighting model parameters. </summary>
        /// <param name="pname"> Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted. </param>
        /// <param name="param"> Specifies the value that param will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLightModel.xml" /></remarks>
        public static void LightModelf(LightModelParameter pname, float param) => GLPointers._glLightModelf_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLightModelfv</c>]</b><br/>  </summary>
        public static void LightModelfv(LightModelParameter pname, float* parameters) => GLPointers._glLightModelfv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLightModeli</c>]</b><br/> Set the lighting model parameters. </summary>
        /// <param name="pname"> Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted. </param>
        /// <param name="param"> Specifies the value that param will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLightModel.xml" /></remarks>
        public static void LightModeli(LightModelParameter pname, int param) => GLPointers._glLightModeli_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLightModeliv</c>]</b><br/>  </summary>
        public static void LightModeliv(LightModelParameter pname, int* parameters) => GLPointers._glLightModeliv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLineStipple</c>]</b><br/> Specify the line stipple pattern. </summary>
        /// <param name="factor"> Specifies a multiplier for each bit in the line stipple pattern. If factor is 3, for example, each bit in the pattern is used three times before the next bit in the pattern is used. factor is clamped to the range [1, 256] and defaults to 1. </param>
        /// <param name="pattern"> Specifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized. Bit zero is used first; the default pattern is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLineStipple.xml" /></remarks>
        public static void LineStipple(int factor, ushort pattern) => GLPointers._glLineStipple_fnptr(factor, pattern);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glLineWidth</c>]</b><br/> Specify the width of rasterized lines. </summary>
        /// <param name="width"> Specifies the width of rasterized lines. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLineWidth.xhtml" /></remarks>
        public static void LineWidth(float width) => GLPointers._glLineWidth_fnptr(width);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glLinkProgram</c>]</b><br/> Links a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be linked.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml" /></remarks>
        public static void LinkProgram(int program) => GLPointers._glLinkProgram_fnptr(program);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glListBase</c>]</b><br/> Set the display-list base for glCallLists. </summary>
        /// <param name="@base"> Specifies an integer offset that will be added to glCallLists offsets to generate display-list names. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glListBase.xml" /></remarks>
        public static void ListBase(int @base) => GLPointers._glListBase_fnptr(@base);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLoadIdentity</c>]</b><br/> Replace the current matrix with the identity matrix. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml" /></remarks>
        public static void LoadIdentity() => GLPointers._glLoadIdentity_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLoadMatrixd</c>]</b><br/> Replace the current matrix with the specified matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadMatrix.xml" /></remarks>
        public static void LoadMatrixd(double* m) => GLPointers._glLoadMatrixd_fnptr(m);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLoadMatrixf</c>]</b><br/> Replace the current matrix with the specified matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadMatrix.xml" /></remarks>
        public static void LoadMatrixf(float* m) => GLPointers._glLoadMatrixf_fnptr(m);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLoadName</c>]</b><br/> Load a name onto the name stack. </summary>
        /// <param name="name"> Specifies a name that will replace the top value on the name stack. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadName.xml" /></remarks>
        public static void LoadName(uint name) => GLPointers._glLoadName_fnptr(name);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLoadTransposeMatrixd</c>]</b><br/> Replace the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadTransposeMatrix.xml" /></remarks>
        public static void LoadTransposeMatrixd(double* m) => GLPointers._glLoadTransposeMatrixd_fnptr(m);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glLoadTransposeMatrixf</c>]</b><br/> Replace the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadTransposeMatrix.xml" /></remarks>
        public static void LoadTransposeMatrixf(float* m) => GLPointers._glLoadTransposeMatrixf_fnptr(m);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glLogicOp</c>]</b><br/> Specify a logical pixel operation for rendering. </summary>
        /// <param name="opcode"> Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLogicOp.xhtml" /></remarks>
        public static void LogicOp(LogicOp opcode) => GLPointers._glLogicOp_fnptr((uint)opcode);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMap1d</c>]</b><br/> Define a one-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="stride"> Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. </param>
        /// <param name="order"> Specifies the number of control points. Must be positive. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap1.xml" /></remarks>
        public static void Map1d(MapTarget target, double u1, double u2, int stride, int order, double* points) => GLPointers._glMap1d_fnptr((uint)target, u1, u2, stride, order, points);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMap1f</c>]</b><br/> Define a one-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord1, to u , the variable that is evaluated by the equations specified by this command. </param>
        /// <param name="stride"> Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. </param>
        /// <param name="order"> Specifies the number of control points. Must be positive. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap1.xml" /></remarks>
        public static void Map1f(MapTarget target, float u1, float u2, int stride, int order, float* points) => GLPointers._glMap1f_fnptr((uint)target, u1, u2, stride, order, points);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMap2d</c>]</b><br/> Define a two-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="ustride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i + 1 j , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0. </param>
        /// <param name="uorder"> Specifies the dimension of the control point array in the u axis. Must be positive. The initial value is 1. </param>
        /// <param name="v1"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="v2"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="vstride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i j + 1 , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0. </param>
        /// <param name="vorder"> Specifies the dimension of the control point array in the v axis. Must be positive. The initial value is 1. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap2.xml" /></remarks>
        public static void Map2d(MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) => GLPointers._glMap2d_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMap2f</c>]</b><br/> Define a two-dimensional evaluator. </summary>
        /// <param name="target"> Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted. </param>
        /// <param name="u1"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="u2"> Specify a linear mapping of u, as presented to glEvalCoord2, to u , one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1. </param>
        /// <param name="ustride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i + 1 j , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0. </param>
        /// <param name="uorder"> Specifies the dimension of the control point array in the u axis. Must be positive. The initial value is 1. </param>
        /// <param name="v1"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="v2"> Specify a linear mapping of v, as presented to glEvalCoord2, to v , one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1. </param>
        /// <param name="vstride"> Specifies the number of floats or doubles between the beginning of control point R ij and the beginning of control point R i j + 1 , where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0. </param>
        /// <param name="vorder"> Specifies the dimension of the control point array in the v axis. Must be positive. The initial value is 1. </param>
        /// <param name="points"> Specifies a pointer to the array of control points. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMap2.xml" /></remarks>
        public static void Map2f(MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) => GLPointers._glMap2f_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glMapBuffer</c>]</b><br/> Map all of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object&apos;s mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
        public static void* MapBuffer(BufferTargetARB target, BufferAccessARB access) => GLPointers._glMapBuffer_fnptr((uint)target, (uint)access);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> <b>[entry point: <c>glMapBufferRange</c>]</b><br/> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
        public static void* MapBufferRange(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapBufferRange_fnptr((uint)target, offset, length, (uint)access);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMapGrid1d</c>]</b><br/> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid1d(int un, double u1, double u2) => GLPointers._glMapGrid1d_fnptr(un, u1, u2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMapGrid1f</c>]</b><br/> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid1f(int un, float u1, float u2) => GLPointers._glMapGrid1f_fnptr(un, u1, u2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMapGrid2d</c>]</b><br/> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="vn"> Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only). </param>
        /// <param name="v1"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <param name="v2"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) => GLPointers._glMapGrid2d_fnptr(un, u1, u2, vn, v1, v2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMapGrid2f</c>]</b><br/> Define a one- or two-dimensional mesh. </summary>
        /// <param name="un"> Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive. </param>
        /// <param name="u1"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="u2"> Specify the mappings for integer grid domain values i = 0 and i = un . </param>
        /// <param name="vn"> Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only). </param>
        /// <param name="v1"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <param name="v2"> Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMapGrid.xml" /></remarks>
        public static void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) => GLPointers._glMapGrid2f_fnptr(un, u1, u2, vn, v1, v2);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glMapNamedBuffer</c>]</b><br/> Map all of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object&apos;s mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
        public static void* MapNamedBuffer(int buffer, BufferAccessARB access) => GLPointers._glMapNamedBuffer_fnptr(buffer, (uint)access);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glMapNamedBufferRange</c>]</b><br/> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
        public static void* MapNamedBufferRange(int buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapNamedBufferRange_fnptr(buffer, offset, length, (uint)access);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMaterialf</c>]</b><br/> Specify material parameters for the lighting model. </summary>
        /// <param name="face"> Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. </param>
        /// <param name="pname"> Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS. </param>
        /// <param name="param"> Specifies the value that parameter GL_SHININESS will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMaterial.xml" /></remarks>
        public static void Materialf(TriangleFace face, MaterialParameter pname, float param) => GLPointers._glMaterialf_fnptr((uint)face, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMaterialfv</c>]</b><br/>  </summary>
        public static void Materialfv(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers._glMaterialfv_fnptr((uint)face, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMateriali</c>]</b><br/> Specify material parameters for the lighting model. </summary>
        /// <param name="face"> Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. </param>
        /// <param name="pname"> Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS. </param>
        /// <param name="param"> Specifies the value that parameter GL_SHININESS will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMaterial.xml" /></remarks>
        public static void Materiali(TriangleFace face, MaterialParameter pname, int param) => GLPointers._glMateriali_fnptr((uint)face, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMaterialiv</c>]</b><br/>  </summary>
        public static void Materialiv(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glMaterialiv_fnptr((uint)face, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMatrixMode</c>]</b><br/> Specify which matrix is the current matrix. </summary>
        /// <param name="mode"> Specifies which matrix stack is the target for subsequent matrix operations. Three values are accepted: GL_MODELVIEW, GL_PROJECTION, and GL_TEXTURE. The initial value is GL_MODELVIEW. Additionally, if the ARB_imaging extension is supported, GL_COLOR is also accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml" /></remarks>
        public static void MatrixMode(MatrixMode mode) => GLPointers._glMatrixMode_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> <b>[entry point: <c>glMemoryBarrier</c>]</b><br/> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
        public static void MemoryBarrier(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrier_fnptr((uint)barriers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility]</b> <b>[entry point: <c>glMemoryBarrierByRegion</c>]</b><br/> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
        public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrierByRegion_fnptr((uint)barriers);
        
        /// <summary> <b>[requires: v4.0]</b> <b>[entry point: <c>glMinSampleShading</c>]</b><br/> Specifies minimum rate at which sample shading takes place. </summary>
        /// <param name="value"> Specifies the rate at which samples are shaded within each covered pixel. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMinSampleShading.xhtml" /></remarks>
        public static void MinSampleShading(float value) => GLPointers._glMinSampleShading_fnptr(value);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glMultiDrawArrays</c>]</b><br/> Render multiple sets of primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Points to an array of starting indices in the enabled arrays. </param>
        /// <param name="count"> Points to an array of the number of indices to be rendered. </param>
        /// <param name="drawcount"> Specifies the size of the first and count </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArrays.xhtml" /></remarks>
        public static void MultiDrawArrays(PrimitiveType mode, int* first, int* count, int drawcount) => GLPointers._glMultiDrawArrays_fnptr((uint)mode, first, count, drawcount);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawArraysIndirect</c>]</b><br/> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml" /></remarks>
        public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => GLPointers._glMultiDrawArraysIndirect_fnptr((uint)mode, indirect, drawcount, stride);
        
        /// <summary> <b>[requires: v4.6]</b> <b>[entry point: <c>glMultiDrawArraysIndirectCount</c>]</b><br/>  </summary>
        public static void MultiDrawArraysIndirectCount(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawArraysIndirectCount_fnptr((uint)mode, indirect, drawcount, maxdrawcount, stride);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glMultiDrawElements</c>]</b><br/> Render multiple sets of primitives by specifying indices of array data elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count and indices arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElements.xhtml" /></remarks>
        public static void MultiDrawElements(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount) => GLPointers._glMultiDrawElements_fnptr((uint)mode, count, (uint)type, indices, drawcount);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glMultiDrawElementsBaseVertex</c>]</b><br/> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
        /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml" /></remarks>
        public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => GLPointers._glMultiDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, drawcount, basevertex);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawElementsIndirect</c>]</b><br/> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml" /></remarks>
        public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => GLPointers._glMultiDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect, drawcount, stride);
        
        /// <summary> <b>[requires: v4.6]</b> <b>[entry point: <c>glMultiDrawElementsIndirectCount</c>]</b><br/>  </summary>
        public static void MultiDrawElementsIndirectCount(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawElementsIndirectCount_fnptr((uint)mode, (uint)type, indirect, drawcount, maxdrawcount, stride);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord1d</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1d(TextureUnit target, double s) => GLPointers._glMultiTexCoord1d_fnptr((uint)target, s);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord1dv</c>]</b><br/>  </summary>
        public static void MultiTexCoord1dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord1dv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord1f</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1f(TextureUnit target, float s) => GLPointers._glMultiTexCoord1f_fnptr((uint)target, s);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord1fv</c>]</b><br/>  </summary>
        public static void MultiTexCoord1fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord1fv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord1i</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1i(TextureUnit target, int s) => GLPointers._glMultiTexCoord1i_fnptr((uint)target, s);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord1iv</c>]</b><br/>  </summary>
        public static void MultiTexCoord1iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord1iv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord1s</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord1s(TextureUnit target, short s) => GLPointers._glMultiTexCoord1s_fnptr((uint)target, s);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord1sv</c>]</b><br/>  </summary>
        public static void MultiTexCoord1sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord1sv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord2d</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2d(TextureUnit target, double s, double t) => GLPointers._glMultiTexCoord2d_fnptr((uint)target, s, t);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord2dv</c>]</b><br/>  </summary>
        public static void MultiTexCoord2dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord2dv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord2f</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2f(TextureUnit target, float s, float t) => GLPointers._glMultiTexCoord2f_fnptr((uint)target, s, t);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord2fv</c>]</b><br/>  </summary>
        public static void MultiTexCoord2fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord2fv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord2i</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2i(TextureUnit target, int s, int t) => GLPointers._glMultiTexCoord2i_fnptr((uint)target, s, t);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord2iv</c>]</b><br/>  </summary>
        public static void MultiTexCoord2iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord2iv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord2s</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord2s(TextureUnit target, short s, short t) => GLPointers._glMultiTexCoord2s_fnptr((uint)target, s, t);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord2sv</c>]</b><br/>  </summary>
        public static void MultiTexCoord2sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord2sv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord3d</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3d(TextureUnit target, double s, double t, double r) => GLPointers._glMultiTexCoord3d_fnptr((uint)target, s, t, r);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord3dv</c>]</b><br/>  </summary>
        public static void MultiTexCoord3dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord3dv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord3f</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3f(TextureUnit target, float s, float t, float r) => GLPointers._glMultiTexCoord3f_fnptr((uint)target, s, t, r);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord3fv</c>]</b><br/>  </summary>
        public static void MultiTexCoord3fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord3fv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord3i</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3i(TextureUnit target, int s, int t, int r) => GLPointers._glMultiTexCoord3i_fnptr((uint)target, s, t, r);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord3iv</c>]</b><br/>  </summary>
        public static void MultiTexCoord3iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord3iv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord3s</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord3s(TextureUnit target, short s, short t, short r) => GLPointers._glMultiTexCoord3s_fnptr((uint)target, s, t, r);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord3sv</c>]</b><br/>  </summary>
        public static void MultiTexCoord3sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord3sv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord4d</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4d(TextureUnit target, double s, double t, double r, double q) => GLPointers._glMultiTexCoord4d_fnptr((uint)target, s, t, r, q);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord4dv</c>]</b><br/>  </summary>
        public static void MultiTexCoord4dv(TextureUnit target, double* v) => GLPointers._glMultiTexCoord4dv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord4f</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4f(TextureUnit target, float s, float t, float r, float q) => GLPointers._glMultiTexCoord4f_fnptr((uint)target, s, t, r, q);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord4fv</c>]</b><br/>  </summary>
        public static void MultiTexCoord4fv(TextureUnit target, float* v) => GLPointers._glMultiTexCoord4fv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord4i</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4i(TextureUnit target, int s, int t, int r, int q) => GLPointers._glMultiTexCoord4i_fnptr((uint)target, s, t, r, q);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord4iv</c>]</b><br/>  </summary>
        public static void MultiTexCoord4iv(TextureUnit target, int* v) => GLPointers._glMultiTexCoord4iv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord4s</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="target"> Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. </param>
        /// <param name="s"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultiTexCoord.xml" /></remarks>
        public static void MultiTexCoord4s(TextureUnit target, short s, short t, short r, short q) => GLPointers._glMultiTexCoord4s_fnptr((uint)target, s, t, r, q);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultiTexCoord4sv</c>]</b><br/>  </summary>
        public static void MultiTexCoord4sv(TextureUnit target, short* v) => GLPointers._glMultiTexCoord4sv_fnptr((uint)target, v);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP1ui</c>]</b><br/>  </summary>
        public static void MultiTexCoordP1ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP1ui_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP1uiv</c>]</b><br/>  </summary>
        public static void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP1uiv_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP2ui</c>]</b><br/>  </summary>
        public static void MultiTexCoordP2ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP2ui_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP2uiv</c>]</b><br/>  </summary>
        public static void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP2uiv_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP3ui</c>]</b><br/>  </summary>
        public static void MultiTexCoordP3ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP3ui_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP3uiv</c>]</b><br/>  </summary>
        public static void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP3uiv_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP4ui</c>]</b><br/>  </summary>
        public static void MultiTexCoordP4ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP4ui_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP4uiv</c>]</b><br/>  </summary>
        public static void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP4uiv_fnptr((uint)texture, (uint)type, coords);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultMatrixd</c>]</b><br/> Multiply the current matrix with the specified matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultMatrix.xml" /></remarks>
        public static void MultMatrixd(double* m) => GLPointers._glMultMatrixd_fnptr(m);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultMatrixf</c>]</b><br/> Multiply the current matrix with the specified matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 column-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultMatrix.xml" /></remarks>
        public static void MultMatrixf(float* m) => GLPointers._glMultMatrixf_fnptr(m);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultTransposeMatrixd</c>]</b><br/> Multiply the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultTransposeMatrix.xml" /></remarks>
        public static void MultTransposeMatrixd(double* m) => GLPointers._glMultTransposeMatrixd_fnptr(m);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glMultTransposeMatrixf</c>]</b><br/> Multiply the current matrix with the specified row-major ordered matrix. </summary>
        /// <param name="m"> Points to 16 consecutive values that are used as the elements of a 4 4 row-major matrix. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMultTransposeMatrix.xml" /></remarks>
        public static void MultTransposeMatrixf(float* m) => GLPointers._glMultTransposeMatrixf_fnptr(m);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferData</c>]</b><br/> Creates and initializes a buffer object&apos;s data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
        public static void NamedBufferData(int buffer, nint size, void* data, VertexBufferObjectUsage usage) => GLPointers._glNamedBufferData_fnptr(buffer, size, data, (uint)usage);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferStorage</c>]</b><br/> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
        public static void NamedBufferStorage(int buffer, nint size, void* data, BufferStorageMask flags) => GLPointers._glNamedBufferStorage_fnptr(buffer, size, data, (uint)flags);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferSubData</c>]</b><br/> Updates a subset of a buffer object&apos;s data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
        public static void NamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glNamedBufferSubData_fnptr(buffer, offset, size, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferDrawBuffer</c>]</b><br/> Specify which color buffers are to be drawn into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
        public static void NamedFramebufferDrawBuffer(int framebuffer, ColorBuffer buf) => GLPointers._glNamedFramebufferDrawBuffer_fnptr(framebuffer, (uint)buf);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferDrawBuffers</c>]</b><br/> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
        public static void NamedFramebufferDrawBuffers(int framebuffer, int n, ColorBuffer* bufs) => GLPointers._glNamedFramebufferDrawBuffers_fnptr(framebuffer, n, (uint*)bufs);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferParameteri</c>]</b><br/> Set a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
        public static void NamedFramebufferParameteri(int framebuffer, FramebufferParameterName pname, int param) => GLPointers._glNamedFramebufferParameteri_fnptr(framebuffer, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferReadBuffer</c>]</b><br/> Select a color buffer source for pixels. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
        /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
        public static void NamedFramebufferReadBuffer(int framebuffer, ColorBuffer src) => GLPointers._glNamedFramebufferReadBuffer_fnptr(framebuffer, (uint)src);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferRenderbuffer</c>]</b><br/> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
        public static void NamedFramebufferRenderbuffer(int framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glNamedFramebufferRenderbuffer_fnptr(framebuffer, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void NamedFramebufferTexture(int framebuffer, FramebufferAttachment attachment, int texture, int level) => GLPointers._glNamedFramebufferTexture_fnptr(framebuffer, (uint)attachment, texture, level);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureLayer</c>]</b><br/> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
        public static void NamedFramebufferTextureLayer(int framebuffer, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glNamedFramebufferTextureLayer_fnptr(framebuffer, (uint)attachment, texture, level, layer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorage</c>]</b><br/> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
        public static void NamedRenderbufferStorage(int renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorage_fnptr(renderbuffer, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisample</c>]</b><br/> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
        public static void NamedRenderbufferStorageMultisample(int renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisample_fnptr(renderbuffer, samples, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNewList</c>]</b><br/> Create or replace a display list. </summary>
        /// <param name="list"> Specifies the display-list name. </param>
        /// <param name="mode"> Specifies the compilation mode, which can be GL_COMPILE or GL_COMPILE_AND_EXECUTE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNewList.xml" /></remarks>
        public static void NewList(int list, ListMode mode) => GLPointers._glNewList_fnptr(list, (uint)mode);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3b</c>]</b><br/> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3b(sbyte nx, sbyte ny, sbyte nz) => GLPointers._glNormal3b_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3bv</c>]</b><br/>  </summary>
        public static void Normal3bv(sbyte* v) => GLPointers._glNormal3bv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3d</c>]</b><br/> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3d(double nx, double ny, double nz) => GLPointers._glNormal3d_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3dv</c>]</b><br/>  </summary>
        public static void Normal3dv(double* v) => GLPointers._glNormal3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3f</c>]</b><br/> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3f(float nx, float ny, float nz) => GLPointers._glNormal3f_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3fv</c>]</b><br/>  </summary>
        public static void Normal3fv(float* v) => GLPointers._glNormal3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3i</c>]</b><br/> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3i(int nx, int ny, int nz) => GLPointers._glNormal3i_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3iv</c>]</b><br/>  </summary>
        public static void Normal3iv(int* v) => GLPointers._glNormal3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3s</c>]</b><br/> Set the current normal vector. </summary>
        /// <param name="nx"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="ny"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <param name="nz"> Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormal.xml" /></remarks>
        public static void Normal3s(short nx, short ny, short nz) => GLPointers._glNormal3s_fnptr(nx, ny, nz);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormal3sv</c>]</b><br/>  </summary>
        public static void Normal3sv(short* v) => GLPointers._glNormal3sv_fnptr(v);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glNormalP3ui</c>]</b><br/>  </summary>
        public static void NormalP3ui(NormalPointerType type, uint coords) => GLPointers._glNormalP3ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glNormalP3uiv</c>]</b><br/>  </summary>
        public static void NormalP3uiv(NormalPointerType type, uint* coords) => GLPointers._glNormalP3uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glNormalPointer</c>]</b><br/> Define an array of normals. </summary>
        /// <param name="type"> Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glNormalPointer.xml" /></remarks>
        public static void NormalPointer(NormalPointerType type, int stride, void* pointer) => GLPointers._glNormalPointer_fnptr((uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glObjectLabel</c>]</b><br/> Label a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object to label. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml" /></remarks>
        public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers._glObjectLabel_fnptr((uint)identifier, name, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glObjectPtrLabel</c>]</b><br/> Label a sync object identified by a pointer. </summary>
        /// <param name="ptr"> A pointer identifying a sync object. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml" /></remarks>
        public static void ObjectPtrLabel(void* ptr, int length, byte* label) => GLPointers._glObjectPtrLabel_fnptr(ptr, length, label);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glOrtho</c>]</b><br/> Multiply the current matrix with an orthographic matrix. </summary>
        /// <param name="left"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="right"> Specify the coordinates for the left and right vertical clipping planes. </param>
        /// <param name="bottom"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="top"> Specify the coordinates for the bottom and top horizontal clipping planes. </param>
        /// <param name="nearVal"> Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer. </param>
        /// <param name="farVal"> Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml" /></remarks>
        public static void Ortho(double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glOrtho_fnptr(left, right, bottom, top, zNear, zFar);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPassThrough</c>]</b><br/> Place a marker in the feedback buffer. </summary>
        /// <param name="token"> Specifies a marker value to be placed in the feedback buffer following a GL_PASS_THROUGH_TOKEN. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPassThrough.xml" /></remarks>
        public static void PassThrough(float token) => GLPointers._glPassThrough_fnptr(token);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> <b>[entry point: <c>glPatchParameterfv</c>]</b><br/> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
        public static void PatchParameterfv(PatchParameterName pname, float* values) => GLPointers._glPatchParameterfv_fnptr((uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> <b>[entry point: <c>glPatchParameteri</c>]</b><br/> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
        public static void PatchParameteri(PatchParameterName pname, int value) => GLPointers._glPatchParameteri_fnptr((uint)pname, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glPauseTransformFeedback</c>]</b><br/> Pause transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml" /></remarks>
        public static void PauseTransformFeedback() => GLPointers._glPauseTransformFeedback_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPixelMapfv</c>]</b><br/> Set up pixel transfer maps. </summary>
        /// <param name="map"> Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="mapsize"> Specifies the size of the map being defined. </param>
        /// <param name="values"> Specifies an array of mapsize values. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelMap.xml" /></remarks>
        public static void PixelMapfv(PixelMap map, int mapsize, float* values) => GLPointers._glPixelMapfv_fnptr((uint)map, mapsize, values);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPixelMapuiv</c>]</b><br/> Set up pixel transfer maps. </summary>
        /// <param name="map"> Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="mapsize"> Specifies the size of the map being defined. </param>
        /// <param name="values"> Specifies an array of mapsize values. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelMap.xml" /></remarks>
        public static void PixelMapuiv(PixelMap map, int mapsize, uint* values) => GLPointers._glPixelMapuiv_fnptr((uint)map, mapsize, values);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPixelMapusv</c>]</b><br/> Set up pixel transfer maps. </summary>
        /// <param name="map"> Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A. </param>
        /// <param name="mapsize"> Specifies the size of the map being defined. </param>
        /// <param name="values"> Specifies an array of mapsize values. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelMap.xml" /></remarks>
        public static void PixelMapusv(PixelMap map, int mapsize, ushort* values) => GLPointers._glPixelMapusv_fnptr((uint)map, mapsize, values);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glPixelStoref</c>]</b><br/> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml" /></remarks>
        public static void PixelStoref(PixelStoreParameter pname, float param) => GLPointers._glPixelStoref_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glPixelStorei</c>]</b><br/> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml" /></remarks>
        public static void PixelStorei(PixelStoreParameter pname, int param) => GLPointers._glPixelStorei_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPixelTransferf</c>]</b><br/> Set pixel transfer modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelTransfer.xml" /></remarks>
        public static void PixelTransferf(PixelTransferParameter pname, float param) => GLPointers._glPixelTransferf_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPixelTransferi</c>]</b><br/> Set pixel transfer modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelTransfer.xml" /></remarks>
        public static void PixelTransferi(PixelTransferParameter pname, int param) => GLPointers._glPixelTransferi_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPixelZoom</c>]</b><br/> Specify the pixel zoom factors. </summary>
        /// <param name="xfactor"> Specify the x and y zoom factors for pixel write operations. </param>
        /// <param name="yfactor"> Specify the x and y zoom factors for pixel write operations. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPixelZoom.xml" /></remarks>
        public static void PixelZoom(float xfactor, float yfactor) => GLPointers._glPixelZoom_fnptr(xfactor, yfactor);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glPointParameterf</c>]</b><br/> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameterf(PointParameterNameARB pname, float param) => GLPointers._glPointParameterf_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glPointParameterfv</c>]</b><br/> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameterfv(PointParameterNameARB pname, float* parameters) => GLPointers._glPointParameterfv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glPointParameteri</c>]</b><br/> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameteri(PointParameterNameARB pname, int param) => GLPointers._glPointParameteri_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[entry point: <c>glPointParameteriv</c>]</b><br/> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameteriv(PointParameterNameARB pname, int* parameters) => GLPointers._glPointParameteriv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glPointSize</c>]</b><br/> Specify the diameter of rasterized points. </summary>
        /// <param name="size"> Specifies the diameter of rasterized points. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointSize.xhtml" /></remarks>
        public static void PointSize(float size) => GLPointers._glPointSize_fnptr(size);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glPolygonMode</c>]</b><br/> Select a polygon rasterization mode. </summary>
        /// <param name="face"> Specifies the polygons that mode applies to. Must be GL_FRONT_AND_BACK for front- and back-facing polygons. </param>
        /// <param name="mode"> Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The initial value is GL_FILL for both front- and back-facing polygons. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonMode.xhtml" /></remarks>
        public static void PolygonMode(TriangleFace face, PolygonMode mode) => GLPointers._glPolygonMode_fnptr((uint)face, (uint)mode);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glPolygonOffset</c>]</b><br/> Set the scale and units used to calculate depth values. </summary>
        /// <param name="factor"> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </param>
        /// <param name="units"> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml" /></remarks>
        public static void PolygonOffset(float factor, float units) => GLPointers._glPolygonOffset_fnptr(factor, units);
        
        /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp]</b> <b>[entry point: <c>glPolygonOffsetClamp</c>]</b><br/>  </summary>
        public static void PolygonOffsetClamp(float factor, float units, float clamp) => GLPointers._glPolygonOffsetClamp_fnptr(factor, units, clamp);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPolygonStipple</c>]</b><br/> Set the polygon stippling pattern. </summary>
        /// <param name="pattern"> Specifies a pointer to a 32 32 stipple pattern that will be unpacked from memory in the same way that glDrawPixels unpacks pixels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPolygonStipple.xml" /></remarks>
        public static void PolygonStipple(byte* mask) => GLPointers._glPolygonStipple_fnptr(mask);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPopAttrib</c>]</b><br/>  </summary>
        public static void PopAttrib() => GLPointers._glPopAttrib_fnptr();
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPopClientAttrib</c>]</b><br/>  </summary>
        public static void PopClientAttrib() => GLPointers._glPopClientAttrib_fnptr();
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glPopDebugGroup</c>]</b><br/> Pop the active debug group. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml" /></remarks>
        public static void PopDebugGroup() => GLPointers._glPopDebugGroup_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPopMatrix</c>]</b><br/>  </summary>
        public static void PopMatrix() => GLPointers._glPopMatrix_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPopName</c>]</b><br/>  </summary>
        public static void PopName() => GLPointers._glPopName_fnptr();
        
        /// <summary> <b>[requires: v3.1]</b> <b>[entry point: <c>glPrimitiveRestartIndex</c>]</b><br/> Specify the primitive restart index. </summary>
        /// <param name="index"> Specifies the value to be interpreted as the primitive restart index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPrimitiveRestartIndex.xhtml" /></remarks>
        public static void PrimitiveRestartIndex(uint index) => GLPointers._glPrimitiveRestartIndex_fnptr(index);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPrioritizeTextures</c>]</b><br/> Set texture residence priority. </summary>
        /// <param name="n"> Specifies the number of textures to be prioritized. </param>
        /// <param name="textures"> Specifies an array containing the names of the textures to be prioritized. </param>
        /// <param name="priorities"> Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPrioritizeTextures.xml" /></remarks>
        public static void PrioritizeTextures(int n, int* textures, float* priorities) => GLPointers._glPrioritizeTextures_fnptr(n, textures, priorities);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> <b>[entry point: <c>glProgramBinary</c>]</b><br/> Load a program object with a program binary. </summary>
        /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
        /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
        /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
        /// <param name="length"> Specifies the number of bytes contained in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml" /></remarks>
        public static void ProgramBinary(int program, All binaryFormat, void* binary, int length) => GLPointers._glProgramBinary_fnptr(program, (uint)binaryFormat, binary, length);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramParameteri</c>]</b><br/> Specify a parameter for a program object. </summary>
        /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the name of the parameter to modify. </param>
        /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml" /></remarks>
        public static void ProgramParameteri(int program, ProgramParameterPName pname, int value) => GLPointers._glProgramParameteri_fnptr(program, (uint)pname, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1d</c>]</b><br/>  </summary>
        public static void ProgramUniform1d(int program, int location, double v0) => GLPointers._glProgramUniform1d_fnptr(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1dv</c>]</b><br/>  </summary>
        public static void ProgramUniform1dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform1dv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1f(int program, int location, float v0) => GLPointers._glProgramUniform1f_fnptr(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform1fv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1i(int program, int location, int v0) => GLPointers._glProgramUniform1i_fnptr(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform1iv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1ui(int program, int location, uint v0) => GLPointers._glProgramUniform1ui_fnptr(program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform1uiv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2d</c>]</b><br/>  </summary>
        public static void ProgramUniform2d(int program, int location, double v0, double v1) => GLPointers._glProgramUniform2d_fnptr(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2dv</c>]</b><br/>  </summary>
        public static void ProgramUniform2dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform2dv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2f(int program, int location, float v0, float v1) => GLPointers._glProgramUniform2f_fnptr(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform2fv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2i(int program, int location, int v0, int v1) => GLPointers._glProgramUniform2i_fnptr(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform2iv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2ui(int program, int location, uint v0, uint v1) => GLPointers._glProgramUniform2ui_fnptr(program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform2uiv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3d</c>]</b><br/>  </summary>
        public static void ProgramUniform3d(int program, int location, double v0, double v1, double v2) => GLPointers._glProgramUniform3d_fnptr(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3dv</c>]</b><br/>  </summary>
        public static void ProgramUniform3dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform3dv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3f(int program, int location, float v0, float v1, float v2) => GLPointers._glProgramUniform3f_fnptr(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform3fv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3i(int program, int location, int v0, int v1, int v2) => GLPointers._glProgramUniform3i_fnptr(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform3iv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3ui(int program, int location, uint v0, uint v1, uint v2) => GLPointers._glProgramUniform3ui_fnptr(program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform3uiv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4d</c>]</b><br/>  </summary>
        public static void ProgramUniform4d(int program, int location, double v0, double v1, double v2, double v3) => GLPointers._glProgramUniform4d_fnptr(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4dv</c>]</b><br/>  </summary>
        public static void ProgramUniform4dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform4dv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3) => GLPointers._glProgramUniform4f_fnptr(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform4fv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3) => GLPointers._glProgramUniform4i_fnptr(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform4iv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4ui(int program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glProgramUniform4ui_fnptr(program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform4uiv_fnptr(program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2dv</c>]</b><br/>  </summary>
        public static void ProgramUniformMatrix2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3dv</c>]</b><br/>  </summary>
        public static void ProgramUniformMatrix2x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4dv</c>]</b><br/>  </summary>
        public static void ProgramUniformMatrix2x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3dv</c>]</b><br/>  </summary>
        public static void ProgramUniformMatrix3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2dv</c>]</b><br/>  </summary>
        public static void ProgramUniformMatrix3x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4dv</c>]</b><br/>  </summary>
        public static void ProgramUniformMatrix3x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4dv</c>]</b><br/>  </summary>
        public static void ProgramUniformMatrix4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2dv</c>]</b><br/>  </summary>
        public static void ProgramUniformMatrix4x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3dv</c>]</b><br/>  </summary>
        public static void ProgramUniformMatrix4x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex]</b> <b>[entry point: <c>glProvokingVertex</c>]</b><br/> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
        /// <param name="provokeMode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml" /></remarks>
        public static void ProvokingVertex(VertexProvokingMode mode) => GLPointers._glProvokingVertex_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPushAttrib</c>]</b><br/> Push and pop the server attribute stack. </summary>
        /// <param name="mask"> Specifies a mask that indicates which attributes to save. Values for mask are listed below. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushAttrib.xml" /></remarks>
        public static void PushAttrib(AttribMask mask) => GLPointers._glPushAttrib_fnptr((uint)mask);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPushClientAttrib</c>]</b><br/> Push and pop the client attribute stack. </summary>
        /// <param name="mask"> Specifies a mask that indicates which attributes to save. Values for mask are listed below. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushClientAttrib.xml" /></remarks>
        public static void PushClientAttrib(ClientAttribMask mask) => GLPointers._glPushClientAttrib_fnptr((uint)mask);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glPushDebugGroup</c>]</b><br/> Push a named debug group into the command stream. </summary>
        /// <param name="source"> The source of the debug message. </param>
        /// <param name="id"> The identifier of the message. </param>
        /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
        /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml" /></remarks>
        public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => GLPointers._glPushDebugGroup_fnptr((uint)source, id, length, message);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPushMatrix</c>]</b><br/> Push and pop the current matrix stack. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushMatrix.xml" /></remarks>
        public static void PushMatrix() => GLPointers._glPushMatrix_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glPushName</c>]</b><br/> Push and pop the name stack. </summary>
        /// <param name="name"> Specifies a name that will be pushed onto the name stack. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glPushName.xml" /></remarks>
        public static void PushName(uint name) => GLPointers._glPushName_fnptr(name);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glQueryCounter</c>]</b><br/> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
        /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
        /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml" /></remarks>
        public static void QueryCounter(int id, QueryCounterTarget target) => GLPointers._glQueryCounter_fnptr(id, (uint)target);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos2d</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2d(double x, double y) => GLPointers._glRasterPos2d_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos2dv</c>]</b><br/>  </summary>
        public static void RasterPos2dv(double* v) => GLPointers._glRasterPos2dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos2f</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2f(float x, float y) => GLPointers._glRasterPos2f_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos2fv</c>]</b><br/>  </summary>
        public static void RasterPos2fv(float* v) => GLPointers._glRasterPos2fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos2i</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2i(int x, int y) => GLPointers._glRasterPos2i_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos2iv</c>]</b><br/>  </summary>
        public static void RasterPos2iv(int* v) => GLPointers._glRasterPos2iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos2s</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos2s(short x, short y) => GLPointers._glRasterPos2s_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos2sv</c>]</b><br/>  </summary>
        public static void RasterPos2sv(short* v) => GLPointers._glRasterPos2sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos3d</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3d(double x, double y, double z) => GLPointers._glRasterPos3d_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos3dv</c>]</b><br/>  </summary>
        public static void RasterPos3dv(double* v) => GLPointers._glRasterPos3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos3f</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3f(float x, float y, float z) => GLPointers._glRasterPos3f_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos3fv</c>]</b><br/>  </summary>
        public static void RasterPos3fv(float* v) => GLPointers._glRasterPos3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos3i</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3i(int x, int y, int z) => GLPointers._glRasterPos3i_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos3iv</c>]</b><br/>  </summary>
        public static void RasterPos3iv(int* v) => GLPointers._glRasterPos3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos3s</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos3s(short x, short y, short z) => GLPointers._glRasterPos3s_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos3sv</c>]</b><br/>  </summary>
        public static void RasterPos3sv(short* v) => GLPointers._glRasterPos3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos4d</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4d(double x, double y, double z, double w) => GLPointers._glRasterPos4d_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos4dv</c>]</b><br/>  </summary>
        public static void RasterPos4dv(double* v) => GLPointers._glRasterPos4dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos4f</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4f(float x, float y, float z, float w) => GLPointers._glRasterPos4f_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos4fv</c>]</b><br/>  </summary>
        public static void RasterPos4fv(float* v) => GLPointers._glRasterPos4fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos4i</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4i(int x, int y, int z, int w) => GLPointers._glRasterPos4i_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos4iv</c>]</b><br/>  </summary>
        public static void RasterPos4iv(int* v) => GLPointers._glRasterPos4iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos4s</c>]</b><br/> Specify the raster position for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="y"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="z"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <param name="w"> Specify the x, y, z, and w object coordinates (if present) for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRasterPos.xml" /></remarks>
        public static void RasterPos4s(short x, short y, short z, short w) => GLPointers._glRasterPos4s_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRasterPos4sv</c>]</b><br/>  </summary>
        public static void RasterPos4sv(short* v) => GLPointers._glRasterPos4sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glReadBuffer</c>]</b><br/> Select a color buffer source for pixels. </summary>
        /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
        public static void ReadBuffer(ReadBufferMode src) => GLPointers._glReadBuffer_fnptr((uint)src);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glReadnPixels</c>]</b><br/> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
        /// <param name="data">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
        public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._glReadnPixels_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glReadPixels</c>]</b><br/> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="data">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
        public static void ReadPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glReadPixels_fnptr(x, y, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRectd</c>]</b><br/> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Rectd(double x1, double y1, double x2, double y2) => GLPointers._glRectd_fnptr(x1, y1, x2, y2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRectdv</c>]</b><br/>  </summary>
        public static void Rectdv(double* v1, double* v2) => GLPointers._glRectdv_fnptr(v1, v2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRectf</c>]</b><br/> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Rectf(float x1, float y1, float x2, float y2) => GLPointers._glRectf_fnptr(x1, y1, x2, y2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRectfv</c>]</b><br/>  </summary>
        public static void Rectfv(float* v1, float* v2) => GLPointers._glRectfv_fnptr(v1, v2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRecti</c>]</b><br/> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Recti(int x1, int y1, int x2, int y2) => GLPointers._glRecti_fnptr(x1, y1, x2, y2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRectiv</c>]</b><br/>  </summary>
        public static void Rectiv(int* v1, int* v2) => GLPointers._glRectiv_fnptr(v1, v2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRects</c>]</b><br/> Draw a rectangle. </summary>
        /// <param name="x1"> Specify one vertex of a rectangle. </param>
        /// <param name="y1"> Specify one vertex of a rectangle. </param>
        /// <param name="x2"> Specify the opposite vertex of the rectangle. </param>
        /// <param name="y2"> Specify the opposite vertex of the rectangle. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRect.xml" /></remarks>
        public static void Rects(short x1, short y1, short x2, short y2) => GLPointers._glRects_fnptr(x1, y1, x2, y2);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRectsv</c>]</b><br/>  </summary>
        public static void Rectsv(short* v1, short* v2) => GLPointers._glRectsv_fnptr(v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glReleaseShaderCompiler</c>]</b><br/> Release resources consumed by the implementation&apos;s shader compiler. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml" /></remarks>
        public static void ReleaseShaderCompiler() => GLPointers._glReleaseShaderCompiler_fnptr();
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorage</c>]</b><br/> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
        public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorage_fnptr((uint)target, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorageMultisample</c>]</b><br/> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
        public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRenderMode</c>]</b><br/> Set rasterization mode. </summary>
        /// <param name="mode"> Specifies the rasterization mode. Three values are accepted: GL_RENDER, GL_SELECT, and GL_FEEDBACK. The initial value is GL_RENDER. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRenderMode.xml" /></remarks>
        public static int RenderMode(RenderingMode mode) => GLPointers._glRenderMode_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glResumeTransformFeedback</c>]</b><br/> Resume transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml" /></remarks>
        public static void ResumeTransformFeedback() => GLPointers._glResumeTransformFeedback_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRotated</c>]</b><br/> Multiply the current matrix by a rotation matrix. </summary>
        /// <param name="angle"> Specifies the angle of rotation, in degrees. </param>
        /// <param name="x"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml" /></remarks>
        public static void Rotated(double angle, double x, double y, double z) => GLPointers._glRotated_fnptr(angle, x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glRotatef</c>]</b><br/> Multiply the current matrix by a rotation matrix. </summary>
        /// <param name="angle"> Specifies the angle of rotation, in degrees. </param>
        /// <param name="x"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a vector, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml" /></remarks>
        public static void Rotatef(float angle, float x, float y, float z) => GLPointers._glRotatef_fnptr(angle, x, y, z);
        
        /// <summary> <b>[requires: v1.3]</b> <b>[entry point: <c>glSampleCoverage</c>]</b><br/> Specify multisample coverage parameters. </summary>
        /// <param name="value"> Specify a single floating-point sample coverage value. The value is clamped to the range 0 1 . The initial value is 1.0. </param>
        /// <param name="invert"> Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleCoverage.xhtml" /></remarks>
        public static void SampleCoverage(float value, bool invert) => GLPointers._glSampleCoverage_fnptr(value, (byte)(invert ? 1 : 0));
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glSampleMaski</c>]</b><br/> Set the value of a sub-word of the sample mask. </summary>
        /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
        /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml" /></remarks>
        public static void SampleMaski(uint maskNumber, uint mask) => GLPointers._glSampleMaski_fnptr(maskNumber, mask);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterf</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterf(int sampler, SamplerParameterF pname, float param) => GLPointers._glSamplerParameterf_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterfv</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterfv(int sampler, SamplerParameterF pname, float* param) => GLPointers._glSamplerParameterfv_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameteri</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameteri(int sampler, SamplerParameterI pname, int param) => GLPointers._glSamplerParameteri_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterIiv</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterIiv(int sampler, SamplerParameterI pname, int* param) => GLPointers._glSamplerParameterIiv_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterIuiv</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* param) => GLPointers._glSamplerParameterIuiv_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameteriv</c>]</b><br/> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameteriv(int sampler, SamplerParameterI pname, int* param) => GLPointers._glSamplerParameteriv_fnptr(sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glScaled</c>]</b><br/> Multiply the current matrix by a general scaling matrix. </summary>
        /// <param name="x"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="y"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="z"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glScale.xml" /></remarks>
        public static void Scaled(double x, double y, double z) => GLPointers._glScaled_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glScalef</c>]</b><br/> Multiply the current matrix by a general scaling matrix. </summary>
        /// <param name="x"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="y"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <param name="z"> Specify scale factors along the x, y, and z axes, respectively. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glScale.xml" /></remarks>
        public static void Scalef(float x, float y, float z) => GLPointers._glScalef_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glScissor</c>]</b><br/> Define the scissor box. </summary>
        /// <param name="x"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="y"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="width"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissor.xhtml" /></remarks>
        public static void Scissor(int x, int y, int width, int height) => GLPointers._glScissor_fnptr(x, y, width, height);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorArrayv</c>]</b><br/> Define the scissor box for multiple viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
        /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
        /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml" /></remarks>
        public static void ScissorArrayv(uint first, int count, int* v) => GLPointers._glScissorArrayv_fnptr(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorIndexed</c>]</b><br/> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
        public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => GLPointers._glScissorIndexed_fnptr(index, left, bottom, width, height);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorIndexedv</c>]</b><br/> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
        public static void ScissorIndexedv(uint index, int* v) => GLPointers._glScissorIndexedv_fnptr(index, v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3b</c>]</b><br/> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3b(sbyte red, sbyte green, sbyte blue) => GLPointers._glSecondaryColor3b_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3bv</c>]</b><br/>  </summary>
        public static void SecondaryColor3bv(sbyte* v) => GLPointers._glSecondaryColor3bv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3d</c>]</b><br/> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3d(double red, double green, double blue) => GLPointers._glSecondaryColor3d_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3dv</c>]</b><br/>  </summary>
        public static void SecondaryColor3dv(double* v) => GLPointers._glSecondaryColor3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3f</c>]</b><br/> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3f(float red, float green, float blue) => GLPointers._glSecondaryColor3f_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3fv</c>]</b><br/>  </summary>
        public static void SecondaryColor3fv(float* v) => GLPointers._glSecondaryColor3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3i</c>]</b><br/> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3i(int red, int green, int blue) => GLPointers._glSecondaryColor3i_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3iv</c>]</b><br/>  </summary>
        public static void SecondaryColor3iv(int* v) => GLPointers._glSecondaryColor3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3s</c>]</b><br/> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3s(short red, short green, short blue) => GLPointers._glSecondaryColor3s_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3sv</c>]</b><br/>  </summary>
        public static void SecondaryColor3sv(short* v) => GLPointers._glSecondaryColor3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3ub</c>]</b><br/> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3ub(byte red, byte green, byte blue) => GLPointers._glSecondaryColor3ub_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3ubv</c>]</b><br/>  </summary>
        public static void SecondaryColor3ubv(byte* v) => GLPointers._glSecondaryColor3ubv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3ui</c>]</b><br/> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3ui(uint red, uint green, uint blue) => GLPointers._glSecondaryColor3ui_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3uiv</c>]</b><br/>  </summary>
        public static void SecondaryColor3uiv(uint* v) => GLPointers._glSecondaryColor3uiv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3us</c>]</b><br/> Set the current secondary color. </summary>
        /// <param name="red"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="green"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <param name="blue"> Specify new red, green, and blue values for the current secondary color. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColor.xml" /></remarks>
        public static void SecondaryColor3us(ushort red, ushort green, ushort blue) => GLPointers._glSecondaryColor3us_fnptr(red, green, blue);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColor3usv</c>]</b><br/>  </summary>
        public static void SecondaryColor3usv(ushort* v) => GLPointers._glSecondaryColor3usv_fnptr(v);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glSecondaryColorP3ui</c>]</b><br/>  </summary>
        public static void SecondaryColorP3ui(ColorPointerType type, uint color) => GLPointers._glSecondaryColorP3ui_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glSecondaryColorP3uiv</c>]</b><br/>  </summary>
        public static void SecondaryColorP3uiv(ColorPointerType type, uint* color) => GLPointers._glSecondaryColorP3uiv_fnptr((uint)type, color);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSecondaryColorPointer</c>]</b><br/> Define an array of secondary colors. </summary>
        /// <param name="size"> Specifies the number of components per color. Must be 3. </param>
        /// <param name="type"> Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first component of the first color element in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSecondaryColorPointer.xml" /></remarks>
        public static void SecondaryColorPointer(int size, ColorPointerType type, int stride, void* pointer) => GLPointers._glSecondaryColorPointer_fnptr(size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glSelectBuffer</c>]</b><br/> Establish a buffer for selection mode values. </summary>
        /// <param name="size"> Specifies the size of buffer. </param>
        /// <param name="buffer"> Returns the selection data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSelectBuffer.xml" /></remarks>
        public static void SelectBuffer(int size, uint* buffer) => GLPointers._glSelectBuffer_fnptr(size, buffer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glShadeModel</c>]</b><br/> Select flat or smooth shading. </summary>
        /// <param name="mode"> Specifies a symbolic value representing a shading technique. Accepted values are GL_FLAT and GL_SMOOTH. The initial value is GL_SMOOTH. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glShadeModel.xml" /></remarks>
        public static void ShadeModel(ShadingModel mode) => GLPointers._glShadeModel_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glShaderBinary</c>]</b><br/> Load pre-compiled shader binaries. </summary>
        /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
        /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
        /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
        /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
        /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml" /></remarks>
        public static void ShaderBinary(int count, int* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => GLPointers._glShaderBinary_fnptr(count, shaders, (uint)binaryFormat, binary, length);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glShaderSource</c>]</b><br/> Replaces the source code in a shader object. </summary>
        /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the string and length arrays.</param>
        /// <param name="str">Specifies an array of pointers to strings containing the source code to be loaded into the shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderSource.xhtml" /></remarks>
        public static void ShaderSource(int shader, int count, byte** str, int* length) => GLPointers._glShaderSource_fnptr(shader, count, str, length);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object]</b> <b>[entry point: <c>glShaderStorageBlockBinding</c>]</b><br/> Change an active shader storage block binding. </summary>
        /// <param name="program"> The name of the program containing the block whose binding to change. </param>
        /// <param name="storageBlockIndex"> The index storage block within the program. </param>
        /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml" /></remarks>
        public static void ShaderStorageBlockBinding(int program, uint storageBlockIndex, uint storageBlockBinding) => GLPointers._glShaderStorageBlockBinding_fnptr(program, storageBlockIndex, storageBlockBinding);
        
        /// <summary> <b>[requires: v4.6]</b> <b>[entry point: <c>glSpecializeShader</c>]</b><br/>  </summary>
        public static void SpecializeShader(int shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => GLPointers._glSpecializeShader_fnptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glStencilFunc</c>]</b><br/> Set front and back function and reference value for stencil testing. </summary>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml" /></remarks>
        public static void StencilFunc(StencilFunction func, int reference, uint mask) => GLPointers._glStencilFunc_fnptr((uint)func, reference, mask);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glStencilFuncSeparate</c>]</b><br/> Set front and/or back function and reference value for stencil testing. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFuncSeparate.xhtml" /></remarks>
        public static void StencilFuncSeparate(TriangleFace face, StencilFunction func, int reference, uint mask) => GLPointers._glStencilFuncSeparate_fnptr((uint)face, (uint)func, reference, mask);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glStencilMask</c>]</b><br/> Control the front and back writing of individual bits in the stencil planes. </summary>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMask.xhtml" /></remarks>
        public static void StencilMask(uint mask) => GLPointers._glStencilMask_fnptr(mask);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glStencilMaskSeparate</c>]</b><br/> Control the front and/or back writing of individual bits in the stencil planes. </summary>
        /// <param name="face"> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1&apos;s. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMaskSeparate.xhtml" /></remarks>
        public static void StencilMaskSeparate(TriangleFace face, uint mask) => GLPointers._glStencilMaskSeparate_fnptr((uint)face, mask);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glStencilOp</c>]</b><br/> Set front and back stencil test actions. </summary>
        /// <param name="sfail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="dpfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="dppass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOp.xhtml" /></remarks>
        public static void StencilOp(StencilOp fail, StencilOp zfail, StencilOp zpass) => GLPointers._glStencilOp_fnptr((uint)fail, (uint)zfail, (uint)zpass);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glStencilOpSeparate</c>]</b><br/> Set front and/or back stencil test actions. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="sfail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="dpfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="dppass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOpSeparate.xhtml" /></remarks>
        public static void StencilOpSeparate(TriangleFace face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => GLPointers._glStencilOpSeparate_fnptr((uint)face, (uint)sfail, (uint)dpfail, (uint)dppass);
        
        /// <summary> <b>[requires: v3.1]</b> <b>[entry point: <c>glTexBuffer</c>]</b><br/> Attach a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
        public static void TexBuffer(TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers._glTexBuffer_fnptr((uint)target, (uint)internalformat, buffer);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range]</b> <b>[entry point: <c>glTexBufferRange</c>]</b><br/> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
        public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTexBufferRange_fnptr((uint)target, (uint)internalformat, buffer, offset, size);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord1d</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1d(double s) => GLPointers._glTexCoord1d_fnptr(s);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord1dv</c>]</b><br/>  </summary>
        public static void TexCoord1dv(double* v) => GLPointers._glTexCoord1dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord1f</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1f(float s) => GLPointers._glTexCoord1f_fnptr(s);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord1fv</c>]</b><br/>  </summary>
        public static void TexCoord1fv(float* v) => GLPointers._glTexCoord1fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord1i</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1i(int s) => GLPointers._glTexCoord1i_fnptr(s);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord1iv</c>]</b><br/>  </summary>
        public static void TexCoord1iv(int* v) => GLPointers._glTexCoord1iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord1s</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord1s(short s) => GLPointers._glTexCoord1s_fnptr(s);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord1sv</c>]</b><br/>  </summary>
        public static void TexCoord1sv(short* v) => GLPointers._glTexCoord1sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord2d</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2d(double s, double t) => GLPointers._glTexCoord2d_fnptr(s, t);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord2dv</c>]</b><br/>  </summary>
        public static void TexCoord2dv(double* v) => GLPointers._glTexCoord2dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord2f</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2f(float s, float t) => GLPointers._glTexCoord2f_fnptr(s, t);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord2fv</c>]</b><br/>  </summary>
        public static void TexCoord2fv(float* v) => GLPointers._glTexCoord2fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord2i</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2i(int s, int t) => GLPointers._glTexCoord2i_fnptr(s, t);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord2iv</c>]</b><br/>  </summary>
        public static void TexCoord2iv(int* v) => GLPointers._glTexCoord2iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord2s</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord2s(short s, short t) => GLPointers._glTexCoord2s_fnptr(s, t);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord2sv</c>]</b><br/>  </summary>
        public static void TexCoord2sv(short* v) => GLPointers._glTexCoord2sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord3d</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3d(double s, double t, double r) => GLPointers._glTexCoord3d_fnptr(s, t, r);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord3dv</c>]</b><br/>  </summary>
        public static void TexCoord3dv(double* v) => GLPointers._glTexCoord3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord3f</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3f(float s, float t, float r) => GLPointers._glTexCoord3f_fnptr(s, t, r);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord3fv</c>]</b><br/>  </summary>
        public static void TexCoord3fv(float* v) => GLPointers._glTexCoord3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord3i</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3i(int s, int t, int r) => GLPointers._glTexCoord3i_fnptr(s, t, r);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord3iv</c>]</b><br/>  </summary>
        public static void TexCoord3iv(int* v) => GLPointers._glTexCoord3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord3s</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord3s(short s, short t, short r) => GLPointers._glTexCoord3s_fnptr(s, t, r);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord3sv</c>]</b><br/>  </summary>
        public static void TexCoord3sv(short* v) => GLPointers._glTexCoord3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord4d</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4d(double s, double t, double r, double q) => GLPointers._glTexCoord4d_fnptr(s, t, r, q);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord4dv</c>]</b><br/>  </summary>
        public static void TexCoord4dv(double* v) => GLPointers._glTexCoord4dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord4f</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4f(float s, float t, float r, float q) => GLPointers._glTexCoord4f_fnptr(s, t, r, q);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord4fv</c>]</b><br/>  </summary>
        public static void TexCoord4fv(float* v) => GLPointers._glTexCoord4fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord4i</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4i(int s, int t, int r, int q) => GLPointers._glTexCoord4i_fnptr(s, t, r, q);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord4iv</c>]</b><br/>  </summary>
        public static void TexCoord4iv(int* v) => GLPointers._glTexCoord4iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord4s</c>]</b><br/> Set the current texture coordinates. </summary>
        /// <param name="s"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="t"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="r"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <param name="q"> Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoord.xml" /></remarks>
        public static void TexCoord4s(short s, short t, short r, short q) => GLPointers._glTexCoord4s_fnptr(s, t, r, q);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoord4sv</c>]</b><br/>  </summary>
        public static void TexCoord4sv(short* v) => GLPointers._glTexCoord4sv_fnptr(v);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP1ui</c>]</b><br/>  </summary>
        public static void TexCoordP1ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP1ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP1uiv</c>]</b><br/>  </summary>
        public static void TexCoordP1uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP1uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP2ui</c>]</b><br/>  </summary>
        public static void TexCoordP2ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP2ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP2uiv</c>]</b><br/>  </summary>
        public static void TexCoordP2uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP2uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP3ui</c>]</b><br/>  </summary>
        public static void TexCoordP3ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP3ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP3uiv</c>]</b><br/>  </summary>
        public static void TexCoordP3uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP3uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP4ui</c>]</b><br/>  </summary>
        public static void TexCoordP4ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP4ui_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP4uiv</c>]</b><br/>  </summary>
        public static void TexCoordP4uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP4uiv_fnptr((uint)type, coords);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexCoordPointer</c>]</b><br/> Define an array of texture coordinates. </summary>
        /// <param name="size"> Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4. </param>
        /// <param name="type"> Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexCoordPointer.xml" /></remarks>
        public static void TexCoordPointer(int size, TexCoordPointerType type, int stride, void* pointer) => GLPointers._glTexCoordPointer_fnptr(size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexEnvf</c>]</b><br/> Set texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="param"> Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml" /></remarks>
        public static void TexEnvf(TextureEnvTarget target, TextureEnvParameter pname, float param) => GLPointers._glTexEnvf_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexEnvfv</c>]</b><br/>  </summary>
        public static void TexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._glTexEnvfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexEnvi</c>]</b><br/> Set texture environment parameters. </summary>
        /// <param name="target"> Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE. </param>
        /// <param name="pname"> Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE. </param>
        /// <param name="param"> Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml" /></remarks>
        public static void TexEnvi(TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers._glTexEnvi_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexEnviv</c>]</b><br/>  </summary>
        public static void TexEnviv(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glTexEnviv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexGend</c>]</b><br/> Control the generation of texture coordinates. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE. </param>
        /// <param name="param"> Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexGen.xml" /></remarks>
        public static void TexGend(TextureCoordName coord, TextureGenParameter pname, double param) => GLPointers._glTexGend_fnptr((uint)coord, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexGendv</c>]</b><br/>  </summary>
        public static void TexGendv(TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._glTexGendv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexGenf</c>]</b><br/> Control the generation of texture coordinates. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE. </param>
        /// <param name="param"> Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexGen.xml" /></remarks>
        public static void TexGenf(TextureCoordName coord, TextureGenParameter pname, float param) => GLPointers._glTexGenf_fnptr((uint)coord, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexGenfv</c>]</b><br/>  </summary>
        public static void TexGenfv(TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._glTexGenfv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexGeni</c>]</b><br/> Control the generation of texture coordinates. </summary>
        /// <param name="coord"> Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q. </param>
        /// <param name="pname"> Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE. </param>
        /// <param name="param"> Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexGen.xml" /></remarks>
        public static void TexGeni(TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers._glTexGeni_fnptr((uint)coord, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTexGeniv</c>]</b><br/>  </summary>
        public static void TexGeniv(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glTexGeniv_fnptr((uint)coord, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexImage1D</c>]</b><br/> Specify a one-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage1D.xhtml" /></remarks>
        public static void TexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage1D_fnptr((uint)target, level, (int)internalformat, width, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexImage2D</c>]</b><br/> Specify a two-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml" /></remarks>
        public static void TexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage2D_fnptr((uint)target, level, (int)internalformat, width, height, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glTexImage2DMultisample</c>]</b><br/> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
        /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml" /></remarks>
        public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTexImage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v1.2]</b> <b>[entry point: <c>glTexImage3D</c>]</b><br/> Specify a three-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3D.xhtml" /></remarks>
        public static void TexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage3D_fnptr((uint)target, level, (int)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glTexImage3DMultisample</c>]</b><br/> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
        /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
        /// <param name="depth">!!missing documentation!!</param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml" /></remarks>
        public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTexImage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexParameterf</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterf(TextureTarget target, TextureParameterName pname, float param) => GLPointers._glTexParameterf_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexParameterfv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterfv(TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers._glTexParameterfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexParameteri</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameteri(TextureTarget target, TextureParameterName pname, int param) => GLPointers._glTexParameteri_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glTexParameterIiv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterIiv(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTexParameterIiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glTexParameterIuiv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterIuiv(TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._glTexParameterIuiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glTexParameteriv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameteriv(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTexParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage1D</c>]</b><br/> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
        public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTexStorage1D_fnptr((uint)target, levels, (uint)internalformat, width);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage2D</c>]</b><br/> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
        public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTexStorage2D_fnptr((uint)target, levels, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> <b>[entry point: <c>glTexStorage2DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
        public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTexStorage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage3D</c>]</b><br/> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
        public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTexStorage3D_fnptr((uint)target, levels, (uint)internalformat, width, height, depth);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> <b>[entry point: <c>glTexStorage3DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
        public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTexStorage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glTexSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage1D. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
        public static void TexSubImage1D(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage1D_fnptr((uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[entry point: <c>glTexSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage2D. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
        public static void TexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage2D_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.2]</b> <b>[entry point: <c>glTexSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage3D. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
        public static void TexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage3D_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier]</b> <b>[entry point: <c>glTextureBarrier</c>]</b><br/> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml" /></remarks>
        public static void TextureBarrier() => GLPointers._glTextureBarrier_fnptr();
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureBuffer</c>]</b><br/> Attach a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
        public static void TextureBuffer(int texture, SizedInternalFormat internalformat, int buffer) => GLPointers._glTextureBuffer_fnptr(texture, (uint)internalformat, buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureBufferRange</c>]</b><br/> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
        public static void TextureBufferRange(int texture, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTextureBufferRange_fnptr(texture, (uint)internalformat, buffer, offset, size);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterf</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterf(int texture, TextureParameterName pname, float param) => GLPointers._glTextureParameterf_fnptr(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterfv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterfv(int texture, TextureParameterName pname, float* param) => GLPointers._glTextureParameterfv_fnptr(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameteri</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameteri(int texture, TextureParameterName pname, int param) => GLPointers._glTextureParameteri_fnptr(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIiv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterIiv(int texture, TextureParameterName pname, int* parameters) => GLPointers._glTextureParameterIiv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIuiv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterIuiv(int texture, TextureParameterName pname, uint* parameters) => GLPointers._glTextureParameterIuiv_fnptr(texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameteriv</c>]</b><br/> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameteriv(int texture, TextureParameterName pname, int* param) => GLPointers._glTextureParameteriv_fnptr(texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage1D</c>]</b><br/> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
        public static void TextureStorage1D(int texture, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTextureStorage1D_fnptr(texture, levels, (uint)internalformat, width);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2D</c>]</b><br/> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
        public static void TextureStorage2D(int texture, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTextureStorage2D_fnptr(texture, levels, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
        public static void TextureStorage2DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTextureStorage2DMultisample_fnptr(texture, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3D</c>]</b><br/> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
        public static void TextureStorage3D(int texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTextureStorage3D_fnptr(texture, levels, (uint)internalformat, width, height, depth);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
        public static void TextureStorage3DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTextureStorage3DMultisample_fnptr(texture, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
        public static void TextureSubImage1D(int texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage1D_fnptr(texture, level, xoffset, width, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
        public static void TextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
        public static void TextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view]</b> <b>[entry point: <c>glTextureView</c>]</b><br/> Initialize a texture as a data alias of another texture&apos;s data store. </summary>
        /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
        /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
        /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
        /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
        /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
        /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
        /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
        /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml" /></remarks>
        public static void TextureView(int texture, TextureTarget target, int origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => GLPointers._glTextureView_fnptr(texture, (uint)target, origtexture, (uint)internalformat, minlevel, numlevels, minlayer, numlayers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTransformFeedbackBufferBase</c>]</b><br/> Bind a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml" /></remarks>
        public static void TransformFeedbackBufferBase(int xfb, uint index, int buffer) => GLPointers._glTransformFeedbackBufferBase_fnptr(xfb, index, buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTransformFeedbackBufferRange</c>]</b><br/> Bind a range within a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
        /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml" /></remarks>
        public static void TransformFeedbackBufferRange(int xfb, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glTransformFeedbackBufferRange_fnptr(xfb, index, buffer, offset, size);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glTransformFeedbackVaryings</c>]</b><br/> Specify values to record in transform feedback buffers. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="count"> The number of varying variables used for transform feedback. </param>
        /// <param name="varyings"> An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback. </param>
        /// <param name="bufferMode"> Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackVaryings.xhtml" /></remarks>
        public static void TransformFeedbackVaryings(int program, int count, byte** varyings, TransformFeedbackBufferMode bufferMode) => GLPointers._glTransformFeedbackVaryings_fnptr(program, count, varyings, (uint)bufferMode);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTranslated</c>]</b><br/> Multiply the current matrix by a translation matrix. </summary>
        /// <param name="x"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTranslate.xml" /></remarks>
        public static void Translated(double x, double y, double z) => GLPointers._glTranslated_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glTranslatef</c>]</b><br/> Multiply the current matrix by a translation matrix. </summary>
        /// <param name="x"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="y"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <param name="z"> Specify the x, y, and z coordinates of a translation vector. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTranslate.xml" /></remarks>
        public static void Translatef(float x, float y, float z) => GLPointers._glTranslatef_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform1d</c>]</b><br/>  </summary>
        public static void Uniform1d(int location, double x) => GLPointers._glUniform1d_fnptr(location, x);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform1dv</c>]</b><br/>  </summary>
        public static void Uniform1dv(int location, int count, double* value) => GLPointers._glUniform1dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform1f</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1f(int location, float v0) => GLPointers._glUniform1f_fnptr(location, v0);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform1fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1fv(int location, int count, float* value) => GLPointers._glUniform1fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform1i</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1i(int location, int v0) => GLPointers._glUniform1i_fnptr(location, v0);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform1iv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1iv(int location, int count, int* value) => GLPointers._glUniform1iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform1ui</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1ui(int location, uint v0) => GLPointers._glUniform1ui_fnptr(location, v0);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform1uiv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1uiv(int location, int count, uint* value) => GLPointers._glUniform1uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform2d</c>]</b><br/>  </summary>
        public static void Uniform2d(int location, double x, double y) => GLPointers._glUniform2d_fnptr(location, x, y);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform2dv</c>]</b><br/>  </summary>
        public static void Uniform2dv(int location, int count, double* value) => GLPointers._glUniform2dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform2f</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2f(int location, float v0, float v1) => GLPointers._glUniform2f_fnptr(location, v0, v1);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform2fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2fv(int location, int count, float* value) => GLPointers._glUniform2fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform2i</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2i(int location, int v0, int v1) => GLPointers._glUniform2i_fnptr(location, v0, v1);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform2iv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2iv(int location, int count, int* value) => GLPointers._glUniform2iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform2ui</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2ui(int location, uint v0, uint v1) => GLPointers._glUniform2ui_fnptr(location, v0, v1);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform2uiv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2uiv(int location, int count, uint* value) => GLPointers._glUniform2uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform3d</c>]</b><br/>  </summary>
        public static void Uniform3d(int location, double x, double y, double z) => GLPointers._glUniform3d_fnptr(location, x, y, z);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform3dv</c>]</b><br/>  </summary>
        public static void Uniform3dv(int location, int count, double* value) => GLPointers._glUniform3dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform3f</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3f(int location, float v0, float v1, float v2) => GLPointers._glUniform3f_fnptr(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform3fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3fv(int location, int count, float* value) => GLPointers._glUniform3fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform3i</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3i(int location, int v0, int v1, int v2) => GLPointers._glUniform3i_fnptr(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform3iv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3iv(int location, int count, int* value) => GLPointers._glUniform3iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform3ui</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3ui(int location, uint v0, uint v1, uint v2) => GLPointers._glUniform3ui_fnptr(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform3uiv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3uiv(int location, int count, uint* value) => GLPointers._glUniform3uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform4d</c>]</b><br/>  </summary>
        public static void Uniform4d(int location, double x, double y, double z, double w) => GLPointers._glUniform4d_fnptr(location, x, y, z, w);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform4dv</c>]</b><br/>  </summary>
        public static void Uniform4dv(int location, int count, double* value) => GLPointers._glUniform4dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform4f</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4f(int location, float v0, float v1, float v2, float v3) => GLPointers._glUniform4f_fnptr(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform4fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4fv(int location, int count, float* value) => GLPointers._glUniform4fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform4i</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4i(int location, int v0, int v1, int v2, int v3) => GLPointers._glUniform4i_fnptr(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniform4iv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4iv(int location, int count, int* value) => GLPointers._glUniform4iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform4ui</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glUniform4ui_fnptr(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glUniform4uiv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4uiv(int location, int count, uint* value) => GLPointers._glUniform4uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glUniformBlockBinding</c>]</b><br/> Assign a binding point to an active uniform block. </summary>
        /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
        /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
        /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml" /></remarks>
        public static void UniformBlockBinding(int program, uint uniformBlockIndex, uint uniformBlockBinding) => GLPointers._glUniformBlockBinding_fnptr(program, uniformBlockIndex, uniformBlockBinding);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2dv</c>]</b><br/>  </summary>
        public static void UniformMatrix2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniformMatrix2fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix2fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2x3dv</c>]</b><br/>  </summary>
        public static void UniformMatrix2x3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix2x3fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2x3fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix2x3fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2x4dv</c>]</b><br/>  </summary>
        public static void UniformMatrix2x4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix2x4fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2x4fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix2x4fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3dv</c>]</b><br/>  </summary>
        public static void UniformMatrix3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniformMatrix3fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix3fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3x2dv</c>]</b><br/>  </summary>
        public static void UniformMatrix3x2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix3x2fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3x2fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix3x2fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3x4dv</c>]</b><br/>  </summary>
        public static void UniformMatrix3x4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix3x4fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3x4fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix3x4fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4dv</c>]</b><br/>  </summary>
        public static void UniformMatrix4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUniformMatrix4fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix4fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4x2dv</c>]</b><br/>  </summary>
        public static void UniformMatrix4x2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix4x2fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4x2fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix4x2fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4x3dv</c>]</b><br/>  </summary>
        public static void UniformMatrix4x3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> <b>[entry point: <c>glUniformMatrix4x3fv</c>]</b><br/> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4x3fv(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix4x3fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glUniformSubroutinesuiv</c>]</b><br/> Load active subroutine uniforms. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
        /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml" /></remarks>
        public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => GLPointers._glUniformSubroutinesuiv_fnptr((uint)shadertype, count, indices);
        
        /// <summary> <b>[requires: v1.5]</b> <b>[entry point: <c>glUnmapBuffer</c>]</b><br/> Release the mapping of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glUnmapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
        public static bool UnmapBuffer(BufferTargetARB target) => GLPointers._glUnmapBuffer_fnptr((uint)target) != 0;
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glUnmapNamedBuffer</c>]</b><br/> Release the mapping of a buffer object&apos;s data store into the client&apos;s address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
        public static bool UnmapNamedBuffer(int buffer) => GLPointers._glUnmapNamedBuffer_fnptr(buffer) != 0;
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glUseProgram</c>]</b><br/> Installs a program object as part of current rendering state. </summary>
        /// <param name="program">Specifies the handle of the program object whose executables are to be used as part of current rendering state.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgram.xhtml" /></remarks>
        public static void UseProgram(int program) => GLPointers._glUseProgram_fnptr(program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glUseProgramStages</c>]</b><br/> Bind stages of a program object to a program pipeline. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
        /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
        /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml" /></remarks>
        public static void UseProgramStages(int pipeline, UseProgramStageMask stages, int program) => GLPointers._glUseProgramStages_fnptr(pipeline, (uint)stages, program);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glValidateProgram</c>]</b><br/> Validates a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be validated.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgram.xhtml" /></remarks>
        public static void ValidateProgram(int program) => GLPointers._glValidateProgram_fnptr(program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glValidateProgramPipeline</c>]</b><br/> Validate a program pipeline object against current GL state. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml" /></remarks>
        public static void ValidateProgramPipeline(int pipeline) => GLPointers._glValidateProgramPipeline_fnptr(pipeline);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex2d</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2d(double x, double y) => GLPointers._glVertex2d_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex2dv</c>]</b><br/>  </summary>
        public static void Vertex2dv(double* v) => GLPointers._glVertex2dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex2f</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2f(float x, float y) => GLPointers._glVertex2f_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex2fv</c>]</b><br/>  </summary>
        public static void Vertex2fv(float* v) => GLPointers._glVertex2fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex2i</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2i(int x, int y) => GLPointers._glVertex2i_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex2iv</c>]</b><br/>  </summary>
        public static void Vertex2iv(int* v) => GLPointers._glVertex2iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex2s</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex2s(short x, short y) => GLPointers._glVertex2s_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex2sv</c>]</b><br/>  </summary>
        public static void Vertex2sv(short* v) => GLPointers._glVertex2sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex3d</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3d(double x, double y, double z) => GLPointers._glVertex3d_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex3dv</c>]</b><br/>  </summary>
        public static void Vertex3dv(double* v) => GLPointers._glVertex3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex3f</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3f(float x, float y, float z) => GLPointers._glVertex3f_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex3fv</c>]</b><br/>  </summary>
        public static void Vertex3fv(float* v) => GLPointers._glVertex3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex3i</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3i(int x, int y, int z) => GLPointers._glVertex3i_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex3iv</c>]</b><br/>  </summary>
        public static void Vertex3iv(int* v) => GLPointers._glVertex3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex3s</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex3s(short x, short y, short z) => GLPointers._glVertex3s_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex3sv</c>]</b><br/>  </summary>
        public static void Vertex3sv(short* v) => GLPointers._glVertex3sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex4d</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4d(double x, double y, double z, double w) => GLPointers._glVertex4d_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex4dv</c>]</b><br/>  </summary>
        public static void Vertex4dv(double* v) => GLPointers._glVertex4dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex4f</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4f(float x, float y, float z, float w) => GLPointers._glVertex4f_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex4fv</c>]</b><br/>  </summary>
        public static void Vertex4fv(float* v) => GLPointers._glVertex4fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex4i</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4i(int x, int y, int z, int w) => GLPointers._glVertex4i_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex4iv</c>]</b><br/>  </summary>
        public static void Vertex4iv(int* v) => GLPointers._glVertex4iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex4s</c>]</b><br/> Specify a vertex. </summary>
        /// <param name="x"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="y"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="z"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <param name="w"> Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertex.xml" /></remarks>
        public static void Vertex4s(short x, short y, short z, short w) => GLPointers._glVertex4s_fnptr(x, y, z, w);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertex4sv</c>]</b><br/>  </summary>
        public static void Vertex4sv(short* v) => GLPointers._glVertex4sv_fnptr(v);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribBinding</c>]</b><br/> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
        public static void VertexArrayAttribBinding(int vaobj, uint attribindex, uint bindingindex) => GLPointers._glVertexArrayAttribBinding_fnptr(vaobj, attribindex, bindingindex);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribFormat(int vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexArrayAttribFormat_fnptr(vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribIFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribIFormat(int vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexArrayAttribIFormat_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribLFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribLFormat(int vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexArrayAttribLFormat_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayBindingDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
        public static void VertexArrayBindingDivisor(int vaobj, uint bindingindex, uint divisor) => GLPointers._glVertexArrayBindingDivisor_fnptr(vaobj, bindingindex, divisor);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayElementBuffer</c>]</b><br/> Configures element array buffer binding of a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
        /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml" /></remarks>
        public static void VertexArrayElementBuffer(int vaobj, int buffer) => GLPointers._glVertexArrayElementBuffer_fnptr(vaobj, buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBuffer</c>]</b><br/> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
        public static void VertexArrayVertexBuffer(int vaobj, uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glVertexArrayVertexBuffer_fnptr(vaobj, bindingindex, buffer, offset, stride);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBuffers</c>]</b><br/> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
        public static void VertexArrayVertexBuffers(int vaobj, uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers._glVertexArrayVertexBuffers_fnptr(vaobj, first, count, buffers, offsets, strides);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1d(uint index, double x) => GLPointers._glVertexAttrib1d_fnptr(index, x);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1dv(uint index, double* v) => GLPointers._glVertexAttrib1dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1f</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1f(uint index, float x) => GLPointers._glVertexAttrib1f_fnptr(index, x);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1fv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1fv(uint index, float* v) => GLPointers._glVertexAttrib1fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1s</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1s(uint index, short x) => GLPointers._glVertexAttrib1s_fnptr(index, x);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib1sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1sv(uint index, short* v) => GLPointers._glVertexAttrib1sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2d(uint index, double x, double y) => GLPointers._glVertexAttrib2d_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2dv(uint index, double* v) => GLPointers._glVertexAttrib2dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2f</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2f(uint index, float x, float y) => GLPointers._glVertexAttrib2f_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2fv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2fv(uint index, float* v) => GLPointers._glVertexAttrib2fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2s</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2s(uint index, short x, short y) => GLPointers._glVertexAttrib2s_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib2sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2sv(uint index, short* v) => GLPointers._glVertexAttrib2sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3d(uint index, double x, double y, double z) => GLPointers._glVertexAttrib3d_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3dv(uint index, double* v) => GLPointers._glVertexAttrib3dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3f</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3f(uint index, float x, float y, float z) => GLPointers._glVertexAttrib3f_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3fv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3fv(uint index, float* v) => GLPointers._glVertexAttrib3fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3s</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3s(uint index, short x, short y, short z) => GLPointers._glVertexAttrib3s_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib3sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3sv(uint index, short* v) => GLPointers._glVertexAttrib3sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4bv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4bv(uint index, sbyte* v) => GLPointers._glVertexAttrib4bv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4d(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttrib4d_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4dv(uint index, double* v) => GLPointers._glVertexAttrib4dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4f</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4f(uint index, float x, float y, float z, float w) => GLPointers._glVertexAttrib4f_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4fv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4fv(uint index, float* v) => GLPointers._glVertexAttrib4fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4iv(uint index, int* v) => GLPointers._glVertexAttrib4iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nbv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nbv(uint index, sbyte* v) => GLPointers._glVertexAttrib4Nbv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Niv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Niv(uint index, int* v) => GLPointers._glVertexAttrib4Niv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nsv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nsv(uint index, short* v) => GLPointers._glVertexAttrib4Nsv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nub</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nub(uint index, byte x, byte y, byte z, byte w) => GLPointers._glVertexAttrib4Nub_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nubv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nubv(uint index, byte* v) => GLPointers._glVertexAttrib4Nubv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nuiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nuiv(uint index, uint* v) => GLPointers._glVertexAttrib4Nuiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4Nusv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nusv(uint index, ushort* v) => GLPointers._glVertexAttrib4Nusv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4s</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4s(uint index, short x, short y, short z, short w) => GLPointers._glVertexAttrib4s_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4sv(uint index, short* v) => GLPointers._glVertexAttrib4sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4ubv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4ubv(uint index, byte* v) => GLPointers._glVertexAttrib4ubv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4uiv(uint index, uint* v) => GLPointers._glVertexAttrib4uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttrib4usv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4usv(uint index, ushort* v) => GLPointers._glVertexAttrib4usv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribBinding</c>]</b><br/> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
        public static void VertexAttribBinding(uint attribindex, uint bindingindex) => GLPointers._glVertexAttribBinding_fnptr(attribindex, bindingindex);
        
        /// <summary> <b>[requires: v3.3]</b> <b>[entry point: <c>glVertexAttribDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes advance during instanced rendering. </summary>
        /// <param name="index"> Specify the index of the generic vertex attribute. </param>
        /// <param name="divisor"> Specify the number of instances that will pass between updates of the generic attribute at slot index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribDivisor.xhtml" /></remarks>
        public static void VertexAttribDivisor(uint index, uint divisor) => GLPointers._glVertexAttribDivisor_fnptr(index, divisor);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexAttribFormat_fnptr(attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI1i</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1i(uint index, int x) => GLPointers._glVertexAttribI1i_fnptr(index, x);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI1iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1iv(uint index, int* v) => GLPointers._glVertexAttribI1iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI1ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1ui(uint index, uint x) => GLPointers._glVertexAttribI1ui_fnptr(index, x);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI1uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1uiv(uint index, uint* v) => GLPointers._glVertexAttribI1uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI2i</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2i(uint index, int x, int y) => GLPointers._glVertexAttribI2i_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI2iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2iv(uint index, int* v) => GLPointers._glVertexAttribI2iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI2ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2ui(uint index, uint x, uint y) => GLPointers._glVertexAttribI2ui_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI2uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2uiv(uint index, uint* v) => GLPointers._glVertexAttribI2uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI3i</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3i(uint index, int x, int y, int z) => GLPointers._glVertexAttribI3i_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI3iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3iv(uint index, int* v) => GLPointers._glVertexAttribI3iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI3ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3ui(uint index, uint x, uint y, uint z) => GLPointers._glVertexAttribI3ui_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI3uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3uiv(uint index, uint* v) => GLPointers._glVertexAttribI3uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4bv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4bv(uint index, sbyte* v) => GLPointers._glVertexAttribI4bv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4i</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4i(uint index, int x, int y, int z, int w) => GLPointers._glVertexAttribI4i_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4iv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4iv(uint index, int* v) => GLPointers._glVertexAttribI4iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4sv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4sv(uint index, short* v) => GLPointers._glVertexAttribI4sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4ubv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4ubv(uint index, byte* v) => GLPointers._glVertexAttribI4ubv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w) => GLPointers._glVertexAttribI4ui_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4uiv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4uiv(uint index, uint* v) => GLPointers._glVertexAttribI4uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribI4usv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4usv(uint index, ushort* v) => GLPointers._glVertexAttribI4usv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribIFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexAttribIFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v3.0]</b> <b>[entry point: <c>glVertexAttribIPointer</c>]</b><br/> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribIPointer(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers._glVertexAttribIPointer_fnptr(index, size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL1d(uint index, double x) => GLPointers._glVertexAttribL1d_fnptr(index, x);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL1dv(uint index, double* v) => GLPointers._glVertexAttribL1dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL2d(uint index, double x, double y) => GLPointers._glVertexAttribL2d_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL2dv(uint index, double* v) => GLPointers._glVertexAttribL2dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL3d(uint index, double x, double y, double z) => GLPointers._glVertexAttribL3d_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL3dv(uint index, double* v) => GLPointers._glVertexAttribL3dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttribL4d_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL4dv(uint index, double* v) => GLPointers._glVertexAttribL4dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribLFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexAttribLFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribLPointer</c>]</b><br/> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers._glVertexAttribLPointer_fnptr(index, size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP1ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP1ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP1uiv</c>]</b><br/>  </summary>
        public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP1uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP2ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP2ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP2uiv</c>]</b><br/>  </summary>
        public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP2uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP3ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP3ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP3uiv</c>]</b><br/>  </summary>
        public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP3uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP4ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP4ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP4uiv</c>]</b><br/>  </summary>
        public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP4uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> <b>[entry point: <c>glVertexAttribPointer</c>]</b><br/> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribPointer(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, void* pointer) => GLPointers._glVertexAttribPointer_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, pointer);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexBindingDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
        public static void VertexBindingDivisor(uint bindingindex, uint divisor) => GLPointers._glVertexBindingDivisor_fnptr(bindingindex, divisor);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP2ui</c>]</b><br/>  </summary>
        public static void VertexP2ui(VertexPointerType type, uint value) => GLPointers._glVertexP2ui_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP2uiv</c>]</b><br/>  </summary>
        public static void VertexP2uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP2uiv_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP3ui</c>]</b><br/>  </summary>
        public static void VertexP3ui(VertexPointerType type, uint value) => GLPointers._glVertexP3ui_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP3uiv</c>]</b><br/>  </summary>
        public static void VertexP3uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP3uiv_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP4ui</c>]</b><br/>  </summary>
        public static void VertexP4ui(VertexPointerType type, uint value) => GLPointers._glVertexP4ui_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP4uiv</c>]</b><br/>  </summary>
        public static void VertexP4uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP4uiv_fnptr((uint)type, value);
        
        /// <summary> <b>[requires: v1.1]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glVertexPointer</c>]</b><br/> Define an array of vertex data. </summary>
        /// <param name="size"> Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4. </param>
        /// <param name="type"> Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT. </param>
        /// <param name="stride"> Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0. </param>
        /// <param name="pointer"> Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glVertexPointer.xml" /></remarks>
        public static void VertexPointer(int size, VertexPointerType type, int stride, void* pointer) => GLPointers._glVertexPointer_fnptr(size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v1.0]</b> <b>[entry point: <c>glViewport</c>]</b><br/> Set the viewport. </summary>
        /// <param name="x"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="width"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml" /></remarks>
        public static void Viewport(int x, int y, int width, int height) => GLPointers._glViewport_fnptr(x, y, width, height);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportArrayv</c>]</b><br/> Set multiple viewports. </summary>
        /// <param name="first"> Specify the first viewport to set. </param>
        /// <param name="count"> Specify the number of viewports to set. </param>
        /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml" /></remarks>
        public static void ViewportArrayv(uint first, int count, float* v) => GLPointers._glViewportArrayv_fnptr(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportIndexedf</c>]</b><br/> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
        public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => GLPointers._glViewportIndexedf_fnptr(index, x, y, w, h);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportIndexedfv</c>]</b><br/> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
        public static void ViewportIndexedfv(uint index, float* v) => GLPointers._glViewportIndexedfv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glWaitSync</c>]</b><br/> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
        /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
        /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml" /></remarks>
        public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => GLPointers._glWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos2d</c>]</b><br/> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2d(double x, double y) => GLPointers._glWindowPos2d_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos2dv</c>]</b><br/>  </summary>
        public static void WindowPos2dv(double* v) => GLPointers._glWindowPos2dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos2f</c>]</b><br/> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2f(float x, float y) => GLPointers._glWindowPos2f_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos2fv</c>]</b><br/>  </summary>
        public static void WindowPos2fv(float* v) => GLPointers._glWindowPos2fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos2i</c>]</b><br/> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2i(int x, int y) => GLPointers._glWindowPos2i_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos2iv</c>]</b><br/>  </summary>
        public static void WindowPos2iv(int* v) => GLPointers._glWindowPos2iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos2s</c>]</b><br/> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos2s(short x, short y) => GLPointers._glWindowPos2s_fnptr(x, y);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos2sv</c>]</b><br/>  </summary>
        public static void WindowPos2sv(short* v) => GLPointers._glWindowPos2sv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos3d</c>]</b><br/> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3d(double x, double y, double z) => GLPointers._glWindowPos3d_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos3dv</c>]</b><br/>  </summary>
        public static void WindowPos3dv(double* v) => GLPointers._glWindowPos3dv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos3f</c>]</b><br/> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3f(float x, float y, float z) => GLPointers._glWindowPos3f_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos3fv</c>]</b><br/>  </summary>
        public static void WindowPos3fv(float* v) => GLPointers._glWindowPos3fv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos3i</c>]</b><br/> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3i(int x, int y, int z) => GLPointers._glWindowPos3i_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos3iv</c>]</b><br/>  </summary>
        public static void WindowPos3iv(int* v) => GLPointers._glWindowPos3iv_fnptr(v);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos3s</c>]</b><br/> Specify the raster position in window coordinates for pixel operations. </summary>
        /// <param name="x"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="y"> Specify the x, y, z coordinates for the raster position. </param>
        /// <param name="z"> Specify the x, y, z coordinates for the raster position. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glWindowPos.xml" /></remarks>
        public static void WindowPos3s(short x, short y, short z) => GLPointers._glWindowPos3s_fnptr(x, y, z);
        
        /// <summary> <b>[requires: v1.4]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glWindowPos3sv</c>]</b><br/>  </summary>
        public static void WindowPos3sv(short* v) => GLPointers._glWindowPos3sv_fnptr(v);
        
        /// <summary>_3DFX extensions.</summary>
        public static unsafe partial class _3DFX
        {
            /// <summary> <b>[requires: GL_3DFX_tbuffer]</b> <b>[entry point: <c>glTbufferMask3DFX</c>]</b><br/>  </summary>
            public static void TbufferMask3DFX(uint mask) => GLPointers._glTbufferMask3DFX_fnptr(mask);
            
        }
        /// <summary>AMD extensions.</summary>
        public static unsafe partial class AMD
        {
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glBeginPerfMonitorAMD</c>]</b><br/>  </summary>
            public static void BeginPerfMonitorAMD(uint monitor) => GLPointers._glBeginPerfMonitorAMD_fnptr(monitor);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b> <b>[entry point: <c>glBlendEquationIndexedAMD</c>]</b><br/>  </summary>
            public static void BlendEquationIndexedAMD(uint buf, BlendEquationModeEXT mode) => GLPointers._glBlendEquationIndexedAMD_fnptr(buf, (uint)mode);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b> <b>[entry point: <c>glBlendEquationSeparateIndexedAMD</c>]</b><br/>  </summary>
            public static void BlendEquationSeparateIndexedAMD(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparateIndexedAMD_fnptr(buf, (uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b> <b>[entry point: <c>glBlendFuncIndexedAMD</c>]</b><br/>  </summary>
            public static void BlendFuncIndexedAMD(uint buf, All src, All dst) => GLPointers._glBlendFuncIndexedAMD_fnptr(buf, (uint)src, (uint)dst);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b> <b>[entry point: <c>glBlendFuncSeparateIndexedAMD</c>]</b><br/>  </summary>
            public static void BlendFuncSeparateIndexedAMD(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers._glBlendFuncSeparateIndexedAMD_fnptr(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b> <b>[entry point: <c>glDebugMessageCallbackAMD</c>]</b><br/>  </summary>
            public static void DebugMessageCallbackAMD(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallbackAMD_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b> <b>[entry point: <c>glDebugMessageEnableAMD</c>]</b><br/>  </summary>
            public static void DebugMessageEnableAMD(All category, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageEnableAMD_fnptr((uint)category, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b> <b>[entry point: <c>glDebugMessageInsertAMD</c>]</b><br/>  </summary>
            public static void DebugMessageInsertAMD(All category, DebugSeverity severity, uint id, int length, byte* buf) => GLPointers._glDebugMessageInsertAMD_fnptr((uint)category, (uint)severity, id, length, buf);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b> <b>[entry point: <c>glDeleteNamesAMD</c>]</b><br/>  </summary>
            public static void DeleteNamesAMD(All identifier, uint num, uint* names) => GLPointers._glDeleteNamesAMD_fnptr((uint)identifier, num, names);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glDeletePerfMonitorsAMD</c>]</b><br/>  </summary>
            public static void DeletePerfMonitorsAMD(int n, uint* monitors) => GLPointers._glDeletePerfMonitorsAMD_fnptr(n, monitors);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glEndPerfMonitorAMD</c>]</b><br/>  </summary>
            public static void EndPerfMonitorAMD(uint monitor) => GLPointers._glEndPerfMonitorAMD_fnptr(monitor);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b> <b>[entry point: <c>glFramebufferSamplePositionsfvAMD</c>]</b><br/>  </summary>
            public static void FramebufferSamplePositionsfvAMD(FramebufferTarget target, uint numsamples, uint pixelindex, float* values) => GLPointers._glFramebufferSamplePositionsfvAMD_fnptr((uint)target, numsamples, pixelindex, values);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b> <b>[entry point: <c>glGenNamesAMD</c>]</b><br/>  </summary>
            public static void GenNamesAMD(All identifier, uint num, uint* names) => GLPointers._glGenNamesAMD_fnptr((uint)identifier, num, names);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGenPerfMonitorsAMD</c>]</b><br/>  </summary>
            public static void GenPerfMonitorsAMD(int n, uint* monitors) => GLPointers._glGenPerfMonitorsAMD_fnptr(n, monitors);
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b> <b>[entry point: <c>glGetDebugMessageLogAMD</c>]</b><br/>  </summary>
            public static uint GetDebugMessageLogAMD(uint count, int bufSize, All* categories, DebugSeverity* severities, uint* ids, int* lengths, byte* message) => GLPointers._glGetDebugMessageLogAMD_fnptr(count, bufSize, (uint*)categories, (uint*)severities, ids, lengths, message);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b> <b>[entry point: <c>glGetFramebufferParameterfvAMD</c>]</b><br/>  </summary>
            public static void GetFramebufferParameterfvAMD(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, float* values) => GLPointers._glGetFramebufferParameterfvAMD_fnptr((uint)target, (uint)pname, numsamples, pixelindex, size, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b> <b>[entry point: <c>glGetNamedFramebufferParameterfvAMD</c>]</b><br/>  </summary>
            public static void GetNamedFramebufferParameterfvAMD(int framebuffer, All pname, uint numsamples, uint pixelindex, int size, float* values) => GLPointers._glGetNamedFramebufferParameterfvAMD_fnptr(framebuffer, (uint)pname, numsamples, pixelindex, size, values);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorCounterDataAMD</c>]</b><br/>  </summary>
            public static void GetPerfMonitorCounterDataAMD(uint monitor, All pname, int dataSize, uint* data, int* bytesWritten) => GLPointers._glGetPerfMonitorCounterDataAMD_fnptr(monitor, (uint)pname, dataSize, data, bytesWritten);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorCounterInfoAMD</c>]</b><br/>  </summary>
            public static void GetPerfMonitorCounterInfoAMD(uint group, uint counter, All pname, void* data) => GLPointers._glGetPerfMonitorCounterInfoAMD_fnptr(group, counter, (uint)pname, data);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorCountersAMD</c>]</b><br/>  </summary>
            public static void GetPerfMonitorCountersAMD(uint group, int* numCounters, int* maxActiveCounters, int counterSize, uint* counters) => GLPointers._glGetPerfMonitorCountersAMD_fnptr(group, numCounters, maxActiveCounters, counterSize, counters);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorCounterStringAMD</c>]</b><br/>  </summary>
            public static void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, int* length, byte* counterString) => GLPointers._glGetPerfMonitorCounterStringAMD_fnptr(group, counter, bufSize, length, counterString);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorGroupsAMD</c>]</b><br/>  </summary>
            public static void GetPerfMonitorGroupsAMD(int* numGroups, int groupsSize, uint* groups) => GLPointers._glGetPerfMonitorGroupsAMD_fnptr(numGroups, groupsSize, groups);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glGetPerfMonitorGroupStringAMD</c>]</b><br/>  </summary>
            public static void GetPerfMonitorGroupStringAMD(uint group, int bufSize, int* length, byte* groupString) => GLPointers._glGetPerfMonitorGroupStringAMD_fnptr(group, bufSize, length, groupString);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glGetUniformi64vNV</c>]</b><br/>  </summary>
            public static void GetUniformi64vNV(int program, int location, long* parameters) => GLPointers._glGetUniformi64vNV_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetUniformui64vNV</c>]</b><br/>  </summary>
            public static void GetUniformui64vNV(int program, int location, ulong* parameters) => GLPointers._glGetUniformui64vNV_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b> <b>[entry point: <c>glIsNameAMD</c>]</b><br/>  </summary>
            public static bool IsNameAMD(All identifier, uint name) => GLPointers._glIsNameAMD_fnptr((uint)identifier, name) != 0;
            
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawArraysIndirectAMD</c>]</b><br/>  </summary>
            public static void MultiDrawArraysIndirectAMD(PrimitiveType mode, void* indirect, int primcount, int stride) => GLPointers._glMultiDrawArraysIndirectAMD_fnptr((uint)mode, indirect, primcount, stride);
            
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawElementsIndirectAMD</c>]</b><br/>  </summary>
            public static void MultiDrawElementsIndirectAMD(PrimitiveType mode, DrawElementsType type, void* indirect, int primcount, int stride) => GLPointers._glMultiDrawElementsIndirectAMD_fnptr((uint)mode, (uint)type, indirect, primcount, stride);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b> <b>[entry point: <c>glNamedFramebufferSamplePositionsfvAMD</c>]</b><br/>  </summary>
            public static void NamedFramebufferSamplePositionsfvAMD(int framebuffer, uint numsamples, uint pixelindex, float* values) => GLPointers._glNamedFramebufferSamplePositionsfvAMD_fnptr(framebuffer, numsamples, pixelindex, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisampleAdvancedAMD</c>]</b><br/>  </summary>
            public static void NamedRenderbufferStorageMultisampleAdvancedAMD(int renderbuffer, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisampleAdvancedAMD_fnptr(renderbuffer, samples, storageSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1i64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform1i64NV(int program, int location, long x) => GLPointers._glProgramUniform1i64NV_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1i64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform1i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform1i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1ui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform1ui64NV(int program, int location, ulong x) => GLPointers._glProgramUniform1ui64NV_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1ui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform1ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform1ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2i64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform2i64NV(int program, int location, long x, long y) => GLPointers._glProgramUniform2i64NV_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2i64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform2i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform2i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2ui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform2ui64NV(int program, int location, ulong x, ulong y) => GLPointers._glProgramUniform2ui64NV_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2ui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform2ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform2ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3i64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform3i64NV(int program, int location, long x, long y, long z) => GLPointers._glProgramUniform3i64NV_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3i64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform3i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform3i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3ui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform3ui64NV(int program, int location, ulong x, ulong y, ulong z) => GLPointers._glProgramUniform3ui64NV_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3ui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform3ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform3ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4i64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform4i64NV(int program, int location, long x, long y, long z, long w) => GLPointers._glProgramUniform4i64NV_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4i64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform4i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform4i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4ui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform4ui64NV(int program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glProgramUniform4ui64NV_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4ui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform4ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform4ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_occlusion_query_event]</b> <b>[entry point: <c>glQueryObjectParameteruiAMD</c>]</b><br/>  </summary>
            public static void QueryObjectParameteruiAMD(QueryTarget target, int id, All pname, OcclusionQueryEventMaskAMD param) => GLPointers._glQueryObjectParameteruiAMD_fnptr((uint)target, id, (uint)pname, (uint)param);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced]</b> <b>[entry point: <c>glRenderbufferStorageMultisampleAdvancedAMD</c>]</b><br/>  </summary>
            public static void RenderbufferStorageMultisampleAdvancedAMD(RenderbufferTarget target, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisampleAdvancedAMD_fnptr((uint)target, samples, storageSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b> <b>[entry point: <c>glSelectPerfMonitorCountersAMD</c>]</b><br/>  </summary>
            public static void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, uint* counterList) => GLPointers._glSelectPerfMonitorCountersAMD_fnptr(monitor, (byte)(enable ? 1 : 0), group, numCounters, counterList);
            
            /// <summary> <b>[requires: GL_AMD_sample_positions]</b> <b>[entry point: <c>glSetMultisamplefvAMD</c>]</b><br/>  </summary>
            public static void SetMultisamplefvAMD(All pname, uint index, float* val) => GLPointers._glSetMultisamplefvAMD_fnptr((uint)pname, index, val);
            
            /// <summary> <b>[requires: GL_AMD_stencil_operation_extended]</b> <b>[entry point: <c>glStencilOpValueAMD</c>]</b><br/>  </summary>
            public static void StencilOpValueAMD(TriangleFace face, uint value) => GLPointers._glStencilOpValueAMD_fnptr((uint)face, value);
            
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator]</b> <b>[entry point: <c>glTessellationFactorAMD</c>]</b><br/>  </summary>
            public static void TessellationFactorAMD(float factor) => GLPointers._glTessellationFactorAMD_fnptr(factor);
            
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator]</b> <b>[entry point: <c>glTessellationModeAMD</c>]</b><br/>  </summary>
            public static void TessellationModeAMD(All mode) => GLPointers._glTessellationModeAMD_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_AMD_sparse_texture]</b> <b>[entry point: <c>glTexStorageSparseAMD</c>]</b><br/>  </summary>
            public static void TexStorageSparseAMD(TextureTarget target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => GLPointers._glTexStorageSparseAMD_fnptr((uint)target, (uint)internalFormat, width, height, depth, layers, (uint)flags);
            
            /// <summary> <b>[requires: GL_AMD_sparse_texture]</b> <b>[entry point: <c>glTextureStorageSparseAMD</c>]</b><br/>  </summary>
            public static void TextureStorageSparseAMD(int texture, All target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => GLPointers._glTextureStorageSparseAMD_fnptr(texture, (uint)target, (uint)internalFormat, width, height, depth, layers, (uint)flags);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1i64NV</c>]</b><br/>  </summary>
            public static void Uniform1i64NV(int location, long x) => GLPointers._glUniform1i64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1i64vNV</c>]</b><br/>  </summary>
            public static void Uniform1i64vNV(int location, int count, long* value) => GLPointers._glUniform1i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1ui64NV</c>]</b><br/>  </summary>
            public static void Uniform1ui64NV(int location, ulong x) => GLPointers._glUniform1ui64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1ui64vNV</c>]</b><br/>  </summary>
            public static void Uniform1ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform1ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2i64NV</c>]</b><br/>  </summary>
            public static void Uniform2i64NV(int location, long x, long y) => GLPointers._glUniform2i64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2i64vNV</c>]</b><br/>  </summary>
            public static void Uniform2i64vNV(int location, int count, long* value) => GLPointers._glUniform2i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2ui64NV</c>]</b><br/>  </summary>
            public static void Uniform2ui64NV(int location, ulong x, ulong y) => GLPointers._glUniform2ui64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2ui64vNV</c>]</b><br/>  </summary>
            public static void Uniform2ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform2ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3i64NV</c>]</b><br/>  </summary>
            public static void Uniform3i64NV(int location, long x, long y, long z) => GLPointers._glUniform3i64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3i64vNV</c>]</b><br/>  </summary>
            public static void Uniform3i64vNV(int location, int count, long* value) => GLPointers._glUniform3i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3ui64NV</c>]</b><br/>  </summary>
            public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z) => GLPointers._glUniform3ui64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3ui64vNV</c>]</b><br/>  </summary>
            public static void Uniform3ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform3ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4i64NV</c>]</b><br/>  </summary>
            public static void Uniform4i64NV(int location, long x, long y, long z, long w) => GLPointers._glUniform4i64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4i64vNV</c>]</b><br/>  </summary>
            public static void Uniform4i64vNV(int location, int count, long* value) => GLPointers._glUniform4i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4ui64NV</c>]</b><br/>  </summary>
            public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glUniform4ui64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4ui64vNV</c>]</b><br/>  </summary>
            public static void Uniform4ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform4ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_interleaved_elements]</b> <b>[entry point: <c>glVertexAttribParameteriAMD</c>]</b><br/>  </summary>
            public static void VertexAttribParameteriAMD(uint index, All pname, int param) => GLPointers._glVertexAttribParameteriAMD_fnptr(index, (uint)pname, param);
            
        }
        /// <summary>APPLE extensions.</summary>
        public static unsafe partial class APPLE
        {
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b> <b>[entry point: <c>glBindVertexArrayAPPLE</c>]</b><br/>  </summary>
            public static void BindVertexArrayAPPLE(int array) => GLPointers._glBindVertexArrayAPPLE_fnptr(array);
            
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range]</b> <b>[entry point: <c>glBufferParameteriAPPLE</c>]</b><br/>  </summary>
            public static void BufferParameteriAPPLE(All target, All pname, int param) => GLPointers._glBufferParameteriAPPLE_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glDeleteFencesAPPLE</c>]</b><br/>  </summary>
            public static void DeleteFencesAPPLE(int n, uint* fences) => GLPointers._glDeleteFencesAPPLE_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b> <b>[entry point: <c>glDeleteVertexArraysAPPLE</c>]</b><br/>  </summary>
            public static void DeleteVertexArraysAPPLE(int n, int* arrays) => GLPointers._glDeleteVertexArraysAPPLE_fnptr(n, arrays);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glDisableVertexAttribAPPLE</c>]</b><br/>  </summary>
            public static void DisableVertexAttribAPPLE(uint index, All pname) => GLPointers._glDisableVertexAttribAPPLE_fnptr(index, (uint)pname);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glDrawElementArrayAPPLE</c>]</b><br/>  </summary>
            public static void DrawElementArrayAPPLE(PrimitiveType mode, int first, int count) => GLPointers._glDrawElementArrayAPPLE_fnptr((uint)mode, first, count);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glDrawRangeElementArrayAPPLE</c>]</b><br/>  </summary>
            public static void DrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int first, int count) => GLPointers._glDrawRangeElementArrayAPPLE_fnptr((uint)mode, start, end, first, count);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glElementPointerAPPLE</c>]</b><br/>  </summary>
            public static void ElementPointerAPPLE(ElementPointerTypeATI type, void* pointer) => GLPointers._glElementPointerAPPLE_fnptr((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glEnableVertexAttribAPPLE</c>]</b><br/>  </summary>
            public static void EnableVertexAttribAPPLE(uint index, All pname) => GLPointers._glEnableVertexAttribAPPLE_fnptr(index, (uint)pname);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glFinishFenceAPPLE</c>]</b><br/>  </summary>
            public static void FinishFenceAPPLE(uint fence) => GLPointers._glFinishFenceAPPLE_fnptr(fence);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glFinishObjectAPPLE</c>]</b><br/>  </summary>
            public static void FinishObjectAPPLE(ObjectTypeAPPLE obj, int name) => GLPointers._glFinishObjectAPPLE_fnptr((uint)obj, name);
            
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range]</b> <b>[entry point: <c>glFlushMappedBufferRangeAPPLE</c>]</b><br/>  </summary>
            public static void FlushMappedBufferRangeAPPLE(BufferTargetARB target, IntPtr offset, nint size) => GLPointers._glFlushMappedBufferRangeAPPLE_fnptr((uint)target, offset, size);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b> <b>[entry point: <c>glFlushVertexArrayRangeAPPLE</c>]</b><br/>  </summary>
            public static void FlushVertexArrayRangeAPPLE(int length, void* pointer) => GLPointers._glFlushVertexArrayRangeAPPLE_fnptr(length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glGenFencesAPPLE</c>]</b><br/>  </summary>
            public static void GenFencesAPPLE(int n, uint* fences) => GLPointers._glGenFencesAPPLE_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b> <b>[entry point: <c>glGenVertexArraysAPPLE</c>]</b><br/>  </summary>
            public static void GenVertexArraysAPPLE(int n, int* arrays) => GLPointers._glGenVertexArraysAPPLE_fnptr(n, arrays);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b> <b>[entry point: <c>glGetObjectParameterivAPPLE</c>]</b><br/>  </summary>
            public static void GetObjectParameterivAPPLE(All objectType, uint name, All pname, int* parameters) => GLPointers._glGetObjectParameterivAPPLE_fnptr((uint)objectType, name, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_APPLE_texture_range]</b> <b>[entry point: <c>glGetTexParameterPointervAPPLE</c>]</b><br/>  </summary>
            public static void GetTexParameterPointervAPPLE_(All target, All pname, void** parameters) => GLPointers._glGetTexParameterPointervAPPLE_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glIsFenceAPPLE</c>]</b><br/>  </summary>
            public static bool IsFenceAPPLE(uint fence) => GLPointers._glIsFenceAPPLE_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b> <b>[entry point: <c>glIsVertexArrayAPPLE</c>]</b><br/>  </summary>
            public static bool IsVertexArrayAPPLE(int array) => GLPointers._glIsVertexArrayAPPLE_fnptr(array) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glIsVertexAttribEnabledAPPLE</c>]</b><br/>  </summary>
            public static bool IsVertexAttribEnabledAPPLE(uint index, All pname) => GLPointers._glIsVertexAttribEnabledAPPLE_fnptr(index, (uint)pname) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glMapVertexAttrib1dAPPLE</c>]</b><br/>  </summary>
            public static void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, double* points) => GLPointers._glMapVertexAttrib1dAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glMapVertexAttrib1fAPPLE</c>]</b><br/>  </summary>
            public static void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, float* points) => GLPointers._glMapVertexAttrib1fAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glMapVertexAttrib2dAPPLE</c>]</b><br/>  </summary>
            public static void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) => GLPointers._glMapVertexAttrib2dAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b> <b>[entry point: <c>glMapVertexAttrib2fAPPLE</c>]</b><br/>  </summary>
            public static void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) => GLPointers._glMapVertexAttrib2fAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glMultiDrawElementArrayAPPLE</c>]</b><br/>  </summary>
            public static void MultiDrawElementArrayAPPLE(PrimitiveType mode, int* first, int* count, int primcount) => GLPointers._glMultiDrawElementArrayAPPLE_fnptr((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b> <b>[entry point: <c>glMultiDrawRangeElementArrayAPPLE</c>]</b><br/>  </summary>
            public static void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int* first, int* count, int primcount) => GLPointers._glMultiDrawRangeElementArrayAPPLE_fnptr((uint)mode, start, end, first, count, primcount);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b> <b>[entry point: <c>glObjectPurgeableAPPLE</c>]</b><br/>  </summary>
            public static All ObjectPurgeableAPPLE(All objectType, uint name, All option) => (All) GLPointers._glObjectPurgeableAPPLE_fnptr((uint)objectType, name, (uint)option);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b> <b>[entry point: <c>glObjectUnpurgeableAPPLE</c>]</b><br/>  </summary>
            public static All ObjectUnpurgeableAPPLE(All objectType, uint name, All option) => (All) GLPointers._glObjectUnpurgeableAPPLE_fnptr((uint)objectType, name, (uint)option);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glSetFenceAPPLE</c>]</b><br/>  </summary>
            public static void SetFenceAPPLE(uint fence) => GLPointers._glSetFenceAPPLE_fnptr(fence);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glTestFenceAPPLE</c>]</b><br/>  </summary>
            public static bool TestFenceAPPLE(uint fence) => GLPointers._glTestFenceAPPLE_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b> <b>[entry point: <c>glTestObjectAPPLE</c>]</b><br/>  </summary>
            public static bool TestObjectAPPLE(ObjectTypeAPPLE obj, uint name) => GLPointers._glTestObjectAPPLE_fnptr((uint)obj, name) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_texture_range]</b> <b>[entry point: <c>glTextureRangeAPPLE</c>]</b><br/>  </summary>
            public static void TextureRangeAPPLE(All target, int length, void* pointer) => GLPointers._glTextureRangeAPPLE_fnptr((uint)target, length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b> <b>[entry point: <c>glVertexArrayParameteriAPPLE</c>]</b><br/>  </summary>
            public static void VertexArrayParameteriAPPLE(VertexArrayPNameAPPLE pname, int param) => GLPointers._glVertexArrayParameteriAPPLE_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b> <b>[entry point: <c>glVertexArrayRangeAPPLE</c>]</b><br/>  </summary>
            public static void VertexArrayRangeAPPLE(int length, void* pointer) => GLPointers._glVertexArrayRangeAPPLE_fnptr(length, pointer);
            
        }
        /// <summary>ARB extensions.</summary>
        public static unsafe partial class ARB
        {
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glActiveShaderProgram</c>]</b><br/> Set the active program object for a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
            /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml" /></remarks>
            public static void ActiveShaderProgram(int pipeline, int program) => GLPointers._glActiveShaderProgram_fnptr(pipeline, program);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glActiveTextureARB</c>]</b><br/>  </summary>
            public static void ActiveTextureARB(TextureUnit texture) => GLPointers._glActiveTextureARB_fnptr((uint)texture);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glAttachObjectARB</c>]</b><br/>  </summary>
            public static void AttachObjectARB(GLHandleARB containerObj, GLHandleARB obj) => GLPointers._glAttachObjectARB_fnptr((IntPtr)containerObj, (IntPtr)obj);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glBeginQueryARB</c>]</b><br/>  </summary>
            public static void BeginQueryARB(QueryTarget target, int id) => GLPointers._glBeginQueryARB_fnptr((uint)target, id);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glBeginQueryIndexed</c>]</b><br/> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
            public static void BeginQueryIndexed(QueryTarget target, uint index, int id) => GLPointers._glBeginQueryIndexed_fnptr((uint)target, index, id);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b> <b>[entry point: <c>glBindAttribLocationARB</c>]</b><br/>  </summary>
            public static void BindAttribLocationARB(GLHandleARB programObj, uint index, byte* name) => GLPointers._glBindAttribLocationARB_fnptr((IntPtr)programObj, index, name);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glBindBufferARB</c>]</b><br/>  </summary>
            public static void BindBufferARB(BufferTargetARB target, int buffer) => GLPointers._glBindBufferARB_fnptr((uint)target, buffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glBindBufferBase</c>]</b><br/> Bind a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml" /></remarks>
            public static void BindBufferBase(BufferTargetARB target, uint index, int buffer) => GLPointers._glBindBufferBase_fnptr((uint)target, index, buffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glBindBufferRange</c>]</b><br/> Bind a range within a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
            /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml" /></remarks>
            public static void BindBufferRange(BufferTargetARB target, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glBindBufferRange_fnptr((uint)target, index, buffer, offset, size);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindBuffersBase</c>]</b><br/> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml" /></remarks>
            public static void BindBuffersBase(BufferTargetARB target, uint first, int count, int* buffers) => GLPointers._glBindBuffersBase_fnptr((uint)target, first, count, buffers);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindBuffersRange</c>]</b><br/> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml" /></remarks>
            public static void BindBuffersRange(BufferTargetARB target, uint first, int count, int* buffers, IntPtr* offsets, nint* sizes) => GLPointers._glBindBuffersRange_fnptr((uint)target, first, count, buffers, offsets, sizes);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> <b>[entry point: <c>glBindFragDataLocationIndexed</c>]</b><br/> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
            /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
            /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
            /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml" /></remarks>
            public static void BindFragDataLocationIndexed(int program, uint colorNumber, uint index, byte* name) => GLPointers._glBindFragDataLocationIndexed_fnptr(program, colorNumber, index, name);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBindFramebuffer</c>]</b><br/> Bind a framebuffer to a framebuffer target. </summary>
            /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml" /></remarks>
            public static void BindFramebuffer(FramebufferTarget target, int framebuffer) => GLPointers._glBindFramebuffer_fnptr((uint)target, framebuffer);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> <b>[entry point: <c>glBindImageTexture</c>]</b><br/> Bind a level of a texture to an image unit. </summary>
            /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
            /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
            /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
            /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
            /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
            /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
            /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml" /></remarks>
            public static void BindImageTexture(uint unit, int texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format) => GLPointers._glBindImageTexture_fnptr(unit, texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, (uint)format);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindImageTextures</c>]</b><br/> Bind one or more named texture images to a sequence of consecutive image units. </summary>
            /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml" /></remarks>
            public static void BindImageTextures(uint first, int count, int* textures) => GLPointers._glBindImageTextures_fnptr(first, count, textures);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glBindProgramARB</c>]</b><br/>  </summary>
            public static void BindProgramARB(ProgramTarget target, int program) => GLPointers._glBindProgramARB_fnptr((uint)target, program);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glBindProgramPipeline</c>]</b><br/> Bind a program pipeline to the current context. </summary>
            /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml" /></remarks>
            public static void BindProgramPipeline(int pipeline) => GLPointers._glBindProgramPipeline_fnptr(pipeline);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBindRenderbuffer</c>]</b><br/> Bind a renderbuffer to a renderbuffer target. </summary>
            /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml" /></remarks>
            public static void BindRenderbuffer(RenderbufferTarget target, int renderbuffer) => GLPointers._glBindRenderbuffer_fnptr((uint)target, renderbuffer);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glBindSampler</c>]</b><br/> Bind a named sampler to a texturing target. </summary>
            /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
            /// <param name="sampler"> Specifies the name of a sampler. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml" /></remarks>
            public static void BindSampler(uint unit, int sampler) => GLPointers._glBindSampler_fnptr(unit, sampler);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindSamplers</c>]</b><br/> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
            /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
            /// <param name="count"> Specifies the number of samplers to bind. </param>
            /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml" /></remarks>
            public static void BindSamplers(uint first, int count, int* samplers) => GLPointers._glBindSamplers_fnptr(first, count, samplers);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindTextures</c>]</b><br/> Bind one or more named textures to a sequence of consecutive texture units. </summary>
            /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml" /></remarks>
            public static void BindTextures(uint first, int count, int* textures) => GLPointers._glBindTextures_fnptr(first, count, textures);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glBindTextureUnit</c>]</b><br/> Bind an existing texture object to the specified texture unit . </summary>
            /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
            /// <param name="texture">Specifies the name of a texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml" /></remarks>
            public static void BindTextureUnit(uint unit, int texture) => GLPointers._glBindTextureUnit_fnptr(unit, texture);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glBindTransformFeedback</c>]</b><br/> Bind a transform feedback object. </summary>
            /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
            /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml" /></remarks>
            public static void BindTransformFeedback(BindTransformFeedbackTarget target, int id) => GLPointers._glBindTransformFeedback_fnptr((uint)target, id);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glBindVertexArray</c>]</b><br/> Bind a vertex array object. </summary>
            /// <param name="array"> Specifies the name of the vertex array to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" /></remarks>
            public static void BindVertexArray(int array) => GLPointers._glBindVertexArray_fnptr(array);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glBindVertexBuffer</c>]</b><br/> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
            public static void BindVertexBuffer(uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glBindVertexBuffer_fnptr(bindingindex, buffer, offset, stride);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> <b>[entry point: <c>glBindVertexBuffers</c>]</b><br/> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
            public static void BindVertexBuffers(uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers._glBindVertexBuffers_fnptr(first, count, buffers, offsets, strides);
            
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> <b>[entry point: <c>glBlendColor</c>]</b><br/> Set the blend color. </summary>
            /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml" /></remarks>
            public static void BlendColor(float red, float green, float blue, float alpha) => GLPointers._glBlendColor_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> <b>[entry point: <c>glBlendEquation</c>]</b><br/> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
            /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
            public static void BlendEquation(BlendEquationModeEXT mode) => GLPointers._glBlendEquation_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b> <b>[entry point: <c>glBlendEquationiARB</c>]</b><br/>  </summary>
            public static void BlendEquationiARB(uint buf, BlendEquationModeEXT mode) => GLPointers._glBlendEquationiARB_fnptr(buf, (uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b> <b>[entry point: <c>glBlendEquationSeparateiARB</c>]</b><br/>  </summary>
            public static void BlendEquationSeparateiARB(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparateiARB_fnptr(buf, (uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b> <b>[entry point: <c>glBlendFunciARB</c>]</b><br/>  </summary>
            public static void BlendFunciARB(uint buf, BlendingFactor src, BlendingFactor dst) => GLPointers._glBlendFunciARB_fnptr(buf, (uint)src, (uint)dst);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b> <b>[entry point: <c>glBlendFuncSeparateiARB</c>]</b><br/>  </summary>
            public static void BlendFuncSeparateiARB(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers._glBlendFuncSeparateiARB_fnptr(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glBlitFramebuffer</c>]</b><br/> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
            public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glBlitNamedFramebuffer</c>]</b><br/> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
            public static void BlitNamedFramebuffer(int readFramebuffer, int drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitNamedFramebuffer_fnptr(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glBufferDataARB</c>]</b><br/>  </summary>
            public static void BufferDataARB(BufferTargetARB target, nint size, void* data, BufferUsageARB usage) => GLPointers._glBufferDataARB_fnptr((uint)target, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b> <b>[entry point: <c>glBufferPageCommitmentARB</c>]</b><br/>  </summary>
            public static void BufferPageCommitmentARB(All target, IntPtr offset, nint size, bool commit) => GLPointers._glBufferPageCommitmentARB_fnptr((uint)target, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage]</b> <b>[entry point: <c>glBufferStorage</c>]</b><br/> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
            public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => GLPointers._glBufferStorage_fnptr((uint)target, size, data, (uint)flags);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glBufferSubDataARB</c>]</b><br/>  </summary>
            public static void BufferSubDataARB(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._glBufferSubDataARB_fnptr((uint)target, offset, size, data);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glCheckFramebufferStatus</c>]</b><br/> Check the completeness status of a framebuffer. </summary>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
            public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckFramebufferStatus_fnptr((uint)target);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCheckNamedFramebufferStatus</c>]</b><br/> Check the completeness status of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
            public static FramebufferStatus CheckNamedFramebufferStatus(int framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckNamedFramebufferStatus_fnptr(framebuffer, (uint)target);
            
            /// <summary> <b>[requires: GL_ARB_color_buffer_float]</b> <b>[entry point: <c>glClampColorARB</c>]</b><br/>  </summary>
            public static void ClampColorARB(ClampColorTargetARB target, ClampColorModeARB clamp) => GLPointers._glClampColorARB_fnptr((uint)target, (uint)clamp);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> <b>[entry point: <c>glClearBufferData</c>]</b><br/> Fill a buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
            public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearBufferData_fnptr((uint)target, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> <b>[entry point: <c>glClearBufferSubData</c>]</b><br/> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
            public static void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearBufferSubData_fnptr((uint)target, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glClearDepthf</c>]</b><br/> Specify the clear value for the depth buffer. </summary>
            /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
            public static void ClearDepthf(float d) => GLPointers._glClearDepthf_fnptr(d);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferData</c>]</b><br/> Fill a buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
            public static void ClearNamedBufferData(int buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferData_fnptr(buffer, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferSubData</c>]</b><br/> Fill all or part of buffer object&apos;s data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object&apos;s data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer&apos;s data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
            public static void ClearNamedBufferSubData(int buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferSubData_fnptr(buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferfi</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="depth"> The value to clear the depth buffer to. </param>
            /// <param name="stencil"> The value to clear the stencil buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferfi(int framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers._glClearNamedFramebufferfi_fnptr(framebuffer, (uint)buffer, drawbuffer, depth, stencil);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferfv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferfv(int framebuffer, Buffer buffer, int drawbuffer, float* value) => GLPointers._glClearNamedFramebufferfv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferiv(int framebuffer, Buffer buffer, int drawbuffer, int* value) => GLPointers._glClearNamedFramebufferiv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glClearNamedFramebufferuiv</c>]</b><br/> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferuiv(int framebuffer, Buffer buffer, int drawbuffer, uint* value) => GLPointers._glClearNamedFramebufferuiv_fnptr(framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> <b>[entry point: <c>glClearTexImage</c>]</b><br/> Fills all a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml" /></remarks>
            public static void ClearTexImage(int texture, int level, PixelFormat format, PixelType type, void* data) => GLPointers._glClearTexImage_fnptr(texture, level, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> <b>[entry point: <c>glClearTexSubImage</c>]</b><br/> Fills all or part of a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
            /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
            /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
            /// <param name="width"> The width of the region to be cleared. </param>
            /// <param name="height"> The height of the region to be cleared. </param>
            /// <param name="depth"> The depth of the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml" /></remarks>
            public static void ClearTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => GLPointers._glClearTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glClientActiveTextureARB</c>]</b><br/>  </summary>
            public static void ClientActiveTextureARB(TextureUnit texture) => GLPointers._glClientActiveTextureARB_fnptr((uint)texture);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glClientWaitSync</c>]</b><br/> Block and wait for a sync object to become signaled. </summary>
            /// <param name="sync"> The sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
            /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml" /></remarks>
            public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => (SyncStatus) GLPointers._glClientWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control]</b> <b>[entry point: <c>glClipControl</c>]</b><br/> Control clip coordinate to window coordinate behavior. </summary>
            /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
            /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml" /></remarks>
            public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => GLPointers._glClipControl_fnptr((uint)origin, (uint)depth);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP3ui</c>]</b><br/>  </summary>
            public static void ColorP3ui(ColorPointerType type, uint color) => GLPointers._glColorP3ui_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP3uiv</c>]</b><br/>  </summary>
            public static void ColorP3uiv(ColorPointerType type, uint* color) => GLPointers._glColorP3uiv_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP4ui</c>]</b><br/>  </summary>
            public static void ColorP4ui(ColorPointerType type, uint color) => GLPointers._glColorP4ui_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glColorP4uiv</c>]</b><br/>  </summary>
            public static void ColorP4uiv(ColorPointerType type, uint* color) => GLPointers._glColorP4uiv_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glColorSubTable</c>]</b><br/> Respecify a portion of a color table. </summary>
            /// <param name="target"> Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="start"> The starting index of the portion of the color table to be replaced. </param>
            /// <param name="count"> The number of table entries to replace. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA. </param>
            /// <param name="type"> The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="data"> Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorSubTable.xml" /></remarks>
            public static void ColorSubTable(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data) => GLPointers._glColorSubTable_fnptr((uint)target, start, count, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glColorTable</c>]</b><br/> Define a color lookup table. </summary>
            /// <param name="target"> Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="internalformat"> The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16. </param>
            /// <param name="width"> The number of entries in the color lookup table specified by data. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA. </param>
            /// <param name="type"> The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="data"> Pointer to a one-dimensional array of pixel data that is processed to build the color table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorTable.xml" /></remarks>
            public static void ColorTable(ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table) => GLPointers._glColorTable_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glColorTableParameterfv</c>]</b><br/> Set color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorTableParameter.xml" /></remarks>
            public static void ColorTableParameterfv(ColorTableTarget target, ColorTableParameterPName pname, float* parameters) => GLPointers._glColorTableParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glColorTableParameteriv</c>]</b><br/> Set color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColorTableParameter.xml" /></remarks>
            public static void ColorTableParameteriv(ColorTableTarget target, ColorTableParameterPName pname, int* parameters) => GLPointers._glColorTableParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glCompileShaderARB</c>]</b><br/>  </summary>
            public static void CompileShaderARB(GLHandleARB shaderObj) => GLPointers._glCompileShaderARB_fnptr((IntPtr)shaderObj);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glCompileShaderIncludeARB</c>]</b><br/>  </summary>
            public static void CompileShaderIncludeARB(int shader, int count, byte** path, int* length) => GLPointers._glCompileShaderIncludeARB_fnptr(shader, count, path, length);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexImage1DARB</c>]</b><br/>  </summary>
            public static void CompressedTexImage1DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage1DARB_fnptr((uint)target, level, (uint)internalformat, width, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexImage2DARB</c>]</b><br/>  </summary>
            public static void CompressedTexImage2DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage2DARB_fnptr((uint)target, level, (uint)internalformat, width, height, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexImage3DARB</c>]</b><br/>  </summary>
            public static void CompressedTexImage3DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => GLPointers._glCompressedTexImage3DARB_fnptr((uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexSubImage1DARB</c>]</b><br/>  </summary>
            public static void CompressedTexSubImage1DARB(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage1DARB_fnptr((uint)target, level, xoffset, width, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexSubImage2DARB</c>]</b><br/>  </summary>
            public static void CompressedTexSubImage2DARB(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage2DARB_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glCompressedTexSubImage3DARB</c>]</b><br/>  </summary>
            public static void CompressedTexSubImage3DARB(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTexSubImage3DARB_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage in a compressed    format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
            public static void CompressedTextureSubImage1D(int texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage1D_fnptr(texture, level, xoffset, width, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
            public static void CompressedTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">!!missing documentation!!</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
            public static void CompressedTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._glCompressedTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionFilter1D</c>]</b><br/> Define a one-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_1D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="width"> The width of the pixel array referenced by data. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA. </param>
            /// <param name="type"> The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="data"> Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionFilter1D.xml" /></remarks>
            public static void ConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image) => GLPointers._glConvolutionFilter1D_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionFilter2D</c>]</b><br/> Define a two-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_2D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="width"> The width of the pixel array referenced by data. </param>
            /// <param name="height"> The height of the pixel array referenced by data. </param>
            /// <param name="format"> The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="data"> Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionFilter2D.xml" /></remarks>
            public static void ConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image) => GLPointers._glConvolutionFilter2D_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionParameterf</c>]</b><br/> Set convolution parameters. </summary>
            /// <param name="target"> The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE. </param>
            /// <param name="parameters"> The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionParameter.xml" /></remarks>
            public static void ConvolutionParameterf(ConvolutionTarget target, ConvolutionParameter pname, float parameters) => GLPointers._glConvolutionParameterf_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionParameterfv</c>]</b><br/>  </summary>
            public static void ConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameter pname, float* parameters) => GLPointers._glConvolutionParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionParameteri</c>]</b><br/> Set convolution parameters. </summary>
            /// <param name="target"> The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE. </param>
            /// <param name="parameters"> The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glConvolutionParameter.xml" /></remarks>
            public static void ConvolutionParameteri(ConvolutionTarget target, ConvolutionParameter pname, int parameters) => GLPointers._glConvolutionParameteri_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glConvolutionParameteriv</c>]</b><br/>  </summary>
            public static void ConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameter pname, int* parameters) => GLPointers._glConvolutionParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer]</b> <b>[entry point: <c>glCopyBufferSubData</c>]</b><br/> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
            /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
            public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glCopyBufferSubData_fnptr((uint)readTarget, (uint)writeTarget, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glCopyColorSubTable</c>]</b><br/> Respecify a portion of a color table. </summary>
            /// <param name="target"> Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="start"> The starting index of the portion of the color table to be replaced. </param>
            /// <param name="x"> The window coordinates of the left corner of the row of pixels to be copied. </param>
            /// <param name="y"> The window coordinates of the left corner of the row of pixels to be copied. </param>
            /// <param name="width"> The number of table entries to replace. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyColorSubTable.xml" /></remarks>
            public static void CopyColorSubTable(ColorTableTarget target, int start, int x, int y, int width) => GLPointers._glCopyColorSubTable_fnptr((uint)target, start, x, y, width);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glCopyColorTable</c>]</b><br/> Copy pixels into a color table. </summary>
            /// <param name="target"> The color table target. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="internalformat"> The internal storage format of the texture image. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="x"> The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table. </param>
            /// <param name="y"> The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table. </param>
            /// <param name="width"> The width of the pixel rectangle. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyColorTable.xml" /></remarks>
            public static void CopyColorTable(ColorTableTarget target, InternalFormat internalformat, int x, int y, int width) => GLPointers._glCopyColorTable_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glCopyConvolutionFilter1D</c>]</b><br/> Copy pixels into a one-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_1D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="x"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="y"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="width"> The width of the pixel array to copy. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyConvolutionFilter1D.xml" /></remarks>
            public static void CopyConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width) => GLPointers._glCopyConvolutionFilter1D_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glCopyConvolutionFilter2D</c>]</b><br/> Copy pixels into a two-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_CONVOLUTION_2D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="x"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="y"> The window space coordinates of the lower-left coordinate of the pixel array to copy. </param>
            /// <param name="width"> The width of the pixel array to copy. </param>
            /// <param name="height"> The height of the pixel array to copy. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glCopyConvolutionFilter2D.xml" /></remarks>
            public static void CopyConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width, int height) => GLPointers._glCopyConvolutionFilter2D_fnptr((uint)target, (uint)internalformat, x, y, width, height);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image]</b> <b>[entry point: <c>glCopyImageSubData</c>]</b><br/> Perform a raw data copy between two images. </summary>
            /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
            /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
            /// <param name="srcLevel"> The mipmap level to read from the source. </param>
            /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
            /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
            /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
            /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
            /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
            /// <param name="dstLevel">!!missing documentation!!</param>
            /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
            /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
            /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
            /// <param name="srcWidth"> The width of the region to be copied. </param>
            /// <param name="srcHeight"> The height of the region to be copied. </param>
            /// <param name="srcDepth"> The depth of the region to be copied. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml" /></remarks>
            public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers._glCopyImageSubData_fnptr(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyNamedBufferSubData</c>]</b><br/> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
            public static void CopyNamedBufferSubData(int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glCopyNamedBufferSubData_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage1D</c>]</b><br/> Copy a one-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
            public static void CopyTextureSubImage1D(int texture, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTextureSubImage1D_fnptr(texture, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage2D</c>]</b><br/> Copy a two-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
            public static void CopyTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage3D</c>]</b><br/> Copy a three-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
            public static void CopyTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateBuffers</c>]</b><br/> Create buffer objects. </summary>
            /// <param name="n"> Specifies the number of buffer objects to create. </param>
            /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml" /></remarks>
            public static void CreateBuffers(int n, int* buffers) => GLPointers._glCreateBuffers_fnptr(n, buffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateFramebuffers</c>]</b><br/> Create framebuffer objects. </summary>
            /// <param name="n"> Number of framebuffer objects to create. </param>
            /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml" /></remarks>
            public static void CreateFramebuffers(int n, int* framebuffers) => GLPointers._glCreateFramebuffers_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glCreateProgramObjectARB</c>]</b><br/>  </summary>
            public static GLHandleARB CreateProgramObjectARB() => (GLHandleARB) GLPointers._glCreateProgramObjectARB_fnptr();
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateProgramPipelines</c>]</b><br/> Create program pipeline objects. </summary>
            /// <param name="n"> Number of program pipeline objects to create. </param>
            /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml" /></remarks>
            public static void CreateProgramPipelines(int n, int* pipelines) => GLPointers._glCreateProgramPipelines_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateQueries</c>]</b><br/> Create query objects. </summary>
            /// <param name="target"> Specifies the target of each created query object. </param>
            /// <param name="n"> Number of query objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml" /></remarks>
            public static void CreateQueries(QueryTarget target, int n, int* ids) => GLPointers._glCreateQueries_fnptr((uint)target, n, ids);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateRenderbuffers</c>]</b><br/> Create renderbuffer objects. </summary>
            /// <param name="n"> Number of renderbuffer objects to create. </param>
            /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml" /></remarks>
            public static void CreateRenderbuffers(int n, int* renderbuffers) => GLPointers._glCreateRenderbuffers_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateSamplers</c>]</b><br/> Create sampler objects. </summary>
            /// <param name="n"> Number of sampler objects to create. </param>
            /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml" /></remarks>
            public static void CreateSamplers(int n, int* samplers) => GLPointers._glCreateSamplers_fnptr(n, samplers);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glCreateShaderObjectARB</c>]</b><br/>  </summary>
            public static GLHandleARB CreateShaderObjectARB(ShaderType shaderType) => (GLHandleARB) GLPointers._glCreateShaderObjectARB_fnptr((uint)shaderType);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glCreateShaderProgramv</c>]</b><br/> Create a stand-alone program from an array of null-terminated source code strings. </summary>
            /// <param name="type"> Specifies the type of shader to create. </param>
            /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
            /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml" /></remarks>
            public static int CreateShaderProgramv(ShaderType type, int count, byte** strings) => GLPointers._glCreateShaderProgramv_fnptr((uint)type, count, strings);
            
            /// <summary> <b>[requires: GL_ARB_cl_event]</b> <b>[entry point: <c>glCreateSyncFromCLeventARB</c>]</b><br/>  </summary>
            public static GLSync CreateSyncFromCLeventARB(CLContext* context, CLEvent* @event, uint flags) => (GLSync) GLPointers._glCreateSyncFromCLeventARB_fnptr((IntPtr*)context, (IntPtr*)@event, flags);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateTextures</c>]</b><br/> Create texture objects. </summary>
            /// <param name="target"> Specifies the effective texture target of each created texture. </param>
            /// <param name="n"> Number of texture objects to create. </param>
            /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml" /></remarks>
            public static void CreateTextures(TextureTarget target, int n, int* textures) => GLPointers._glCreateTextures_fnptr((uint)target, n, textures);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateTransformFeedbacks</c>]</b><br/> Create transform feedback objects. </summary>
            /// <param name="n"> Number of transform feedback objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml" /></remarks>
            public static void CreateTransformFeedbacks(int n, int* ids) => GLPointers._glCreateTransformFeedbacks_fnptr(n, ids);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glCreateVertexArrays</c>]</b><br/> Create vertex array objects. </summary>
            /// <param name="n"> Number of vertex array objects to create. </param>
            /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml" /></remarks>
            public static void CreateVertexArrays(int n, int* arrays) => GLPointers._glCreateVertexArrays_fnptr(n, arrays);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glCurrentPaletteMatrixARB</c>]</b><br/>  </summary>
            public static void CurrentPaletteMatrixARB(int index) => GLPointers._glCurrentPaletteMatrixARB_fnptr(index);
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b> <b>[entry point: <c>glDebugMessageCallbackARB</c>]</b><br/>  </summary>
            public static void DebugMessageCallbackARB(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallbackARB_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b> <b>[entry point: <c>glDebugMessageControlARB</c>]</b><br/>  </summary>
            public static void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageControlARB_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b> <b>[entry point: <c>glDebugMessageInsertARB</c>]</b><br/>  </summary>
            public static void DebugMessageInsertARB(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._glDebugMessageInsertARB_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glDeleteBuffersARB</c>]</b><br/>  </summary>
            public static void DeleteBuffersARB(int n, int* buffers) => GLPointers._glDeleteBuffersARB_fnptr(n, buffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glDeleteFramebuffers</c>]</b><br/> Delete framebuffer objects. </summary>
            /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
            /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml" /></remarks>
            public static void DeleteFramebuffers(int n, int* framebuffers) => GLPointers._glDeleteFramebuffers_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glDeleteNamedStringARB</c>]</b><br/>  </summary>
            public static void DeleteNamedStringARB(int namelen, byte* name) => GLPointers._glDeleteNamedStringARB_fnptr(namelen, name);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glDeleteObjectARB</c>]</b><br/>  </summary>
            public static void DeleteObjectARB(GLHandleARB obj) => GLPointers._glDeleteObjectARB_fnptr((IntPtr)obj);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glDeleteProgramPipelines</c>]</b><br/> Delete program pipeline objects. </summary>
            /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
            /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml" /></remarks>
            public static void DeleteProgramPipelines(int n, int* pipelines) => GLPointers._glDeleteProgramPipelines_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glDeleteProgramsARB</c>]</b><br/>  </summary>
            public static void DeleteProgramsARB(int n, int* programs) => GLPointers._glDeleteProgramsARB_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glDeleteQueriesARB</c>]</b><br/>  </summary>
            public static void DeleteQueriesARB(int n, int* ids) => GLPointers._glDeleteQueriesARB_fnptr(n, ids);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glDeleteRenderbuffers</c>]</b><br/> Delete renderbuffer objects. </summary>
            /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
            /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml" /></remarks>
            public static void DeleteRenderbuffers(int n, int* renderbuffers) => GLPointers._glDeleteRenderbuffers_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glDeleteSamplers</c>]</b><br/> Delete named sampler objects. </summary>
            /// <param name="n"> Specifies the number of sampler objects to be deleted. </param>
            /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml" /></remarks>
            public static void DeleteSamplers(int count, int* samplers) => GLPointers._glDeleteSamplers_fnptr(count, samplers);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glDeleteSync</c>]</b><br/> Delete a sync object. </summary>
            /// <param name="sync"> The sync object to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml" /></remarks>
            public static void DeleteSync(GLSync sync) => GLPointers._glDeleteSync_fnptr((IntPtr)sync);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glDeleteTransformFeedbacks</c>]</b><br/> Delete transform feedback objects. </summary>
            /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
            /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml" /></remarks>
            public static void DeleteTransformFeedbacks(int n, int* ids) => GLPointers._glDeleteTransformFeedbacks_fnptr(n, ids);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glDeleteVertexArrays</c>]</b><br/> Delete vertex array objects. </summary>
            /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
            /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml" /></remarks>
            public static void DeleteVertexArrays(int n, int* arrays) => GLPointers._glDeleteVertexArrays_fnptr(n, arrays);
            
            /// <summary> <b>[requires: GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeArraydvNV</c>]</b><br/>  </summary>
            public static void DepthRangeArraydvNV(uint first, int count, double* v) => GLPointers._glDepthRangeArraydvNV_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeArrayv</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
            /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
            /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml" /></remarks>
            public static void DepthRangeArrayv(uint first, int count, double* v) => GLPointers._glDepthRangeArrayv_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glDepthRangef</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
            /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
            public static void DepthRangef(float n, float f) => GLPointers._glDepthRangef_fnptr(n, f);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeIndexed</c>]</b><br/> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
            /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml" /></remarks>
            public static void DepthRangeIndexed(uint index, double n, double f) => GLPointers._glDepthRangeIndexed_fnptr(index, n, f);
            
            /// <summary> <b>[requires: GL_ARB_viewport_array]</b> <b>[entry point: <c>glDepthRangeIndexeddNV</c>]</b><br/>  </summary>
            public static void DepthRangeIndexeddNV(uint index, double n, double f) => GLPointers._glDepthRangeIndexeddNV_fnptr(index, n, f);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glDetachObjectARB</c>]</b><br/>  </summary>
            public static void DetachObjectARB(GLHandleARB containerObj, GLHandleARB attachedObj) => GLPointers._glDetachObjectARB_fnptr((IntPtr)containerObj, (IntPtr)attachedObj);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glDisableVertexArrayAttrib</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
            public static void DisableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glDisableVertexArrayAttrib_fnptr(vaobj, index);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glDisableVertexAttribArrayARB</c>]</b><br/>  </summary>
            public static void DisableVertexAttribArrayARB(uint index) => GLPointers._glDisableVertexAttribArrayARB_fnptr(index);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> <b>[entry point: <c>glDispatchCompute</c>]</b><br/> Launch one or more compute work groups. </summary>
            /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
            /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
            /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml" /></remarks>
            public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => GLPointers._glDispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
            
            /// <summary> <b>[requires: GL_ARB_compute_variable_group_size]</b> <b>[entry point: <c>glDispatchComputeGroupSizeARB</c>]</b><br/>  </summary>
            public static void DispatchComputeGroupSizeARB(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z) => GLPointers._glDispatchComputeGroupSizeARB_fnptr(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> <b>[entry point: <c>glDispatchComputeIndirect</c>]</b><br/> Launch one or more compute work groups using parameters stored in a buffer. </summary>
            /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml" /></remarks>
            public static void DispatchComputeIndirect(IntPtr indirect) => GLPointers._glDispatchComputeIndirect_fnptr(indirect);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> <b>[entry point: <c>glDrawArraysIndirect</c>]</b><br/> Render primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml" /></remarks>
            public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => GLPointers._glDrawArraysIndirect_fnptr((uint)mode, indirect);
            
            /// <summary> <b>[requires: GL_ARB_draw_instanced]</b> <b>[entry point: <c>glDrawArraysInstancedARB</c>]</b><br/>  </summary>
            public static void DrawArraysInstancedARB(PrimitiveType mode, int first, int count, int primcount) => GLPointers._glDrawArraysInstancedARB_fnptr((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawArraysInstancedBaseInstance</c>]</b><br/> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
            /// <param name="count"> Specifies the number of indices to be rendered. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml" /></remarks>
            public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => GLPointers._glDrawArraysInstancedBaseInstance_fnptr((uint)mode, first, count, instancecount, baseinstance);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers]</b> <b>[entry point: <c>glDrawBuffersARB</c>]</b><br/>  </summary>
            public static void DrawBuffersARB(int n, DrawBufferMode* bufs) => GLPointers._glDrawBuffersARB_fnptr(n, (uint*)bufs);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawElementsBaseVertex</c>]</b><br/> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml" /></remarks>
            public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._glDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, basevertex);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> <b>[entry point: <c>glDrawElementsIndirect</c>]</b><br/> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml" /></remarks>
            public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => GLPointers._glDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect);
            
            /// <summary> <b>[requires: GL_ARB_draw_instanced]</b> <b>[entry point: <c>glDrawElementsInstancedARB</c>]</b><br/>  </summary>
            public static void DrawElementsInstancedARB(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => GLPointers._glDrawElementsInstancedARB_fnptr((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawElementsInstancedBaseInstance</c>]</b><br/> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, uint baseinstance) => GLPointers._glDrawElementsInstancedBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, baseinstance);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawElementsInstancedBaseVertex</c>]</b><br/> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => GLPointers._glDrawElementsInstancedBaseVertex_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> <b>[entry point: <c>glDrawElementsInstancedBaseVertexBaseInstance</c>]</b><br/> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => GLPointers._glDrawElementsInstancedBaseVertexBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex, baseinstance);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glDrawRangeElementsBaseVertex</c>]</b><br/> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="start"> Specifies the minimum array index contained in indices. </param>
            /// <param name="end"> Specifies the maximum array index contained in indices. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml" /></remarks>
            public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._glDrawRangeElementsBaseVertex_fnptr((uint)mode, start, end, count, (uint)type, indices, basevertex);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glDrawTransformFeedback</c>]</b><br/> Render primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml" /></remarks>
            public static void DrawTransformFeedback(PrimitiveType mode, int id) => GLPointers._glDrawTransformFeedback_fnptr((uint)mode, id);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> <b>[entry point: <c>glDrawTransformFeedbackInstanced</c>]</b><br/> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml" /></remarks>
            public static void DrawTransformFeedbackInstanced(PrimitiveType mode, int id, int instancecount) => GLPointers._glDrawTransformFeedbackInstanced_fnptr((uint)mode, id, instancecount);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glDrawTransformFeedbackStream</c>]</b><br/> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml" /></remarks>
            public static void DrawTransformFeedbackStream(PrimitiveType mode, int id, uint stream) => GLPointers._glDrawTransformFeedbackStream_fnptr((uint)mode, id, stream);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> <b>[entry point: <c>glDrawTransformFeedbackStreamInstanced</c>]</b><br/> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml" /></remarks>
            public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, int id, uint stream, int instancecount) => GLPointers._glDrawTransformFeedbackStreamInstanced_fnptr((uint)mode, id, stream, instancecount);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glEnableVertexArrayAttrib</c>]</b><br/> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
            public static void EnableVertexArrayAttrib(int vaobj, uint index) => GLPointers._glEnableVertexArrayAttrib_fnptr(vaobj, index);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glEnableVertexAttribArrayARB</c>]</b><br/>  </summary>
            public static void EnableVertexAttribArrayARB(uint index) => GLPointers._glEnableVertexAttribArrayARB_fnptr(index);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glEndQueryARB</c>]</b><br/>  </summary>
            public static void EndQueryARB(QueryTarget target) => GLPointers._glEndQueryARB_fnptr((uint)target);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glEndQueryIndexed</c>]</b><br/> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
            public static void EndQueryIndexed(QueryTarget target, uint index) => GLPointers._glEndQueryIndexed_fnptr((uint)target, index);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b> <b>[entry point: <c>glEvaluateDepthValuesARB</c>]</b><br/>  </summary>
            public static void EvaluateDepthValuesARB() => GLPointers._glEvaluateDepthValuesARB_fnptr();
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glFenceSync</c>]</b><br/> Create a new sync object and insert it into the GL command stream. </summary>
            /// <param name="condition"> Specifies the condition that must be met to set the sync object&apos;s state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
            /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml" /></remarks>
            public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) GLPointers._glFenceSync_fnptr((uint)condition, (uint)flags);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> <b>[entry point: <c>glFlushMappedBufferRange</c>]</b><br/> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
            public static void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, nint length) => GLPointers._glFlushMappedBufferRange_fnptr((uint)target, offset, length);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glFlushMappedNamedBufferRange</c>]</b><br/> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
            public static void FlushMappedNamedBufferRange(int buffer, IntPtr offset, nint length) => GLPointers._glFlushMappedNamedBufferRange_fnptr(buffer, offset, length);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> <b>[entry point: <c>glFramebufferParameteri</c>]</b><br/> Set a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
            public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers._glFramebufferParameteri_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferRenderbuffer</c>]</b><br/> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
            public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glFramebufferRenderbuffer_fnptr((uint)target, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b> <b>[entry point: <c>glFramebufferSampleLocationsfvARB</c>]</b><br/>  </summary>
            public static void FramebufferSampleLocationsfvARB(FramebufferTarget target, uint start, int count, float* v) => GLPointers._glFramebufferSampleLocationsfvARB_fnptr((uint)target, start, count, v);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture1D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture1D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture2D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture2D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture3D</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers._glFramebufferTexture3D_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b> <b>[entry point: <c>glFramebufferTextureARB</c>]</b><br/>  </summary>
            public static void FramebufferTextureARB(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level) => GLPointers._glFramebufferTextureARB_fnptr((uint)target, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b> <b>[entry point: <c>glFramebufferTextureFaceARB</c>]</b><br/>  </summary>
            public static void FramebufferTextureFaceARB(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, TextureTarget face) => GLPointers._glFramebufferTextureFaceARB_fnptr((uint)target, (uint)attachment, texture, level, (uint)face);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTextureLayer</c>]</b><br/> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
            public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayer_fnptr((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b> <b>[entry point: <c>glFramebufferTextureLayerARB</c>]</b><br/>  </summary>
            public static void FramebufferTextureLayerARB(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayerARB_fnptr((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glGenBuffersARB</c>]</b><br/>  </summary>
            public static void GenBuffersARB(int n, int* buffers) => GLPointers._glGenBuffersARB_fnptr(n, buffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenerateMipmap</c>]</b><br/> Generate mipmaps for a specified texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
            public static void GenerateMipmap(TextureTarget target) => GLPointers._glGenerateMipmap_fnptr((uint)target);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGenerateTextureMipmap</c>]</b><br/> Generate mipmaps for a specified texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
            public static void GenerateTextureMipmap(int texture) => GLPointers._glGenerateTextureMipmap_fnptr(texture);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenFramebuffers</c>]</b><br/> Generate framebuffer object names. </summary>
            /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
            /// <param name="ids"> Specifies an array in which the generated framebuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml" /></remarks>
            public static void GenFramebuffers(int n, int* framebuffers) => GLPointers._glGenFramebuffers_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGenProgramPipelines</c>]</b><br/> Reserve program pipeline object names. </summary>
            /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
            /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml" /></remarks>
            public static void GenProgramPipelines(int n, int* pipelines) => GLPointers._glGenProgramPipelines_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGenProgramsARB</c>]</b><br/>  </summary>
            public static void GenProgramsARB(int n, int* programs) => GLPointers._glGenProgramsARB_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glGenQueriesARB</c>]</b><br/>  </summary>
            public static void GenQueriesARB(int n, int* ids) => GLPointers._glGenQueriesARB_fnptr(n, ids);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGenRenderbuffers</c>]</b><br/> Generate renderbuffer object names. </summary>
            /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
            /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml" /></remarks>
            public static void GenRenderbuffers(int n, int* renderbuffers) => GLPointers._glGenRenderbuffers_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGenSamplers</c>]</b><br/> Generate sampler object names. </summary>
            /// <param name="n"> Specifies the number of sampler object names to generate. </param>
            /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml" /></remarks>
            public static void GenSamplers(int count, int* samplers) => GLPointers._glGenSamplers_fnptr(count, samplers);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glGenTransformFeedbacks</c>]</b><br/> Reserve transform feedback object names. </summary>
            /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
            /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml" /></remarks>
            public static void GenTransformFeedbacks(int n, int* ids) => GLPointers._glGenTransformFeedbacks_fnptr(n, ids);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glGenVertexArrays</c>]</b><br/> Generate vertex array object names. </summary>
            /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
            /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" /></remarks>
            public static void GenVertexArrays(int n, int* arrays) => GLPointers._glGenVertexArrays_fnptr(n, arrays);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters]</b> <b>[entry point: <c>glGetActiveAtomicCounterBufferiv</c>]</b><br/> Retrieve information about the set of active atomic counter buffers for a program. </summary>
            /// <param name="program"> The name of a program object from which to retrieve information. </param>
            /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
            /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml" /></remarks>
            public static void GetActiveAtomicCounterBufferiv(int program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => GLPointers._glGetActiveAtomicCounterBufferiv_fnptr(program, bufferIndex, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetActiveAttribARB</c>]</b><br/>  </summary>
            public static void GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, AttributeType* type, byte* name) => GLPointers._glGetActiveAttribARB_fnptr((IntPtr)programObj, index, maxLength, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineName</c>]</b><br/> Query the name of an active shader subroutine. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
            /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml" /></remarks>
            public static void GetActiveSubroutineName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetActiveSubroutineName_fnptr(program, (uint)shadertype, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineUniformiv</c>]</b><br/> Query a property of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
            /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml" /></remarks>
            public static void GetActiveSubroutineUniformiv(int program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => GLPointers._glGetActiveSubroutineUniformiv_fnptr(program, (uint)shadertype, index, (uint)pname, values);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetActiveSubroutineUniformName</c>]</b><br/> Query the name of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
            /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml" /></remarks>
            public static void GetActiveSubroutineUniformName(int program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetActiveSubroutineUniformName_fnptr(program, (uint)shadertype, index, bufSize, length, name);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetActiveUniformARB</c>]</b><br/>  </summary>
            public static void GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, UniformType* type, byte* name) => GLPointers._glGetActiveUniformARB_fnptr((IntPtr)programObj, index, maxLength, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformBlockiv</c>]</b><br/> Query information about an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="pname"> Specifies the name of the parameter to query. </param>
            /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml" /></remarks>
            public static void GetActiveUniformBlockiv(int program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => GLPointers._glGetActiveUniformBlockiv_fnptr(program, uniformBlockIndex, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformBlockName</c>]</b><br/> Retrieve the name of an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml" /></remarks>
            public static void GetActiveUniformBlockName(int program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => GLPointers._glGetActiveUniformBlockName_fnptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformName</c>]</b><br/> Query the name of an active uniform. </summary>
            /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
            /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
            /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
            /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
            /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml" /></remarks>
            public static void GetActiveUniformName(int program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => GLPointers._glGetActiveUniformName_fnptr(program, uniformIndex, bufSize, length, uniformName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetActiveUniformsiv</c>]</b><br/> Returns information about several active uniform variables for the specified program object. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
            /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
            /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
            /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml" /></remarks>
            public static void GetActiveUniformsiv(int program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => GLPointers._glGetActiveUniformsiv_fnptr(program, uniformCount, uniformIndices, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetAttachedObjectsARB</c>]</b><br/>  </summary>
            public static void GetAttachedObjectsARB(GLHandleARB containerObj, int maxCount, int* count, GLHandleARB* obj) => GLPointers._glGetAttachedObjectsARB_fnptr((IntPtr)containerObj, maxCount, count, (IntPtr*)obj);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetAttribLocationARB</c>]</b><br/>  </summary>
            public static int GetAttribLocationARB(GLHandleARB programObj, byte* name) => GLPointers._glGetAttribLocationARB_fnptr((IntPtr)programObj, name);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glGetBufferParameterivARB</c>]</b><br/>  </summary>
            public static void GetBufferParameterivARB(BufferTargetARB target, BufferPNameARB pname, int* parameters) => GLPointers._glGetBufferParameterivARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glGetBufferPointervARB</c>]</b><br/>  </summary>
            public static void GetBufferPointervARB_(BufferTargetARB target, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetBufferPointervARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glGetBufferSubDataARB</c>]</b><br/>  </summary>
            public static void GetBufferSubDataARB(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._glGetBufferSubDataARB_fnptr((uint)target, offset, size, data);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetColorTable</c>]</b><br/> Retrieve contents of a color lookup table. </summary>
            /// <param name="target"> Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="format"> The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA. </param>
            /// <param name="type"> The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="table"> Pointer to a one-dimensional array of pixel data containing the contents of the color table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetColorTable.xml" /></remarks>
            public static void GetColorTable(ColorTableTarget target, PixelFormat format, PixelType type, void* table) => GLPointers._glGetColorTable_fnptr((uint)target, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetColorTableParameterfv</c>]</b><br/> Get color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameter will be stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetColorTableParameter.xml" /></remarks>
            public static void GetColorTableParameterfv(ColorTableTarget target, ColorTableParameterPName pname, float* parameters) => GLPointers._glGetColorTableParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetColorTableParameteriv</c>]</b><br/> Get color lookup table parameters. </summary>
            /// <param name="target"> The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE. </param>
            /// <param name="pname"> The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE. </param>
            /// <param name="parameters"> A pointer to an array where the values of the parameter will be stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetColorTableParameter.xml" /></remarks>
            public static void GetColorTableParameteriv(ColorTableTarget target, ColorTableParameterPName pname, int* parameters) => GLPointers._glGetColorTableParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b> <b>[entry point: <c>glGetCompressedTexImageARB</c>]</b><br/>  </summary>
            public static void GetCompressedTexImageARB(TextureTarget target, int level, void* img) => GLPointers._glGetCompressedTexImageARB_fnptr((uint)target, level, img);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetCompressedTextureImage</c>]</b><br/> Return a compressed texture image. </summary>
            /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
            /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
            /// <param name="pixels">Returns the compressed texture image.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
            public static void GetCompressedTextureImage(int texture, int level, int bufSize, void* pixels) => GLPointers._glGetCompressedTextureImage_fnptr(texture, level, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> <b>[entry point: <c>glGetCompressedTextureSubImage</c>]</b><br/> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block&apos;s width, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block&apos;s height, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block&apos;s depth, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml" /></remarks>
            public static void GetCompressedTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => GLPointers._glGetCompressedTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetConvolutionFilter</c>]</b><br/> Get current 1D or 2D convolution filter kernel. </summary>
            /// <param name="target"> The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D. </param>
            /// <param name="format"> Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="image"> Pointer to storage for the output image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetConvolutionFilter.xml" /></remarks>
            public static void GetConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, void* image) => GLPointers._glGetConvolutionFilter_fnptr((uint)target, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetConvolutionParameterfv</c>]</b><br/> Get convolution parameters. </summary>
            /// <param name="target"> The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT. </param>
            /// <param name="parameters"> Pointer to storage for the parameters to be retrieved. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetConvolutionParameter.xml" /></remarks>
            public static void GetConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameter pname, float* parameters) => GLPointers._glGetConvolutionParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetConvolutionParameteriv</c>]</b><br/> Get convolution parameters. </summary>
            /// <param name="target"> The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT. </param>
            /// <param name="parameters"> Pointer to storage for the parameters to be retrieved. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetConvolutionParameter.xml" /></remarks>
            public static void GetConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameter pname, int* parameters) => GLPointers._glGetConvolutionParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b> <b>[entry point: <c>glGetDebugMessageLogARB</c>]</b><br/>  </summary>
            public static uint GetDebugMessageLogARB(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._glGetDebugMessageLogARB_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glGetDoublei_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetDoublei_v(GetPName target, uint index, double* data) => GLPointers._glGetDoublei_v_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glGetFloati_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetFloati_v(GetPName target, uint index, float* data) => GLPointers._glGetFloati_v_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> <b>[entry point: <c>glGetFragDataIndex</c>]</b><br/> Query the bindings of color indices to user-defined varying out variables. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
            /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml" /></remarks>
            public static int GetFragDataIndex(int program, byte* name) => GLPointers._glGetFragDataIndex_fnptr(program, name);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGetFramebufferAttachmentParameteriv</c>]</b><br/> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
            public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferAttachmentParameteriv_fnptr((uint)target, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> <b>[entry point: <c>glGetFramebufferParameteriv</c>]</b><br/> Query a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
            public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetGraphicsResetStatusARB</c>]</b><br/>  </summary>
            public static GraphicsResetStatus GetGraphicsResetStatusARB() => (GraphicsResetStatus) GLPointers._glGetGraphicsResetStatusARB_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetHandleARB</c>]</b><br/>  </summary>
            public static GLHandleARB GetHandleARB(ContainerType pname) => (GLHandleARB) GLPointers._glGetHandleARB_fnptr((uint)pname);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetHistogram</c>]</b><br/> Get histogram table. </summary>
            /// <param name="target"> Must be GL_HISTOGRAM. </param>
            /// <param name="reset"> If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified. </param>
            /// <param name="format"> The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="values"> A pointer to storage for the returned histogram table. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetHistogram.xml" /></remarks>
            public static void GetHistogram(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._glGetHistogram_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetHistogramParameterfv</c>]</b><br/> Get histogram parameters. </summary>
            /// <param name="target"> Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM. </param>
            /// <param name="pname"> The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK. </param>
            /// <param name="parameters"> Pointer to storage for the returned values. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetHistogramParameter.xml" /></remarks>
            public static void GetHistogramParameterfv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters) => GLPointers._glGetHistogramParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetHistogramParameteriv</c>]</b><br/> Get histogram parameters. </summary>
            /// <param name="target"> Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM. </param>
            /// <param name="pname"> The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK. </param>
            /// <param name="parameters"> Pointer to storage for the returned values. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetHistogramParameter.xml" /></remarks>
            public static void GetHistogramParameteriv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers._glGetHistogramParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glGetImageHandleARB</c>]</b><br/>  </summary>
            public static ulong GetImageHandleARB(int texture, int level, bool layered, int layer, PixelFormat format) => GLPointers._glGetImageHandleARB_fnptr(texture, level, (byte)(layered ? 1 : 0), layer, (uint)format);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetInfoLogARB</c>]</b><br/>  </summary>
            public static void GetInfoLogARB(GLHandleARB obj, int maxLength, int* length, byte* infoLog) => GLPointers._glGetInfoLogARB_fnptr((IntPtr)obj, maxLength, length, infoLog);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glGetInteger64v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
            /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetInteger64v(GetPName pname, long* data) => GLPointers._glGetInteger64v_fnptr((uint)pname, data);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetIntegeri_v</c>]</b><br/> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetIntegeri_v(GetPName target, uint index, int* data) => GLPointers._glGetIntegeri_v_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2]</b> <b>[entry point: <c>glGetInternalformati64v</c>]</b><br/> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
            public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => GLPointers._glGetInternalformati64v_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query]</b> <b>[entry point: <c>glGetInternalformativ</c>]</b><br/> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
            public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => GLPointers._glGetInternalformativ_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetMinmax</c>]</b><br/> Get minimum and maximum pixel values. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <param name="reset"> If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered. </param>
            /// <param name="format"> The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="types"> The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="values"> A pointer to storage for the returned values. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMinmax.xml" /></remarks>
            public static void GetMinmax(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._glGetMinmax_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetMinmaxParameterfv</c>]</b><br/> Get minmax parameters. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK. </param>
            /// <param name="parameters"> A pointer to storage for the retrieved parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMinmaxParameter.xml" /></remarks>
            public static void GetMinmaxParameterfv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters) => GLPointers._glGetMinmaxParameterfv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetMinmaxParameteriv</c>]</b><br/> Get minmax parameters. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <param name="pname"> The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK. </param>
            /// <param name="parameters"> A pointer to storage for the retrieved parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetMinmaxParameter.xml" /></remarks>
            public static void GetMinmaxParameteriv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters) => GLPointers._glGetMinmaxParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glGetMultisamplefv</c>]</b><br/> Retrieve the location of a sample. </summary>
            /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
            /// <param name="index"> Specifies the index of the sample whose position to query. </param>
            /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml" /></remarks>
            public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers._glGetMultisamplefv_fnptr((uint)pname, index, val);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameteri64v</c>]</b><br/> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
            public static void GetNamedBufferParameteri64v(int buffer, BufferPNameARB pname, long* parameters) => GLPointers._glGetNamedBufferParameteri64v_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameteriv</c>]</b><br/> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
            public static void GetNamedBufferParameteriv(int buffer, BufferPNameARB pname, int* parameters) => GLPointers._glGetNamedBufferParameteriv_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferPointerv</c>]</b><br/> Return the pointer to a mapped buffer object&apos;s data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
            /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
            /// <param name="parameters"> Returns the pointer value specified by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
            public static void GetNamedBufferPointerv(int buffer, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetNamedBufferPointerv_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferSubData</c>]</b><br/> Returns a subset of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store from which data will be returned, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
            /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
            public static void GetNamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glGetNamedBufferSubData_fnptr(buffer, offset, size, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferAttachmentParameteriv</c>]</b><br/> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
            public static void GetNamedFramebufferAttachmentParameteriv(int framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetNamedFramebufferAttachmentParameteriv_fnptr(framebuffer, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferParameteriv</c>]</b><br/> Query a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="param">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
            public static void GetNamedFramebufferParameteriv(int framebuffer, GetFramebufferParameter pname, int* param) => GLPointers._glGetNamedFramebufferParameteriv_fnptr(framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetNamedRenderbufferParameteriv</c>]</b><br/> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
            public static void GetNamedRenderbufferParameteriv(int renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetNamedRenderbufferParameteriv_fnptr(renderbuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glGetNamedStringARB</c>]</b><br/>  </summary>
            public static void GetNamedStringARB(int namelen, byte* name, int bufSize, int* stringlen, byte* str) => GLPointers._glGetNamedStringARB_fnptr(namelen, name, bufSize, stringlen, str);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glGetNamedStringivARB</c>]</b><br/>  </summary>
            public static void GetNamedStringivARB(int namelen, byte* name, All pname, int* parameters) => GLPointers._glGetNamedStringivARB_fnptr(namelen, name, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnColorTableARB</c>]</b><br/>  </summary>
            public static void GetnColorTableARB(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, void* table) => GLPointers._glGetnColorTableARB_fnptr((uint)target, (uint)format, (uint)type, bufSize, table);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnCompressedTexImageARB</c>]</b><br/>  </summary>
            public static void GetnCompressedTexImageARB(TextureTarget target, int lod, int bufSize, void* img) => GLPointers._glGetnCompressedTexImageARB_fnptr((uint)target, lod, bufSize, img);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnConvolutionFilterARB</c>]</b><br/>  </summary>
            public static void GetnConvolutionFilterARB(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, void* image) => GLPointers._glGetnConvolutionFilterARB_fnptr((uint)target, (uint)format, (uint)type, bufSize, image);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnHistogramARB</c>]</b><br/>  </summary>
            public static void GetnHistogramARB(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers._glGetnHistogramARB_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnMapdvARB</c>]</b><br/>  </summary>
            public static void GetnMapdvARB(MapTarget target, MapQuery query, int bufSize, double* v) => GLPointers._glGetnMapdvARB_fnptr((uint)target, (uint)query, bufSize, v);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnMapfvARB</c>]</b><br/>  </summary>
            public static void GetnMapfvARB(MapTarget target, MapQuery query, int bufSize, float* v) => GLPointers._glGetnMapfvARB_fnptr((uint)target, (uint)query, bufSize, v);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnMapivARB</c>]</b><br/>  </summary>
            public static void GetnMapivARB(MapTarget target, MapQuery query, int bufSize, int* v) => GLPointers._glGetnMapivARB_fnptr((uint)target, (uint)query, bufSize, v);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnMinmaxARB</c>]</b><br/>  </summary>
            public static void GetnMinmaxARB(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, void* values) => GLPointers._glGetnMinmaxARB_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnPixelMapfvARB</c>]</b><br/>  </summary>
            public static void GetnPixelMapfvARB(PixelMap map, int bufSize, float* values) => GLPointers._glGetnPixelMapfvARB_fnptr((uint)map, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnPixelMapuivARB</c>]</b><br/>  </summary>
            public static void GetnPixelMapuivARB(PixelMap map, int bufSize, uint* values) => GLPointers._glGetnPixelMapuivARB_fnptr((uint)map, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnPixelMapusvARB</c>]</b><br/>  </summary>
            public static void GetnPixelMapusvARB(PixelMap map, int bufSize, ushort* values) => GLPointers._glGetnPixelMapusvARB_fnptr((uint)map, bufSize, values);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnPolygonStippleARB</c>]</b><br/>  </summary>
            public static void GetnPolygonStippleARB(int bufSize, byte* pattern) => GLPointers._glGetnPolygonStippleARB_fnptr(bufSize, pattern);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnSeparableFilterARB</c>]</b><br/>  </summary>
            public static void GetnSeparableFilterARB(SeparableTargetEXT target, PixelFormat format, PixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span) => GLPointers._glGetnSeparableFilterARB_fnptr((uint)target, (uint)format, (uint)type, rowBufSize, row, columnBufSize, column, span);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnTexImageARB</c>]</b><br/>  </summary>
            public static void GetnTexImageARB(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* img) => GLPointers._glGetnTexImageARB_fnptr((uint)target, level, (uint)format, (uint)type, bufSize, img);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnUniformdvARB</c>]</b><br/>  </summary>
            public static void GetnUniformdvARB(int program, int location, int bufSize, double* parameters) => GLPointers._glGetnUniformdvARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnUniformfvARB</c>]</b><br/>  </summary>
            public static void GetnUniformfvARB(int program, int location, int bufSize, float* parameters) => GLPointers._glGetnUniformfvARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glGetnUniformi64vARB</c>]</b><br/>  </summary>
            public static void GetnUniformi64vARB(int program, int location, int bufSize, long* parameters) => GLPointers._glGetnUniformi64vARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnUniformivARB</c>]</b><br/>  </summary>
            public static void GetnUniformivARB(int program, int location, int bufSize, int* parameters) => GLPointers._glGetnUniformivARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glGetnUniformui64vARB</c>]</b><br/>  </summary>
            public static void GetnUniformui64vARB(int program, int location, int bufSize, ulong* parameters) => GLPointers._glGetnUniformui64vARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glGetnUniformuivARB</c>]</b><br/>  </summary>
            public static void GetnUniformuivARB(int program, int location, int bufSize, uint* parameters) => GLPointers._glGetnUniformuivARB_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetObjectParameterfvARB</c>]</b><br/>  </summary>
            public static void GetObjectParameterfvARB(GLHandleARB obj, All pname, float* parameters) => GLPointers._glGetObjectParameterfvARB_fnptr((IntPtr)obj, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetObjectParameterivARB</c>]</b><br/>  </summary>
            public static void GetObjectParameterivARB(GLHandleARB obj, All pname, int* parameters) => GLPointers._glGetObjectParameterivARB_fnptr((IntPtr)obj, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> <b>[entry point: <c>glGetProgramBinary</c>]</b><br/> Return a binary representation of a program object&apos;s compiled and linked executable source. </summary>
            /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
            /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
            /// <param name="binary"> Specifies the address an array into which the GL will return program&apos;s binary representation. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml" /></remarks>
            public static void GetProgramBinary(int program, int bufSize, int* length, All* binaryFormat, void* binary) => GLPointers._glGetProgramBinary_fnptr(program, bufSize, length, (uint*)binaryFormat, binary);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramEnvParameterdvARB</c>]</b><br/>  </summary>
            public static void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, double* parameters) => GLPointers._glGetProgramEnvParameterdvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramEnvParameterfvARB</c>]</b><br/>  </summary>
            public static void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, float* parameters) => GLPointers._glGetProgramEnvParameterfvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramInterfaceiv</c>]</b><br/> Query a property of an interface in a program. </summary>
            /// <param name="program"> The name of a program object whose interface to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program to query. </param>
            /// <param name="pname"> The name of the parameter within programInterface to query. </param>
            /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml" /></remarks>
            public static void GetProgramInterfaceiv(int program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => GLPointers._glGetProgramInterfaceiv_fnptr(program, (uint)programInterface, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramivARB</c>]</b><br/>  </summary>
            public static void GetProgramivARB(ProgramTarget target, ProgramPropertyARB pname, int* parameters) => GLPointers._glGetProgramivARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramLocalParameterdvARB</c>]</b><br/>  </summary>
            public static void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, double* parameters) => GLPointers._glGetProgramLocalParameterdvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramLocalParameterfvARB</c>]</b><br/>  </summary>
            public static void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, float* parameters) => GLPointers._glGetProgramLocalParameterfvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineInfoLog</c>]</b><br/> Retrieve the info log string from a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
            /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
            /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
            /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml" /></remarks>
            public static void GetProgramPipelineInfoLog(int pipeline, int bufSize, int* length, byte* infoLog) => GLPointers._glGetProgramPipelineInfoLog_fnptr(pipeline, bufSize, length, infoLog);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineiv</c>]</b><br/> Retrieve properties of a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
            /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml" /></remarks>
            public static void GetProgramPipelineiv(int pipeline, PipelineParameterName pname, int* parameters) => GLPointers._glGetProgramPipelineiv_fnptr(pipeline, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceIndex</c>]</b><br/> Query the index of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the index of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml" /></remarks>
            public static uint GetProgramResourceIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceIndex_fnptr(program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceiv</c>]</b><br/> Retrieve values for multiple properties of a single active resource within a program object. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="index">!!missing documentation!!</param>
            /// <param name="propCount">!!missing documentation!!</param>
            /// <param name="props">!!missing documentation!!</param>
            /// <param name="bufSize">!!missing documentation!!</param>
            /// <param name="length">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml" /></remarks>
            public static void GetProgramResourceiv(int program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => GLPointers._glGetProgramResourceiv_fnptr(program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceLocation</c>]</b><br/> Query the location of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml" /></remarks>
            public static int GetProgramResourceLocation(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceLocation_fnptr(program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceLocationIndex</c>]</b><br/> Query the fragment color index of a named variable within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml" /></remarks>
            public static int GetProgramResourceLocationIndex(int program, ProgramInterface programInterface, byte* name) => GLPointers._glGetProgramResourceLocationIndex_fnptr(program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> <b>[entry point: <c>glGetProgramResourceName</c>]</b><br/> Query the name of an indexed resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
            /// <param name="index"> The index of the resource within programInterface of program. </param>
            /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
            /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
            /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml" /></remarks>
            public static void GetProgramResourceName(int program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => GLPointers._glGetProgramResourceName_fnptr(program, (uint)programInterface, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetProgramStageiv</c>]</b><br/> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
            /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml" /></remarks>
            public static void GetProgramStageiv(int program, ShaderType shadertype, ProgramStagePName pname, int* values) => GLPointers._glGetProgramStageiv_fnptr(program, (uint)shadertype, (uint)pname, values);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glGetProgramStringARB</c>]</b><br/>  </summary>
            public static void GetProgramStringARB(ProgramTarget target, ProgramStringProperty pname, void* str) => GLPointers._glGetProgramStringARB_fnptr((uint)target, (uint)pname, str);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjecti64v</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjecti64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjecti64v_fnptr(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectiv</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectiv_fnptr(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectui64v</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectui64v(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectui64v_fnptr(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetQueryBufferObjectuiv</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer&apos;s data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectuiv(int id, int buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._glGetQueryBufferObjectuiv_fnptr(id, buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> <b>[entry point: <c>glGetQueryIndexediv</c>]</b><br/> Return parameters of an indexed query object target. </summary>
            /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
            /// <param name="index"> Specifies the index of the query object target. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
            /// <param name="parameters"> Returns the requested data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml" /></remarks>
            public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => GLPointers._glGetQueryIndexediv_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glGetQueryivARB</c>]</b><br/>  </summary>
            public static void GetQueryivARB(QueryTarget target, QueryParameterName pname, int* parameters) => GLPointers._glGetQueryivARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glGetQueryObjecti64v</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryObjecti64v(int id, QueryObjectParameterName pname, long* parameters) => GLPointers._glGetQueryObjecti64v_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glGetQueryObjectivARB</c>]</b><br/>  </summary>
            public static void GetQueryObjectivARB(int id, QueryObjectParameterName pname, int* parameters) => GLPointers._glGetQueryObjectivARB_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glGetQueryObjectui64v</c>]</b><br/> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer&apos;s data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryObjectui64v(int id, QueryObjectParameterName pname, ulong* parameters) => GLPointers._glGetQueryObjectui64v_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glGetQueryObjectuivARB</c>]</b><br/>  </summary>
            public static void GetQueryObjectuivARB(int id, QueryObjectParameterName pname, uint* parameters) => GLPointers._glGetQueryObjectuivARB_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glGetRenderbufferParameteriv</c>]</b><br/> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
            public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetRenderbufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterfv</c>]</b><br/> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterfv(int sampler, SamplerParameterF pname, float* parameters) => GLPointers._glGetSamplerParameterfv_fnptr(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterIiv</c>]</b><br/> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterIiv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers._glGetSamplerParameterIiv_fnptr(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameterIuiv</c>]</b><br/> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* parameters) => GLPointers._glGetSamplerParameterIuiv_fnptr(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glGetSamplerParameteriv</c>]</b><br/> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameteriv(int sampler, SamplerParameterI pname, int* parameters) => GLPointers._glGetSamplerParameteriv_fnptr(sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glGetSeparableFilter</c>]</b><br/> Get separable convolution filter kernel images. </summary>
            /// <param name="target"> The separable filter to be retrieved. Must be GL_SEPARABLE_2D. </param>
            /// <param name="format"> Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="row"> Pointer to storage for the row filter image. </param>
            /// <param name="column"> Pointer to storage for the column filter image. </param>
            /// <param name="span"> Pointer to storage for the span filter image (currently unused). </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetSeparableFilter.xml" /></remarks>
            public static void GetSeparableFilter(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span) => GLPointers._glGetSeparableFilter_fnptr((uint)target, (uint)format, (uint)type, row, column, span);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glGetShaderPrecisionFormat</c>]</b><br/> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
            /// <param name="shaderType"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="precisionType"> Specifies the numeric format whose precision and range to query. </param>
            /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation&apos;s numeric range are returned. </param>
            /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml" /></remarks>
            public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => GLPointers._glGetShaderPrecisionFormat_fnptr((uint)shadertype, (uint)precisiontype, range, precision);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetShaderSourceARB</c>]</b><br/>  </summary>
            public static void GetShaderSourceARB(GLHandleARB obj, int maxLength, int* length, byte* source) => GLPointers._glGetShaderSourceARB_fnptr((IntPtr)obj, maxLength, length, source);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetSubroutineIndex</c>]</b><br/> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml" /></remarks>
            public static uint GetSubroutineIndex(int program, ShaderType shadertype, byte* name) => GLPointers._glGetSubroutineIndex_fnptr(program, (uint)shadertype, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetSubroutineUniformLocation</c>]</b><br/> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml" /></remarks>
            public static int GetSubroutineUniformLocation(int program, ShaderType shadertype, byte* name) => GLPointers._glGetSubroutineUniformLocation_fnptr(program, (uint)shadertype, name);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glGetSynciv</c>]</b><br/> Query the properties of a sync object. </summary>
            /// <param name="sync"> Specifies the sync object whose properties to query. </param>
            /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in values. </param>
            /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
            /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml" /></remarks>
            public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => GLPointers._glGetSynciv_fnptr((IntPtr)sync, (uint)pname, count, length, values);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glGetTextureHandleARB</c>]</b><br/>  </summary>
            public static ulong GetTextureHandleARB(int texture) => GLPointers._glGetTextureHandleARB_fnptr(texture);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureImage</c>]</b><br/> Return a texture image. </summary>
            /// <param name="texture"> Specifies the texture object name. </param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
            /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
            /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
            public static void GetTextureImage(int texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetTextureImage_fnptr(texture, level, (uint)format, (uint)type, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameterfv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
            public static void GetTextureLevelParameterfv(int texture, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureLevelParameterfv_fnptr(texture, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameteriv</c>]</b><br/> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
            public static void GetTextureLevelParameteriv(int texture, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureLevelParameteriv_fnptr(texture, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterfv</c>]</b><br/> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterfv(int texture, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureParameterfv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIiv</c>]</b><br/> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterIiv(int texture, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameterIiv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIuiv</c>]</b><br/> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterIuiv(int texture, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTextureParameterIuiv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameteriv</c>]</b><br/> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameteriv(int texture, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameteriv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glGetTextureSamplerHandleARB</c>]</b><br/>  </summary>
            public static ulong GetTextureSamplerHandleARB(int texture, int sampler) => GLPointers._glGetTextureSamplerHandleARB_fnptr(texture, sampler);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> <b>[entry point: <c>glGetTextureSubImage</c>]</b><br/> Retrieve a sub-region of a texture image from a texture    object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
            /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml" /></remarks>
            public static void GetTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._glGetTextureSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbacki_v</c>]</b><br/> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbacki_v(int xfb, TransformFeedbackPName pname, uint index, int* param) => GLPointers._glGetTransformFeedbacki_v_fnptr(xfb, (uint)pname, index, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbacki64_v</c>]</b><br/> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbacki64_v(int xfb, TransformFeedbackPName pname, uint index, long* param) => GLPointers._glGetTransformFeedbacki64_v_fnptr(xfb, (uint)pname, index, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetTransformFeedbackiv</c>]</b><br/> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbackiv(int xfb, TransformFeedbackPName pname, int* param) => GLPointers._glGetTransformFeedbackiv_fnptr(xfb, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetUniformBlockIndex</c>]</b><br/> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml" /></remarks>
            public static uint GetUniformBlockIndex(int program, byte* uniformBlockName) => GLPointers._glGetUniformBlockIndex_fnptr(program, uniformBlockName);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glGetUniformdv</c>]</b><br/> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetUniformdv(int program, int location, double* parameters) => GLPointers._glGetUniformdv_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetUniformfvARB</c>]</b><br/>  </summary>
            public static void GetUniformfvARB(GLHandleARB programObj, int location, float* parameters) => GLPointers._glGetUniformfvARB_fnptr((IntPtr)programObj, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glGetUniformi64vARB</c>]</b><br/>  </summary>
            public static void GetUniformi64vARB(int program, int location, long* parameters) => GLPointers._glGetUniformi64vARB_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glGetUniformIndices</c>]</b><br/> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
            /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
            /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
            /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml" /></remarks>
            public static void GetUniformIndices(int program, int uniformCount, byte** uniformNames, uint* uniformIndices) => GLPointers._glGetUniformIndices_fnptr(program, uniformCount, uniformNames, uniformIndices);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetUniformivARB</c>]</b><br/>  </summary>
            public static void GetUniformivARB(GLHandleARB programObj, int location, int* parameters) => GLPointers._glGetUniformivARB_fnptr((IntPtr)programObj, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glGetUniformLocationARB</c>]</b><br/>  </summary>
            public static int GetUniformLocationARB(GLHandleARB programObj, byte* name) => GLPointers._glGetUniformLocationARB_fnptr((IntPtr)programObj, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glGetUniformSubroutineuiv</c>]</b><br/> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="location"> Specifies the location of the subroutine uniform. </param>
            /// <param name="values"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml" /></remarks>
            public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => GLPointers._glGetUniformSubroutineuiv_fnptr((uint)shadertype, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glGetUniformui64vARB</c>]</b><br/>  </summary>
            public static void GetUniformui64vARB(int program, int location, ulong* parameters) => GLPointers._glGetUniformui64vARB_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIndexed64iv</c>]</b><br/> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
            public static void GetVertexArrayIndexed64iv(int vaobj, uint index, VertexArrayPName pname, long* param) => GLPointers._glGetVertexArrayIndexed64iv_fnptr(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIndexediv</c>]</b><br/> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
            public static void GetVertexArrayIndexediv(int vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayIndexediv_fnptr(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayiv</c>]</b><br/> Retrieve parameters of a vertex array object. </summary>
            /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
            /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml" /></remarks>
            public static void GetVertexArrayiv(int vaobj, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayiv_fnptr(vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetVertexAttribdvARB</c>]</b><br/>  </summary>
            public static void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, double* parameters) => GLPointers._glGetVertexAttribdvARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetVertexAttribfvARB</c>]</b><br/>  </summary>
            public static void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, float* parameters) => GLPointers._glGetVertexAttribfvARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetVertexAttribivARB</c>]</b><br/>  </summary>
            public static void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, int* parameters) => GLPointers._glGetVertexAttribivARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glGetVertexAttribLdv</c>]</b><br/> Return a generic vertex attribute parameter. </summary>
            /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
            /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
            public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => GLPointers._glGetVertexAttribLdv_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glGetVertexAttribLui64vARB</c>]</b><br/>  </summary>
            public static void GetVertexAttribLui64vARB(uint index, VertexAttribEnum pname, ulong* parameters) => GLPointers._glGetVertexAttribLui64vARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glGetVertexAttribPointervARB</c>]</b><br/>  </summary>
            public static void GetVertexAttribPointervARB_(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => GLPointers._glGetVertexAttribPointervARB_fnptr(index, (uint)pname, pointer);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glHistogram</c>]</b><br/> Define histogram table. </summary>
            /// <param name="target"> The histogram whose parameters are to be set. Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM. </param>
            /// <param name="width"> The number of entries in the histogram table. Must be a power of 2. </param>
            /// <param name="internalformat"> The format of entries in the histogram table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="sink"> If GL_TRUE, pixels will be consumed by the histogramming process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the minmax process after histogramming. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glHistogram.xml" /></remarks>
            public static void Histogram(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink) => GLPointers._glHistogram_fnptr((uint)target, width, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateBufferData</c>]</b><br/> Invalidate the content of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml" /></remarks>
            public static void InvalidateBufferData(int buffer) => GLPointers._glInvalidateBufferData_fnptr(buffer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateBufferSubData</c>]</b><br/> Invalidate a region of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
            /// <param name="offset"> The offset within the buffer&apos;s data store of the start of the range to be invalidated. </param>
            /// <param name="length"> The length of the range within the buffer&apos;s data store to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml" /></remarks>
            public static void InvalidateBufferSubData(int buffer, IntPtr offset, nint length) => GLPointers._glInvalidateBufferSubData_fnptr(buffer, offset, length);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateFramebuffer</c>]</b><br/> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
            public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => GLPointers._glInvalidateFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glInvalidateNamedFramebufferData</c>]</b><br/> Invalidate the content of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
            public static void InvalidateNamedFramebufferData(int framebuffer, int numAttachments, FramebufferAttachment* attachments) => GLPointers._glInvalidateNamedFramebufferData_fnptr(framebuffer, numAttachments, (uint*)attachments);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glInvalidateNamedFramebufferSubData</c>]</b><br/> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
            public static void InvalidateNamedFramebufferSubData(int framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._glInvalidateNamedFramebufferSubData_fnptr(framebuffer, numAttachments, (uint*)attachments, x, y, width, height);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateSubFramebuffer</c>]</b><br/> Invalidate the content of a region of some or all of a framebuffer&apos;s attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
            public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._glInvalidateSubFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments, x, y, width, height);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateTexImage</c>]</b><br/> Invalidate the entirety a texture image. </summary>
            /// <param name="texture"> The name of a texture object to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml" /></remarks>
            public static void InvalidateTexImage(int texture, int level) => GLPointers._glInvalidateTexImage_fnptr(texture, level);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> <b>[entry point: <c>glInvalidateTexSubImage</c>]</b><br/> Invalidate a region of a texture image. </summary>
            /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
            /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
            /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
            /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
            /// <param name="width"> The width of the region to be invalidated. </param>
            /// <param name="height"> The height of the region to be invalidated. </param>
            /// <param name="depth"> The depth of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml" /></remarks>
            public static void InvalidateTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => GLPointers._glInvalidateTexSubImage_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glIsBufferARB</c>]</b><br/>  </summary>
            public static bool IsBufferARB(int buffer) => GLPointers._glIsBufferARB_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glIsFramebuffer</c>]</b><br/> Determine if a name corresponds to a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml" /></remarks>
            public static bool IsFramebuffer(int framebuffer) => GLPointers._glIsFramebuffer_fnptr(framebuffer) != 0;
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glIsImageHandleResidentARB</c>]</b><br/>  </summary>
            public static bool IsImageHandleResidentARB(ulong handle) => GLPointers._glIsImageHandleResidentARB_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glIsNamedStringARB</c>]</b><br/>  </summary>
            public static bool IsNamedStringARB(int namelen, byte* name) => GLPointers._glIsNamedStringARB_fnptr(namelen, name) != 0;
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glIsProgramARB</c>]</b><br/>  </summary>
            public static bool IsProgramARB(int program) => GLPointers._glIsProgramARB_fnptr(program) != 0;
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glIsProgramPipeline</c>]</b><br/> Determine if a name corresponds to a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml" /></remarks>
            public static bool IsProgramPipeline(int pipeline) => GLPointers._glIsProgramPipeline_fnptr(pipeline) != 0;
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b> <b>[entry point: <c>glIsQueryARB</c>]</b><br/>  </summary>
            public static bool IsQueryARB(int id) => GLPointers._glIsQueryARB_fnptr(id) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glIsRenderbuffer</c>]</b><br/> Determine if a name corresponds to a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml" /></remarks>
            public static bool IsRenderbuffer(int renderbuffer) => GLPointers._glIsRenderbuffer_fnptr(renderbuffer) != 0;
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glIsSampler</c>]</b><br/> Determine if a name corresponds to a sampler object. </summary>
            /// <param name="id"> Specifies a value that may be the name of a sampler object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml" /></remarks>
            public static bool IsSampler(int sampler) => GLPointers._glIsSampler_fnptr(sampler) != 0;
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glIsSync</c>]</b><br/> Determine if a name corresponds to a sync object. </summary>
            /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml" /></remarks>
            public static bool IsSync(GLSync sync) => GLPointers._glIsSync_fnptr((IntPtr)sync) != 0;
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glIsTextureHandleResidentARB</c>]</b><br/>  </summary>
            public static bool IsTextureHandleResidentARB(ulong handle) => GLPointers._glIsTextureHandleResidentARB_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glIsTransformFeedback</c>]</b><br/> Determine if a name corresponds to a transform feedback object. </summary>
            /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml" /></remarks>
            public static bool IsTransformFeedback(int id) => GLPointers._glIsTransformFeedback_fnptr(id) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> <b>[entry point: <c>glIsVertexArray</c>]</b><br/> Determine if a name corresponds to a vertex array object. </summary>
            /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml" /></remarks>
            public static bool IsVertexArray(int array) => GLPointers._glIsVertexArray_fnptr(array) != 0;
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glLinkProgramARB</c>]</b><br/>  </summary>
            public static void LinkProgramARB(GLHandleARB programObj) => GLPointers._glLinkProgramARB_fnptr((IntPtr)programObj);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b> <b>[entry point: <c>glLoadTransposeMatrixdARB</c>]</b><br/>  </summary>
            public static void LoadTransposeMatrixdARB(double* m) => GLPointers._glLoadTransposeMatrixdARB_fnptr(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b> <b>[entry point: <c>glLoadTransposeMatrixfARB</c>]</b><br/>  </summary>
            public static void LoadTransposeMatrixfARB(float* m) => GLPointers._glLoadTransposeMatrixfARB_fnptr(m);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glMakeImageHandleNonResidentARB</c>]</b><br/>  </summary>
            public static void MakeImageHandleNonResidentARB(ulong handle) => GLPointers._glMakeImageHandleNonResidentARB_fnptr(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glMakeImageHandleResidentARB</c>]</b><br/>  </summary>
            public static void MakeImageHandleResidentARB(ulong handle, All access) => GLPointers._glMakeImageHandleResidentARB_fnptr(handle, (uint)access);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glMakeTextureHandleNonResidentARB</c>]</b><br/>  </summary>
            public static void MakeTextureHandleNonResidentARB(ulong handle) => GLPointers._glMakeTextureHandleNonResidentARB_fnptr(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glMakeTextureHandleResidentARB</c>]</b><br/>  </summary>
            public static void MakeTextureHandleResidentARB(ulong handle) => GLPointers._glMakeTextureHandleResidentARB_fnptr(handle);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glMapBufferARB</c>]</b><br/>  </summary>
            public static void* MapBufferARB(BufferTargetARB target, BufferAccessARB access) => GLPointers._glMapBufferARB_fnptr((uint)target, (uint)access);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> <b>[entry point: <c>glMapBufferRange</c>]</b><br/> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
            public static void* MapBufferRange(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapBufferRange_fnptr((uint)target, offset, length, (uint)access);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glMapNamedBuffer</c>]</b><br/> Map all of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
            /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object&apos;s mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
            public static void* MapNamedBuffer(int buffer, BufferAccessARB access) => GLPointers._glMapNamedBuffer_fnptr(buffer, (uint)access);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glMapNamedBufferRange</c>]</b><br/> Map all or part of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
            public static void* MapNamedBufferRange(int buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapNamedBufferRange_fnptr(buffer, offset, length, (uint)access);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glMatrixIndexPointerARB</c>]</b><br/>  </summary>
            public static void MatrixIndexPointerARB(int size, MatrixIndexPointerTypeARB type, int stride, void* pointer) => GLPointers._glMatrixIndexPointerARB_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glMatrixIndexubvARB</c>]</b><br/>  </summary>
            public static void MatrixIndexubvARB(int size, byte* indices) => GLPointers._glMatrixIndexubvARB_fnptr(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glMatrixIndexuivARB</c>]</b><br/>  </summary>
            public static void MatrixIndexuivARB(int size, uint* indices) => GLPointers._glMatrixIndexuivARB_fnptr(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b> <b>[entry point: <c>glMatrixIndexusvARB</c>]</b><br/>  </summary>
            public static void MatrixIndexusvARB(int size, ushort* indices) => GLPointers._glMatrixIndexusvARB_fnptr(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_parallel_shader_compile]</b> <b>[entry point: <c>glMaxShaderCompilerThreadsARB</c>]</b><br/>  </summary>
            public static void MaxShaderCompilerThreadsARB(uint count) => GLPointers._glMaxShaderCompilerThreadsARB_fnptr(count);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> <b>[entry point: <c>glMemoryBarrier</c>]</b><br/> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
            public static void MemoryBarrier(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrier_fnptr((uint)barriers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility]</b> <b>[entry point: <c>glMemoryBarrierByRegion</c>]</b><br/> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
            public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrierByRegion_fnptr((uint)barriers);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glMinmax</c>]</b><br/> Define minmax table. </summary>
            /// <param name="target"> The minmax table whose parameters are to be set. Must be GL_MINMAX. </param>
            /// <param name="internalformat"> The format of entries in the minmax table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="sink"> If GL_TRUE, pixels will be consumed by the minmax process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the final conversion process after minmax. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMinmax.xml" /></remarks>
            public static void Minmax(MinmaxTargetEXT target, InternalFormat internalformat, bool sink) => GLPointers._glMinmax_fnptr((uint)target, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sample_shading]</b> <b>[entry point: <c>glMinSampleShadingARB</c>]</b><br/>  </summary>
            public static void MinSampleShadingARB(float value) => GLPointers._glMinSampleShadingARB_fnptr(value);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawArraysIndirect</c>]</b><br/> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml" /></remarks>
            public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => GLPointers._glMultiDrawArraysIndirect_fnptr((uint)mode, indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_indirect_parameters]</b> <b>[entry point: <c>glMultiDrawArraysIndirectCountARB</c>]</b><br/>  </summary>
            public static void MultiDrawArraysIndirectCountARB(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawArraysIndirectCountARB_fnptr((uint)mode, indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> <b>[entry point: <c>glMultiDrawElementsBaseVertex</c>]</b><br/> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Points to an array of the elements counts. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
            /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml" /></remarks>
            public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => GLPointers._glMultiDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, drawcount, basevertex);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawElementsIndirect</c>]</b><br/> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml" /></remarks>
            public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => GLPointers._glMultiDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_indirect_parameters]</b> <b>[entry point: <c>glMultiDrawElementsIndirectCountARB</c>]</b><br/>  </summary>
            public static void MultiDrawElementsIndirectCountARB(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawElementsIndirectCountARB_fnptr((uint)mode, (uint)type, indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1dARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord1dARB(TextureUnit target, double s) => GLPointers._glMultiTexCoord1dARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1dvARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord1dvARB(TextureUnit target, double* v) => GLPointers._glMultiTexCoord1dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1fARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord1fARB(TextureUnit target, float s) => GLPointers._glMultiTexCoord1fARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1fvARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord1fvARB(TextureUnit target, float* v) => GLPointers._glMultiTexCoord1fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1iARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord1iARB(TextureUnit target, int s) => GLPointers._glMultiTexCoord1iARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1ivARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord1ivARB(TextureUnit target, int* v) => GLPointers._glMultiTexCoord1ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1sARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord1sARB(TextureUnit target, short s) => GLPointers._glMultiTexCoord1sARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord1svARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord1svARB(TextureUnit target, short* v) => GLPointers._glMultiTexCoord1svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2dARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord2dARB(TextureUnit target, double s, double t) => GLPointers._glMultiTexCoord2dARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2dvARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord2dvARB(TextureUnit target, double* v) => GLPointers._glMultiTexCoord2dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2fARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord2fARB(TextureUnit target, float s, float t) => GLPointers._glMultiTexCoord2fARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2fvARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord2fvARB(TextureUnit target, float* v) => GLPointers._glMultiTexCoord2fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2iARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord2iARB(TextureUnit target, int s, int t) => GLPointers._glMultiTexCoord2iARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2ivARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord2ivARB(TextureUnit target, int* v) => GLPointers._glMultiTexCoord2ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2sARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord2sARB(TextureUnit target, short s, short t) => GLPointers._glMultiTexCoord2sARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord2svARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord2svARB(TextureUnit target, short* v) => GLPointers._glMultiTexCoord2svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3dARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord3dARB(TextureUnit target, double s, double t, double r) => GLPointers._glMultiTexCoord3dARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3dvARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord3dvARB(TextureUnit target, double* v) => GLPointers._glMultiTexCoord3dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3fARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord3fARB(TextureUnit target, float s, float t, float r) => GLPointers._glMultiTexCoord3fARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3fvARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord3fvARB(TextureUnit target, float* v) => GLPointers._glMultiTexCoord3fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3iARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord3iARB(TextureUnit target, int s, int t, int r) => GLPointers._glMultiTexCoord3iARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3ivARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord3ivARB(TextureUnit target, int* v) => GLPointers._glMultiTexCoord3ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3sARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord3sARB(TextureUnit target, short s, short t, short r) => GLPointers._glMultiTexCoord3sARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord3svARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord3svARB(TextureUnit target, short* v) => GLPointers._glMultiTexCoord3svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4dARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord4dARB(TextureUnit target, double s, double t, double r, double q) => GLPointers._glMultiTexCoord4dARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4dvARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord4dvARB(TextureUnit target, double* v) => GLPointers._glMultiTexCoord4dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4fARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord4fARB(TextureUnit target, float s, float t, float r, float q) => GLPointers._glMultiTexCoord4fARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4fvARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord4fvARB(TextureUnit target, float* v) => GLPointers._glMultiTexCoord4fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4iARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord4iARB(TextureUnit target, int s, int t, int r, int q) => GLPointers._glMultiTexCoord4iARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4ivARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord4ivARB(TextureUnit target, int* v) => GLPointers._glMultiTexCoord4ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4sARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord4sARB(TextureUnit target, short s, short t, short r, short q) => GLPointers._glMultiTexCoord4sARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b> <b>[entry point: <c>glMultiTexCoord4svARB</c>]</b><br/>  </summary>
            public static void MultiTexCoord4svARB(TextureUnit target, short* v) => GLPointers._glMultiTexCoord4svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP1ui</c>]</b><br/>  </summary>
            public static void MultiTexCoordP1ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP1ui_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP1uiv</c>]</b><br/>  </summary>
            public static void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP1uiv_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP2ui</c>]</b><br/>  </summary>
            public static void MultiTexCoordP2ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP2ui_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP2uiv</c>]</b><br/>  </summary>
            public static void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP2uiv_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP3ui</c>]</b><br/>  </summary>
            public static void MultiTexCoordP3ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP3ui_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP3uiv</c>]</b><br/>  </summary>
            public static void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP3uiv_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP4ui</c>]</b><br/>  </summary>
            public static void MultiTexCoordP4ui(TextureUnit texture, TexCoordPointerType type, uint coords) => GLPointers._glMultiTexCoordP4ui_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glMultiTexCoordP4uiv</c>]</b><br/>  </summary>
            public static void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, uint* coords) => GLPointers._glMultiTexCoordP4uiv_fnptr((uint)texture, (uint)type, coords);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b> <b>[entry point: <c>glMultTransposeMatrixdARB</c>]</b><br/>  </summary>
            public static void MultTransposeMatrixdARB(double* m) => GLPointers._glMultTransposeMatrixdARB_fnptr(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b> <b>[entry point: <c>glMultTransposeMatrixfARB</c>]</b><br/>  </summary>
            public static void MultTransposeMatrixfARB(float* m) => GLPointers._glMultTransposeMatrixfARB_fnptr(m);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferData</c>]</b><br/> Creates and initializes a buffer object&apos;s data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
            public static void NamedBufferData(int buffer, nint size, void* data, VertexBufferObjectUsage usage) => GLPointers._glNamedBufferData_fnptr(buffer, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b> <b>[entry point: <c>glNamedBufferPageCommitmentARB</c>]</b><br/>  </summary>
            public static void NamedBufferPageCommitmentARB(int buffer, IntPtr offset, nint size, bool commit) => GLPointers._glNamedBufferPageCommitmentARB_fnptr(buffer, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b> <b>[entry point: <c>glNamedBufferPageCommitmentEXT</c>]</b><br/>  </summary>
            public static void NamedBufferPageCommitmentEXT(int buffer, IntPtr offset, nint size, bool commit) => GLPointers._glNamedBufferPageCommitmentEXT_fnptr(buffer, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferStorage</c>]</b><br/> Creates and initializes a buffer object&apos;s immutable data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object&apos;s new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer&apos;s data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
            public static void NamedBufferStorage(int buffer, nint size, void* data, BufferStorageMask flags) => GLPointers._glNamedBufferStorage_fnptr(buffer, size, data, (uint)flags);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedBufferSubData</c>]</b><br/> Updates a subset of a buffer object&apos;s data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object&apos;s data store where data replacement will begin, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
            /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
            public static void NamedBufferSubData(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glNamedBufferSubData_fnptr(buffer, offset, size, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferDrawBuffer</c>]</b><br/> Specify which color buffers are to be drawn into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
            /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
            public static void NamedFramebufferDrawBuffer(int framebuffer, ColorBuffer buf) => GLPointers._glNamedFramebufferDrawBuffer_fnptr(framebuffer, (uint)buf);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferDrawBuffers</c>]</b><br/> Specifies a list of color buffers to be drawn    into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
            /// <param name="n">Specifies the number of buffers in bufs.</param>
            /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
            public static void NamedFramebufferDrawBuffers(int framebuffer, int n, ColorBuffer* bufs) => GLPointers._glNamedFramebufferDrawBuffers_fnptr(framebuffer, n, (uint*)bufs);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferParameteri</c>]</b><br/> Set a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
            public static void NamedFramebufferParameteri(int framebuffer, FramebufferParameterName pname, int param) => GLPointers._glNamedFramebufferParameteri_fnptr(framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferReadBuffer</c>]</b><br/> Select a color buffer source for pixels. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
            /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
            public static void NamedFramebufferReadBuffer(int framebuffer, ColorBuffer src) => GLPointers._glNamedFramebufferReadBuffer_fnptr(framebuffer, (uint)src);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferRenderbuffer</c>]</b><br/> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
            public static void NamedFramebufferRenderbuffer(int framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glNamedFramebufferRenderbuffer_fnptr(framebuffer, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b> <b>[entry point: <c>glNamedFramebufferSampleLocationsfvARB</c>]</b><br/>  </summary>
            public static void NamedFramebufferSampleLocationsfvARB(int framebuffer, uint start, int count, float* v) => GLPointers._glNamedFramebufferSampleLocationsfvARB_fnptr(framebuffer, start, count, v);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture</c>]</b><br/> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void NamedFramebufferTexture(int framebuffer, FramebufferAttachment attachment, int texture, int level) => GLPointers._glNamedFramebufferTexture_fnptr(framebuffer, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureLayer</c>]</b><br/> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
            public static void NamedFramebufferTextureLayer(int framebuffer, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glNamedFramebufferTextureLayer_fnptr(framebuffer, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorage</c>]</b><br/> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
            public static void NamedRenderbufferStorage(int renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorage_fnptr(renderbuffer, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisample</c>]</b><br/> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
            public static void NamedRenderbufferStorageMultisample(int renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisample_fnptr(renderbuffer, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b> <b>[entry point: <c>glNamedStringARB</c>]</b><br/>  </summary>
            public static void NamedStringARB(All type, int namelen, byte* name, int stringlen, byte* str) => GLPointers._glNamedStringARB_fnptr((uint)type, namelen, name, stringlen, str);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glNormalP3ui</c>]</b><br/>  </summary>
            public static void NormalP3ui(NormalPointerType type, uint coords) => GLPointers._glNormalP3ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glNormalP3uiv</c>]</b><br/>  </summary>
            public static void NormalP3uiv(NormalPointerType type, uint* coords) => GLPointers._glNormalP3uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> <b>[entry point: <c>glPatchParameterfv</c>]</b><br/> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
            public static void PatchParameterfv(PatchParameterName pname, float* values) => GLPointers._glPatchParameterfv_fnptr((uint)pname, values);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> <b>[entry point: <c>glPatchParameteri</c>]</b><br/> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
            public static void PatchParameteri(PatchParameterName pname, int value) => GLPointers._glPatchParameteri_fnptr((uint)pname, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glPauseTransformFeedback</c>]</b><br/> Pause transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml" /></remarks>
            public static void PauseTransformFeedback() => GLPointers._glPauseTransformFeedback_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_point_parameters]</b> <b>[entry point: <c>glPointParameterfARB</c>]</b><br/>  </summary>
            public static void PointParameterfARB(PointParameterNameARB pname, float param) => GLPointers._glPointParameterfARB_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ARB_point_parameters]</b> <b>[entry point: <c>glPointParameterfvARB</c>]</b><br/>  </summary>
            public static void PointParameterfvARB(PointParameterNameARB pname, float* parameters) => GLPointers._glPointParameterfvARB_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp]</b> <b>[entry point: <c>glPolygonOffsetClamp</c>]</b><br/>  </summary>
            public static void PolygonOffsetClamp(float factor, float units, float clamp) => GLPointers._glPolygonOffsetClamp_fnptr(factor, units, clamp);
            
            /// <summary> <b>[requires: GL_ARB_ES3_2_compatibility]</b> <b>[entry point: <c>glPrimitiveBoundingBoxARB</c>]</b><br/>  </summary>
            public static void PrimitiveBoundingBoxARB(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) => GLPointers._glPrimitiveBoundingBoxARB_fnptr(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> <b>[entry point: <c>glProgramBinary</c>]</b><br/> Load a program object with a program binary. </summary>
            /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
            /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
            /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
            /// <param name="length"> Specifies the number of bytes contained in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml" /></remarks>
            public static void ProgramBinary(int program, All binaryFormat, void* binary, int length) => GLPointers._glProgramBinary_fnptr(program, (uint)binaryFormat, binary, length);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramEnvParameter4dARB</c>]</b><br/>  </summary>
            public static void ProgramEnvParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers._glProgramEnvParameter4dARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramEnvParameter4dvARB</c>]</b><br/>  </summary>
            public static void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, double* parameters) => GLPointers._glProgramEnvParameter4dvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramEnvParameter4fARB</c>]</b><br/>  </summary>
            public static void ProgramEnvParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers._glProgramEnvParameter4fARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramEnvParameter4fvARB</c>]</b><br/>  </summary>
            public static void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, float* parameters) => GLPointers._glProgramEnvParameter4fvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramLocalParameter4dARB</c>]</b><br/>  </summary>
            public static void ProgramLocalParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers._glProgramLocalParameter4dARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramLocalParameter4dvARB</c>]</b><br/>  </summary>
            public static void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, double* parameters) => GLPointers._glProgramLocalParameter4dvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramLocalParameter4fARB</c>]</b><br/>  </summary>
            public static void ProgramLocalParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers._glProgramLocalParameter4fARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramLocalParameter4fvARB</c>]</b><br/>  </summary>
            public static void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, float* parameters) => GLPointers._glProgramLocalParameter4fvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramParameteri</c>]</b><br/> Specify a parameter for a program object. </summary>
            /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the name of the parameter to modify. </param>
            /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml" /></remarks>
            public static void ProgramParameteri(int program, ProgramParameterPName pname, int value) => GLPointers._glProgramParameteri_fnptr(program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b> <b>[entry point: <c>glProgramParameteriARB</c>]</b><br/>  </summary>
            public static void ProgramParameteriARB(int program, ProgramParameterPName pname, int value) => GLPointers._glProgramParameteriARB_fnptr(program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b> <b>[entry point: <c>glProgramStringARB</c>]</b><br/>  </summary>
            public static void ProgramStringARB(ProgramTarget target, ProgramFormat format, int len, void* str) => GLPointers._glProgramStringARB_fnptr((uint)target, (uint)format, len, str);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1d</c>]</b><br/>  </summary>
            public static void ProgramUniform1d(int program, int location, double v0) => GLPointers._glProgramUniform1d_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1dv</c>]</b><br/>  </summary>
            public static void ProgramUniform1dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform1dv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1f(int program, int location, float v0) => GLPointers._glProgramUniform1f_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform1fv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1i(int program, int location, int v0) => GLPointers._glProgramUniform1i_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform1i64ARB</c>]</b><br/>  </summary>
            public static void ProgramUniform1i64ARB(int program, int location, long x) => GLPointers._glProgramUniform1i64ARB_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform1i64vARB</c>]</b><br/>  </summary>
            public static void ProgramUniform1i64vARB(int program, int location, int count, long* value) => GLPointers._glProgramUniform1i64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform1iv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1ui(int program, int location, uint v0) => GLPointers._glProgramUniform1ui_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform1ui64ARB</c>]</b><br/>  </summary>
            public static void ProgramUniform1ui64ARB(int program, int location, ulong x) => GLPointers._glProgramUniform1ui64ARB_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform1ui64vARB</c>]</b><br/>  </summary>
            public static void ProgramUniform1ui64vARB(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform1ui64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform1uiv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2d</c>]</b><br/>  </summary>
            public static void ProgramUniform2d(int program, int location, double v0, double v1) => GLPointers._glProgramUniform2d_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2dv</c>]</b><br/>  </summary>
            public static void ProgramUniform2dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform2dv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2f(int program, int location, float v0, float v1) => GLPointers._glProgramUniform2f_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform2fv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2i(int program, int location, int v0, int v1) => GLPointers._glProgramUniform2i_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform2i64ARB</c>]</b><br/>  </summary>
            public static void ProgramUniform2i64ARB(int program, int location, long x, long y) => GLPointers._glProgramUniform2i64ARB_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform2i64vARB</c>]</b><br/>  </summary>
            public static void ProgramUniform2i64vARB(int program, int location, int count, long* value) => GLPointers._glProgramUniform2i64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform2iv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2ui(int program, int location, uint v0, uint v1) => GLPointers._glProgramUniform2ui_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform2ui64ARB</c>]</b><br/>  </summary>
            public static void ProgramUniform2ui64ARB(int program, int location, ulong x, ulong y) => GLPointers._glProgramUniform2ui64ARB_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform2ui64vARB</c>]</b><br/>  </summary>
            public static void ProgramUniform2ui64vARB(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform2ui64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform2uiv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3d</c>]</b><br/>  </summary>
            public static void ProgramUniform3d(int program, int location, double v0, double v1, double v2) => GLPointers._glProgramUniform3d_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3dv</c>]</b><br/>  </summary>
            public static void ProgramUniform3dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform3dv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3f(int program, int location, float v0, float v1, float v2) => GLPointers._glProgramUniform3f_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform3fv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3i(int program, int location, int v0, int v1, int v2) => GLPointers._glProgramUniform3i_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform3i64ARB</c>]</b><br/>  </summary>
            public static void ProgramUniform3i64ARB(int program, int location, long x, long y, long z) => GLPointers._glProgramUniform3i64ARB_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform3i64vARB</c>]</b><br/>  </summary>
            public static void ProgramUniform3i64vARB(int program, int location, int count, long* value) => GLPointers._glProgramUniform3i64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform3iv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3ui(int program, int location, uint v0, uint v1, uint v2) => GLPointers._glProgramUniform3ui_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform3ui64ARB</c>]</b><br/>  </summary>
            public static void ProgramUniform3ui64ARB(int program, int location, ulong x, ulong y, ulong z) => GLPointers._glProgramUniform3ui64ARB_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform3ui64vARB</c>]</b><br/>  </summary>
            public static void ProgramUniform3ui64vARB(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform3ui64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform3uiv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4d</c>]</b><br/>  </summary>
            public static void ProgramUniform4d(int program, int location, double v0, double v1, double v2, double v3) => GLPointers._glProgramUniform4d_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4dv</c>]</b><br/>  </summary>
            public static void ProgramUniform4dv(int program, int location, int count, double* value) => GLPointers._glProgramUniform4dv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4f</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3) => GLPointers._glProgramUniform4f_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4fv(int program, int location, int count, float* value) => GLPointers._glProgramUniform4fv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4i</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3) => GLPointers._glProgramUniform4i_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform4i64ARB</c>]</b><br/>  </summary>
            public static void ProgramUniform4i64ARB(int program, int location, long x, long y, long z, long w) => GLPointers._glProgramUniform4i64ARB_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform4i64vARB</c>]</b><br/>  </summary>
            public static void ProgramUniform4i64vARB(int program, int location, int count, long* value) => GLPointers._glProgramUniform4i64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4iv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4iv(int program, int location, int count, int* value) => GLPointers._glProgramUniform4iv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4ui</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4ui(int program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glProgramUniform4ui_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform4ui64ARB</c>]</b><br/>  </summary>
            public static void ProgramUniform4ui64ARB(int program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glProgramUniform4ui64ARB_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glProgramUniform4ui64vARB</c>]</b><br/>  </summary>
            public static void ProgramUniform4ui64vARB(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform4ui64vARB_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4uiv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4uiv(int program, int location, int count, uint* value) => GLPointers._glProgramUniform4uiv_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glProgramUniformHandleui64ARB</c>]</b><br/>  </summary>
            public static void ProgramUniformHandleui64ARB(int program, int location, ulong value) => GLPointers._glProgramUniformHandleui64ARB_fnptr(program, location, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glProgramUniformHandleui64vARB</c>]</b><br/>  </summary>
            public static void ProgramUniformHandleui64vARB(int program, int location, int count, ulong* values) => GLPointers._glProgramUniformHandleui64vARB_fnptr(program, location, count, values);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2dv</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3dv</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix2x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4dv</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix2x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3dv</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2dv</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix3x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4dv</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix3x4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3x4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4dv</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix4dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2dv</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix4x2dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x2dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4x2fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x2fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3dv</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix4x3dv(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x3dv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3fv</c>]</b><br/> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4x3fv(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x3fv_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex]</b> <b>[entry point: <c>glProvokingVertex</c>]</b><br/> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
            /// <param name="provokeMode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml" /></remarks>
            public static void ProvokingVertex(VertexProvokingMode mode) => GLPointers._glProvokingVertex_fnptr((uint)mode);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> <b>[entry point: <c>glQueryCounter</c>]</b><br/> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
            /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
            /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml" /></remarks>
            public static void QueryCounter(int id, QueryCounterTarget target) => GLPointers._glQueryCounter_fnptr(id, (uint)target);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b> <b>[entry point: <c>glReadnPixelsARB</c>]</b><br/>  </summary>
            public static void ReadnPixelsARB(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._glReadnPixelsARB_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glReleaseShaderCompiler</c>]</b><br/> Release resources consumed by the implementation&apos;s shader compiler. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml" /></remarks>
            public static void ReleaseShaderCompiler() => GLPointers._glReleaseShaderCompiler_fnptr();
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorage</c>]</b><br/> Establish data storage, format and dimensions of a    renderbuffer object&apos;s image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
            public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorage_fnptr((uint)target, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorageMultisample</c>]</b><br/> Establish data storage, format, dimensions and sample count of    a renderbuffer object&apos;s image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object&apos;s storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object&apos;s image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
            public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glResetHistogram</c>]</b><br/> Reset histogram table entries to zero. </summary>
            /// <param name="target"> Must be GL_HISTOGRAM. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glResetHistogram.xml" /></remarks>
            public static void ResetHistogram(HistogramTargetEXT target) => GLPointers._glResetHistogram_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glResetMinmax</c>]</b><br/> Reset minmax table entries to initial values. </summary>
            /// <param name="target"> Must be GL_MINMAX. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glResetMinmax.xml" /></remarks>
            public static void ResetMinmax(MinmaxTargetEXT target) => GLPointers._glResetMinmax_fnptr((uint)target);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> <b>[entry point: <c>glResumeTransformFeedback</c>]</b><br/> Resume transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml" /></remarks>
            public static void ResumeTransformFeedback() => GLPointers._glResumeTransformFeedback_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_multisample]</b> <b>[entry point: <c>glSampleCoverageARB</c>]</b><br/>  </summary>
            public static void SampleCoverageARB(float value, bool invert) => GLPointers._glSampleCoverageARB_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glSampleMaski</c>]</b><br/> Set the value of a sub-word of the sample mask. </summary>
            /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
            /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml" /></remarks>
            public static void SampleMaski(uint maskNumber, uint mask) => GLPointers._glSampleMaski_fnptr(maskNumber, mask);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterf</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterf(int sampler, SamplerParameterF pname, float param) => GLPointers._glSamplerParameterf_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterfv</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterfv(int sampler, SamplerParameterF pname, float* param) => GLPointers._glSamplerParameterfv_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameteri</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameteri(int sampler, SamplerParameterI pname, int param) => GLPointers._glSamplerParameteri_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterIiv</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterIiv(int sampler, SamplerParameterI pname, int* param) => GLPointers._glSamplerParameterIiv_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameterIuiv</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterIuiv(int sampler, SamplerParameterI pname, uint* param) => GLPointers._glSamplerParameterIuiv_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> <b>[entry point: <c>glSamplerParameteriv</c>]</b><br/> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameteriv(int sampler, SamplerParameterI pname, int* param) => GLPointers._glSamplerParameteriv_fnptr(sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorArrayv</c>]</b><br/> Define the scissor box for multiple viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
            /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
            /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml" /></remarks>
            public static void ScissorArrayv(uint first, int count, int* v) => GLPointers._glScissorArrayv_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorIndexed</c>]</b><br/> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
            public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => GLPointers._glScissorIndexed_fnptr(index, left, bottom, width, height);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glScissorIndexedv</c>]</b><br/> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
            public static void ScissorIndexedv(uint index, int* v) => GLPointers._glScissorIndexedv_fnptr(index, v);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glSecondaryColorP3ui</c>]</b><br/>  </summary>
            public static void SecondaryColorP3ui(ColorPointerType type, uint color) => GLPointers._glSecondaryColorP3ui_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glSecondaryColorP3uiv</c>]</b><br/>  </summary>
            public static void SecondaryColorP3uiv(ColorPointerType type, uint* color) => GLPointers._glSecondaryColorP3uiv_fnptr((uint)type, color);
            
            /// <summary> <b>[requires: GL_ARB_imaging]</b> <b>[entry point: <c>glSeparableFilter2D</c>]</b><br/> Define a separable two-dimensional convolution filter. </summary>
            /// <param name="target"> Must be GL_SEPARABLE_2D. </param>
            /// <param name="internalformat"> The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16. </param>
            /// <param name="width"> The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.) </param>
            /// <param name="height"> The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.) </param>
            /// <param name="format"> The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA. </param>
            /// <param name="type"> The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted. </param>
            /// <param name="row"> Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel. </param>
            /// <param name="column"> Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glSeparableFilter2D.xml" /></remarks>
            public static void SeparableFilter2D(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column) => GLPointers._glSeparableFilter2D_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, row, column);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> <b>[entry point: <c>glShaderBinary</c>]</b><br/> Load pre-compiled shader binaries. </summary>
            /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
            /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
            /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
            /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
            /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml" /></remarks>
            public static void ShaderBinary(int count, int* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => GLPointers._glShaderBinary_fnptr(count, shaders, (uint)binaryFormat, binary, length);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glShaderSourceARB</c>]</b><br/>  </summary>
            public static void ShaderSourceARB(GLHandleARB shaderObj, int count, byte** str, int* length) => GLPointers._glShaderSourceARB_fnptr((IntPtr)shaderObj, count, str, length);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object]</b> <b>[entry point: <c>glShaderStorageBlockBinding</c>]</b><br/> Change an active shader storage block binding. </summary>
            /// <param name="program"> The name of the program containing the block whose binding to change. </param>
            /// <param name="storageBlockIndex"> The index storage block within the program. </param>
            /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml" /></remarks>
            public static void ShaderStorageBlockBinding(int program, uint storageBlockIndex, uint storageBlockBinding) => GLPointers._glShaderStorageBlockBinding_fnptr(program, storageBlockIndex, storageBlockBinding);
            
            /// <summary> <b>[requires: GL_ARB_gl_spirv]</b> <b>[entry point: <c>glSpecializeShaderARB</c>]</b><br/>  </summary>
            public static void SpecializeShaderARB(int shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => GLPointers._glSpecializeShaderARB_fnptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
            
            /// <summary> <b>[requires: GL_ARB_texture_buffer_object]</b> <b>[entry point: <c>glTexBufferARB</c>]</b><br/>  </summary>
            public static void TexBufferARB(TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers._glTexBufferARB_fnptr((uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range]</b> <b>[entry point: <c>glTexBufferRange</c>]</b><br/> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
            public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTexBufferRange_fnptr((uint)target, (uint)internalformat, buffer, offset, size);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP1ui</c>]</b><br/>  </summary>
            public static void TexCoordP1ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP1ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP1uiv</c>]</b><br/>  </summary>
            public static void TexCoordP1uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP1uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP2ui</c>]</b><br/>  </summary>
            public static void TexCoordP2ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP2ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP2uiv</c>]</b><br/>  </summary>
            public static void TexCoordP2uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP2uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP3ui</c>]</b><br/>  </summary>
            public static void TexCoordP3ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP3ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP3uiv</c>]</b><br/>  </summary>
            public static void TexCoordP3uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP3uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP4ui</c>]</b><br/>  </summary>
            public static void TexCoordP4ui(TexCoordPointerType type, uint coords) => GLPointers._glTexCoordP4ui_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glTexCoordP4uiv</c>]</b><br/>  </summary>
            public static void TexCoordP4uiv(TexCoordPointerType type, uint* coords) => GLPointers._glTexCoordP4uiv_fnptr((uint)type, coords);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glTexImage2DMultisample</c>]</b><br/> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
            /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml" /></remarks>
            public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTexImage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> <b>[entry point: <c>glTexImage3DMultisample</c>]</b><br/> Establish the data storage, format, dimensions, and number of samples of a multisample texture&apos;s image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> The number of samples in the multisample texture&apos;s image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture&apos;s image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture&apos;s image, in texels. </param>
            /// <param name="height"> The height of the multisample texture&apos;s image, in texels. </param>
            /// <param name="depth">!!missing documentation!!</param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml" /></remarks>
            public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTexImage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_texture]</b> <b>[entry point: <c>glTexPageCommitmentARB</c>]</b><br/>  </summary>
            public static void TexPageCommitmentARB(All target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => GLPointers._glTexPageCommitmentARB_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage1D</c>]</b><br/> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
            public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTexStorage1D_fnptr((uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage2D</c>]</b><br/> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
            public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTexStorage2D_fnptr((uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> <b>[entry point: <c>glTexStorage2DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
            public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTexStorage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> <b>[entry point: <c>glTexStorage3D</c>]</b><br/> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
            public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTexStorage3D_fnptr((uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> <b>[entry point: <c>glTexStorage3DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
            public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTexStorage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier]</b> <b>[entry point: <c>glTextureBarrier</c>]</b><br/> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml" /></remarks>
            public static void TextureBarrier() => GLPointers._glTextureBarrier_fnptr();
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureBuffer</c>]</b><br/> Attach a buffer object&apos;s data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
            public static void TextureBuffer(int texture, SizedInternalFormat internalformat, int buffer) => GLPointers._glTextureBuffer_fnptr(texture, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureBufferRange</c>]</b><br/> Attach a range of a buffer object&apos;s data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer&apos;s data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer&apos;s data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
            public static void TextureBufferRange(int texture, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTextureBufferRange_fnptr(texture, (uint)internalformat, buffer, offset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterf</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterf(int texture, TextureParameterName pname, float param) => GLPointers._glTextureParameterf_fnptr(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterfv</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterfv(int texture, TextureParameterName pname, float* param) => GLPointers._glTextureParameterfv_fnptr(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameteri</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameteri(int texture, TextureParameterName pname, int param) => GLPointers._glTextureParameteri_fnptr(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIiv</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterIiv(int texture, TextureParameterName pname, int* parameters) => GLPointers._glTextureParameterIiv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIuiv</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterIuiv(int texture, TextureParameterName pname, uint* parameters) => GLPointers._glTextureParameterIuiv_fnptr(texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureParameteriv</c>]</b><br/> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameteriv(int texture, TextureParameterName pname, int* param) => GLPointers._glTextureParameteriv_fnptr(texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage1D</c>]</b><br/> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
            public static void TextureStorage1D(int texture, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTextureStorage1D_fnptr(texture, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2D</c>]</b><br/> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
            public static void TextureStorage2D(int texture, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTextureStorage2D_fnptr(texture, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
            public static void TextureStorage2DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTextureStorage2DMultisample_fnptr(texture, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3D</c>]</b><br/> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
            public static void TextureStorage3D(int texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTextureStorage3D_fnptr(texture, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3DMultisample</c>]</b><br/> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
            public static void TextureStorage3DMultisample(int texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTextureStorage3DMultisample_fnptr(texture, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage1D</c>]</b><br/> Specify a one-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
            public static void TextureSubImage1D(int texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage1D_fnptr(texture, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage2D</c>]</b><br/> Specify a two-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
            public static void TextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage2D_fnptr(texture, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage3D</c>]</b><br/> Specify a three-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="depth"> Specifies the depth of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
            public static void TextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage3D_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view]</b> <b>[entry point: <c>glTextureView</c>]</b><br/> Initialize a texture as a data alias of another texture&apos;s data store. </summary>
            /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
            /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
            /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
            /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
            /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
            /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
            /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
            /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml" /></remarks>
            public static void TextureView(int texture, TextureTarget target, int origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => GLPointers._glTextureView_fnptr(texture, (uint)target, origtexture, (uint)internalformat, minlevel, numlevels, minlayer, numlayers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTransformFeedbackBufferBase</c>]</b><br/> Bind a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml" /></remarks>
            public static void TransformFeedbackBufferBase(int xfb, uint index, int buffer) => GLPointers._glTransformFeedbackBufferBase_fnptr(xfb, index, buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glTransformFeedbackBufferRange</c>]</b><br/> Bind a range within a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
            /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml" /></remarks>
            public static void TransformFeedbackBufferRange(int xfb, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glTransformFeedbackBufferRange_fnptr(xfb, index, buffer, offset, size);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform1d</c>]</b><br/>  </summary>
            public static void Uniform1d(int location, double x) => GLPointers._glUniform1d_fnptr(location, x);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform1dv</c>]</b><br/>  </summary>
            public static void Uniform1dv(int location, int count, double* value) => GLPointers._glUniform1dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform1fARB</c>]</b><br/>  </summary>
            public static void Uniform1fARB(int location, float v0) => GLPointers._glUniform1fARB_fnptr(location, v0);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform1fvARB</c>]</b><br/>  </summary>
            public static void Uniform1fvARB(int location, int count, float* value) => GLPointers._glUniform1fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform1i64ARB</c>]</b><br/>  </summary>
            public static void Uniform1i64ARB(int location, long x) => GLPointers._glUniform1i64ARB_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform1i64vARB</c>]</b><br/>  </summary>
            public static void Uniform1i64vARB(int location, int count, long* value) => GLPointers._glUniform1i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform1iARB</c>]</b><br/>  </summary>
            public static void Uniform1iARB(int location, int v0) => GLPointers._glUniform1iARB_fnptr(location, v0);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform1ivARB</c>]</b><br/>  </summary>
            public static void Uniform1ivARB(int location, int count, int* value) => GLPointers._glUniform1ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform1ui64ARB</c>]</b><br/>  </summary>
            public static void Uniform1ui64ARB(int location, ulong x) => GLPointers._glUniform1ui64ARB_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform1ui64vARB</c>]</b><br/>  </summary>
            public static void Uniform1ui64vARB(int location, int count, ulong* value) => GLPointers._glUniform1ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform2d</c>]</b><br/>  </summary>
            public static void Uniform2d(int location, double x, double y) => GLPointers._glUniform2d_fnptr(location, x, y);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform2dv</c>]</b><br/>  </summary>
            public static void Uniform2dv(int location, int count, double* value) => GLPointers._glUniform2dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform2fARB</c>]</b><br/>  </summary>
            public static void Uniform2fARB(int location, float v0, float v1) => GLPointers._glUniform2fARB_fnptr(location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform2fvARB</c>]</b><br/>  </summary>
            public static void Uniform2fvARB(int location, int count, float* value) => GLPointers._glUniform2fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform2i64ARB</c>]</b><br/>  </summary>
            public static void Uniform2i64ARB(int location, long x, long y) => GLPointers._glUniform2i64ARB_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform2i64vARB</c>]</b><br/>  </summary>
            public static void Uniform2i64vARB(int location, int count, long* value) => GLPointers._glUniform2i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform2iARB</c>]</b><br/>  </summary>
            public static void Uniform2iARB(int location, int v0, int v1) => GLPointers._glUniform2iARB_fnptr(location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform2ivARB</c>]</b><br/>  </summary>
            public static void Uniform2ivARB(int location, int count, int* value) => GLPointers._glUniform2ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform2ui64ARB</c>]</b><br/>  </summary>
            public static void Uniform2ui64ARB(int location, ulong x, ulong y) => GLPointers._glUniform2ui64ARB_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform2ui64vARB</c>]</b><br/>  </summary>
            public static void Uniform2ui64vARB(int location, int count, ulong* value) => GLPointers._glUniform2ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform3d</c>]</b><br/>  </summary>
            public static void Uniform3d(int location, double x, double y, double z) => GLPointers._glUniform3d_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform3dv</c>]</b><br/>  </summary>
            public static void Uniform3dv(int location, int count, double* value) => GLPointers._glUniform3dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform3fARB</c>]</b><br/>  </summary>
            public static void Uniform3fARB(int location, float v0, float v1, float v2) => GLPointers._glUniform3fARB_fnptr(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform3fvARB</c>]</b><br/>  </summary>
            public static void Uniform3fvARB(int location, int count, float* value) => GLPointers._glUniform3fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform3i64ARB</c>]</b><br/>  </summary>
            public static void Uniform3i64ARB(int location, long x, long y, long z) => GLPointers._glUniform3i64ARB_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform3i64vARB</c>]</b><br/>  </summary>
            public static void Uniform3i64vARB(int location, int count, long* value) => GLPointers._glUniform3i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform3iARB</c>]</b><br/>  </summary>
            public static void Uniform3iARB(int location, int v0, int v1, int v2) => GLPointers._glUniform3iARB_fnptr(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform3ivARB</c>]</b><br/>  </summary>
            public static void Uniform3ivARB(int location, int count, int* value) => GLPointers._glUniform3ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform3ui64ARB</c>]</b><br/>  </summary>
            public static void Uniform3ui64ARB(int location, ulong x, ulong y, ulong z) => GLPointers._glUniform3ui64ARB_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform3ui64vARB</c>]</b><br/>  </summary>
            public static void Uniform3ui64vARB(int location, int count, ulong* value) => GLPointers._glUniform3ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform4d</c>]</b><br/>  </summary>
            public static void Uniform4d(int location, double x, double y, double z, double w) => GLPointers._glUniform4d_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniform4dv</c>]</b><br/>  </summary>
            public static void Uniform4dv(int location, int count, double* value) => GLPointers._glUniform4dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform4fARB</c>]</b><br/>  </summary>
            public static void Uniform4fARB(int location, float v0, float v1, float v2, float v3) => GLPointers._glUniform4fARB_fnptr(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform4fvARB</c>]</b><br/>  </summary>
            public static void Uniform4fvARB(int location, int count, float* value) => GLPointers._glUniform4fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform4i64ARB</c>]</b><br/>  </summary>
            public static void Uniform4i64ARB(int location, long x, long y, long z, long w) => GLPointers._glUniform4i64ARB_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform4i64vARB</c>]</b><br/>  </summary>
            public static void Uniform4i64vARB(int location, int count, long* value) => GLPointers._glUniform4i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform4iARB</c>]</b><br/>  </summary>
            public static void Uniform4iARB(int location, int v0, int v1, int v2, int v3) => GLPointers._glUniform4iARB_fnptr(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniform4ivARB</c>]</b><br/>  </summary>
            public static void Uniform4ivARB(int location, int count, int* value) => GLPointers._glUniform4ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform4ui64ARB</c>]</b><br/>  </summary>
            public static void Uniform4ui64ARB(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glUniform4ui64ARB_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b> <b>[entry point: <c>glUniform4ui64vARB</c>]</b><br/>  </summary>
            public static void Uniform4ui64vARB(int location, int count, ulong* value) => GLPointers._glUniform4ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> <b>[entry point: <c>glUniformBlockBinding</c>]</b><br/> Assign a binding point to an active uniform block. </summary>
            /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
            /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
            /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml" /></remarks>
            public static void UniformBlockBinding(int program, uint uniformBlockIndex, uint uniformBlockBinding) => GLPointers._glUniformBlockBinding_fnptr(program, uniformBlockIndex, uniformBlockBinding);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glUniformHandleui64ARB</c>]</b><br/>  </summary>
            public static void UniformHandleui64ARB(int location, ulong value) => GLPointers._glUniformHandleui64ARB_fnptr(location, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glUniformHandleui64vARB</c>]</b><br/>  </summary>
            public static void UniformHandleui64vARB(int location, int count, ulong* value) => GLPointers._glUniformHandleui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2dv</c>]</b><br/>  </summary>
            public static void UniformMatrix2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniformMatrix2fvARB</c>]</b><br/>  </summary>
            public static void UniformMatrix2fvARB(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix2fvARB_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2x3dv</c>]</b><br/>  </summary>
            public static void UniformMatrix2x3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix2x4dv</c>]</b><br/>  </summary>
            public static void UniformMatrix2x4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix2x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3dv</c>]</b><br/>  </summary>
            public static void UniformMatrix3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniformMatrix3fvARB</c>]</b><br/>  </summary>
            public static void UniformMatrix3fvARB(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix3fvARB_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3x2dv</c>]</b><br/>  </summary>
            public static void UniformMatrix3x2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix3x4dv</c>]</b><br/>  </summary>
            public static void UniformMatrix3x4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix3x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4dv</c>]</b><br/>  </summary>
            public static void UniformMatrix4dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUniformMatrix4fvARB</c>]</b><br/>  </summary>
            public static void UniformMatrix4fvARB(int location, int count, bool transpose, float* value) => GLPointers._glUniformMatrix4fvARB_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4x2dv</c>]</b><br/>  </summary>
            public static void UniformMatrix4x2dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> <b>[entry point: <c>glUniformMatrix4x3dv</c>]</b><br/>  </summary>
            public static void UniformMatrix4x3dv(int location, int count, bool transpose, double* value) => GLPointers._glUniformMatrix4x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> <b>[entry point: <c>glUniformSubroutinesuiv</c>]</b><br/> Load active subroutine uniforms. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
            /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml" /></remarks>
            public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => GLPointers._glUniformSubroutinesuiv_fnptr((uint)shadertype, count, indices);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b> <b>[entry point: <c>glUnmapBufferARB</c>]</b><br/>  </summary>
            public static bool UnmapBufferARB(BufferTargetARB target) => GLPointers._glUnmapBufferARB_fnptr((uint)target) != 0;
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glUnmapNamedBuffer</c>]</b><br/> Release the mapping of a buffer object&apos;s data store into the client&apos;s address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
            public static bool UnmapNamedBuffer(int buffer) => GLPointers._glUnmapNamedBuffer_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glUseProgramObjectARB</c>]</b><br/>  </summary>
            public static void UseProgramObjectARB(GLHandleARB programObj) => GLPointers._glUseProgramObjectARB_fnptr((IntPtr)programObj);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glUseProgramStages</c>]</b><br/> Bind stages of a program object to a program pipeline. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
            /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
            /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml" /></remarks>
            public static void UseProgramStages(int pipeline, UseProgramStageMask stages, int program) => GLPointers._glUseProgramStages_fnptr(pipeline, (uint)stages, program);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b> <b>[entry point: <c>glValidateProgramARB</c>]</b><br/>  </summary>
            public static void ValidateProgramARB(GLHandleARB programObj) => GLPointers._glValidateProgramARB_fnptr((IntPtr)programObj);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> <b>[entry point: <c>glValidateProgramPipeline</c>]</b><br/> Validate a program pipeline object against current GL state. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml" /></remarks>
            public static void ValidateProgramPipeline(int pipeline) => GLPointers._glValidateProgramPipeline_fnptr(pipeline);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribBinding</c>]</b><br/> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
            public static void VertexArrayAttribBinding(int vaobj, uint attribindex, uint bindingindex) => GLPointers._glVertexArrayAttribBinding_fnptr(vaobj, attribindex, bindingindex);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribFormat(int vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexArrayAttribFormat_fnptr(vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribIFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribIFormat(int vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexArrayAttribIFormat_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayAttribLFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribLFormat(int vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexArrayAttribLFormat_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayBindingDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
            public static void VertexArrayBindingDivisor(int vaobj, uint bindingindex, uint divisor) => GLPointers._glVertexArrayBindingDivisor_fnptr(vaobj, bindingindex, divisor);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayElementBuffer</c>]</b><br/> Configures element array buffer binding of a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
            /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml" /></remarks>
            public static void VertexArrayElementBuffer(int vaobj, int buffer) => GLPointers._glVertexArrayElementBuffer_fnptr(vaobj, buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBuffer</c>]</b><br/> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
            public static void VertexArrayVertexBuffer(int vaobj, uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glVertexArrayVertexBuffer_fnptr(vaobj, bindingindex, buffer, offset, stride);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBuffers</c>]</b><br/> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
            public static void VertexArrayVertexBuffers(int vaobj, uint first, int count, int* buffers, IntPtr* offsets, int* strides) => GLPointers._glVertexArrayVertexBuffers_fnptr(vaobj, first, count, buffers, offsets, strides);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1dARB</c>]</b><br/>  </summary>
            public static void VertexAttrib1dARB(uint index, double x) => GLPointers._glVertexAttrib1dARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1dvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib1dvARB(uint index, double* v) => GLPointers._glVertexAttrib1dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1fARB</c>]</b><br/>  </summary>
            public static void VertexAttrib1fARB(uint index, float x) => GLPointers._glVertexAttrib1fARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1fvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib1fvARB(uint index, float* v) => GLPointers._glVertexAttrib1fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1sARB</c>]</b><br/>  </summary>
            public static void VertexAttrib1sARB(uint index, short x) => GLPointers._glVertexAttrib1sARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib1svARB</c>]</b><br/>  </summary>
            public static void VertexAttrib1svARB(uint index, short* v) => GLPointers._glVertexAttrib1svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2dARB</c>]</b><br/>  </summary>
            public static void VertexAttrib2dARB(uint index, double x, double y) => GLPointers._glVertexAttrib2dARB_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2dvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib2dvARB(uint index, double* v) => GLPointers._glVertexAttrib2dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2fARB</c>]</b><br/>  </summary>
            public static void VertexAttrib2fARB(uint index, float x, float y) => GLPointers._glVertexAttrib2fARB_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2fvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib2fvARB(uint index, float* v) => GLPointers._glVertexAttrib2fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2sARB</c>]</b><br/>  </summary>
            public static void VertexAttrib2sARB(uint index, short x, short y) => GLPointers._glVertexAttrib2sARB_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib2svARB</c>]</b><br/>  </summary>
            public static void VertexAttrib2svARB(uint index, short* v) => GLPointers._glVertexAttrib2svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3dARB</c>]</b><br/>  </summary>
            public static void VertexAttrib3dARB(uint index, double x, double y, double z) => GLPointers._glVertexAttrib3dARB_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3dvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib3dvARB(uint index, double* v) => GLPointers._glVertexAttrib3dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3fARB</c>]</b><br/>  </summary>
            public static void VertexAttrib3fARB(uint index, float x, float y, float z) => GLPointers._glVertexAttrib3fARB_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3fvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib3fvARB(uint index, float* v) => GLPointers._glVertexAttrib3fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3sARB</c>]</b><br/>  </summary>
            public static void VertexAttrib3sARB(uint index, short x, short y, short z) => GLPointers._glVertexAttrib3sARB_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib3svARB</c>]</b><br/>  </summary>
            public static void VertexAttrib3svARB(uint index, short* v) => GLPointers._glVertexAttrib3svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4bvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4bvARB(uint index, sbyte* v) => GLPointers._glVertexAttrib4bvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4dARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4dARB(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttrib4dARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4dvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4dvARB(uint index, double* v) => GLPointers._glVertexAttrib4dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4fARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4fARB(uint index, float x, float y, float z, float w) => GLPointers._glVertexAttrib4fARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4fvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4fvARB(uint index, float* v) => GLPointers._glVertexAttrib4fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4ivARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4ivARB(uint index, int* v) => GLPointers._glVertexAttrib4ivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NbvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4NbvARB(uint index, sbyte* v) => GLPointers._glVertexAttrib4NbvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NivARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4NivARB(uint index, int* v) => GLPointers._glVertexAttrib4NivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NsvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4NsvARB(uint index, short* v) => GLPointers._glVertexAttrib4NsvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NubARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4NubARB(uint index, byte x, byte y, byte z, byte w) => GLPointers._glVertexAttrib4NubARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NubvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4NubvARB(uint index, byte* v) => GLPointers._glVertexAttrib4NubvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NuivARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4NuivARB(uint index, uint* v) => GLPointers._glVertexAttrib4NuivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4NusvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4NusvARB(uint index, ushort* v) => GLPointers._glVertexAttrib4NusvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4sARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4sARB(uint index, short x, short y, short z, short w) => GLPointers._glVertexAttrib4sARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4svARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4svARB(uint index, short* v) => GLPointers._glVertexAttrib4svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4ubvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4ubvARB(uint index, byte* v) => GLPointers._glVertexAttrib4ubvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4uivARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4uivARB(uint index, uint* v) => GLPointers._glVertexAttrib4uivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttrib4usvARB</c>]</b><br/>  </summary>
            public static void VertexAttrib4usvARB(uint index, ushort* v) => GLPointers._glVertexAttrib4usvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribBinding</c>]</b><br/> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
            public static void VertexAttribBinding(uint attribindex, uint bindingindex) => GLPointers._glVertexAttribBinding_fnptr(attribindex, bindingindex);
            
            /// <summary> <b>[requires: GL_ARB_instanced_arrays]</b> <b>[entry point: <c>glVertexAttribDivisorARB</c>]</b><br/>  </summary>
            public static void VertexAttribDivisorARB(uint index, uint divisor) => GLPointers._glVertexAttribDivisorARB_fnptr(index, divisor);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexAttribFormat_fnptr(attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribIFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexAttribIFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL1d(uint index, double x) => GLPointers._glVertexAttribL1d_fnptr(index, x);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL1dv(uint index, double* v) => GLPointers._glVertexAttribL1dv_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glVertexAttribL1ui64ARB</c>]</b><br/>  </summary>
            public static void VertexAttribL1ui64ARB(uint index, ulong x) => GLPointers._glVertexAttribL1ui64ARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b> <b>[entry point: <c>glVertexAttribL1ui64vARB</c>]</b><br/>  </summary>
            public static void VertexAttribL1ui64vARB(uint index, ulong* v) => GLPointers._glVertexAttribL1ui64vARB_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL2d(uint index, double x, double y) => GLPointers._glVertexAttribL2d_fnptr(index, x, y);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL2dv(uint index, double* v) => GLPointers._glVertexAttribL2dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL3d(uint index, double x, double y, double z) => GLPointers._glVertexAttribL3d_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL3dv(uint index, double* v) => GLPointers._glVertexAttribL3dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4d</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttribL4d_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4dv</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL4dv(uint index, double* v) => GLPointers._glVertexAttribL4dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexAttribLFormat</c>]</b><br/> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexAttribLFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribLPointer</c>]</b><br/> Define an array of generic vertex attribute data. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
            /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
            /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
            /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
            public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers._glVertexAttribLPointer_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP1ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP1ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP1uiv</c>]</b><br/>  </summary>
            public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP1uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP2ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP2ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP2uiv</c>]</b><br/>  </summary>
            public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP2uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP3ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP3ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP3uiv</c>]</b><br/>  </summary>
            public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP3uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP4ui</c>]</b><br/> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._glVertexAttribP4ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexAttribP4uiv</c>]</b><br/>  </summary>
            public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._glVertexAttribP4uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b> <b>[entry point: <c>glVertexAttribPointerARB</c>]</b><br/>  </summary>
            public static void VertexAttribPointerARB(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, void* pointer) => GLPointers._glVertexAttribPointerARB_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, pointer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> <b>[entry point: <c>glVertexBindingDivisor</c>]</b><br/> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
            public static void VertexBindingDivisor(uint bindingindex, uint divisor) => GLPointers._glVertexBindingDivisor_fnptr(bindingindex, divisor);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glVertexBlendARB</c>]</b><br/>  </summary>
            public static void VertexBlendARB(int count) => GLPointers._glVertexBlendARB_fnptr(count);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP2ui</c>]</b><br/>  </summary>
            public static void VertexP2ui(VertexPointerType type, uint value) => GLPointers._glVertexP2ui_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP2uiv</c>]</b><br/>  </summary>
            public static void VertexP2uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP2uiv_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP3ui</c>]</b><br/>  </summary>
            public static void VertexP3ui(VertexPointerType type, uint value) => GLPointers._glVertexP3ui_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP3uiv</c>]</b><br/>  </summary>
            public static void VertexP3uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP3uiv_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP4ui</c>]</b><br/>  </summary>
            public static void VertexP4ui(VertexPointerType type, uint value) => GLPointers._glVertexP4ui_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> <b>[entry point: <c>glVertexP4uiv</c>]</b><br/>  </summary>
            public static void VertexP4uiv(VertexPointerType type, uint* value) => GLPointers._glVertexP4uiv_fnptr((uint)type, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportArrayv</c>]</b><br/> Set multiple viewports. </summary>
            /// <param name="first"> Specify the first viewport to set. </param>
            /// <param name="count"> Specify the number of viewports to set. </param>
            /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml" /></remarks>
            public static void ViewportArrayv(uint first, int count, float* v) => GLPointers._glViewportArrayv_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportIndexedf</c>]</b><br/> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
            public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => GLPointers._glViewportIndexedf_fnptr(index, x, y, w, h);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> <b>[entry point: <c>glViewportIndexedfv</c>]</b><br/> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
            public static void ViewportIndexedfv(uint index, float* v) => GLPointers._glViewportIndexedfv_fnptr(index, v);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> <b>[entry point: <c>glWaitSync</c>]</b><br/> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
            /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
            /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml" /></remarks>
            public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => GLPointers._glWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightbvARB</c>]</b><br/>  </summary>
            public static void WeightbvARB(int size, sbyte* weights) => GLPointers._glWeightbvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightdvARB</c>]</b><br/>  </summary>
            public static void WeightdvARB(int size, double* weights) => GLPointers._glWeightdvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightfvARB</c>]</b><br/>  </summary>
            public static void WeightfvARB(int size, float* weights) => GLPointers._glWeightfvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightivARB</c>]</b><br/>  </summary>
            public static void WeightivARB(int size, int* weights) => GLPointers._glWeightivARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightPointerARB</c>]</b><br/>  </summary>
            public static void WeightPointerARB(int size, WeightPointerTypeARB type, int stride, void* pointer) => GLPointers._glWeightPointerARB_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightsvARB</c>]</b><br/>  </summary>
            public static void WeightsvARB(int size, short* weights) => GLPointers._glWeightsvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightubvARB</c>]</b><br/>  </summary>
            public static void WeightubvARB(int size, byte* weights) => GLPointers._glWeightubvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightuivARB</c>]</b><br/>  </summary>
            public static void WeightuivARB(int size, uint* weights) => GLPointers._glWeightuivARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b> <b>[entry point: <c>glWeightusvARB</c>]</b><br/>  </summary>
            public static void WeightusvARB(int size, ushort* weights) => GLPointers._glWeightusvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2dARB</c>]</b><br/>  </summary>
            public static void WindowPos2dARB(double x, double y) => GLPointers._glWindowPos2dARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2dvARB</c>]</b><br/>  </summary>
            public static void WindowPos2dvARB(double* v) => GLPointers._glWindowPos2dvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2fARB</c>]</b><br/>  </summary>
            public static void WindowPos2fARB(float x, float y) => GLPointers._glWindowPos2fARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2fvARB</c>]</b><br/>  </summary>
            public static void WindowPos2fvARB(float* v) => GLPointers._glWindowPos2fvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2iARB</c>]</b><br/>  </summary>
            public static void WindowPos2iARB(int x, int y) => GLPointers._glWindowPos2iARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2ivARB</c>]</b><br/>  </summary>
            public static void WindowPos2ivARB(int* v) => GLPointers._glWindowPos2ivARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2sARB</c>]</b><br/>  </summary>
            public static void WindowPos2sARB(short x, short y) => GLPointers._glWindowPos2sARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos2svARB</c>]</b><br/>  </summary>
            public static void WindowPos2svARB(short* v) => GLPointers._glWindowPos2svARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3dARB</c>]</b><br/>  </summary>
            public static void WindowPos3dARB(double x, double y, double z) => GLPointers._glWindowPos3dARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3dvARB</c>]</b><br/>  </summary>
            public static void WindowPos3dvARB(double* v) => GLPointers._glWindowPos3dvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3fARB</c>]</b><br/>  </summary>
            public static void WindowPos3fARB(float x, float y, float z) => GLPointers._glWindowPos3fARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3fvARB</c>]</b><br/>  </summary>
            public static void WindowPos3fvARB(float* v) => GLPointers._glWindowPos3fvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3iARB</c>]</b><br/>  </summary>
            public static void WindowPos3iARB(int x, int y, int z) => GLPointers._glWindowPos3iARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3ivARB</c>]</b><br/>  </summary>
            public static void WindowPos3ivARB(int* v) => GLPointers._glWindowPos3ivARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3sARB</c>]</b><br/>  </summary>
            public static void WindowPos3sARB(short x, short y, short z) => GLPointers._glWindowPos3sARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b> <b>[entry point: <c>glWindowPos3svARB</c>]</b><br/>  </summary>
            public static void WindowPos3svARB(short* v) => GLPointers._glWindowPos3svARB_fnptr(v);
            
        }
        /// <summary>ATI extensions.</summary>
        public static unsafe partial class ATI
        {
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glAlphaFragmentOp1ATI</c>]</b><br/>  </summary>
            public static void AlphaFragmentOp1ATI(FragmentOp1ATI op, FragmentShaderRegATI dst, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod) => GLPointers._glAlphaFragmentOp1ATI_fnptr((uint)op, (uint)dst, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glAlphaFragmentOp2ATI</c>]</b><br/>  </summary>
            public static void AlphaFragmentOp2ATI(FragmentOp2ATI op, FragmentShaderRegATI dst, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod) => GLPointers._glAlphaFragmentOp2ATI_fnptr((uint)op, (uint)dst, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glAlphaFragmentOp3ATI</c>]</b><br/>  </summary>
            public static void AlphaFragmentOp3ATI(FragmentOp3ATI op, FragmentShaderRegATI dst, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod, FragmentShaderGenericSourceATI arg3, FragmentShaderValueRepATI arg3Rep, FragmentShaderColorModMaskATI arg3Mod) => GLPointers._glAlphaFragmentOp3ATI_fnptr((uint)op, (uint)dst, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod, (uint)arg3, (uint)arg3Rep, (uint)arg3Mod);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glArrayObjectATI</c>]</b><br/>  </summary>
            public static void ArrayObjectATI(EnableCap array, int size, ScalarType type, int stride, int buffer, uint offset) => GLPointers._glArrayObjectATI_fnptr((uint)array, size, (uint)type, stride, buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glBeginFragmentShaderATI</c>]</b><br/>  </summary>
            public static void BeginFragmentShaderATI() => GLPointers._glBeginFragmentShaderATI_fnptr();
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glBindFragmentShaderATI</c>]</b><br/>  </summary>
            public static void BindFragmentShaderATI(uint id) => GLPointers._glBindFragmentShaderATI_fnptr(id);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glClientActiveVertexStreamATI</c>]</b><br/>  </summary>
            public static void ClientActiveVertexStreamATI(VertexStreamATI stream) => GLPointers._glClientActiveVertexStreamATI_fnptr((uint)stream);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glColorFragmentOp1ATI</c>]</b><br/>  </summary>
            public static void ColorFragmentOp1ATI(FragmentOp1ATI op, FragmentShaderRegATI dst, FragmentShaderDestMaskATI dstMask, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod) => GLPointers._glColorFragmentOp1ATI_fnptr((uint)op, (uint)dst, (uint)dstMask, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glColorFragmentOp2ATI</c>]</b><br/>  </summary>
            public static void ColorFragmentOp2ATI(FragmentOp2ATI op, FragmentShaderRegATI dst, FragmentShaderDestMaskATI dstMask, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod) => GLPointers._glColorFragmentOp2ATI_fnptr((uint)op, (uint)dst, (uint)dstMask, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glColorFragmentOp3ATI</c>]</b><br/>  </summary>
            public static void ColorFragmentOp3ATI(FragmentOp3ATI op, FragmentShaderRegATI dst, FragmentShaderDestMaskATI dstMask, FragmentShaderDestModMaskATI dstMod, FragmentShaderGenericSourceATI arg1, FragmentShaderValueRepATI arg1Rep, FragmentShaderColorModMaskATI arg1Mod, FragmentShaderGenericSourceATI arg2, FragmentShaderValueRepATI arg2Rep, FragmentShaderColorModMaskATI arg2Mod, FragmentShaderGenericSourceATI arg3, FragmentShaderValueRepATI arg3Rep, FragmentShaderColorModMaskATI arg3Mod) => GLPointers._glColorFragmentOp3ATI_fnptr((uint)op, (uint)dst, (uint)dstMask, (uint)dstMod, (uint)arg1, (uint)arg1Rep, (uint)arg1Mod, (uint)arg2, (uint)arg2Rep, (uint)arg2Mod, (uint)arg3, (uint)arg3Rep, (uint)arg3Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glDeleteFragmentShaderATI</c>]</b><br/>  </summary>
            public static void DeleteFragmentShaderATI(uint id) => GLPointers._glDeleteFragmentShaderATI_fnptr(id);
            
            /// <summary> <b>[requires: GL_ATI_draw_buffers]</b> <b>[entry point: <c>glDrawBuffersATI</c>]</b><br/>  </summary>
            public static void DrawBuffersATI(int n, DrawBufferMode* bufs) => GLPointers._glDrawBuffersATI_fnptr(n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_ATI_element_array]</b> <b>[entry point: <c>glDrawElementArrayATI</c>]</b><br/>  </summary>
            public static void DrawElementArrayATI(PrimitiveType mode, int count) => GLPointers._glDrawElementArrayATI_fnptr((uint)mode, count);
            
            /// <summary> <b>[requires: GL_ATI_element_array]</b> <b>[entry point: <c>glDrawRangeElementArrayATI</c>]</b><br/>  </summary>
            public static void DrawRangeElementArrayATI(PrimitiveType mode, uint start, uint end, int count) => GLPointers._glDrawRangeElementArrayATI_fnptr((uint)mode, start, end, count);
            
            /// <summary> <b>[requires: GL_ATI_element_array]</b> <b>[entry point: <c>glElementPointerATI</c>]</b><br/>  </summary>
            public static void ElementPointerATI(ElementPointerTypeATI type, void* pointer) => GLPointers._glElementPointerATI_fnptr((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glEndFragmentShaderATI</c>]</b><br/>  </summary>
            public static void EndFragmentShaderATI() => GLPointers._glEndFragmentShaderATI_fnptr();
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glFreeObjectBufferATI</c>]</b><br/>  </summary>
            public static void FreeObjectBufferATI(int buffer) => GLPointers._glFreeObjectBufferATI_fnptr(buffer);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glGenFragmentShadersATI</c>]</b><br/>  </summary>
            public static uint GenFragmentShadersATI(uint range) => GLPointers._glGenFragmentShadersATI_fnptr(range);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetArrayObjectfvATI</c>]</b><br/>  </summary>
            public static void GetArrayObjectfvATI(EnableCap array, ArrayObjectPNameATI pname, float* parameters) => GLPointers._glGetArrayObjectfvATI_fnptr((uint)array, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetArrayObjectivATI</c>]</b><br/>  </summary>
            public static void GetArrayObjectivATI(EnableCap array, ArrayObjectPNameATI pname, int* parameters) => GLPointers._glGetArrayObjectivATI_fnptr((uint)array, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetObjectBufferfvATI</c>]</b><br/>  </summary>
            public static void GetObjectBufferfvATI(int buffer, ArrayObjectPNameATI pname, float* parameters) => GLPointers._glGetObjectBufferfvATI_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetObjectBufferivATI</c>]</b><br/>  </summary>
            public static void GetObjectBufferivATI(int buffer, ArrayObjectPNameATI pname, int* parameters) => GLPointers._glGetObjectBufferivATI_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b> <b>[entry point: <c>glGetTexBumpParameterfvATI</c>]</b><br/>  </summary>
            public static void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, float* param) => GLPointers._glGetTexBumpParameterfvATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b> <b>[entry point: <c>glGetTexBumpParameterivATI</c>]</b><br/>  </summary>
            public static void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, int* param) => GLPointers._glGetTexBumpParameterivATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetVariantArrayObjectfvATI</c>]</b><br/>  </summary>
            public static void GetVariantArrayObjectfvATI(uint id, ArrayObjectPNameATI pname, float* parameters) => GLPointers._glGetVariantArrayObjectfvATI_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glGetVariantArrayObjectivATI</c>]</b><br/>  </summary>
            public static void GetVariantArrayObjectivATI(uint id, ArrayObjectPNameATI pname, int* parameters) => GLPointers._glGetVariantArrayObjectivATI_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b> <b>[entry point: <c>glGetVertexAttribArrayObjectfvATI</c>]</b><br/>  </summary>
            public static void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, float* parameters) => GLPointers._glGetVertexAttribArrayObjectfvATI_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b> <b>[entry point: <c>glGetVertexAttribArrayObjectivATI</c>]</b><br/>  </summary>
            public static void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, int* parameters) => GLPointers._glGetVertexAttribArrayObjectivATI_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glIsObjectBufferATI</c>]</b><br/>  </summary>
            public static bool IsObjectBufferATI(int buffer) => GLPointers._glIsObjectBufferATI_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: GL_ATI_map_object_buffer]</b> <b>[entry point: <c>glMapObjectBufferATI</c>]</b><br/>  </summary>
            public static void* MapObjectBufferATI(int buffer) => GLPointers._glMapObjectBufferATI_fnptr(buffer);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glNewObjectBufferATI</c>]</b><br/>  </summary>
            public static uint NewObjectBufferATI(int size, void* pointer, ArrayObjectUsageATI usage) => GLPointers._glNewObjectBufferATI_fnptr(size, pointer, (uint)usage);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3bATI</c>]</b><br/>  </summary>
            public static void NormalStream3bATI(VertexStreamATI stream, sbyte nx, sbyte ny, sbyte nz) => GLPointers._glNormalStream3bATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3bvATI</c>]</b><br/>  </summary>
            public static void NormalStream3bvATI(VertexStreamATI stream, sbyte* coords) => GLPointers._glNormalStream3bvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3dATI</c>]</b><br/>  </summary>
            public static void NormalStream3dATI(VertexStreamATI stream, double nx, double ny, double nz) => GLPointers._glNormalStream3dATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3dvATI</c>]</b><br/>  </summary>
            public static void NormalStream3dvATI(VertexStreamATI stream, double* coords) => GLPointers._glNormalStream3dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3fATI</c>]</b><br/>  </summary>
            public static void NormalStream3fATI(VertexStreamATI stream, float nx, float ny, float nz) => GLPointers._glNormalStream3fATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3fvATI</c>]</b><br/>  </summary>
            public static void NormalStream3fvATI(VertexStreamATI stream, float* coords) => GLPointers._glNormalStream3fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3iATI</c>]</b><br/>  </summary>
            public static void NormalStream3iATI(VertexStreamATI stream, int nx, int ny, int nz) => GLPointers._glNormalStream3iATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3ivATI</c>]</b><br/>  </summary>
            public static void NormalStream3ivATI(VertexStreamATI stream, int* coords) => GLPointers._glNormalStream3ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3sATI</c>]</b><br/>  </summary>
            public static void NormalStream3sATI(VertexStreamATI stream, short nx, short ny, short nz) => GLPointers._glNormalStream3sATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glNormalStream3svATI</c>]</b><br/>  </summary>
            public static void NormalStream3svATI(VertexStreamATI stream, short* coords) => GLPointers._glNormalStream3svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glPassTexCoordATI</c>]</b><br/>  </summary>
            public static void PassTexCoordATI(FragmentShaderRegATI dst, FragmentShaderTextureSourceATI coord, SwizzleOpATI swizzle) => GLPointers._glPassTexCoordATI_fnptr((uint)dst, (uint)coord, (uint)swizzle);
            
            /// <summary> <b>[requires: GL_ATI_pn_triangles]</b> <b>[entry point: <c>glPNTrianglesfATI</c>]</b><br/>  </summary>
            public static void PNTrianglesfATI(PNTrianglesPNameATI pname, float param) => GLPointers._glPNTrianglesfATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_pn_triangles]</b> <b>[entry point: <c>glPNTrianglesiATI</c>]</b><br/>  </summary>
            public static void PNTrianglesiATI(PNTrianglesPNameATI pname, int param) => GLPointers._glPNTrianglesiATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glSampleMapATI</c>]</b><br/>  </summary>
            public static void SampleMapATI(FragmentShaderRegATI dst, FragmentShaderTextureSourceATI interp, SwizzleOpATI swizzle) => GLPointers._glSampleMapATI_fnptr((uint)dst, (uint)interp, (uint)swizzle);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b> <b>[entry point: <c>glSetFragmentShaderConstantATI</c>]</b><br/>  </summary>
            public static void SetFragmentShaderConstantATI(FragmentShaderConATI dst, float* value) => GLPointers._glSetFragmentShaderConstantATI_fnptr((uint)dst, value);
            
            /// <summary> <b>[requires: GL_ATI_separate_stencil]</b> <b>[entry point: <c>glStencilFuncSeparateATI</c>]</b><br/>  </summary>
            public static void StencilFuncSeparateATI(StencilFunction frontfunc, StencilFunction backfunc, int reference, uint mask) => GLPointers._glStencilFuncSeparateATI_fnptr((uint)frontfunc, (uint)backfunc, reference, mask);
            
            /// <summary> <b>[requires: GL_ATI_separate_stencil]</b> <b>[entry point: <c>glStencilOpSeparateATI</c>]</b><br/>  </summary>
            public static void StencilOpSeparateATI(TriangleFace face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => GLPointers._glStencilOpSeparateATI_fnptr((uint)face, (uint)sfail, (uint)dpfail, (uint)dppass);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b> <b>[entry point: <c>glTexBumpParameterfvATI</c>]</b><br/>  </summary>
            public static void TexBumpParameterfvATI(TexBumpParameterATI pname, float* param) => GLPointers._glTexBumpParameterfvATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b> <b>[entry point: <c>glTexBumpParameterivATI</c>]</b><br/>  </summary>
            public static void TexBumpParameterivATI(TexBumpParameterATI pname, int* param) => GLPointers._glTexBumpParameterivATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_map_object_buffer]</b> <b>[entry point: <c>glUnmapObjectBufferATI</c>]</b><br/>  </summary>
            public static void UnmapObjectBufferATI(int buffer) => GLPointers._glUnmapObjectBufferATI_fnptr(buffer);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glUpdateObjectBufferATI</c>]</b><br/>  </summary>
            public static void UpdateObjectBufferATI(int buffer, uint offset, int size, void* pointer, PreserveModeATI preserve) => GLPointers._glUpdateObjectBufferATI_fnptr(buffer, offset, size, pointer, (uint)preserve);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b> <b>[entry point: <c>glVariantArrayObjectATI</c>]</b><br/>  </summary>
            public static void VariantArrayObjectATI(uint id, ScalarType type, int stride, int buffer, uint offset) => GLPointers._glVariantArrayObjectATI_fnptr(id, (uint)type, stride, buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b> <b>[entry point: <c>glVertexAttribArrayObjectATI</c>]</b><br/>  </summary>
            public static void VertexAttribArrayObjectATI(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, int buffer, uint offset) => GLPointers._glVertexAttribArrayObjectATI_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexBlendEnvfATI</c>]</b><br/>  </summary>
            public static void VertexBlendEnvfATI(VertexStreamATI pname, float param) => GLPointers._glVertexBlendEnvfATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexBlendEnviATI</c>]</b><br/>  </summary>
            public static void VertexBlendEnviATI(VertexStreamATI pname, int param) => GLPointers._glVertexBlendEnviATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1dATI</c>]</b><br/>  </summary>
            public static void VertexStream1dATI(VertexStreamATI stream, double x) => GLPointers._glVertexStream1dATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1dvATI</c>]</b><br/>  </summary>
            public static void VertexStream1dvATI(VertexStreamATI stream, double* coords) => GLPointers._glVertexStream1dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1fATI</c>]</b><br/>  </summary>
            public static void VertexStream1fATI(VertexStreamATI stream, float x) => GLPointers._glVertexStream1fATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1fvATI</c>]</b><br/>  </summary>
            public static void VertexStream1fvATI(VertexStreamATI stream, float* coords) => GLPointers._glVertexStream1fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1iATI</c>]</b><br/>  </summary>
            public static void VertexStream1iATI(VertexStreamATI stream, int x) => GLPointers._glVertexStream1iATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1ivATI</c>]</b><br/>  </summary>
            public static void VertexStream1ivATI(VertexStreamATI stream, int* coords) => GLPointers._glVertexStream1ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1sATI</c>]</b><br/>  </summary>
            public static void VertexStream1sATI(VertexStreamATI stream, short x) => GLPointers._glVertexStream1sATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream1svATI</c>]</b><br/>  </summary>
            public static void VertexStream1svATI(VertexStreamATI stream, short* coords) => GLPointers._glVertexStream1svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2dATI</c>]</b><br/>  </summary>
            public static void VertexStream2dATI(VertexStreamATI stream, double x, double y) => GLPointers._glVertexStream2dATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2dvATI</c>]</b><br/>  </summary>
            public static void VertexStream2dvATI(VertexStreamATI stream, double* coords) => GLPointers._glVertexStream2dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2fATI</c>]</b><br/>  </summary>
            public static void VertexStream2fATI(VertexStreamATI stream, float x, float y) => GLPointers._glVertexStream2fATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2fvATI</c>]</b><br/>  </summary>
            public static void VertexStream2fvATI(VertexStreamATI stream, float* coords) => GLPointers._glVertexStream2fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2iATI</c>]</b><br/>  </summary>
            public static void VertexStream2iATI(VertexStreamATI stream, int x, int y) => GLPointers._glVertexStream2iATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2ivATI</c>]</b><br/>  </summary>
            public static void VertexStream2ivATI(VertexStreamATI stream, int* coords) => GLPointers._glVertexStream2ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2sATI</c>]</b><br/>  </summary>
            public static void VertexStream2sATI(VertexStreamATI stream, short x, short y) => GLPointers._glVertexStream2sATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream2svATI</c>]</b><br/>  </summary>
            public static void VertexStream2svATI(VertexStreamATI stream, short* coords) => GLPointers._glVertexStream2svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3dATI</c>]</b><br/>  </summary>
            public static void VertexStream3dATI(VertexStreamATI stream, double x, double y, double z) => GLPointers._glVertexStream3dATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3dvATI</c>]</b><br/>  </summary>
            public static void VertexStream3dvATI(VertexStreamATI stream, double* coords) => GLPointers._glVertexStream3dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3fATI</c>]</b><br/>  </summary>
            public static void VertexStream3fATI(VertexStreamATI stream, float x, float y, float z) => GLPointers._glVertexStream3fATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3fvATI</c>]</b><br/>  </summary>
            public static void VertexStream3fvATI(VertexStreamATI stream, float* coords) => GLPointers._glVertexStream3fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3iATI</c>]</b><br/>  </summary>
            public static void VertexStream3iATI(VertexStreamATI stream, int x, int y, int z) => GLPointers._glVertexStream3iATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3ivATI</c>]</b><br/>  </summary>
            public static void VertexStream3ivATI(VertexStreamATI stream, int* coords) => GLPointers._glVertexStream3ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3sATI</c>]</b><br/>  </summary>
            public static void VertexStream3sATI(VertexStreamATI stream, short x, short y, short z) => GLPointers._glVertexStream3sATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream3svATI</c>]</b><br/>  </summary>
            public static void VertexStream3svATI(VertexStreamATI stream, short* coords) => GLPointers._glVertexStream3svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4dATI</c>]</b><br/>  </summary>
            public static void VertexStream4dATI(VertexStreamATI stream, double x, double y, double z, double w) => GLPointers._glVertexStream4dATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4dvATI</c>]</b><br/>  </summary>
            public static void VertexStream4dvATI(VertexStreamATI stream, double* coords) => GLPointers._glVertexStream4dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4fATI</c>]</b><br/>  </summary>
            public static void VertexStream4fATI(VertexStreamATI stream, float x, float y, float z, float w) => GLPointers._glVertexStream4fATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4fvATI</c>]</b><br/>  </summary>
            public static void VertexStream4fvATI(VertexStreamATI stream, float* coords) => GLPointers._glVertexStream4fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4iATI</c>]</b><br/>  </summary>
            public static void VertexStream4iATI(VertexStreamATI stream, int x, int y, int z, int w) => GLPointers._glVertexStream4iATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4ivATI</c>]</b><br/>  </summary>
            public static void VertexStream4ivATI(VertexStreamATI stream, int* coords) => GLPointers._glVertexStream4ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4sATI</c>]</b><br/>  </summary>
            public static void VertexStream4sATI(VertexStreamATI stream, short x, short y, short z, short w) => GLPointers._glVertexStream4sATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b> <b>[entry point: <c>glVertexStream4svATI</c>]</b><br/>  </summary>
            public static void VertexStream4svATI(VertexStreamATI stream, short* coords) => GLPointers._glVertexStream4svATI_fnptr((uint)stream, coords);
            
        }
        /// <summary>EXT extensions.</summary>
        public static unsafe partial class EXT
        {
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex]</b> <b>[entry point: <c>glAcquireKeyedMutexWin32EXT</c>]</b><br/>  </summary>
            public static bool AcquireKeyedMutexWin32EXT(uint memory, ulong key, uint timeout) => GLPointers._glAcquireKeyedMutexWin32EXT_fnptr(memory, key, timeout) != 0;
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glActiveProgramEXT</c>]</b><br/>  </summary>
            public static void ActiveProgramEXT(int program) => GLPointers._glActiveProgramEXT_fnptr(program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glActiveShaderProgramEXT</c>]</b><br/>  </summary>
            public static void ActiveShaderProgramEXT(int pipeline, int program) => GLPointers._glActiveShaderProgramEXT_fnptr(pipeline, program);
            
            /// <summary> <b>[requires: GL_EXT_stencil_two_side]</b> <b>[entry point: <c>glActiveStencilFaceEXT</c>]</b><br/>  </summary>
            public static void ActiveStencilFaceEXT(TriangleFace face) => GLPointers._glActiveStencilFaceEXT_fnptr((uint)face);
            
            /// <summary> <b>[requires: GL_EXT_light_texture]</b> <b>[entry point: <c>glApplyTextureEXT</c>]</b><br/>  </summary>
            public static void ApplyTextureEXT(LightTextureModeEXT mode) => GLPointers._glApplyTextureEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glAreTexturesResidentEXT</c>]</b><br/>  </summary>
            public static bool AreTexturesResidentEXT(int n, int* textures, bool* residences) => GLPointers._glAreTexturesResidentEXT_fnptr(n, textures, (byte*)residences) != 0;
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glArrayElementEXT</c>]</b><br/>  </summary>
            public static void ArrayElementEXT(int i) => GLPointers._glArrayElementEXT_fnptr(i);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glBeginTransformFeedbackEXT</c>]</b><br/>  </summary>
            public static void BeginTransformFeedbackEXT(PrimitiveType primitiveMode) => GLPointers._glBeginTransformFeedbackEXT_fnptr((uint)primitiveMode);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBeginVertexShaderEXT</c>]</b><br/>  </summary>
            public static void BeginVertexShaderEXT() => GLPointers._glBeginVertexShaderEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glBindBufferBaseEXT</c>]</b><br/>  </summary>
            public static void BindBufferBaseEXT(BufferTargetARB target, uint index, int buffer) => GLPointers._glBindBufferBaseEXT_fnptr((uint)target, index, buffer);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glBindBufferOffsetEXT</c>]</b><br/>  </summary>
            public static void BindBufferOffsetEXT(BufferTargetARB target, uint index, int buffer, IntPtr offset) => GLPointers._glBindBufferOffsetEXT_fnptr((uint)target, index, buffer, offset);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glBindBufferRangeEXT</c>]</b><br/>  </summary>
            public static void BindBufferRangeEXT(BufferTargetARB target, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glBindBufferRangeEXT_fnptr((uint)target, index, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glBindFragDataLocationEXT</c>]</b><br/>  </summary>
            public static void BindFragDataLocationEXT(int program, uint color, byte* name) => GLPointers._glBindFragDataLocationEXT_fnptr(program, color, name);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glBindFramebufferEXT</c>]</b><br/>  </summary>
            public static void BindFramebufferEXT(FramebufferTarget target, int framebuffer) => GLPointers._glBindFramebufferEXT_fnptr((uint)target, framebuffer);
            
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store]</b> <b>[entry point: <c>glBindImageTextureEXT</c>]</b><br/>  </summary>
            public static void BindImageTextureEXT(uint index, int texture, int level, bool layered, int layer, BufferAccessARB access, int format) => GLPointers._glBindImageTextureEXT_fnptr(index, texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, format);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindLightParameterEXT</c>]</b><br/>  </summary>
            public static uint BindLightParameterEXT(LightName light, LightParameter value) => GLPointers._glBindLightParameterEXT_fnptr((uint)light, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindMaterialParameterEXT</c>]</b><br/>  </summary>
            public static uint BindMaterialParameterEXT(TriangleFace face, MaterialParameter value) => GLPointers._glBindMaterialParameterEXT_fnptr((uint)face, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glBindMultiTextureEXT</c>]</b><br/>  </summary>
            public static void BindMultiTextureEXT(TextureUnit texunit, TextureTarget target, int texture) => GLPointers._glBindMultiTextureEXT_fnptr((uint)texunit, (uint)target, texture);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindParameterEXT</c>]</b><br/>  </summary>
            public static uint BindParameterEXT(VertexShaderParameterEXT value) => GLPointers._glBindParameterEXT_fnptr((uint)value);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glBindProgramPipelineEXT</c>]</b><br/>  </summary>
            public static void BindProgramPipelineEXT(int pipeline) => GLPointers._glBindProgramPipelineEXT_fnptr(pipeline);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glBindRenderbufferEXT</c>]</b><br/>  </summary>
            public static void BindRenderbufferEXT(RenderbufferTarget target, int renderbuffer) => GLPointers._glBindRenderbufferEXT_fnptr((uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindTexGenParameterEXT</c>]</b><br/>  </summary>
            public static uint BindTexGenParameterEXT(TextureUnit unit, TextureCoordName coord, TextureGenParameter value) => GLPointers._glBindTexGenParameterEXT_fnptr((uint)unit, (uint)coord, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glBindTextureEXT</c>]</b><br/>  </summary>
            public static void BindTextureEXT(TextureTarget target, int texture) => GLPointers._glBindTextureEXT_fnptr((uint)target, texture);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindTextureUnitParameterEXT</c>]</b><br/>  </summary>
            public static uint BindTextureUnitParameterEXT(TextureUnit unit, VertexShaderTextureUnitParameter value) => GLPointers._glBindTextureUnitParameterEXT_fnptr((uint)unit, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glBindVertexShaderEXT</c>]</b><br/>  </summary>
            public static void BindVertexShaderEXT(uint id) => GLPointers._glBindVertexShaderEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3bEXT</c>]</b><br/>  </summary>
            public static void Binormal3bEXT(sbyte bx, sbyte by, sbyte bz) => GLPointers._glBinormal3bEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3bvEXT</c>]</b><br/>  </summary>
            public static void Binormal3bvEXT(sbyte* v) => GLPointers._glBinormal3bvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3dEXT</c>]</b><br/>  </summary>
            public static void Binormal3dEXT(double bx, double by, double bz) => GLPointers._glBinormal3dEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3dvEXT</c>]</b><br/>  </summary>
            public static void Binormal3dvEXT(double* v) => GLPointers._glBinormal3dvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3fEXT</c>]</b><br/>  </summary>
            public static void Binormal3fEXT(float bx, float by, float bz) => GLPointers._glBinormal3fEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3fvEXT</c>]</b><br/>  </summary>
            public static void Binormal3fvEXT(float* v) => GLPointers._glBinormal3fvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3iEXT</c>]</b><br/>  </summary>
            public static void Binormal3iEXT(int bx, int by, int bz) => GLPointers._glBinormal3iEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3ivEXT</c>]</b><br/>  </summary>
            public static void Binormal3ivEXT(int* v) => GLPointers._glBinormal3ivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3sEXT</c>]</b><br/>  </summary>
            public static void Binormal3sEXT(short bx, short by, short bz) => GLPointers._glBinormal3sEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormal3svEXT</c>]</b><br/>  </summary>
            public static void Binormal3svEXT(short* v) => GLPointers._glBinormal3svEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glBinormalPointerEXT</c>]</b><br/>  </summary>
            public static void BinormalPointerEXT(BinormalPointerTypeEXT type, int stride, void* pointer) => GLPointers._glBinormalPointerEXT_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_blend_color]</b> <b>[entry point: <c>glBlendColorEXT</c>]</b><br/>  </summary>
            public static void BlendColorEXT(float red, float green, float blue, float alpha) => GLPointers._glBlendColorEXT_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_minmax]</b> <b>[entry point: <c>glBlendEquationEXT</c>]</b><br/>  </summary>
            public static void BlendEquationEXT(BlendEquationModeEXT mode) => GLPointers._glBlendEquationEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_blend_equation_separate]</b> <b>[entry point: <c>glBlendEquationSeparateEXT</c>]</b><br/>  </summary>
            public static void BlendEquationSeparateEXT(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._glBlendEquationSeparateEXT_fnptr((uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_func_separate]</b> <b>[entry point: <c>glBlendFuncSeparateEXT</c>]</b><br/>  </summary>
            public static void BlendFuncSeparateEXT(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers._glBlendFuncSeparateEXT_fnptr((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit]</b> <b>[entry point: <c>glBlitFramebufferEXT</c>]</b><br/>  </summary>
            public static void BlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebufferEXT_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit_layers]</b> <b>[entry point: <c>glBlitFramebufferLayerEXT</c>]</b><br/>  </summary>
            public static void BlitFramebufferLayerEXT(int srcX0, int srcY0, int srcX1, int srcY1, int srcLayer, int dstX0, int dstY0, int dstX1, int dstY1, int dstLayer, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebufferLayerEXT_fnptr(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit_layers]</b> <b>[entry point: <c>glBlitFramebufferLayersEXT</c>]</b><br/>  </summary>
            public static void BlitFramebufferLayersEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._glBlitFramebufferLayersEXT_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_external_buffer]</b> <b>[entry point: <c>glBufferStorageExternalEXT</c>]</b><br/>  </summary>
            public static void BufferStorageExternalEXT(All target, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => GLPointers._glBufferStorageExternalEXT_fnptr((uint)target, offset, size, clientBuffer, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glBufferStorageMemEXT</c>]</b><br/>  </summary>
            public static void BufferStorageMemEXT(BufferTargetARB target, nint size, uint memory, ulong offset) => GLPointers._glBufferStorageMemEXT_fnptr((uint)target, size, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glCheckFramebufferStatusEXT</c>]</b><br/>  </summary>
            public static FramebufferStatus CheckFramebufferStatusEXT(FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckFramebufferStatusEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCheckNamedFramebufferStatusEXT</c>]</b><br/>  </summary>
            public static FramebufferStatus CheckNamedFramebufferStatusEXT(int framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers._glCheckNamedFramebufferStatusEXT_fnptr(framebuffer, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glClearColorIiEXT</c>]</b><br/>  </summary>
            public static void ClearColorIiEXT(int red, int green, int blue, int alpha) => GLPointers._glClearColorIiEXT_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glClearColorIuiEXT</c>]</b><br/>  </summary>
            public static void ClearColorIuiEXT(uint red, uint green, uint blue, uint alpha) => GLPointers._glClearColorIuiEXT_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferDataEXT</c>]</b><br/>  </summary>
            public static void ClearNamedBufferDataEXT(int buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferDataEXT_fnptr(buffer, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glClearNamedBufferSubDataEXT</c>]</b><br/>  </summary>
            public static void ClearNamedBufferSubDataEXT(int buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._glClearNamedBufferSubDataEXT_fnptr(buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glClientAttribDefaultEXT</c>]</b><br/>  </summary>
            public static void ClientAttribDefaultEXT(ClientAttribMask mask) => GLPointers._glClientAttribDefaultEXT_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glColorMaskIndexedEXT</c>]</b><br/>  </summary>
            public static void ColorMaskIndexedEXT(uint index, bool r, bool g, bool b, bool a) => GLPointers._glColorMaskIndexedEXT_fnptr(index, (byte)(r ? 1 : 0), (byte)(g ? 1 : 0), (byte)(b ? 1 : 0), (byte)(a ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glColorPointerEXT</c>]</b><br/>  </summary>
            public static void ColorPointerEXT(int size, ColorPointerType type, int stride, int count, void* pointer) => GLPointers._glColorPointerEXT_fnptr(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_color_subtable]</b> <b>[entry point: <c>glColorSubTableEXT</c>]</b><br/>  </summary>
            public static void ColorSubTableEXT(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data) => GLPointers._glColorSubTableEXT_fnptr((uint)target, start, count, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b> <b>[entry point: <c>glColorTableEXT</c>]</b><br/>  </summary>
            public static void ColorTableEXT(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, void* table) => GLPointers._glColorTableEXT_fnptr((uint)target, (uint)internalFormat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexImage1DEXT</c>]</b><br/>  </summary>
            public static void CompressedMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => GLPointers._glCompressedMultiTexImage1DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, width, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexImage2DEXT</c>]</b><br/>  </summary>
            public static void CompressedMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => GLPointers._glCompressedMultiTexImage2DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, width, height, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexImage3DEXT</c>]</b><br/>  </summary>
            public static void CompressedMultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => GLPointers._glCompressedMultiTexImage3DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexSubImage1DEXT</c>]</b><br/>  </summary>
            public static void CompressedMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedMultiTexSubImage1DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, width, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexSubImage2DEXT</c>]</b><br/>  </summary>
            public static void CompressedMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedMultiTexSubImage2DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedMultiTexSubImage3DEXT</c>]</b><br/>  </summary>
            public static void CompressedMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedMultiTexSubImage3DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureImage1DEXT</c>]</b><br/>  </summary>
            public static void CompressedTextureImage1DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => GLPointers._glCompressedTextureImage1DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, width, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureImage2DEXT</c>]</b><br/>  </summary>
            public static void CompressedTextureImage2DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => GLPointers._glCompressedTextureImage2DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, width, height, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureImage3DEXT</c>]</b><br/>  </summary>
            public static void CompressedTextureImage3DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => GLPointers._glCompressedTextureImage3DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage1DEXT</c>]</b><br/>  </summary>
            public static void CompressedTextureSubImage1DEXT(int texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedTextureSubImage1DEXT_fnptr(texture, (uint)target, level, xoffset, width, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage2DEXT</c>]</b><br/>  </summary>
            public static void CompressedTextureSubImage2DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedTextureSubImage2DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCompressedTextureSubImage3DEXT</c>]</b><br/>  </summary>
            public static void CompressedTextureSubImage3DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => GLPointers._glCompressedTextureSubImage3DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionFilter1DEXT</c>]</b><br/>  </summary>
            public static void ConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image) => GLPointers._glConvolutionFilter1DEXT_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionFilter2DEXT</c>]</b><br/>  </summary>
            public static void ConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image) => GLPointers._glConvolutionFilter2DEXT_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionParameterfEXT</c>]</b><br/>  </summary>
            public static void ConvolutionParameterfEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, float parameters) => GLPointers._glConvolutionParameterfEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionParameterfvEXT</c>]</b><br/>  </summary>
            public static void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, float* parameters) => GLPointers._glConvolutionParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionParameteriEXT</c>]</b><br/>  </summary>
            public static void ConvolutionParameteriEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, int parameters) => GLPointers._glConvolutionParameteriEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glConvolutionParameterivEXT</c>]</b><br/>  </summary>
            public static void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, int* parameters) => GLPointers._glConvolutionParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_color_subtable]</b> <b>[entry point: <c>glCopyColorSubTableEXT</c>]</b><br/>  </summary>
            public static void CopyColorSubTableEXT(ColorTableTarget target, int start, int x, int y, int width) => GLPointers._glCopyColorSubTableEXT_fnptr((uint)target, start, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glCopyConvolutionFilter1DEXT</c>]</b><br/>  </summary>
            public static void CopyConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width) => GLPointers._glCopyConvolutionFilter1DEXT_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glCopyConvolutionFilter2DEXT</c>]</b><br/>  </summary>
            public static void CopyConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width, int height) => GLPointers._glCopyConvolutionFilter2DEXT_fnptr((uint)target, (uint)internalformat, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexImage1DEXT</c>]</b><br/>  </summary>
            public static void CopyMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._glCopyMultiTexImage1DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexImage2DEXT</c>]</b><br/>  </summary>
            public static void CopyMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._glCopyMultiTexImage2DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexSubImage1DEXT</c>]</b><br/>  </summary>
            public static void CopyMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyMultiTexSubImage1DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexSubImage2DEXT</c>]</b><br/>  </summary>
            public static void CopyMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyMultiTexSubImage2DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyMultiTexSubImage3DEXT</c>]</b><br/>  </summary>
            public static void CopyMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyMultiTexSubImage3DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexImage1DEXT</c>]</b><br/>  </summary>
            public static void CopyTexImage1DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._glCopyTexImage1DEXT_fnptr((uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexImage2DEXT</c>]</b><br/>  </summary>
            public static void CopyTexImage2DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._glCopyTexImage2DEXT_fnptr((uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexSubImage1DEXT</c>]</b><br/>  </summary>
            public static void CopyTexSubImage1DEXT(TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTexSubImage1DEXT_fnptr((uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexSubImage2DEXT</c>]</b><br/>  </summary>
            public static void CopyTexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTexSubImage2DEXT_fnptr((uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b> <b>[entry point: <c>glCopyTexSubImage3DEXT</c>]</b><br/>  </summary>
            public static void CopyTexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTexSubImage3DEXT_fnptr((uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureImage1DEXT</c>]</b><br/>  </summary>
            public static void CopyTextureImage1DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._glCopyTextureImage1DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureImage2DEXT</c>]</b><br/>  </summary>
            public static void CopyTextureImage2DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._glCopyTextureImage2DEXT_fnptr(texture, (uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage1DEXT</c>]</b><br/>  </summary>
            public static void CopyTextureSubImage1DEXT(int texture, TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._glCopyTextureSubImage1DEXT_fnptr(texture, (uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage2DEXT</c>]</b><br/>  </summary>
            public static void CopyTextureSubImage2DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage2DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glCopyTextureSubImage3DEXT</c>]</b><br/>  </summary>
            public static void CopyTextureSubImage3DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._glCopyTextureSubImage3DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glCreateMemoryObjectsEXT</c>]</b><br/>  </summary>
            public static void CreateMemoryObjectsEXT(int n, uint* memoryObjects) => GLPointers._glCreateMemoryObjectsEXT_fnptr(n, memoryObjects);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glCreateShaderProgramEXT</c>]</b><br/>  </summary>
            public static int CreateShaderProgramEXT(ShaderType type, byte* str) => GLPointers._glCreateShaderProgramEXT_fnptr((uint)type, str);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glCreateShaderProgramvEXT</c>]</b><br/>  </summary>
            public static int CreateShaderProgramvEXT(ShaderType type, int count, byte** strings) => GLPointers._glCreateShaderProgramvEXT_fnptr((uint)type, count, strings);
            
            /// <summary> <b>[requires: GL_EXT_cull_vertex]</b> <b>[entry point: <c>glCullParameterdvEXT</c>]</b><br/>  </summary>
            public static void CullParameterdvEXT(CullParameterEXT pname, double* parameters) => GLPointers._glCullParameterdvEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_cull_vertex]</b> <b>[entry point: <c>glCullParameterfvEXT</c>]</b><br/>  </summary>
            public static void CullParameterfvEXT(CullParameterEXT pname, float* parameters) => GLPointers._glCullParameterfvEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glDeleteFramebuffersEXT</c>]</b><br/>  </summary>
            public static void DeleteFramebuffersEXT(int n, int* framebuffers) => GLPointers._glDeleteFramebuffersEXT_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glDeleteMemoryObjectsEXT</c>]</b><br/>  </summary>
            public static void DeleteMemoryObjectsEXT(int n, uint* memoryObjects) => GLPointers._glDeleteMemoryObjectsEXT_fnptr(n, memoryObjects);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glDeleteProgramPipelinesEXT</c>]</b><br/>  </summary>
            public static void DeleteProgramPipelinesEXT(int n, int* pipelines) => GLPointers._glDeleteProgramPipelinesEXT_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glDeleteRenderbuffersEXT</c>]</b><br/>  </summary>
            public static void DeleteRenderbuffersEXT(int n, int* renderbuffers) => GLPointers._glDeleteRenderbuffersEXT_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glDeleteSemaphoresEXT</c>]</b><br/>  </summary>
            public static void DeleteSemaphoresEXT(int n, uint* semaphores) => GLPointers._glDeleteSemaphoresEXT_fnptr(n, semaphores);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glDeleteTexturesEXT</c>]</b><br/>  </summary>
            public static void DeleteTexturesEXT(int n, int* textures) => GLPointers._glDeleteTexturesEXT_fnptr(n, textures);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glDeleteVertexShaderEXT</c>]</b><br/>  </summary>
            public static void DeleteVertexShaderEXT(uint id) => GLPointers._glDeleteVertexShaderEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_depth_bounds_test]</b> <b>[entry point: <c>glDepthBoundsEXT</c>]</b><br/>  </summary>
            public static void DepthBoundsEXT(double zmin, double zmax) => GLPointers._glDepthBoundsEXT_fnptr(zmin, zmax);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glDisableClientStateiEXT</c>]</b><br/>  </summary>
            public static void DisableClientStateiEXT(EnableCap array, uint index) => GLPointers._glDisableClientStateiEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glDisableClientStateIndexedEXT</c>]</b><br/>  </summary>
            public static void DisableClientStateIndexedEXT(EnableCap array, uint index) => GLPointers._glDisableClientStateIndexedEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glDisableIndexedEXT</c>]</b><br/>  </summary>
            public static void DisableIndexedEXT(EnableCap target, uint index) => GLPointers._glDisableIndexedEXT_fnptr((uint)target, index);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glDisableVariantClientStateEXT</c>]</b><br/>  </summary>
            public static void DisableVariantClientStateEXT(uint id) => GLPointers._glDisableVariantClientStateEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glDisableVertexArrayAttribEXT</c>]</b><br/>  </summary>
            public static void DisableVertexArrayAttribEXT(int vaobj, uint index) => GLPointers._glDisableVertexArrayAttribEXT_fnptr(vaobj, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glDisableVertexArrayEXT</c>]</b><br/>  </summary>
            public static void DisableVertexArrayEXT(int vaobj, EnableCap array) => GLPointers._glDisableVertexArrayEXT_fnptr(vaobj, (uint)array);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glDrawArraysEXT</c>]</b><br/>  </summary>
            public static void DrawArraysEXT(PrimitiveType mode, int first, int count) => GLPointers._glDrawArraysEXT_fnptr((uint)mode, first, count);
            
            /// <summary> <b>[requires: GL_EXT_draw_instanced]</b> <b>[entry point: <c>glDrawArraysInstancedEXT</c>]</b><br/>  </summary>
            public static void DrawArraysInstancedEXT(PrimitiveType mode, int start, int count, int primcount) => GLPointers._glDrawArraysInstancedEXT_fnptr((uint)mode, start, count, primcount);
            
            /// <summary> <b>[requires: GL_EXT_draw_instanced]</b> <b>[entry point: <c>glDrawElementsInstancedEXT</c>]</b><br/>  </summary>
            public static void DrawElementsInstancedEXT(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => GLPointers._glDrawElementsInstancedEXT_fnptr((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_EXT_draw_range_elements]</b> <b>[entry point: <c>glDrawRangeElementsEXT</c>]</b><br/>  </summary>
            public static void DrawRangeElementsEXT(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => GLPointers._glDrawRangeElementsEXT_fnptr((uint)mode, start, end, count, (uint)type, indices);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glEdgeFlagPointerEXT</c>]</b><br/>  </summary>
            public static void EdgeFlagPointerEXT(int stride, int count, bool* pointer) => GLPointers._glEdgeFlagPointerEXT_fnptr(stride, count, (byte*)pointer);
            
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage]</b> <b>[entry point: <c>glEGLImageTargetTexStorageEXT</c>]</b><br/>  </summary>
            public static void EGLImageTargetTexStorageEXT(All target, void* image, int* attrib_list) => GLPointers._glEGLImageTargetTexStorageEXT_fnptr((uint)target, image, attrib_list);
            
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage]</b> <b>[entry point: <c>glEGLImageTargetTextureStorageEXT</c>]</b><br/>  </summary>
            public static void EGLImageTargetTextureStorageEXT(int texture, void* image, int* attrib_list) => GLPointers._glEGLImageTargetTextureStorageEXT_fnptr(texture, image, attrib_list);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glEnableClientStateiEXT</c>]</b><br/>  </summary>
            public static void EnableClientStateiEXT(EnableCap array, uint index) => GLPointers._glEnableClientStateiEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glEnableClientStateIndexedEXT</c>]</b><br/>  </summary>
            public static void EnableClientStateIndexedEXT(EnableCap array, uint index) => GLPointers._glEnableClientStateIndexedEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glEnableIndexedEXT</c>]</b><br/>  </summary>
            public static void EnableIndexedEXT(EnableCap target, uint index) => GLPointers._glEnableIndexedEXT_fnptr((uint)target, index);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glEnableVariantClientStateEXT</c>]</b><br/>  </summary>
            public static void EnableVariantClientStateEXT(uint id) => GLPointers._glEnableVariantClientStateEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glEnableVertexArrayAttribEXT</c>]</b><br/>  </summary>
            public static void EnableVertexArrayAttribEXT(int vaobj, uint index) => GLPointers._glEnableVertexArrayAttribEXT_fnptr(vaobj, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glEnableVertexArrayEXT</c>]</b><br/>  </summary>
            public static void EnableVertexArrayEXT(int vaobj, EnableCap array) => GLPointers._glEnableVertexArrayEXT_fnptr(vaobj, (uint)array);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glEndTransformFeedbackEXT</c>]</b><br/>  </summary>
            public static void EndTransformFeedbackEXT() => GLPointers._glEndTransformFeedbackEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glEndVertexShaderEXT</c>]</b><br/>  </summary>
            public static void EndVertexShaderEXT() => GLPointers._glEndVertexShaderEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glExtractComponentEXT</c>]</b><br/>  </summary>
            public static void ExtractComponentEXT(uint res, uint src, uint num) => GLPointers._glExtractComponentEXT_fnptr(res, src, num);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glFlushMappedNamedBufferRangeEXT</c>]</b><br/>  </summary>
            public static void FlushMappedNamedBufferRangeEXT(int buffer, IntPtr offset, nint length) => GLPointers._glFlushMappedNamedBufferRangeEXT_fnptr(buffer, offset, length);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoorddEXT</c>]</b><br/>  </summary>
            public static void FogCoorddEXT(double coord) => GLPointers._glFogCoorddEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoorddvEXT</c>]</b><br/>  </summary>
            public static void FogCoorddvEXT(double* coord) => GLPointers._glFogCoorddvEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoordfEXT</c>]</b><br/>  </summary>
            public static void FogCoordfEXT(float coord) => GLPointers._glFogCoordfEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoordfvEXT</c>]</b><br/>  </summary>
            public static void FogCoordfvEXT(float* coord) => GLPointers._glFogCoordfvEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b> <b>[entry point: <c>glFogCoordPointerEXT</c>]</b><br/>  </summary>
            public static void FogCoordPointerEXT(FogPointerTypeEXT type, int stride, void* pointer) => GLPointers._glFogCoordPointerEXT_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glFramebufferDrawBufferEXT</c>]</b><br/>  </summary>
            public static void FramebufferDrawBufferEXT(int framebuffer, DrawBufferMode mode) => GLPointers._glFramebufferDrawBufferEXT_fnptr(framebuffer, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glFramebufferDrawBuffersEXT</c>]</b><br/>  </summary>
            public static void FramebufferDrawBuffersEXT(int framebuffer, int n, DrawBufferMode* bufs) => GLPointers._glFramebufferDrawBuffersEXT_fnptr(framebuffer, n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_EXT_shader_framebuffer_fetch_non_coherent]</b> <b>[entry point: <c>glFramebufferFetchBarrierEXT</c>]</b><br/>  </summary>
            public static void FramebufferFetchBarrierEXT() => GLPointers._glFramebufferFetchBarrierEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glFramebufferReadBufferEXT</c>]</b><br/>  </summary>
            public static void FramebufferReadBufferEXT(int framebuffer, ReadBufferMode mode) => GLPointers._glFramebufferReadBufferEXT_fnptr(framebuffer, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glFramebufferRenderbufferEXT</c>]</b><br/>  </summary>
            public static void FramebufferRenderbufferEXT(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glFramebufferRenderbufferEXT_fnptr((uint)target, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture1DEXT</c>]</b><br/>  </summary>
            public static void FramebufferTexture1DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture1DEXT_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture2DEXT</c>]</b><br/>  </summary>
            public static void FramebufferTexture2DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glFramebufferTexture2DEXT_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glFramebufferTexture3DEXT</c>]</b><br/>  </summary>
            public static void FramebufferTexture3DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers._glFramebufferTexture3DEXT_fnptr((uint)target, (uint)attachment, (uint)textarget, texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4]</b> <b>[entry point: <c>glFramebufferTextureLayerEXT</c>]</b><br/>  </summary>
            public static void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayerEXT_fnptr((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGenerateMipmapEXT</c>]</b><br/>  </summary>
            public static void GenerateMipmapEXT(TextureTarget target) => GLPointers._glGenerateMipmapEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGenerateMultiTexMipmapEXT</c>]</b><br/>  </summary>
            public static void GenerateMultiTexMipmapEXT(TextureUnit texunit, TextureTarget target) => GLPointers._glGenerateMultiTexMipmapEXT_fnptr((uint)texunit, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGenerateTextureMipmapEXT</c>]</b><br/>  </summary>
            public static void GenerateTextureMipmapEXT(int texture, TextureTarget target) => GLPointers._glGenerateTextureMipmapEXT_fnptr(texture, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGenFramebuffersEXT</c>]</b><br/>  </summary>
            public static void GenFramebuffersEXT(int n, int* framebuffers) => GLPointers._glGenFramebuffersEXT_fnptr(n, framebuffers);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glGenProgramPipelinesEXT</c>]</b><br/>  </summary>
            public static void GenProgramPipelinesEXT(int n, int* pipelines) => GLPointers._glGenProgramPipelinesEXT_fnptr(n, pipelines);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGenRenderbuffersEXT</c>]</b><br/>  </summary>
            public static void GenRenderbuffersEXT(int n, int* renderbuffers) => GLPointers._glGenRenderbuffersEXT_fnptr(n, renderbuffers);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glGenSemaphoresEXT</c>]</b><br/>  </summary>
            public static void GenSemaphoresEXT(int n, uint* semaphores) => GLPointers._glGenSemaphoresEXT_fnptr(n, semaphores);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGenSymbolsEXT</c>]</b><br/>  </summary>
            public static uint GenSymbolsEXT(DataTypeEXT datatype, VertexShaderStorageTypeEXT storagetype, ParameterRangeEXT range, uint components) => GLPointers._glGenSymbolsEXT_fnptr((uint)datatype, (uint)storagetype, (uint)range, components);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glGenTexturesEXT</c>]</b><br/>  </summary>
            public static void GenTexturesEXT(int n, int* textures) => GLPointers._glGenTexturesEXT_fnptr(n, textures);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGenVertexShadersEXT</c>]</b><br/>  </summary>
            public static uint GenVertexShadersEXT(uint range) => GLPointers._glGenVertexShadersEXT_fnptr(range);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glGetBooleanIndexedvEXT</c>]</b><br/>  </summary>
            public static void GetBooleanIndexedvEXT(BufferTargetARB target, uint index, bool* data) => GLPointers._glGetBooleanIndexedvEXT_fnptr((uint)target, index, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b> <b>[entry point: <c>glGetColorTableEXT</c>]</b><br/>  </summary>
            public static void GetColorTableEXT(ColorTableTarget target, PixelFormat format, PixelType type, void* data) => GLPointers._glGetColorTableEXT_fnptr((uint)target, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b> <b>[entry point: <c>glGetColorTableParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetColorTableParameterfvEXT(ColorTableTarget target, ColorTableParameterPName pname, float* parameters) => GLPointers._glGetColorTableParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b> <b>[entry point: <c>glGetColorTableParameterivEXT</c>]</b><br/>  </summary>
            public static void GetColorTableParameterivEXT(ColorTableTarget target, ColorTableParameterPName pname, int* parameters) => GLPointers._glGetColorTableParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetCompressedMultiTexImageEXT</c>]</b><br/>  </summary>
            public static void GetCompressedMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int lod, void* img) => GLPointers._glGetCompressedMultiTexImageEXT_fnptr((uint)texunit, (uint)target, lod, img);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetCompressedTextureImageEXT</c>]</b><br/>  </summary>
            public static void GetCompressedTextureImageEXT(int texture, TextureTarget target, int lod, void* img) => GLPointers._glGetCompressedTextureImageEXT_fnptr(texture, (uint)target, lod, img);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glGetConvolutionFilterEXT</c>]</b><br/>  </summary>
            public static void GetConvolutionFilterEXT(ConvolutionTargetEXT target, PixelFormat format, PixelType type, void* image) => GLPointers._glGetConvolutionFilterEXT_fnptr((uint)target, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glGetConvolutionParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, float* parameters) => GLPointers._glGetConvolutionParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glGetConvolutionParameterivEXT</c>]</b><br/>  </summary>
            public static void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameter pname, int* parameters) => GLPointers._glGetConvolutionParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetDoublei_vEXT</c>]</b><br/>  </summary>
            public static void GetDoublei_vEXT(GetPName pname, uint index, double* parameters) => GLPointers._glGetDoublei_vEXT_fnptr((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetDoubleIndexedvEXT</c>]</b><br/>  </summary>
            public static void GetDoubleIndexedvEXT(GetPName target, uint index, double* data) => GLPointers._glGetDoubleIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetFloati_vEXT</c>]</b><br/>  </summary>
            public static void GetFloati_vEXT(GetPName pname, uint index, float* parameters) => GLPointers._glGetFloati_vEXT_fnptr((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetFloatIndexedvEXT</c>]</b><br/>  </summary>
            public static void GetFloatIndexedvEXT(GetPName target, uint index, float* data) => GLPointers._glGetFloatIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glGetFragDataLocationEXT</c>]</b><br/>  </summary>
            public static int GetFragDataLocationEXT(int program, byte* name) => GLPointers._glGetFragDataLocationEXT_fnptr(program, name);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGetFramebufferAttachmentParameterivEXT</c>]</b><br/>  </summary>
            public static void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferAttachmentParameterivEXT_fnptr((uint)target, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetFramebufferParameterivEXT</c>]</b><br/>  </summary>
            public static void GetFramebufferParameterivEXT(int framebuffer, GetFramebufferParameter pname, int* parameters) => GLPointers._glGetFramebufferParameterivEXT_fnptr(framebuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetHistogramEXT</c>]</b><br/>  </summary>
            public static void GetHistogramEXT(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._glGetHistogramEXT_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetHistogramParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters) => GLPointers._glGetHistogramParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetHistogramParameterivEXT</c>]</b><br/>  </summary>
            public static void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers._glGetHistogramParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glGetIntegerIndexedvEXT</c>]</b><br/>  </summary>
            public static void GetIntegerIndexedvEXT(GetPName target, uint index, int* data) => GLPointers._glGetIntegerIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetInvariantBooleanvEXT</c>]</b><br/>  </summary>
            public static void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, bool* data) => GLPointers._glGetInvariantBooleanvEXT_fnptr(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetInvariantFloatvEXT</c>]</b><br/>  </summary>
            public static void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => GLPointers._glGetInvariantFloatvEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetInvariantIntegervEXT</c>]</b><br/>  </summary>
            public static void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => GLPointers._glGetInvariantIntegervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetLocalConstantBooleanvEXT</c>]</b><br/>  </summary>
            public static void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, bool* data) => GLPointers._glGetLocalConstantBooleanvEXT_fnptr(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetLocalConstantFloatvEXT</c>]</b><br/>  </summary>
            public static void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => GLPointers._glGetLocalConstantFloatvEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetLocalConstantIntegervEXT</c>]</b><br/>  </summary>
            public static void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => GLPointers._glGetLocalConstantIntegervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glGetMemoryObjectParameterivEXT</c>]</b><br/>  </summary>
            public static void GetMemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => GLPointers._glGetMemoryObjectParameterivEXT_fnptr(memoryObject, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetMinmaxEXT</c>]</b><br/>  </summary>
            public static void GetMinmaxEXT(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._glGetMinmaxEXT_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetMinmaxParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters) => GLPointers._glGetMinmaxParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glGetMinmaxParameterivEXT</c>]</b><br/>  </summary>
            public static void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters) => GLPointers._glGetMinmaxParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexEnvfvEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._glGetMultiTexEnvfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexEnvivEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glGetMultiTexEnvivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexGendvEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._glGetMultiTexGendvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexGenfvEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._glGetMultiTexGenfvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexGenivEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glGetMultiTexGenivEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexImageEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers._glGetMultiTexImageEXT_fnptr((uint)texunit, (uint)target, level, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexLevelParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetMultiTexLevelParameterfvEXT_fnptr((uint)texunit, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexLevelParameterivEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetMultiTexLevelParameterivEXT_fnptr((uint)texunit, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers._glGetMultiTexParameterfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexParameterIivEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetMultiTexParameterIivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexParameterIuivEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._glGetMultiTexParameterIuivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetMultiTexParameterivEXT</c>]</b><br/>  </summary>
            public static void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetMultiTexParameterivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferParameterivEXT</c>]</b><br/>  </summary>
            public static void GetNamedBufferParameterivEXT(int buffer, BufferPNameARB pname, int* parameters) => GLPointers._glGetNamedBufferParameterivEXT_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferPointervEXT</c>]</b><br/>  </summary>
            public static void GetNamedBufferPointervEXT_(int buffer, BufferPointerNameARB pname, void** parameters) => GLPointers._glGetNamedBufferPointervEXT_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedBufferSubDataEXT</c>]</b><br/>  </summary>
            public static void GetNamedBufferSubDataEXT(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glGetNamedBufferSubDataEXT_fnptr(buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferAttachmentParameterivEXT</c>]</b><br/>  </summary>
            public static void GetNamedFramebufferAttachmentParameterivEXT(int framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetNamedFramebufferAttachmentParameterivEXT_fnptr(framebuffer, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedFramebufferParameterivEXT</c>]</b><br/>  </summary>
            public static void GetNamedFramebufferParameterivEXT(int framebuffer, GetFramebufferParameter pname, int* parameters) => GLPointers._glGetNamedFramebufferParameterivEXT_fnptr(framebuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramivEXT</c>]</b><br/>  </summary>
            public static void GetNamedProgramivEXT(int program, ProgramTarget target, ProgramPropertyARB pname, int* parameters) => GLPointers._glGetNamedProgramivEXT_fnptr(program, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramLocalParameterdvEXT</c>]</b><br/>  </summary>
            public static void GetNamedProgramLocalParameterdvEXT(int program, ProgramTarget target, uint index, double* parameters) => GLPointers._glGetNamedProgramLocalParameterdvEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramLocalParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetNamedProgramLocalParameterfvEXT(int program, ProgramTarget target, uint index, float* parameters) => GLPointers._glGetNamedProgramLocalParameterfvEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramLocalParameterIivEXT</c>]</b><br/>  </summary>
            public static void GetNamedProgramLocalParameterIivEXT(int program, ProgramTarget target, uint index, int* parameters) => GLPointers._glGetNamedProgramLocalParameterIivEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramLocalParameterIuivEXT</c>]</b><br/>  </summary>
            public static void GetNamedProgramLocalParameterIuivEXT(int program, ProgramTarget target, uint index, uint* parameters) => GLPointers._glGetNamedProgramLocalParameterIuivEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedProgramStringEXT</c>]</b><br/>  </summary>
            public static void GetNamedProgramStringEXT(int program, ProgramTarget target, ProgramStringProperty pname, void* str) => GLPointers._glGetNamedProgramStringEXT_fnptr(program, (uint)target, (uint)pname, str);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetNamedRenderbufferParameterivEXT</c>]</b><br/>  </summary>
            public static void GetNamedRenderbufferParameterivEXT(int renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetNamedRenderbufferParameterivEXT_fnptr(renderbuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_debug_label]</b> <b>[entry point: <c>glGetObjectLabelEXT</c>]</b><br/>  </summary>
            public static void GetObjectLabelEXT(All type, uint obj, int bufSize, int* length, byte* label) => GLPointers._glGetObjectLabelEXT_fnptr((uint)type, obj, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glGetPixelTransformParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetPixelTransformParameterfvEXT(All target, All pname, float* parameters) => GLPointers._glGetPixelTransformParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glGetPixelTransformParameterivEXT</c>]</b><br/>  </summary>
            public static void GetPixelTransformParameterivEXT(All target, All pname, int* parameters) => GLPointers._glGetPixelTransformParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetPointeri_vEXT</c>]</b><br/>  </summary>
            public static void GetPointeri_vEXT_(All pname, uint index, void** parameters) => GLPointers._glGetPointeri_vEXT_fnptr((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetPointerIndexedvEXT</c>]</b><br/>  </summary>
            public static void GetPointerIndexedvEXT_(All target, uint index, void** data) => GLPointers._glGetPointerIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glGetPointervEXT</c>]</b><br/>  </summary>
            public static void GetPointervEXT_(GetPointervPName pname, void** parameters) => GLPointers._glGetPointervEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineInfoLogEXT</c>]</b><br/>  </summary>
            public static void GetProgramPipelineInfoLogEXT(int pipeline, int bufSize, int* length, byte* infoLog) => GLPointers._glGetProgramPipelineInfoLogEXT_fnptr(pipeline, bufSize, length, infoLog);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glGetProgramPipelineivEXT</c>]</b><br/>  </summary>
            public static void GetProgramPipelineivEXT(int pipeline, PipelineParameterName pname, int* parameters) => GLPointers._glGetProgramPipelineivEXT_fnptr(pipeline, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_timer_query]</b> <b>[entry point: <c>glGetQueryObjecti64vEXT</c>]</b><br/>  </summary>
            public static void GetQueryObjecti64vEXT(int id, QueryObjectParameterName pname, long* parameters) => GLPointers._glGetQueryObjecti64vEXT_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_timer_query]</b> <b>[entry point: <c>glGetQueryObjectui64vEXT</c>]</b><br/>  </summary>
            public static void GetQueryObjectui64vEXT(int id, QueryObjectParameterName pname, ulong* parameters) => GLPointers._glGetQueryObjectui64vEXT_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glGetRenderbufferParameterivEXT</c>]</b><br/>  </summary>
            public static void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers._glGetRenderbufferParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glGetSemaphoreParameterui64vEXT</c>]</b><br/>  </summary>
            public static void GetSemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => GLPointers._glGetSemaphoreParameterui64vEXT_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glGetSeparableFilterEXT</c>]</b><br/>  </summary>
            public static void GetSeparableFilterEXT(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span) => GLPointers._glGetSeparableFilterEXT_fnptr((uint)target, (uint)format, (uint)type, row, column, span);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glGetTexParameterIivEXT</c>]</b><br/>  </summary>
            public static void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexParameterIivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glGetTexParameterIuivEXT</c>]</b><br/>  </summary>
            public static void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTexParameterIuivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureImageEXT</c>]</b><br/>  </summary>
            public static void GetTextureImageEXT(int texture, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers._glGetTextureImageEXT_fnptr(texture, (uint)target, level, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetTextureLevelParameterfvEXT(int texture, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureLevelParameterfvEXT_fnptr(texture, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureLevelParameterivEXT</c>]</b><br/>  </summary>
            public static void GetTextureLevelParameterivEXT(int texture, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureLevelParameterivEXT_fnptr(texture, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterfvEXT</c>]</b><br/>  </summary>
            public static void GetTextureParameterfvEXT(int texture, TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers._glGetTextureParameterfvEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIivEXT</c>]</b><br/>  </summary>
            public static void GetTextureParameterIivEXT(int texture, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameterIivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterIuivEXT</c>]</b><br/>  </summary>
            public static void GetTextureParameterIuivEXT(int texture, TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._glGetTextureParameterIuivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetTextureParameterivEXT</c>]</b><br/>  </summary>
            public static void GetTextureParameterivEXT(int texture, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTextureParameterivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glGetTransformFeedbackVaryingEXT</c>]</b><br/>  </summary>
            public static void GetTransformFeedbackVaryingEXT(int program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers._glGetTransformFeedbackVaryingEXT_fnptr(program, index, bufSize, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b> <b>[entry point: <c>glGetUniformBufferSizeEXT</c>]</b><br/>  </summary>
            public static int GetUniformBufferSizeEXT(int program, int location) => GLPointers._glGetUniformBufferSizeEXT_fnptr(program, location);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b> <b>[entry point: <c>glGetUniformOffsetEXT</c>]</b><br/>  </summary>
            public static IntPtr GetUniformOffsetEXT(int program, int location) => GLPointers._glGetUniformOffsetEXT_fnptr(program, location);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glGetUniformuivEXT</c>]</b><br/>  </summary>
            public static void GetUniformuivEXT(int program, int location, uint* parameters) => GLPointers._glGetUniformuivEXT_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore]</b> <b>[entry point: <c>glGetUnsignedBytei_vEXT</c>]</b><br/>  </summary>
            public static void GetUnsignedBytei_vEXT(All target, uint index, byte* data) => GLPointers._glGetUnsignedBytei_vEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore]</b> <b>[entry point: <c>glGetUnsignedBytevEXT</c>]</b><br/>  </summary>
            public static void GetUnsignedBytevEXT(GetPName pname, byte* data) => GLPointers._glGetUnsignedBytevEXT_fnptr((uint)pname, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetVariantBooleanvEXT</c>]</b><br/>  </summary>
            public static void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, bool* data) => GLPointers._glGetVariantBooleanvEXT_fnptr(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetVariantFloatvEXT</c>]</b><br/>  </summary>
            public static void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => GLPointers._glGetVariantFloatvEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetVariantIntegervEXT</c>]</b><br/>  </summary>
            public static void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => GLPointers._glGetVariantIntegervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glGetVariantPointervEXT</c>]</b><br/>  </summary>
            public static void GetVariantPointervEXT_(uint id, GetVariantValueEXT value, void** data) => GLPointers._glGetVariantPointervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIntegeri_vEXT</c>]</b><br/>  </summary>
            public static void GetVertexArrayIntegeri_vEXT(int vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayIntegeri_vEXT_fnptr(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayIntegervEXT</c>]</b><br/>  </summary>
            public static void GetVertexArrayIntegervEXT(int vaobj, VertexArrayPName pname, int* param) => GLPointers._glGetVertexArrayIntegervEXT_fnptr(vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayPointeri_vEXT</c>]</b><br/>  </summary>
            public static void GetVertexArrayPointeri_vEXT_(int vaobj, uint index, VertexArrayPName pname, void** param) => GLPointers._glGetVertexArrayPointeri_vEXT_fnptr(vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glGetVertexArrayPointervEXT</c>]</b><br/>  </summary>
            public static void GetVertexArrayPointervEXT_(int vaobj, VertexArrayPName pname, void** param) => GLPointers._glGetVertexArrayPointervEXT_fnptr(vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glGetVertexAttribIivEXT</c>]</b><br/>  </summary>
            public static void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int* parameters) => GLPointers._glGetVertexAttribIivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glGetVertexAttribIuivEXT</c>]</b><br/>  </summary>
            public static void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers._glGetVertexAttribIuivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glGetVertexAttribLdvEXT</c>]</b><br/>  </summary>
            public static void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, double* parameters) => GLPointers._glGetVertexAttribLdvEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glHistogramEXT</c>]</b><br/>  </summary>
            public static void HistogramEXT(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink) => GLPointers._glHistogramEXT_fnptr((uint)target, width, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_memory_object_fd]</b> <b>[entry point: <c>glImportMemoryFdEXT</c>]</b><br/>  </summary>
            public static void ImportMemoryFdEXT(uint memory, ulong size, ExternalHandleType handleType, int fd) => GLPointers._glImportMemoryFdEXT_fnptr(memory, size, (uint)handleType, fd);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_win32]</b> <b>[entry point: <c>glImportMemoryWin32HandleEXT</c>]</b><br/>  </summary>
            public static void ImportMemoryWin32HandleEXT(uint memory, ulong size, ExternalHandleType handleType, void* handle) => GLPointers._glImportMemoryWin32HandleEXT_fnptr(memory, size, (uint)handleType, handle);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_win32]</b> <b>[entry point: <c>glImportMemoryWin32NameEXT</c>]</b><br/>  </summary>
            public static void ImportMemoryWin32NameEXT(uint memory, ulong size, ExternalHandleType handleType, void* name) => GLPointers._glImportMemoryWin32NameEXT_fnptr(memory, size, (uint)handleType, name);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_fd]</b> <b>[entry point: <c>glImportSemaphoreFdEXT</c>]</b><br/>  </summary>
            public static void ImportSemaphoreFdEXT(uint semaphore, ExternalHandleType handleType, int fd) => GLPointers._glImportSemaphoreFdEXT_fnptr(semaphore, (uint)handleType, fd);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_win32]</b> <b>[entry point: <c>glImportSemaphoreWin32HandleEXT</c>]</b><br/>  </summary>
            public static void ImportSemaphoreWin32HandleEXT(uint semaphore, ExternalHandleType handleType, void* handle) => GLPointers._glImportSemaphoreWin32HandleEXT_fnptr(semaphore, (uint)handleType, handle);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_win32]</b> <b>[entry point: <c>glImportSemaphoreWin32NameEXT</c>]</b><br/>  </summary>
            public static void ImportSemaphoreWin32NameEXT(uint semaphore, ExternalHandleType handleType, void* name) => GLPointers._glImportSemaphoreWin32NameEXT_fnptr(semaphore, (uint)handleType, name);
            
            /// <summary> <b>[requires: GL_EXT_x11_sync_object]</b> <b>[entry point: <c>glImportSyncEXT</c>]</b><br/>  </summary>
            public static GLSync ImportSyncEXT(All external_sync_type, IntPtr external_sync, uint flags) => (GLSync) GLPointers._glImportSyncEXT_fnptr((uint)external_sync_type, external_sync, flags);
            
            /// <summary> <b>[requires: GL_EXT_index_func]</b> <b>[entry point: <c>glIndexFuncEXT</c>]</b><br/>  </summary>
            public static void IndexFuncEXT(IndexFunctionEXT func, float reference) => GLPointers._glIndexFuncEXT_fnptr((uint)func, reference);
            
            /// <summary> <b>[requires: GL_EXT_index_material]</b> <b>[entry point: <c>glIndexMaterialEXT</c>]</b><br/>  </summary>
            public static void IndexMaterialEXT(TriangleFace face, IndexMaterialParameterEXT mode) => GLPointers._glIndexMaterialEXT_fnptr((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glIndexPointerEXT</c>]</b><br/>  </summary>
            public static void IndexPointerEXT(IndexPointerType type, int stride, int count, void* pointer) => GLPointers._glIndexPointerEXT_fnptr((uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glInsertComponentEXT</c>]</b><br/>  </summary>
            public static void InsertComponentEXT(uint res, uint src, uint num) => GLPointers._glInsertComponentEXT_fnptr(res, src, num);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b> <b>[entry point: <c>glInsertEventMarkerEXT</c>]</b><br/>  </summary>
            public static void InsertEventMarkerEXT(int length, byte* marker) => GLPointers._glInsertEventMarkerEXT_fnptr(length, marker);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b> <b>[entry point: <c>glIsEnabledIndexedEXT</c>]</b><br/>  </summary>
            public static bool IsEnabledIndexedEXT(EnableCap target, uint index) => GLPointers._glIsEnabledIndexedEXT_fnptr((uint)target, index) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glIsFramebufferEXT</c>]</b><br/>  </summary>
            public static bool IsFramebufferEXT(int framebuffer) => GLPointers._glIsFramebufferEXT_fnptr(framebuffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glIsMemoryObjectEXT</c>]</b><br/>  </summary>
            public static bool IsMemoryObjectEXT(uint memoryObject) => GLPointers._glIsMemoryObjectEXT_fnptr(memoryObject) != 0;
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glIsProgramPipelineEXT</c>]</b><br/>  </summary>
            public static bool IsProgramPipelineEXT(int pipeline) => GLPointers._glIsProgramPipelineEXT_fnptr(pipeline) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glIsRenderbufferEXT</c>]</b><br/>  </summary>
            public static bool IsRenderbufferEXT(int renderbuffer) => GLPointers._glIsRenderbufferEXT_fnptr(renderbuffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glIsSemaphoreEXT</c>]</b><br/>  </summary>
            public static bool IsSemaphoreEXT(uint semaphore) => GLPointers._glIsSemaphoreEXT_fnptr(semaphore) != 0;
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glIsTextureEXT</c>]</b><br/>  </summary>
            public static bool IsTextureEXT(int texture) => GLPointers._glIsTextureEXT_fnptr(texture) != 0;
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glIsVariantEnabledEXT</c>]</b><br/>  </summary>
            public static bool IsVariantEnabledEXT(uint id, VariantCapEXT cap) => GLPointers._glIsVariantEnabledEXT_fnptr(id, (uint)cap) != 0;
            
            /// <summary> <b>[requires: GL_EXT_debug_label]</b> <b>[entry point: <c>glLabelObjectEXT</c>]</b><br/>  </summary>
            public static void LabelObjectEXT(All type, uint obj, int length, byte* label) => GLPointers._glLabelObjectEXT_fnptr((uint)type, obj, length, label);
            
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array]</b> <b>[entry point: <c>glLockArraysEXT</c>]</b><br/>  </summary>
            public static void LockArraysEXT(int first, int count) => GLPointers._glLockArraysEXT_fnptr(first, count);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMapNamedBufferEXT</c>]</b><br/>  </summary>
            public static void* MapNamedBufferEXT(int buffer, BufferAccessARB access) => GLPointers._glMapNamedBufferEXT_fnptr(buffer, (uint)access);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMapNamedBufferRangeEXT</c>]</b><br/>  </summary>
            public static void* MapNamedBufferRangeEXT(int buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._glMapNamedBufferRangeEXT_fnptr(buffer, offset, length, (uint)access);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixFrustumEXT</c>]</b><br/>  </summary>
            public static void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glMatrixFrustumEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoaddEXT</c>]</b><br/>  </summary>
            public static void MatrixLoaddEXT(MatrixMode mode, double* m) => GLPointers._glMatrixLoaddEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadfEXT</c>]</b><br/>  </summary>
            public static void MatrixLoadfEXT(MatrixMode mode, float* m) => GLPointers._glMatrixLoadfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadIdentityEXT</c>]</b><br/>  </summary>
            public static void MatrixLoadIdentityEXT(MatrixMode mode) => GLPointers._glMatrixLoadIdentityEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTransposedEXT</c>]</b><br/>  </summary>
            public static void MatrixLoadTransposedEXT(MatrixMode mode, double* m) => GLPointers._glMatrixLoadTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTransposefEXT</c>]</b><br/>  </summary>
            public static void MatrixLoadTransposefEXT(MatrixMode mode, float* m) => GLPointers._glMatrixLoadTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultdEXT</c>]</b><br/>  </summary>
            public static void MatrixMultdEXT(MatrixMode mode, double* m) => GLPointers._glMatrixMultdEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultfEXT</c>]</b><br/>  </summary>
            public static void MatrixMultfEXT(MatrixMode mode, float* m) => GLPointers._glMatrixMultfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTransposedEXT</c>]</b><br/>  </summary>
            public static void MatrixMultTransposedEXT(MatrixMode mode, double* m) => GLPointers._glMatrixMultTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTransposefEXT</c>]</b><br/>  </summary>
            public static void MatrixMultTransposefEXT(MatrixMode mode, float* m) => GLPointers._glMatrixMultTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixOrthoEXT</c>]</b><br/>  </summary>
            public static void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glMatrixOrthoEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixPopEXT</c>]</b><br/>  </summary>
            public static void MatrixPopEXT(MatrixMode mode) => GLPointers._glMatrixPopEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixPushEXT</c>]</b><br/>  </summary>
            public static void MatrixPushEXT(MatrixMode mode) => GLPointers._glMatrixPushEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixRotatedEXT</c>]</b><br/>  </summary>
            public static void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => GLPointers._glMatrixRotatedEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixRotatefEXT</c>]</b><br/>  </summary>
            public static void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => GLPointers._glMatrixRotatefEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixScaledEXT</c>]</b><br/>  </summary>
            public static void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => GLPointers._glMatrixScaledEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixScalefEXT</c>]</b><br/>  </summary>
            public static void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._glMatrixScalefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixTranslatedEXT</c>]</b><br/>  </summary>
            public static void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => GLPointers._glMatrixTranslatedEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixTranslatefEXT</c>]</b><br/>  </summary>
            public static void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._glMatrixTranslatefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store]</b> <b>[entry point: <c>glMemoryBarrierEXT</c>]</b><br/>  </summary>
            public static void MemoryBarrierEXT(MemoryBarrierMask barriers) => GLPointers._glMemoryBarrierEXT_fnptr((uint)barriers);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glMemoryObjectParameterivEXT</c>]</b><br/>  </summary>
            public static void MemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => GLPointers._glMemoryObjectParameterivEXT_fnptr(memoryObject, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glMinmaxEXT</c>]</b><br/>  </summary>
            public static void MinmaxEXT(MinmaxTargetEXT target, InternalFormat internalformat, bool sink) => GLPointers._glMinmaxEXT_fnptr((uint)target, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays]</b> <b>[entry point: <c>glMultiDrawArraysEXT</c>]</b><br/>  </summary>
            public static void MultiDrawArraysEXT(PrimitiveType mode, int* first, int* count, int primcount) => GLPointers._glMultiDrawArraysEXT_fnptr((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays]</b> <b>[entry point: <c>glMultiDrawElementsEXT</c>]</b><br/>  </summary>
            public static void MultiDrawElementsEXT(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int primcount) => GLPointers._glMultiDrawElementsEXT_fnptr((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexBufferEXT</c>]</b><br/>  </summary>
            public static void MultiTexBufferEXT(TextureUnit texunit, TextureTarget target, InternalFormat internalformat, int buffer) => GLPointers._glMultiTexBufferEXT_fnptr((uint)texunit, (uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexCoordPointerEXT</c>]</b><br/>  </summary>
            public static void MultiTexCoordPointerEXT(TextureUnit texunit, int size, TexCoordPointerType type, int stride, void* pointer) => GLPointers._glMultiTexCoordPointerEXT_fnptr((uint)texunit, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexEnvfEXT</c>]</b><br/>  </summary>
            public static void MultiTexEnvfEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float param) => GLPointers._glMultiTexEnvfEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexEnvfvEXT</c>]</b><br/>  </summary>
            public static void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._glMultiTexEnvfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexEnviEXT</c>]</b><br/>  </summary>
            public static void MultiTexEnviEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers._glMultiTexEnviEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexEnvivEXT</c>]</b><br/>  </summary>
            public static void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glMultiTexEnvivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGendEXT</c>]</b><br/>  </summary>
            public static void MultiTexGendEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double param) => GLPointers._glMultiTexGendEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGendvEXT</c>]</b><br/>  </summary>
            public static void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._glMultiTexGendvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGenfEXT</c>]</b><br/>  </summary>
            public static void MultiTexGenfEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float param) => GLPointers._glMultiTexGenfEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGenfvEXT</c>]</b><br/>  </summary>
            public static void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._glMultiTexGenfvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGeniEXT</c>]</b><br/>  </summary>
            public static void MultiTexGeniEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers._glMultiTexGeniEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexGenivEXT</c>]</b><br/>  </summary>
            public static void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glMultiTexGenivEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexImage1DEXT</c>]</b><br/>  </summary>
            public static void MultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexImage1DEXT_fnptr((uint)texunit, (uint)target, level, (int)internalformat, width, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexImage2DEXT</c>]</b><br/>  </summary>
            public static void MultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexImage2DEXT_fnptr((uint)texunit, (uint)target, level, (int)internalformat, width, height, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexImage3DEXT</c>]</b><br/>  </summary>
            public static void MultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexImage3DEXT_fnptr((uint)texunit, (uint)target, level, (int)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterfEXT</c>]</b><br/>  </summary>
            public static void MultiTexParameterfEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float param) => GLPointers._glMultiTexParameterfEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterfvEXT</c>]</b><br/>  </summary>
            public static void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers._glMultiTexParameterfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameteriEXT</c>]</b><br/>  </summary>
            public static void MultiTexParameteriEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int param) => GLPointers._glMultiTexParameteriEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterIivEXT</c>]</b><br/>  </summary>
            public static void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glMultiTexParameterIivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterIuivEXT</c>]</b><br/>  </summary>
            public static void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._glMultiTexParameterIuivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexParameterivEXT</c>]</b><br/>  </summary>
            public static void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glMultiTexParameterivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexRenderbufferEXT</c>]</b><br/>  </summary>
            public static void MultiTexRenderbufferEXT(TextureUnit texunit, TextureTarget target, int renderbuffer) => GLPointers._glMultiTexRenderbufferEXT_fnptr((uint)texunit, (uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexSubImage1DEXT</c>]</b><br/>  </summary>
            public static void MultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexSubImage1DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexSubImage2DEXT</c>]</b><br/>  </summary>
            public static void MultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexSubImage2DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glMultiTexSubImage3DEXT</c>]</b><br/>  </summary>
            public static void MultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glMultiTexSubImage3DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedBufferDataEXT</c>]</b><br/>  </summary>
            public static void NamedBufferDataEXT(int buffer, nint size, void* data, VertexBufferObjectUsage usage) => GLPointers._glNamedBufferDataEXT_fnptr(buffer, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedBufferStorageEXT</c>]</b><br/>  </summary>
            public static void NamedBufferStorageEXT(int buffer, nint size, void* data, BufferStorageMask flags) => GLPointers._glNamedBufferStorageEXT_fnptr(buffer, size, data, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_external_buffer]</b> <b>[entry point: <c>glNamedBufferStorageExternalEXT</c>]</b><br/>  </summary>
            public static void NamedBufferStorageExternalEXT(int buffer, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => GLPointers._glNamedBufferStorageExternalEXT_fnptr(buffer, offset, size, clientBuffer, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glNamedBufferStorageMemEXT</c>]</b><br/>  </summary>
            public static void NamedBufferStorageMemEXT(int buffer, nint size, uint memory, ulong offset) => GLPointers._glNamedBufferStorageMemEXT_fnptr(buffer, size, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedBufferSubDataEXT</c>]</b><br/>  </summary>
            public static void NamedBufferSubDataEXT(int buffer, IntPtr offset, nint size, void* data) => GLPointers._glNamedBufferSubDataEXT_fnptr(buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedCopyBufferSubDataEXT</c>]</b><br/>  </summary>
            public static void NamedCopyBufferSubDataEXT(int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glNamedCopyBufferSubDataEXT_fnptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferParameteriEXT</c>]</b><br/>  </summary>
            public static void NamedFramebufferParameteriEXT(int framebuffer, FramebufferParameterName pname, int param) => GLPointers._glNamedFramebufferParameteriEXT_fnptr(framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferRenderbufferEXT</c>]</b><br/>  </summary>
            public static void NamedFramebufferRenderbufferEXT(int framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, int renderbuffer) => GLPointers._glNamedFramebufferRenderbufferEXT_fnptr(framebuffer, (uint)attachment, (uint)renderbuffertarget, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture1DEXT</c>]</b><br/>  </summary>
            public static void NamedFramebufferTexture1DEXT(int framebuffer, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glNamedFramebufferTexture1DEXT_fnptr(framebuffer, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture2DEXT</c>]</b><br/>  </summary>
            public static void NamedFramebufferTexture2DEXT(int framebuffer, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level) => GLPointers._glNamedFramebufferTexture2DEXT_fnptr(framebuffer, (uint)attachment, (uint)textarget, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTexture3DEXT</c>]</b><br/>  </summary>
            public static void NamedFramebufferTexture3DEXT(int framebuffer, FramebufferAttachment attachment, TextureTarget textarget, int texture, int level, int zoffset) => GLPointers._glNamedFramebufferTexture3DEXT_fnptr(framebuffer, (uint)attachment, (uint)textarget, texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureEXT</c>]</b><br/>  </summary>
            public static void NamedFramebufferTextureEXT(int framebuffer, FramebufferAttachment attachment, int texture, int level) => GLPointers._glNamedFramebufferTextureEXT_fnptr(framebuffer, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureFaceEXT</c>]</b><br/>  </summary>
            public static void NamedFramebufferTextureFaceEXT(int framebuffer, FramebufferAttachment attachment, int texture, int level, TextureTarget face) => GLPointers._glNamedFramebufferTextureFaceEXT_fnptr(framebuffer, (uint)attachment, texture, level, (uint)face);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedFramebufferTextureLayerEXT</c>]</b><br/>  </summary>
            public static void NamedFramebufferTextureLayerEXT(int framebuffer, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glNamedFramebufferTextureLayerEXT_fnptr(framebuffer, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameter4dEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParameter4dEXT(int program, ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers._glNamedProgramLocalParameter4dEXT_fnptr(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameter4dvEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParameter4dvEXT(int program, ProgramTarget target, uint index, double* parameters) => GLPointers._glNamedProgramLocalParameter4dvEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameter4fEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParameter4fEXT(int program, ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers._glNamedProgramLocalParameter4fEXT_fnptr(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameter4fvEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParameter4fvEXT(int program, ProgramTarget target, uint index, float* parameters) => GLPointers._glNamedProgramLocalParameter4fvEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameterI4iEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParameterI4iEXT(int program, ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers._glNamedProgramLocalParameterI4iEXT_fnptr(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameterI4ivEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParameterI4ivEXT(int program, ProgramTarget target, uint index, int* parameters) => GLPointers._glNamedProgramLocalParameterI4ivEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameterI4uiEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParameterI4uiEXT(int program, ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers._glNamedProgramLocalParameterI4uiEXT_fnptr(program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameterI4uivEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParameterI4uivEXT(int program, ProgramTarget target, uint index, uint* parameters) => GLPointers._glNamedProgramLocalParameterI4uivEXT_fnptr(program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParameters4fvEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParameters4fvEXT(int program, ProgramTarget target, uint index, int count, float* parameters) => GLPointers._glNamedProgramLocalParameters4fvEXT_fnptr(program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParametersI4ivEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParametersI4ivEXT(int program, ProgramTarget target, uint index, int count, int* parameters) => GLPointers._glNamedProgramLocalParametersI4ivEXT_fnptr(program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramLocalParametersI4uivEXT</c>]</b><br/>  </summary>
            public static void NamedProgramLocalParametersI4uivEXT(int program, ProgramTarget target, uint index, int count, uint* parameters) => GLPointers._glNamedProgramLocalParametersI4uivEXT_fnptr(program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedProgramStringEXT</c>]</b><br/>  </summary>
            public static void NamedProgramStringEXT(int program, ProgramTarget target, ProgramFormat format, int len, void* str) => GLPointers._glNamedProgramStringEXT_fnptr(program, (uint)target, (uint)format, len, str);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageEXT</c>]</b><br/>  </summary>
            public static void NamedRenderbufferStorageEXT(int renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageEXT_fnptr(renderbuffer, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisampleCoverageEXT</c>]</b><br/>  </summary>
            public static void NamedRenderbufferStorageMultisampleCoverageEXT(int renderbuffer, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisampleCoverageEXT_fnptr(renderbuffer, coverageSamples, colorSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glNamedRenderbufferStorageMultisampleEXT</c>]</b><br/>  </summary>
            public static void NamedRenderbufferStorageMultisampleEXT(int renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glNamedRenderbufferStorageMultisampleEXT_fnptr(renderbuffer, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glNormalPointerEXT</c>]</b><br/>  </summary>
            public static void NormalPointerEXT(NormalPointerType type, int stride, int count, void* pointer) => GLPointers._glNormalPointerEXT_fnptr((uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glPixelTransformParameterfEXT</c>]</b><br/>  </summary>
            public static void PixelTransformParameterfEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float param) => GLPointers._glPixelTransformParameterfEXT_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glPixelTransformParameterfvEXT</c>]</b><br/>  </summary>
            public static void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float* parameters) => GLPointers._glPixelTransformParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glPixelTransformParameteriEXT</c>]</b><br/>  </summary>
            public static void PixelTransformParameteriEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int param) => GLPointers._glPixelTransformParameteriEXT_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b> <b>[entry point: <c>glPixelTransformParameterivEXT</c>]</b><br/>  </summary>
            public static void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int* parameters) => GLPointers._glPixelTransformParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_point_parameters]</b> <b>[entry point: <c>glPointParameterfEXT</c>]</b><br/>  </summary>
            public static void PointParameterfEXT(PointParameterNameARB pname, float param) => GLPointers._glPointParameterfEXT_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_point_parameters]</b> <b>[entry point: <c>glPointParameterfvEXT</c>]</b><br/>  </summary>
            public static void PointParameterfvEXT(PointParameterNameARB pname, float* parameters) => GLPointers._glPointParameterfvEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_polygon_offset_clamp]</b> <b>[entry point: <c>glPolygonOffsetClampEXT</c>]</b><br/>  </summary>
            public static void PolygonOffsetClampEXT(float factor, float units, float clamp) => GLPointers._glPolygonOffsetClampEXT_fnptr(factor, units, clamp);
            
            /// <summary> <b>[requires: GL_EXT_polygon_offset]</b> <b>[entry point: <c>glPolygonOffsetEXT</c>]</b><br/>  </summary>
            public static void PolygonOffsetEXT(float factor, float bias) => GLPointers._glPolygonOffsetEXT_fnptr(factor, bias);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b> <b>[entry point: <c>glPopGroupMarkerEXT</c>]</b><br/>  </summary>
            public static void PopGroupMarkerEXT() => GLPointers._glPopGroupMarkerEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b> <b>[entry point: <c>glPrioritizeTexturesEXT</c>]</b><br/>  </summary>
            public static void PrioritizeTexturesEXT(int n, int* textures, float* priorities) => GLPointers._glPrioritizeTexturesEXT_fnptr(n, textures, priorities);
            
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters]</b> <b>[entry point: <c>glProgramEnvParameters4fvEXT</c>]</b><br/>  </summary>
            public static void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, int count, float* parameters) => GLPointers._glProgramEnvParameters4fvEXT_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters]</b> <b>[entry point: <c>glProgramLocalParameters4fvEXT</c>]</b><br/>  </summary>
            public static void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, int count, float* parameters) => GLPointers._glProgramLocalParameters4fvEXT_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_geometry_shader4 | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramParameteriEXT</c>]</b><br/>  </summary>
            public static void ProgramParameteriEXT(int program, ProgramParameterPName pname, int value) => GLPointers._glProgramParameteriEXT_fnptr(program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform1dEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform1dEXT(int program, int location, double x) => GLPointers._glProgramUniform1dEXT_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform1dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform1dvEXT(int program, int location, int count, double* value) => GLPointers._glProgramUniform1dvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1fEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform1fEXT(int program, int location, float v0) => GLPointers._glProgramUniform1fEXT_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform1fvEXT(int program, int location, int count, float* value) => GLPointers._glProgramUniform1fvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1iEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform1iEXT(int program, int location, int v0) => GLPointers._glProgramUniform1iEXT_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1ivEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform1ivEXT(int program, int location, int count, int* value) => GLPointers._glProgramUniform1ivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1uiEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform1uiEXT(int program, int location, uint v0) => GLPointers._glProgramUniform1uiEXT_fnptr(program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform1uivEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform1uivEXT(int program, int location, int count, uint* value) => GLPointers._glProgramUniform1uivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform2dEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform2dEXT(int program, int location, double x, double y) => GLPointers._glProgramUniform2dEXT_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform2dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform2dvEXT(int program, int location, int count, double* value) => GLPointers._glProgramUniform2dvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2fEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform2fEXT(int program, int location, float v0, float v1) => GLPointers._glProgramUniform2fEXT_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform2fvEXT(int program, int location, int count, float* value) => GLPointers._glProgramUniform2fvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2iEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform2iEXT(int program, int location, int v0, int v1) => GLPointers._glProgramUniform2iEXT_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2ivEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform2ivEXT(int program, int location, int count, int* value) => GLPointers._glProgramUniform2ivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2uiEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform2uiEXT(int program, int location, uint v0, uint v1) => GLPointers._glProgramUniform2uiEXT_fnptr(program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform2uivEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform2uivEXT(int program, int location, int count, uint* value) => GLPointers._glProgramUniform2uivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform3dEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform3dEXT(int program, int location, double x, double y, double z) => GLPointers._glProgramUniform3dEXT_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform3dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform3dvEXT(int program, int location, int count, double* value) => GLPointers._glProgramUniform3dvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3fEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform3fEXT(int program, int location, float v0, float v1, float v2) => GLPointers._glProgramUniform3fEXT_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform3fvEXT(int program, int location, int count, float* value) => GLPointers._glProgramUniform3fvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3iEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform3iEXT(int program, int location, int v0, int v1, int v2) => GLPointers._glProgramUniform3iEXT_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3ivEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform3ivEXT(int program, int location, int count, int* value) => GLPointers._glProgramUniform3ivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3uiEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform3uiEXT(int program, int location, uint v0, uint v1, uint v2) => GLPointers._glProgramUniform3uiEXT_fnptr(program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform3uivEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform3uivEXT(int program, int location, int count, uint* value) => GLPointers._glProgramUniform3uivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform4dEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform4dEXT(int program, int location, double x, double y, double z, double w) => GLPointers._glProgramUniform4dEXT_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniform4dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform4dvEXT(int program, int location, int count, double* value) => GLPointers._glProgramUniform4dvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4fEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform4fEXT(int program, int location, float v0, float v1, float v2, float v3) => GLPointers._glProgramUniform4fEXT_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform4fvEXT(int program, int location, int count, float* value) => GLPointers._glProgramUniform4fvEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4iEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform4iEXT(int program, int location, int v0, int v1, int v2, int v3) => GLPointers._glProgramUniform4iEXT_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4ivEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform4ivEXT(int program, int location, int count, int* value) => GLPointers._glProgramUniform4ivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4uiEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform4uiEXT(int program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glProgramUniform4uiEXT_fnptr(program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniform4uivEXT</c>]</b><br/>  </summary>
            public static void ProgramUniform4uivEXT(int program, int location, int count, uint* value) => GLPointers._glProgramUniform4uivEXT_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix2dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix2dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix2fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix2x3dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix2x3dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x3dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x3fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix2x3fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x3fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix2x4dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix2x4dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix2x4dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix2x4fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix2x4fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix2x4fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix3dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix3dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix3fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix3x2dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix3x2dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x2dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x2fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix3x2fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x2fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix3x4dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix3x4dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix3x4dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix3x4fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix3x4fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix3x4fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix4dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix4dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix4fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix4x2dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix4x2dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x2dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x2fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix4x2fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x2fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glProgramUniformMatrix4x3dvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix4x3dvEXT(int program, int location, int count, bool transpose, double* value) => GLPointers._glProgramUniformMatrix4x3dvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glProgramUniformMatrix4x3fvEXT</c>]</b><br/>  </summary>
            public static void ProgramUniformMatrix4x3fvEXT(int program, int location, int count, bool transpose, float* value) => GLPointers._glProgramUniformMatrix4x3fvEXT_fnptr(program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_provoking_vertex]</b> <b>[entry point: <c>glProvokingVertexEXT</c>]</b><br/>  </summary>
            public static void ProvokingVertexEXT(VertexProvokingMode mode) => GLPointers._glProvokingVertexEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glPushClientAttribDefaultEXT</c>]</b><br/>  </summary>
            public static void PushClientAttribDefaultEXT(ClientAttribMask mask) => GLPointers._glPushClientAttribDefaultEXT_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b> <b>[entry point: <c>glPushGroupMarkerEXT</c>]</b><br/>  </summary>
            public static void PushGroupMarkerEXT(int length, byte* marker) => GLPointers._glPushGroupMarkerEXT_fnptr(length, marker);
            
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glRasterSamplesEXT</c>]</b><br/>  </summary>
            public static void RasterSamplesEXT(uint samples, bool fixedsamplelocations) => GLPointers._glRasterSamplesEXT_fnptr(samples, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex]</b> <b>[entry point: <c>glReleaseKeyedMutexWin32EXT</c>]</b><br/>  </summary>
            public static bool ReleaseKeyedMutexWin32EXT(uint memory, ulong key) => GLPointers._glReleaseKeyedMutexWin32EXT_fnptr(memory, key) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b> <b>[entry point: <c>glRenderbufferStorageEXT</c>]</b><br/>  </summary>
            public static void RenderbufferStorageEXT(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageEXT_fnptr((uint)target, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_multisample]</b> <b>[entry point: <c>glRenderbufferStorageMultisampleEXT</c>]</b><br/>  </summary>
            public static void RenderbufferStorageMultisampleEXT(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisampleEXT_fnptr((uint)target, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glResetHistogramEXT</c>]</b><br/>  </summary>
            public static void ResetHistogramEXT(HistogramTargetEXT target) => GLPointers._glResetHistogramEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b> <b>[entry point: <c>glResetMinmaxEXT</c>]</b><br/>  </summary>
            public static void ResetMinmaxEXT(MinmaxTargetEXT target) => GLPointers._glResetMinmaxEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_multisample]</b> <b>[entry point: <c>glSampleMaskEXT</c>]</b><br/>  </summary>
            public static void SampleMaskEXT(float value, bool invert) => GLPointers._glSampleMaskEXT_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_multisample]</b> <b>[entry point: <c>glSamplePatternEXT</c>]</b><br/>  </summary>
            public static void SamplePatternEXT(SamplePatternEXT pattern) => GLPointers._glSamplePatternEXT_fnptr((uint)pattern);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3bEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3bEXT(sbyte red, sbyte green, sbyte blue) => GLPointers._glSecondaryColor3bEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3bvEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3bvEXT(sbyte* v) => GLPointers._glSecondaryColor3bvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3dEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3dEXT(double red, double green, double blue) => GLPointers._glSecondaryColor3dEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3dvEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3dvEXT(double* v) => GLPointers._glSecondaryColor3dvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3fEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3fEXT(float red, float green, float blue) => GLPointers._glSecondaryColor3fEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3fvEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3fvEXT(float* v) => GLPointers._glSecondaryColor3fvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3iEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3iEXT(int red, int green, int blue) => GLPointers._glSecondaryColor3iEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3ivEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3ivEXT(int* v) => GLPointers._glSecondaryColor3ivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3sEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3sEXT(short red, short green, short blue) => GLPointers._glSecondaryColor3sEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3svEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3svEXT(short* v) => GLPointers._glSecondaryColor3svEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3ubEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3ubEXT(byte red, byte green, byte blue) => GLPointers._glSecondaryColor3ubEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3ubvEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3ubvEXT(byte* v) => GLPointers._glSecondaryColor3ubvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3uiEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3uiEXT(uint red, uint green, uint blue) => GLPointers._glSecondaryColor3uiEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3uivEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3uivEXT(uint* v) => GLPointers._glSecondaryColor3uivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3usEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3usEXT(ushort red, ushort green, ushort blue) => GLPointers._glSecondaryColor3usEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColor3usvEXT</c>]</b><br/>  </summary>
            public static void SecondaryColor3usvEXT(ushort* v) => GLPointers._glSecondaryColor3usvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b> <b>[entry point: <c>glSecondaryColorPointerEXT</c>]</b><br/>  </summary>
            public static void SecondaryColorPointerEXT(int size, ColorPointerType type, int stride, void* pointer) => GLPointers._glSecondaryColorPointerEXT_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glSemaphoreParameterui64vEXT</c>]</b><br/>  </summary>
            public static void SemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => GLPointers._glSemaphoreParameterui64vEXT_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b> <b>[entry point: <c>glSeparableFilter2DEXT</c>]</b><br/>  </summary>
            public static void SeparableFilter2DEXT(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column) => GLPointers._glSeparableFilter2DEXT_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, row, column);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glSetInvariantEXT</c>]</b><br/>  </summary>
            public static void SetInvariantEXT(uint id, ScalarType type, void* addr) => GLPointers._glSetInvariantEXT_fnptr(id, (uint)type, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glSetLocalConstantEXT</c>]</b><br/>  </summary>
            public static void SetLocalConstantEXT(uint id, ScalarType type, void* addr) => GLPointers._glSetLocalConstantEXT_fnptr(id, (uint)type, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glShaderOp1EXT</c>]</b><br/>  </summary>
            public static void ShaderOp1EXT(VertexShaderOpEXT op, uint res, uint arg1) => GLPointers._glShaderOp1EXT_fnptr((uint)op, res, arg1);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glShaderOp2EXT</c>]</b><br/>  </summary>
            public static void ShaderOp2EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2) => GLPointers._glShaderOp2EXT_fnptr((uint)op, res, arg1, arg2);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glShaderOp3EXT</c>]</b><br/>  </summary>
            public static void ShaderOp3EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2, uint arg3) => GLPointers._glShaderOp3EXT_fnptr((uint)op, res, arg1, arg2, arg3);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glSignalSemaphoreEXT</c>]</b><br/>  </summary>
            public static void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, int* buffers, uint numTextureBarriers, int* textures, TextureLayout* dstLayouts) => GLPointers._glSignalSemaphoreEXT_fnptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, (uint*)dstLayouts);
            
            /// <summary> <b>[requires: GL_EXT_stencil_clear_tag]</b> <b>[entry point: <c>glStencilClearTagEXT</c>]</b><br/>  </summary>
            public static void StencilClearTagEXT(int stencilTagBits, uint stencilClearTag) => GLPointers._glStencilClearTagEXT_fnptr(stencilTagBits, stencilClearTag);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glSwizzleEXT</c>]</b><br/>  </summary>
            public static void SwizzleEXT(uint res, uint input, VertexShaderCoordOutEXT outX, VertexShaderCoordOutEXT outY, VertexShaderCoordOutEXT outZ, VertexShaderCoordOutEXT outW) => GLPointers._glSwizzleEXT_fnptr(res, input, (uint)outX, (uint)outY, (uint)outZ, (uint)outW);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3bEXT</c>]</b><br/>  </summary>
            public static void Tangent3bEXT(sbyte tx, sbyte ty, sbyte tz) => GLPointers._glTangent3bEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3bvEXT</c>]</b><br/>  </summary>
            public static void Tangent3bvEXT(sbyte* v) => GLPointers._glTangent3bvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3dEXT</c>]</b><br/>  </summary>
            public static void Tangent3dEXT(double tx, double ty, double tz) => GLPointers._glTangent3dEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3dvEXT</c>]</b><br/>  </summary>
            public static void Tangent3dvEXT(double* v) => GLPointers._glTangent3dvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3fEXT</c>]</b><br/>  </summary>
            public static void Tangent3fEXT(float tx, float ty, float tz) => GLPointers._glTangent3fEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3fvEXT</c>]</b><br/>  </summary>
            public static void Tangent3fvEXT(float* v) => GLPointers._glTangent3fvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3iEXT</c>]</b><br/>  </summary>
            public static void Tangent3iEXT(int tx, int ty, int tz) => GLPointers._glTangent3iEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3ivEXT</c>]</b><br/>  </summary>
            public static void Tangent3ivEXT(int* v) => GLPointers._glTangent3ivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3sEXT</c>]</b><br/>  </summary>
            public static void Tangent3sEXT(short tx, short ty, short tz) => GLPointers._glTangent3sEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangent3svEXT</c>]</b><br/>  </summary>
            public static void Tangent3svEXT(short* v) => GLPointers._glTangent3svEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b> <b>[entry point: <c>glTangentPointerEXT</c>]</b><br/>  </summary>
            public static void TangentPointerEXT(TangentPointerTypeEXT type, int stride, void* pointer) => GLPointers._glTangentPointerEXT_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_texture_buffer_object]</b> <b>[entry point: <c>glTexBufferEXT</c>]</b><br/>  </summary>
            public static void TexBufferEXT(TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers._glTexBufferEXT_fnptr((uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glTexCoordPointerEXT</c>]</b><br/>  </summary>
            public static void TexCoordPointerEXT(int size, TexCoordPointerType type, int stride, int count, void* pointer) => GLPointers._glTexCoordPointerEXT_fnptr(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_texture3D]</b> <b>[entry point: <c>glTexImage3DEXT</c>]</b><br/>  </summary>
            public static void TexImage3DEXT(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage3DEXT_fnptr((uint)target, level, (uint)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glTexParameterIivEXT</c>]</b><br/>  </summary>
            public static void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTexParameterIivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b> <b>[entry point: <c>glTexParameterIuivEXT</c>]</b><br/>  </summary>
            public static void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._glTexParameterIuivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b> <b>[entry point: <c>glTexStorage1DEXT</c>]</b><br/>  </summary>
            public static void TexStorage1DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTexStorage1DEXT_fnptr((uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b> <b>[entry point: <c>glTexStorage2DEXT</c>]</b><br/>  </summary>
            public static void TexStorage2DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTexStorage2DEXT_fnptr((uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b> <b>[entry point: <c>glTexStorage3DEXT</c>]</b><br/>  </summary>
            public static void TexStorage3DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTexStorage3DEXT_fnptr((uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem1DEXT</c>]</b><br/>  </summary>
            public static void TexStorageMem1DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => GLPointers._glTexStorageMem1DEXT_fnptr((uint)target, levels, (uint)internalFormat, width, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem2DEXT</c>]</b><br/>  </summary>
            public static void TexStorageMem2DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => GLPointers._glTexStorageMem2DEXT_fnptr((uint)target, levels, (uint)internalFormat, width, height, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem2DMultisampleEXT</c>]</b><br/>  </summary>
            public static void TexStorageMem2DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._glTexStorageMem2DMultisampleEXT_fnptr((uint)target, samples, (uint)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem3DEXT</c>]</b><br/>  </summary>
            public static void TexStorageMem3DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => GLPointers._glTexStorageMem3DEXT_fnptr((uint)target, levels, (uint)internalFormat, width, height, depth, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTexStorageMem3DMultisampleEXT</c>]</b><br/>  </summary>
            public static void TexStorageMem3DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._glTexStorageMem3DMultisampleEXT_fnptr((uint)target, samples, (uint)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_subtexture]</b> <b>[entry point: <c>glTexSubImage1DEXT</c>]</b><br/>  </summary>
            public static void TexSubImage1DEXT(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage1DEXT_fnptr((uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_subtexture]</b> <b>[entry point: <c>glTexSubImage2DEXT</c>]</b><br/>  </summary>
            public static void TexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage2DEXT_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture3D]</b> <b>[entry point: <c>glTexSubImage3DEXT</c>]</b><br/>  </summary>
            public static void TexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage3DEXT_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureBufferEXT</c>]</b><br/>  </summary>
            public static void TextureBufferEXT(int texture, TextureTarget target, SizedInternalFormat internalformat, int buffer) => GLPointers._glTextureBufferEXT_fnptr(texture, (uint)target, (uint)internalformat, buffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureBufferRangeEXT</c>]</b><br/>  </summary>
            public static void TextureBufferRangeEXT(int texture, TextureTarget target, SizedInternalFormat internalformat, int buffer, IntPtr offset, nint size) => GLPointers._glTextureBufferRangeEXT_fnptr(texture, (uint)target, (uint)internalformat, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureImage1DEXT</c>]</b><br/>  </summary>
            public static void TextureImage1DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureImage1DEXT_fnptr(texture, (uint)target, level, (int)internalformat, width, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureImage2DEXT</c>]</b><br/>  </summary>
            public static void TextureImage2DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureImage2DEXT_fnptr(texture, (uint)target, level, (int)internalformat, width, height, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureImage3DEXT</c>]</b><br/>  </summary>
            public static void TextureImage3DEXT(int texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureImage3DEXT_fnptr(texture, (uint)target, level, (int)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_light_texture]</b> <b>[entry point: <c>glTextureLightEXT</c>]</b><br/>  </summary>
            public static void TextureLightEXT(LightTexturePNameEXT pname) => GLPointers._glTextureLightEXT_fnptr((uint)pname);
            
            /// <summary> <b>[requires: GL_EXT_light_texture]</b> <b>[entry point: <c>glTextureMaterialEXT</c>]</b><br/>  </summary>
            public static void TextureMaterialEXT(TriangleFace face, MaterialParameter mode) => GLPointers._glTextureMaterialEXT_fnptr((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_texture_perturb_normal]</b> <b>[entry point: <c>glTextureNormalEXT</c>]</b><br/>  </summary>
            public static void TextureNormalEXT(TextureNormalModeEXT mode) => GLPointers._glTextureNormalEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTexturePageCommitmentEXT</c>]</b><br/>  </summary>
            public static void TexturePageCommitmentEXT(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => GLPointers._glTexturePageCommitmentEXT_fnptr(texture, level, xoffset, yoffset, zoffset, width, height, depth, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterfEXT</c>]</b><br/>  </summary>
            public static void TextureParameterfEXT(int texture, TextureTarget target, TextureParameterName pname, float param) => GLPointers._glTextureParameterfEXT_fnptr(texture, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterfvEXT</c>]</b><br/>  </summary>
            public static void TextureParameterfvEXT(int texture, TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers._glTextureParameterfvEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameteriEXT</c>]</b><br/>  </summary>
            public static void TextureParameteriEXT(int texture, TextureTarget target, TextureParameterName pname, int param) => GLPointers._glTextureParameteriEXT_fnptr(texture, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIivEXT</c>]</b><br/>  </summary>
            public static void TextureParameterIivEXT(int texture, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTextureParameterIivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterIuivEXT</c>]</b><br/>  </summary>
            public static void TextureParameterIuivEXT(int texture, TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._glTextureParameterIuivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureParameterivEXT</c>]</b><br/>  </summary>
            public static void TextureParameterivEXT(int texture, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._glTextureParameterivEXT_fnptr(texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureRenderbufferEXT</c>]</b><br/>  </summary>
            public static void TextureRenderbufferEXT(int texture, TextureTarget target, int renderbuffer) => GLPointers._glTextureRenderbufferEXT_fnptr(texture, (uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b> <b>[entry point: <c>glTextureStorage1DEXT</c>]</b><br/>  </summary>
            public static void TextureStorage1DEXT(int texture, All target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._glTextureStorage1DEXT_fnptr(texture, (uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b> <b>[entry point: <c>glTextureStorage2DEXT</c>]</b><br/>  </summary>
            public static void TextureStorage2DEXT(int texture, All target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._glTextureStorage2DEXT_fnptr(texture, (uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureStorage2DMultisampleEXT</c>]</b><br/>  </summary>
            public static void TextureStorage2DMultisampleEXT(int texture, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._glTextureStorage2DMultisampleEXT_fnptr(texture, (uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b> <b>[entry point: <c>glTextureStorage3DEXT</c>]</b><br/>  </summary>
            public static void TextureStorage3DEXT(int texture, All target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._glTextureStorage3DEXT_fnptr(texture, (uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureStorage3DMultisampleEXT</c>]</b><br/>  </summary>
            public static void TextureStorage3DMultisampleEXT(int texture, All target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._glTextureStorage3DMultisampleEXT_fnptr(texture, (uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem1DEXT</c>]</b><br/>  </summary>
            public static void TextureStorageMem1DEXT(int texture, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => GLPointers._glTextureStorageMem1DEXT_fnptr(texture, levels, (uint)internalFormat, width, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem2DEXT</c>]</b><br/>  </summary>
            public static void TextureStorageMem2DEXT(int texture, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => GLPointers._glTextureStorageMem2DEXT_fnptr(texture, levels, (uint)internalFormat, width, height, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem2DMultisampleEXT</c>]</b><br/>  </summary>
            public static void TextureStorageMem2DMultisampleEXT(int texture, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._glTextureStorageMem2DMultisampleEXT_fnptr(texture, samples, (uint)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem3DEXT</c>]</b><br/>  </summary>
            public static void TextureStorageMem3DEXT(int texture, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => GLPointers._glTextureStorageMem3DEXT_fnptr(texture, levels, (uint)internalFormat, width, height, depth, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b> <b>[entry point: <c>glTextureStorageMem3DMultisampleEXT</c>]</b><br/>  </summary>
            public static void TextureStorageMem3DMultisampleEXT(int texture, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._glTextureStorageMem3DMultisampleEXT_fnptr(texture, samples, (uint)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage1DEXT</c>]</b><br/>  </summary>
            public static void TextureSubImage1DEXT(int texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage1DEXT_fnptr(texture, (uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage2DEXT</c>]</b><br/>  </summary>
            public static void TextureSubImage2DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage2DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glTextureSubImage3DEXT</c>]</b><br/>  </summary>
            public static void TextureSubImage3DEXT(int texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTextureSubImage3DEXT_fnptr(texture, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b> <b>[entry point: <c>glTransformFeedbackVaryingsEXT</c>]</b><br/>  </summary>
            public static void TransformFeedbackVaryingsEXT(int program, int count, byte** varyings, TransformFeedbackBufferMode bufferMode) => GLPointers._glTransformFeedbackVaryingsEXT_fnptr(program, count, varyings, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform1uiEXT</c>]</b><br/>  </summary>
            public static void Uniform1uiEXT(int location, uint v0) => GLPointers._glUniform1uiEXT_fnptr(location, v0);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform1uivEXT</c>]</b><br/>  </summary>
            public static void Uniform1uivEXT(int location, int count, uint* value) => GLPointers._glUniform1uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform2uiEXT</c>]</b><br/>  </summary>
            public static void Uniform2uiEXT(int location, uint v0, uint v1) => GLPointers._glUniform2uiEXT_fnptr(location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform2uivEXT</c>]</b><br/>  </summary>
            public static void Uniform2uivEXT(int location, int count, uint* value) => GLPointers._glUniform2uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform3uiEXT</c>]</b><br/>  </summary>
            public static void Uniform3uiEXT(int location, uint v0, uint v1, uint v2) => GLPointers._glUniform3uiEXT_fnptr(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform3uivEXT</c>]</b><br/>  </summary>
            public static void Uniform3uivEXT(int location, int count, uint* value) => GLPointers._glUniform3uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform4uiEXT</c>]</b><br/>  </summary>
            public static void Uniform4uiEXT(int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._glUniform4uiEXT_fnptr(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b> <b>[entry point: <c>glUniform4uivEXT</c>]</b><br/>  </summary>
            public static void Uniform4uivEXT(int location, int count, uint* value) => GLPointers._glUniform4uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b> <b>[entry point: <c>glUniformBufferEXT</c>]</b><br/>  </summary>
            public static void UniformBufferEXT(int program, int location, int buffer) => GLPointers._glUniformBufferEXT_fnptr(program, location, buffer);
            
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array]</b> <b>[entry point: <c>glUnlockArraysEXT</c>]</b><br/>  </summary>
            public static void UnlockArraysEXT() => GLPointers._glUnlockArraysEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glUnmapNamedBufferEXT</c>]</b><br/>  </summary>
            public static bool UnmapNamedBufferEXT(int buffer) => GLPointers._glUnmapNamedBufferEXT_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glUseProgramStagesEXT</c>]</b><br/>  </summary>
            public static void UseProgramStagesEXT(int pipeline, UseProgramStageMask stages, int program) => GLPointers._glUseProgramStagesEXT_fnptr(pipeline, (uint)stages, program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glUseShaderProgramEXT</c>]</b><br/>  </summary>
            public static void UseShaderProgramEXT(All type, int program) => GLPointers._glUseShaderProgramEXT_fnptr((uint)type, program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b> <b>[entry point: <c>glValidateProgramPipelineEXT</c>]</b><br/>  </summary>
            public static void ValidateProgramPipelineEXT(int pipeline) => GLPointers._glValidateProgramPipelineEXT_fnptr(pipeline);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantbvEXT</c>]</b><br/>  </summary>
            public static void VariantbvEXT(uint id, sbyte* addr) => GLPointers._glVariantbvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantdvEXT</c>]</b><br/>  </summary>
            public static void VariantdvEXT(uint id, double* addr) => GLPointers._glVariantdvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantfvEXT</c>]</b><br/>  </summary>
            public static void VariantfvEXT(uint id, float* addr) => GLPointers._glVariantfvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantivEXT</c>]</b><br/>  </summary>
            public static void VariantivEXT(uint id, int* addr) => GLPointers._glVariantivEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantPointerEXT</c>]</b><br/>  </summary>
            public static void VariantPointerEXT(uint id, ScalarType type, uint stride, void* addr) => GLPointers._glVariantPointerEXT_fnptr(id, (uint)type, stride, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantsvEXT</c>]</b><br/>  </summary>
            public static void VariantsvEXT(uint id, short* addr) => GLPointers._glVariantsvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantubvEXT</c>]</b><br/>  </summary>
            public static void VariantubvEXT(uint id, byte* addr) => GLPointers._glVariantubvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantuivEXT</c>]</b><br/>  </summary>
            public static void VariantuivEXT(uint id, uint* addr) => GLPointers._glVariantuivEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glVariantusvEXT</c>]</b><br/>  </summary>
            public static void VariantusvEXT(uint id, ushort* addr) => GLPointers._glVariantusvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayBindVertexBufferEXT</c>]</b><br/>  </summary>
            public static void VertexArrayBindVertexBufferEXT(int vaobj, uint bindingindex, int buffer, IntPtr offset, int stride) => GLPointers._glVertexArrayBindVertexBufferEXT_fnptr(vaobj, bindingindex, buffer, offset, stride);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayColorOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayColorOffsetEXT(int vaobj, int buffer, int size, ColorPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayColorOffsetEXT_fnptr(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayEdgeFlagOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayEdgeFlagOffsetEXT(int vaobj, int buffer, int stride, IntPtr offset) => GLPointers._glVertexArrayEdgeFlagOffsetEXT_fnptr(vaobj, buffer, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayFogCoordOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayFogCoordOffsetEXT(int vaobj, int buffer, FogCoordinatePointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayFogCoordOffsetEXT_fnptr(vaobj, buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayIndexOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayIndexOffsetEXT(int vaobj, int buffer, IndexPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayIndexOffsetEXT_fnptr(vaobj, buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayMultiTexCoordOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayMultiTexCoordOffsetEXT(int vaobj, int buffer, All texunit, int size, TexCoordPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayMultiTexCoordOffsetEXT_fnptr(vaobj, buffer, (uint)texunit, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayNormalOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayNormalOffsetEXT(int vaobj, int buffer, NormalPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayNormalOffsetEXT_fnptr(vaobj, buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArraySecondaryColorOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArraySecondaryColorOffsetEXT(int vaobj, int buffer, int size, ColorPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArraySecondaryColorOffsetEXT_fnptr(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayTexCoordOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayTexCoordOffsetEXT(int vaobj, int buffer, int size, TexCoordPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayTexCoordOffsetEXT_fnptr(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribBindingEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexAttribBindingEXT(int vaobj, uint attribindex, uint bindingindex) => GLPointers._glVertexArrayVertexAttribBindingEXT_fnptr(vaobj, attribindex, bindingindex);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribDivisorEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexAttribDivisorEXT(int vaobj, uint index, uint divisor) => GLPointers._glVertexArrayVertexAttribDivisorEXT_fnptr(vaobj, index, divisor);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribFormatEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexAttribFormatEXT(int vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._glVertexArrayVertexAttribFormatEXT_fnptr(vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribIFormatEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexAttribIFormatEXT(int vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._glVertexArrayVertexAttribIFormatEXT_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribIOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexAttribIOffsetEXT(int vaobj, int buffer, uint index, int size, VertexAttribType type, int stride, IntPtr offset) => GLPointers._glVertexArrayVertexAttribIOffsetEXT_fnptr(vaobj, buffer, index, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribLFormatEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexAttribLFormatEXT(int vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._glVertexArrayVertexAttribLFormatEXT_fnptr(vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribLOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexAttribLOffsetEXT(int vaobj, int buffer, uint index, int size, VertexAttribLType type, int stride, IntPtr offset) => GLPointers._glVertexArrayVertexAttribLOffsetEXT_fnptr(vaobj, buffer, index, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexAttribOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexAttribOffsetEXT(int vaobj, int buffer, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr offset) => GLPointers._glVertexArrayVertexAttribOffsetEXT_fnptr(vaobj, buffer, index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexBindingDivisorEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexBindingDivisorEXT(int vaobj, uint bindingindex, uint divisor) => GLPointers._glVertexArrayVertexBindingDivisorEXT_fnptr(vaobj, bindingindex, divisor);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b> <b>[entry point: <c>glVertexArrayVertexOffsetEXT</c>]</b><br/>  </summary>
            public static void VertexArrayVertexOffsetEXT(int vaobj, int buffer, int size, VertexPointerType type, int stride, IntPtr offset) => GLPointers._glVertexArrayVertexOffsetEXT_fnptr(vaobj, buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1iEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI1iEXT(uint index, int x) => GLPointers._glVertexAttribI1iEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1ivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI1ivEXT(uint index, int* v) => GLPointers._glVertexAttribI1ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1uiEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI1uiEXT(uint index, uint x) => GLPointers._glVertexAttribI1uiEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1uivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI1uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI1uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2iEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI2iEXT(uint index, int x, int y) => GLPointers._glVertexAttribI2iEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2ivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI2ivEXT(uint index, int* v) => GLPointers._glVertexAttribI2ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2uiEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI2uiEXT(uint index, uint x, uint y) => GLPointers._glVertexAttribI2uiEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2uivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI2uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI2uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3iEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI3iEXT(uint index, int x, int y, int z) => GLPointers._glVertexAttribI3iEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3ivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI3ivEXT(uint index, int* v) => GLPointers._glVertexAttribI3ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3uiEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => GLPointers._glVertexAttribI3uiEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3uivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI3uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI3uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4bvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4bvEXT(uint index, sbyte* v) => GLPointers._glVertexAttribI4bvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4iEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => GLPointers._glVertexAttribI4iEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4ivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4ivEXT(uint index, int* v) => GLPointers._glVertexAttribI4ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4svEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4svEXT(uint index, short* v) => GLPointers._glVertexAttribI4svEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4ubvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4ubvEXT(uint index, byte* v) => GLPointers._glVertexAttribI4ubvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4uiEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => GLPointers._glVertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4uivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI4uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4usvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4usvEXT(uint index, ushort* v) => GLPointers._glVertexAttribI4usvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribIPointerEXT</c>]</b><br/>  </summary>
            public static void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers._glVertexAttribIPointerEXT_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1dEXT</c>]</b><br/>  </summary>
            public static void VertexAttribL1dEXT(uint index, double x) => GLPointers._glVertexAttribL1dEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL1dvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribL1dvEXT(uint index, double* v) => GLPointers._glVertexAttribL1dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2dEXT</c>]</b><br/>  </summary>
            public static void VertexAttribL2dEXT(uint index, double x, double y) => GLPointers._glVertexAttribL2dEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL2dvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribL2dvEXT(uint index, double* v) => GLPointers._glVertexAttribL2dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3dEXT</c>]</b><br/>  </summary>
            public static void VertexAttribL3dEXT(uint index, double x, double y, double z) => GLPointers._glVertexAttribL3dEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL3dvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribL3dvEXT(uint index, double* v) => GLPointers._glVertexAttribL3dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4dEXT</c>]</b><br/>  </summary>
            public static void VertexAttribL4dEXT(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttribL4dEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribL4dvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribL4dvEXT(uint index, double* v) => GLPointers._glVertexAttribL4dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b> <b>[entry point: <c>glVertexAttribLPointerEXT</c>]</b><br/>  </summary>
            public static void VertexAttribLPointerEXT(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers._glVertexAttribLPointerEXT_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b> <b>[entry point: <c>glVertexPointerEXT</c>]</b><br/>  </summary>
            public static void VertexPointerEXT(int size, VertexPointerType type, int stride, int count, void* pointer) => GLPointers._glVertexPointerEXT_fnptr(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b> <b>[entry point: <c>glVertexWeightfEXT</c>]</b><br/>  </summary>
            public static void VertexWeightfEXT(float weight) => GLPointers._glVertexWeightfEXT_fnptr(weight);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b> <b>[entry point: <c>glVertexWeightfvEXT</c>]</b><br/>  </summary>
            public static void VertexWeightfvEXT(float* weight) => GLPointers._glVertexWeightfvEXT_fnptr(weight);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b> <b>[entry point: <c>glVertexWeightPointerEXT</c>]</b><br/>  </summary>
            public static void VertexWeightPointerEXT(int size, VertexWeightPointerTypeEXT type, int stride, void* pointer) => GLPointers._glVertexWeightPointerEXT_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b> <b>[entry point: <c>glWaitSemaphoreEXT</c>]</b><br/>  </summary>
            public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, int* buffers, uint numTextureBarriers, int* textures, TextureLayout* srcLayouts) => GLPointers._glWaitSemaphoreEXT_fnptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, (uint*)srcLayouts);
            
            /// <summary> <b>[requires: GL_EXT_window_rectangles]</b> <b>[entry point: <c>glWindowRectanglesEXT</c>]</b><br/>  </summary>
            public static void WindowRectanglesEXT(All mode, int count, int* box) => GLPointers._glWindowRectanglesEXT_fnptr((uint)mode, count, box);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b> <b>[entry point: <c>glWriteMaskEXT</c>]</b><br/>  </summary>
            public static void WriteMaskEXT(uint res, uint input, VertexShaderWriteMaskEXT outX, VertexShaderWriteMaskEXT outY, VertexShaderWriteMaskEXT outZ, VertexShaderWriteMaskEXT outW) => GLPointers._glWriteMaskEXT_fnptr(res, input, (uint)outX, (uint)outY, (uint)outZ, (uint)outW);
            
        }
        /// <summary>GREMEDY extensions.</summary>
        public static unsafe partial class GREMEDY
        {
            /// <summary> <b>[requires: GL_GREMEDY_frame_terminator]</b> <b>[entry point: <c>glFrameTerminatorGREMEDY</c>]</b><br/>  </summary>
            public static void FrameTerminatorGREMEDY() => GLPointers._glFrameTerminatorGREMEDY_fnptr();
            
            /// <summary> <b>[requires: GL_GREMEDY_string_marker]</b> <b>[entry point: <c>glStringMarkerGREMEDY</c>]</b><br/>  </summary>
            public static void StringMarkerGREMEDY(int len, void* str) => GLPointers._glStringMarkerGREMEDY_fnptr(len, str);
            
        }
        /// <summary>HP extensions.</summary>
        public static unsafe partial class HP
        {
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glGetImageTransformParameterfvHP</c>]</b><br/>  </summary>
            public static void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => GLPointers._glGetImageTransformParameterfvHP_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glGetImageTransformParameterivHP</c>]</b><br/>  </summary>
            public static void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => GLPointers._glGetImageTransformParameterivHP_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glImageTransformParameterfHP</c>]</b><br/>  </summary>
            public static void ImageTransformParameterfHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float param) => GLPointers._glImageTransformParameterfHP_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glImageTransformParameterfvHP</c>]</b><br/>  </summary>
            public static void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => GLPointers._glImageTransformParameterfvHP_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glImageTransformParameteriHP</c>]</b><br/>  </summary>
            public static void ImageTransformParameteriHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int param) => GLPointers._glImageTransformParameteriHP_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b> <b>[entry point: <c>glImageTransformParameterivHP</c>]</b><br/>  </summary>
            public static void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => GLPointers._glImageTransformParameterivHP_fnptr((uint)target, (uint)pname, parameters);
            
        }
        /// <summary>IBM extensions.</summary>
        public static unsafe partial class IBM
        {
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glColorPointerListIBM</c>]</b><br/>  </summary>
            public static void ColorPointerListIBM(int size, ColorPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glColorPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glEdgeFlagPointerListIBM</c>]</b><br/>  </summary>
            public static void EdgeFlagPointerListIBM(int stride, bool** pointer, int ptrstride) => GLPointers._glEdgeFlagPointerListIBM_fnptr(stride, (byte**)pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_static_data]</b> <b>[entry point: <c>glFlushStaticDataIBM</c>]</b><br/>  </summary>
            public static void FlushStaticDataIBM(All target) => GLPointers._glFlushStaticDataIBM_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glFogCoordPointerListIBM</c>]</b><br/>  </summary>
            public static void FogCoordPointerListIBM(FogPointerTypeIBM type, int stride, void** pointer, int ptrstride) => GLPointers._glFogCoordPointerListIBM_fnptr((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glIndexPointerListIBM</c>]</b><br/>  </summary>
            public static void IndexPointerListIBM(IndexPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glIndexPointerListIBM_fnptr((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays]</b> <b>[entry point: <c>glMultiModeDrawArraysIBM</c>]</b><br/>  </summary>
            public static void MultiModeDrawArraysIBM(PrimitiveType* mode, int* first, int* count, int primcount, int modestride) => GLPointers._glMultiModeDrawArraysIBM_fnptr((uint*)mode, first, count, primcount, modestride);
            
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays]</b> <b>[entry point: <c>glMultiModeDrawElementsIBM</c>]</b><br/>  </summary>
            public static void MultiModeDrawElementsIBM(PrimitiveType* mode, int* count, DrawElementsType type, void** indices, int primcount, int modestride) => GLPointers._glMultiModeDrawElementsIBM_fnptr((uint*)mode, count, (uint)type, indices, primcount, modestride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glNormalPointerListIBM</c>]</b><br/>  </summary>
            public static void NormalPointerListIBM(NormalPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glNormalPointerListIBM_fnptr((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glSecondaryColorPointerListIBM</c>]</b><br/>  </summary>
            public static void SecondaryColorPointerListIBM(int size, SecondaryColorPointerTypeIBM type, int stride, void** pointer, int ptrstride) => GLPointers._glSecondaryColorPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glTexCoordPointerListIBM</c>]</b><br/>  </summary>
            public static void TexCoordPointerListIBM(int size, TexCoordPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glTexCoordPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b> <b>[entry point: <c>glVertexPointerListIBM</c>]</b><br/>  </summary>
            public static void VertexPointerListIBM(int size, VertexPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._glVertexPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
        }
        /// <summary>INGR extensions.</summary>
        public static unsafe partial class INGR
        {
            /// <summary> <b>[requires: GL_INGR_blend_func_separate]</b> <b>[entry point: <c>glBlendFuncSeparateINGR</c>]</b><br/>  </summary>
            public static void BlendFuncSeparateINGR(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers._glBlendFuncSeparateINGR_fnptr((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
            
        }
        /// <summary>INTEL extensions.</summary>
        public static unsafe partial class INTEL
        {
            /// <summary> <b>[requires: GL_INTEL_framebuffer_CMAA]</b> <b>[entry point: <c>glApplyFramebufferAttachmentCMAAINTEL</c>]</b><br/>  </summary>
            public static void ApplyFramebufferAttachmentCMAAINTEL() => GLPointers._glApplyFramebufferAttachmentCMAAINTEL_fnptr();
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glBeginPerfQueryINTEL</c>]</b><br/>  </summary>
            public static void BeginPerfQueryINTEL(int queryHandle) => GLPointers._glBeginPerfQueryINTEL_fnptr(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b> <b>[entry point: <c>glColorPointervINTEL</c>]</b><br/>  </summary>
            public static void ColorPointervINTEL(int size, VertexPointerType type, void** pointer) => GLPointers._glColorPointervINTEL_fnptr(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glCreatePerfQueryINTEL</c>]</b><br/>  </summary>
            public static void CreatePerfQueryINTEL(uint queryId, int* queryHandle) => GLPointers._glCreatePerfQueryINTEL_fnptr(queryId, queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glDeletePerfQueryINTEL</c>]</b><br/>  </summary>
            public static void DeletePerfQueryINTEL(int queryHandle) => GLPointers._glDeletePerfQueryINTEL_fnptr(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glEndPerfQueryINTEL</c>]</b><br/>  </summary>
            public static void EndPerfQueryINTEL(int queryHandle) => GLPointers._glEndPerfQueryINTEL_fnptr(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetFirstPerfQueryIdINTEL</c>]</b><br/>  </summary>
            public static void GetFirstPerfQueryIdINTEL(uint* queryId) => GLPointers._glGetFirstPerfQueryIdINTEL_fnptr(queryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetNextPerfQueryIdINTEL</c>]</b><br/>  </summary>
            public static void GetNextPerfQueryIdINTEL(uint queryId, uint* nextQueryId) => GLPointers._glGetNextPerfQueryIdINTEL_fnptr(queryId, nextQueryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetPerfCounterInfoINTEL</c>]</b><br/>  </summary>
            public static void GetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, byte* counterName, uint counterDescLength, byte* counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) => GLPointers._glGetPerfCounterInfoINTEL_fnptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetPerfQueryDataINTEL</c>]</b><br/>  </summary>
            public static void GetPerfQueryDataINTEL(int queryHandle, PerfQueryDataFlags flags, int dataSize, void* data, uint* bytesWritten) => GLPointers._glGetPerfQueryDataINTEL_fnptr(queryHandle, (uint)flags, dataSize, data, bytesWritten);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetPerfQueryIdByNameINTEL</c>]</b><br/>  </summary>
            public static void GetPerfQueryIdByNameINTEL(byte* queryName, uint* queryId) => GLPointers._glGetPerfQueryIdByNameINTEL_fnptr(queryName, queryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b> <b>[entry point: <c>glGetPerfQueryInfoINTEL</c>]</b><br/>  </summary>
            public static void GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, byte* queryName, uint* dataSize, uint* noCounters, uint* noInstances, PerformanceQueryCapsMaskINTEL* capsMask) => GLPointers._glGetPerfQueryInfoINTEL_fnptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, (uint*)capsMask);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b> <b>[entry point: <c>glMapTexture2DINTEL</c>]</b><br/>  </summary>
            public static void* MapTexture2DINTEL(int texture, int level, uint access, int* stride, All* layout) => GLPointers._glMapTexture2DINTEL_fnptr(texture, level, access, stride, (uint*)layout);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b> <b>[entry point: <c>glNormalPointervINTEL</c>]</b><br/>  </summary>
            public static void NormalPointervINTEL(NormalPointerType type, void** pointer) => GLPointers._glNormalPointervINTEL_fnptr((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b> <b>[entry point: <c>glSyncTextureINTEL</c>]</b><br/>  </summary>
            public static void SyncTextureINTEL(int texture) => GLPointers._glSyncTextureINTEL_fnptr(texture);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b> <b>[entry point: <c>glTexCoordPointervINTEL</c>]</b><br/>  </summary>
            public static void TexCoordPointervINTEL(int size, VertexPointerType type, void** pointer) => GLPointers._glTexCoordPointervINTEL_fnptr(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b> <b>[entry point: <c>glUnmapTexture2DINTEL</c>]</b><br/>  </summary>
            public static void UnmapTexture2DINTEL(int texture, int level) => GLPointers._glUnmapTexture2DINTEL_fnptr(texture, level);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b> <b>[entry point: <c>glVertexPointervINTEL</c>]</b><br/>  </summary>
            public static void VertexPointervINTEL(int size, VertexPointerType type, void** pointer) => GLPointers._glVertexPointervINTEL_fnptr(size, (uint)type, pointer);
            
        }
        /// <summary>KHR extensions.</summary>
        public static unsafe partial class KHR
        {
            /// <summary> <b>[requires: GL_KHR_blend_equation_advanced]</b> <b>[entry point: <c>glBlendBarrierKHR</c>]</b><br/>  </summary>
            public static void BlendBarrierKHR() => GLPointers._glBlendBarrierKHR_fnptr();
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageCallback</c>]</b><br/> Specify a callback to receive debugging messages from the GL. </summary>
            /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
            /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml" /></remarks>
            public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallback_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageCallbackKHR</c>]</b><br/>  </summary>
            public static void DebugMessageCallbackKHR(IntPtr callback, void* userParam) => GLPointers._glDebugMessageCallbackKHR_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageControl</c>]</b><br/> Control the reporting of debug messages in a debug context. </summary>
            /// <param name="source"> The source of debug messages to enable or disable. </param>
            /// <param name="type"> The type of debug messages to enable or disable. </param>
            /// <param name="severity"> The severity of debug messages to enable or disable. </param>
            /// <param name="count"> The length of the array ids. </param>
            /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
            /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml" /></remarks>
            public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageControl_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageControlKHR</c>]</b><br/>  </summary>
            public static void DebugMessageControlKHR(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._glDebugMessageControlKHR_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageInsert</c>]</b><br/> Inject an application-supplied message into the debug message queue. </summary>
            /// <param name="source"> The source of the debug message to insert. </param>
            /// <param name="type"> The type of the debug message insert. </param>
            /// <param name="id"> The user-supplied identifier of the message to insert. </param>
            /// <param name="severity"> The severity of the debug messages to insert. </param>
            /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
            /// <param name="message"> The address of a character array containing the message to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml" /></remarks>
            public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._glDebugMessageInsert_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glDebugMessageInsertKHR</c>]</b><br/>  </summary>
            public static void DebugMessageInsertKHR(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._glDebugMessageInsertKHR_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetDebugMessageLog</c>]</b><br/> Retrieve messages from the debug message log. </summary>
            /// <param name="count"> The number of debug messages to retrieve from the log. </param>
            /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
            /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
            /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
            /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
            /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
            /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
            /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml" /></remarks>
            public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._glGetDebugMessageLog_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glGetDebugMessageLogKHR</c>]</b><br/>  </summary>
            public static uint GetDebugMessageLogKHR(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._glGetDebugMessageLogKHR_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetGraphicsResetStatus</c>]</b><br/> Check if the rendering context has not been lost due to software or hardware issues. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml" /></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatus() => (GraphicsResetStatus) GLPointers._glGetGraphicsResetStatus_fnptr();
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glGetGraphicsResetStatusKHR</c>]</b><br/>  </summary>
            public static GraphicsResetStatus GetGraphicsResetStatusKHR() => (GraphicsResetStatus) GLPointers._glGetGraphicsResetStatusKHR_fnptr();
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformfv</c>]</b><br/> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformfv(int program, int location, int bufSize, float* parameters) => GLPointers._glGetnUniformfv_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformfvKHR</c>]</b><br/>  </summary>
            public static void GetnUniformfvKHR(int program, int location, int bufSize, float* parameters) => GLPointers._glGetnUniformfvKHR_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformiv(int program, int location, int bufSize, int* parameters) => GLPointers._glGetnUniformiv_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformivKHR</c>]</b><br/>  </summary>
            public static void GetnUniformivKHR(int program, int location, int bufSize, int* parameters) => GLPointers._glGetnUniformivKHR_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformuiv</c>]</b><br/> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformuiv(int program, int location, int bufSize, uint* parameters) => GLPointers._glGetnUniformuiv_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glGetnUniformuivKHR</c>]</b><br/>  </summary>
            public static void GetnUniformuivKHR(int program, int location, int bufSize, uint* parameters) => GLPointers._glGetnUniformuivKHR_fnptr(program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectLabel</c>]</b><br/> Retrieve the label of a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml" /></remarks>
            public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => GLPointers._glGetObjectLabel_fnptr((uint)identifier, name, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectLabelKHR</c>]</b><br/>  </summary>
            public static void GetObjectLabelKHR(All identifier, uint name, int bufSize, int* length, byte* label) => GLPointers._glGetObjectLabelKHR_fnptr((uint)identifier, name, bufSize, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectPtrLabel</c>]</b><br/> Retrieve the label of a sync object identified by a pointer. </summary>
            /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml" /></remarks>
            public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => GLPointers._glGetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glGetObjectPtrLabelKHR</c>]</b><br/>  </summary>
            public static void GetObjectPtrLabelKHR(void* ptr, int bufSize, int* length, byte* label) => GLPointers._glGetObjectPtrLabelKHR_fnptr(ptr, bufSize, length, label);
            
            /// <summary> <b>[requires: v1.1 | GL_KHR_debug]</b> <b>[removed in: v3.2]</b> <b>[entry point: <c>glGetPointerv</c>]</b><br/> Return the address of the specified pointer. </summary>
            /// <param name="pname"> Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or GL_DEBUG_CALLBACK_USER_PARAM. </param>
            /// <param name="parameters"> Returns the pointer value specified by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml" /></remarks>
            public static void GetPointerv(GetPointervPName pname, void** parameters) => GLPointers._glGetPointerv_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glGetPointervKHR</c>]</b><br/>  </summary>
            public static void GetPointervKHR_(All pname, void** parameters) => GLPointers._glGetPointervKHR_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_KHR_parallel_shader_compile]</b> <b>[entry point: <c>glMaxShaderCompilerThreadsKHR</c>]</b><br/>  </summary>
            public static void MaxShaderCompilerThreadsKHR(uint count) => GLPointers._glMaxShaderCompilerThreadsKHR_fnptr(count);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glObjectLabel</c>]</b><br/> Label a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object to label. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml" /></remarks>
            public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers._glObjectLabel_fnptr((uint)identifier, name, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glObjectLabelKHR</c>]</b><br/>  </summary>
            public static void ObjectLabelKHR(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers._glObjectLabelKHR_fnptr((uint)identifier, name, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glObjectPtrLabel</c>]</b><br/> Label a sync object identified by a pointer. </summary>
            /// <param name="ptr"> A pointer identifying a sync object. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml" /></remarks>
            public static void ObjectPtrLabel(void* ptr, int length, byte* label) => GLPointers._glObjectPtrLabel_fnptr(ptr, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glObjectPtrLabelKHR</c>]</b><br/>  </summary>
            public static void ObjectPtrLabelKHR(void* ptr, int length, byte* label) => GLPointers._glObjectPtrLabelKHR_fnptr(ptr, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glPopDebugGroup</c>]</b><br/> Pop the active debug group. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml" /></remarks>
            public static void PopDebugGroup() => GLPointers._glPopDebugGroup_fnptr();
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glPopDebugGroupKHR</c>]</b><br/>  </summary>
            public static void PopDebugGroupKHR() => GLPointers._glPopDebugGroupKHR_fnptr();
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> <b>[entry point: <c>glPushDebugGroup</c>]</b><br/> Push a named debug group into the command stream. </summary>
            /// <param name="source"> The source of the debug message. </param>
            /// <param name="id"> The identifier of the message. </param>
            /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
            /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml" /></remarks>
            public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => GLPointers._glPushDebugGroup_fnptr((uint)source, id, length, message);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b> <b>[entry point: <c>glPushDebugGroupKHR</c>]</b><br/>  </summary>
            public static void PushDebugGroupKHR(DebugSource source, uint id, int length, byte* message) => GLPointers._glPushDebugGroupKHR_fnptr((uint)source, id, length, message);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> <b>[entry point: <c>glReadnPixels</c>]</b><br/> Read a block of pixels from the frame buffer. </summary>
            /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
            /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
            /// <param name="data">Returns the pixel data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
            public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._glReadnPixels_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b> <b>[entry point: <c>glReadnPixelsKHR</c>]</b><br/>  </summary>
            public static void ReadnPixelsKHR(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._glReadnPixelsKHR_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
        }
        /// <summary>MESA extensions.</summary>
        public static unsafe partial class MESA
        {
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y]</b> <b>[entry point: <c>glFramebufferParameteriMESA</c>]</b><br/>  </summary>
            public static void FramebufferParameteriMESA(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers._glFramebufferParameteriMESA_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y]</b> <b>[entry point: <c>glGetFramebufferParameterivMESA</c>]</b><br/>  </summary>
            public static void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._glGetFramebufferParameterivMESA_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_MESA_resize_buffers]</b> <b>[entry point: <c>glResizeBuffersMESA</c>]</b><br/>  </summary>
            public static void ResizeBuffersMESA() => GLPointers._glResizeBuffersMESA_fnptr();
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2dMESA</c>]</b><br/>  </summary>
            public static void WindowPos2dMESA(double x, double y) => GLPointers._glWindowPos2dMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2dvMESA</c>]</b><br/>  </summary>
            public static void WindowPos2dvMESA(double* v) => GLPointers._glWindowPos2dvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2fMESA</c>]</b><br/>  </summary>
            public static void WindowPos2fMESA(float x, float y) => GLPointers._glWindowPos2fMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2fvMESA</c>]</b><br/>  </summary>
            public static void WindowPos2fvMESA(float* v) => GLPointers._glWindowPos2fvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2iMESA</c>]</b><br/>  </summary>
            public static void WindowPos2iMESA(int x, int y) => GLPointers._glWindowPos2iMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2ivMESA</c>]</b><br/>  </summary>
            public static void WindowPos2ivMESA(int* v) => GLPointers._glWindowPos2ivMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2sMESA</c>]</b><br/>  </summary>
            public static void WindowPos2sMESA(short x, short y) => GLPointers._glWindowPos2sMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos2svMESA</c>]</b><br/>  </summary>
            public static void WindowPos2svMESA(short* v) => GLPointers._glWindowPos2svMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3dMESA</c>]</b><br/>  </summary>
            public static void WindowPos3dMESA(double x, double y, double z) => GLPointers._glWindowPos3dMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3dvMESA</c>]</b><br/>  </summary>
            public static void WindowPos3dvMESA(double* v) => GLPointers._glWindowPos3dvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3fMESA</c>]</b><br/>  </summary>
            public static void WindowPos3fMESA(float x, float y, float z) => GLPointers._glWindowPos3fMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3fvMESA</c>]</b><br/>  </summary>
            public static void WindowPos3fvMESA(float* v) => GLPointers._glWindowPos3fvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3iMESA</c>]</b><br/>  </summary>
            public static void WindowPos3iMESA(int x, int y, int z) => GLPointers._glWindowPos3iMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3ivMESA</c>]</b><br/>  </summary>
            public static void WindowPos3ivMESA(int* v) => GLPointers._glWindowPos3ivMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3sMESA</c>]</b><br/>  </summary>
            public static void WindowPos3sMESA(short x, short y, short z) => GLPointers._glWindowPos3sMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos3svMESA</c>]</b><br/>  </summary>
            public static void WindowPos3svMESA(short* v) => GLPointers._glWindowPos3svMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4dMESA</c>]</b><br/>  </summary>
            public static void WindowPos4dMESA(double x, double y, double z, double w) => GLPointers._glWindowPos4dMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4dvMESA</c>]</b><br/>  </summary>
            public static void WindowPos4dvMESA(double* v) => GLPointers._glWindowPos4dvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4fMESA</c>]</b><br/>  </summary>
            public static void WindowPos4fMESA(float x, float y, float z, float w) => GLPointers._glWindowPos4fMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4fvMESA</c>]</b><br/>  </summary>
            public static void WindowPos4fvMESA(float* v) => GLPointers._glWindowPos4fvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4iMESA</c>]</b><br/>  </summary>
            public static void WindowPos4iMESA(int x, int y, int z, int w) => GLPointers._glWindowPos4iMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4ivMESA</c>]</b><br/>  </summary>
            public static void WindowPos4ivMESA(int* v) => GLPointers._glWindowPos4ivMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4sMESA</c>]</b><br/>  </summary>
            public static void WindowPos4sMESA(short x, short y, short z, short w) => GLPointers._glWindowPos4sMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b> <b>[entry point: <c>glWindowPos4svMESA</c>]</b><br/>  </summary>
            public static void WindowPos4svMESA(short* v) => GLPointers._glWindowPos4svMESA_fnptr(v);
            
        }
        /// <summary>NV extensions.</summary>
        public static unsafe partial class NV
        {
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glActiveVaryingNV</c>]</b><br/>  </summary>
            public static void ActiveVaryingNV(int program, byte* name) => GLPointers._glActiveVaryingNV_fnptr(program, name);
            
            /// <summary> <b>[requires: GL_NV_alpha_to_coverage_dither_control]</b> <b>[entry point: <c>glAlphaToCoverageDitherControlNV</c>]</b><br/>  </summary>
            public static void AlphaToCoverageDitherControlNV(All mode) => GLPointers._glAlphaToCoverageDitherControlNV_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glAreProgramsResidentNV</c>]</b><br/>  </summary>
            public static bool AreProgramsResidentNV(int n, int* programs, bool* residences) => GLPointers._glAreProgramsResidentNV_fnptr(n, programs, (byte*)residences) != 0;
            
            /// <summary> <b>[requires: GL_NV_conditional_render]</b> <b>[entry point: <c>glBeginConditionalRenderNV</c>]</b><br/>  </summary>
            public static void BeginConditionalRenderNV(uint id, ConditionalRenderMode mode) => GLPointers._glBeginConditionalRenderNV_fnptr(id, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glBeginOcclusionQueryNV</c>]</b><br/>  </summary>
            public static void BeginOcclusionQueryNV(uint id) => GLPointers._glBeginOcclusionQueryNV_fnptr(id);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glBeginTransformFeedbackNV</c>]</b><br/>  </summary>
            public static void BeginTransformFeedbackNV(PrimitiveType primitiveMode) => GLPointers._glBeginTransformFeedbackNV_fnptr((uint)primitiveMode);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glBeginVideoCaptureNV</c>]</b><br/>  </summary>
            public static void BeginVideoCaptureNV(uint video_capture_slot) => GLPointers._glBeginVideoCaptureNV_fnptr(video_capture_slot);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glBindBufferBaseNV</c>]</b><br/>  </summary>
            public static void BindBufferBaseNV(BufferTargetARB target, uint index, int buffer) => GLPointers._glBindBufferBaseNV_fnptr((uint)target, index, buffer);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glBindBufferOffsetNV</c>]</b><br/>  </summary>
            public static void BindBufferOffsetNV(BufferTargetARB target, uint index, int buffer, IntPtr offset) => GLPointers._glBindBufferOffsetNV_fnptr((uint)target, index, buffer, offset);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glBindBufferRangeNV</c>]</b><br/>  </summary>
            public static void BindBufferRangeNV(BufferTargetARB target, uint index, int buffer, IntPtr offset, nint size) => GLPointers._glBindBufferRangeNV_fnptr((uint)target, index, buffer, offset, size);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glBindProgramNV</c>]</b><br/>  </summary>
            public static void BindProgramNV(VertexAttribEnumNV target, int id) => GLPointers._glBindProgramNV_fnptr((uint)target, id);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glBindShadingRateImageNV</c>]</b><br/>  </summary>
            public static void BindShadingRateImageNV(int texture) => GLPointers._glBindShadingRateImageNV_fnptr(texture);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glBindTransformFeedbackNV</c>]</b><br/>  </summary>
            public static void BindTransformFeedbackNV(BufferTargetARB target, int id) => GLPointers._glBindTransformFeedbackNV_fnptr((uint)target, id);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glBindVideoCaptureStreamBufferNV</c>]</b><br/>  </summary>
            public static void BindVideoCaptureStreamBufferNV(uint video_capture_slot, uint stream, All frame_region, IntPtr offset) => GLPointers._glBindVideoCaptureStreamBufferNV_fnptr(video_capture_slot, stream, (uint)frame_region, offset);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glBindVideoCaptureStreamTextureNV</c>]</b><br/>  </summary>
            public static void BindVideoCaptureStreamTextureNV(uint video_capture_slot, uint stream, All frame_region, All target, int texture) => GLPointers._glBindVideoCaptureStreamTextureNV_fnptr(video_capture_slot, stream, (uint)frame_region, (uint)target, texture);
            
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced]</b> <b>[entry point: <c>glBlendBarrierNV</c>]</b><br/>  </summary>
            public static void BlendBarrierNV() => GLPointers._glBlendBarrierNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced]</b> <b>[entry point: <c>glBlendParameteriNV</c>]</b><br/>  </summary>
            public static void BlendParameteriNV(All pname, int value) => GLPointers._glBlendParameteriNV_fnptr((uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glBufferAddressRangeNV</c>]</b><br/>  </summary>
            public static void BufferAddressRangeNV(All pname, uint index, ulong address, nint length) => GLPointers._glBufferAddressRangeNV_fnptr((uint)pname, index, address, length);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glBufferAttachMemoryNV</c>]</b><br/>  </summary>
            public static void BufferAttachMemoryNV(BufferTargetARB target, uint memory, ulong offset) => GLPointers._glBufferAttachMemoryNV_fnptr((uint)target, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b> <b>[entry point: <c>glBufferPageCommitmentMemNV</c>]</b><br/>  </summary>
            public static void BufferPageCommitmentMemNV(BufferStorageTarget target, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit) => GLPointers._glBufferPageCommitmentMemNV_fnptr((uint)target, offset, size, memory, memOffset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCallCommandListNV</c>]</b><br/>  </summary>
            public static void CallCommandListNV(uint list) => GLPointers._glCallCommandListNV_fnptr(list);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b> <b>[entry point: <c>glClearDepthdNV</c>]</b><br/>  </summary>
            public static void ClearDepthdNV(double depth) => GLPointers._glClearDepthdNV_fnptr(depth);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glColor3hNV</c>]</b><br/>  </summary>
            public static void Color3hNV(Half red, Half green, Half blue) => GLPointers._glColor3hNV_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glColor3hvNV</c>]</b><br/>  </summary>
            public static void Color3hvNV(Half* v) => GLPointers._glColor3hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glColor4hNV</c>]</b><br/>  </summary>
            public static void Color4hNV(Half red, Half green, Half blue, Half alpha) => GLPointers._glColor4hNV_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glColor4hvNV</c>]</b><br/>  </summary>
            public static void Color4hvNV(Half* v) => GLPointers._glColor4hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glColorFormatNV</c>]</b><br/>  </summary>
            public static void ColorFormatNV(int size, ColorPointerType type, int stride) => GLPointers._glColorFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerInputNV</c>]</b><br/>  </summary>
            public static void CombinerInputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => GLPointers._glCombinerInputNV_fnptr((uint)stage, (uint)portion, (uint)variable, (uint)input, (uint)mapping, (uint)componentUsage);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerOutputNV</c>]</b><br/>  </summary>
            public static void CombinerOutputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerRegisterNV abOutput, CombinerRegisterNV cdOutput, CombinerRegisterNV sumOutput, CombinerScaleNV scale, CombinerBiasNV bias, bool abDotProduct, bool cdDotProduct, bool muxSum) => GLPointers._glCombinerOutputNV_fnptr((uint)stage, (uint)portion, (uint)abOutput, (uint)cdOutput, (uint)sumOutput, (uint)scale, (uint)bias, (byte)(abDotProduct ? 1 : 0), (byte)(cdDotProduct ? 1 : 0), (byte)(muxSum ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerParameterfNV</c>]</b><br/>  </summary>
            public static void CombinerParameterfNV(CombinerParameterNV pname, float param) => GLPointers._glCombinerParameterfNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerParameterfvNV</c>]</b><br/>  </summary>
            public static void CombinerParameterfvNV(CombinerParameterNV pname, float* parameters) => GLPointers._glCombinerParameterfvNV_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerParameteriNV</c>]</b><br/>  </summary>
            public static void CombinerParameteriNV(CombinerParameterNV pname, int param) => GLPointers._glCombinerParameteriNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glCombinerParameterivNV</c>]</b><br/>  </summary>
            public static void CombinerParameterivNV(CombinerParameterNV pname, int* parameters) => GLPointers._glCombinerParameterivNV_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners2]</b> <b>[entry point: <c>glCombinerStageParameterfvNV</c>]</b><br/>  </summary>
            public static void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => GLPointers._glCombinerStageParameterfvNV_fnptr((uint)stage, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCommandListSegmentsNV</c>]</b><br/>  </summary>
            public static void CommandListSegmentsNV(uint list, uint segments) => GLPointers._glCommandListSegmentsNV_fnptr(list, segments);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCompileCommandListNV</c>]</b><br/>  </summary>
            public static void CompileCommandListNV(uint list) => GLPointers._glCompileCommandListNV_fnptr(list);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster_dilate]</b> <b>[entry point: <c>glConservativeRasterParameterfNV</c>]</b><br/>  </summary>
            public static void ConservativeRasterParameterfNV(All pname, float value) => GLPointers._glConservativeRasterParameterfNV_fnptr((uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster_pre_snap_triangles]</b> <b>[entry point: <c>glConservativeRasterParameteriNV</c>]</b><br/>  </summary>
            public static void ConservativeRasterParameteriNV(All pname, int param) => GLPointers._glConservativeRasterParameteriNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_copy_image]</b> <b>[entry point: <c>glCopyImageSubDataNV</c>]</b><br/>  </summary>
            public static void CopyImageSubDataNV(uint srcName, CopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => GLPointers._glCopyImageSubDataNV_fnptr(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCopyPathNV</c>]</b><br/>  </summary>
            public static void CopyPathNV(uint resultPath, uint srcPath) => GLPointers._glCopyPathNV_fnptr(resultPath, srcPath);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glCoverageModulationNV</c>]</b><br/>  </summary>
            public static void CoverageModulationNV(All components) => GLPointers._glCoverageModulationNV_fnptr((uint)components);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glCoverageModulationTableNV</c>]</b><br/>  </summary>
            public static void CoverageModulationTableNV(int n, float* v) => GLPointers._glCoverageModulationTableNV_fnptr(n, v);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCoverFillPathInstancedNV</c>]</b><br/>  </summary>
            public static void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._glCoverFillPathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCoverFillPathNV</c>]</b><br/>  </summary>
            public static void CoverFillPathNV(uint path, PathCoverMode coverMode) => GLPointers._glCoverFillPathNV_fnptr(path, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCoverStrokePathInstancedNV</c>]</b><br/>  </summary>
            public static void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._glCoverStrokePathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glCoverStrokePathNV</c>]</b><br/>  </summary>
            public static void CoverStrokePathNV(uint path, PathCoverMode coverMode) => GLPointers._glCoverStrokePathNV_fnptr(path, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCreateCommandListsNV</c>]</b><br/>  </summary>
            public static void CreateCommandListsNV(int n, uint* lists) => GLPointers._glCreateCommandListsNV_fnptr(n, lists);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b> <b>[entry point: <c>glCreateSemaphoresNV</c>]</b><br/>  </summary>
            public static void CreateSemaphoresNV(int n, uint* semaphores) => GLPointers._glCreateSemaphoresNV_fnptr(n, semaphores);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glCreateStatesNV</c>]</b><br/>  </summary>
            public static void CreateStatesNV(int n, uint* states) => GLPointers._glCreateStatesNV_fnptr(n, states);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDeleteCommandListsNV</c>]</b><br/>  </summary>
            public static void DeleteCommandListsNV(int n, uint* lists) => GLPointers._glDeleteCommandListsNV_fnptr(n, lists);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glDeleteFencesNV</c>]</b><br/>  </summary>
            public static void DeleteFencesNV(int n, uint* fences) => GLPointers._glDeleteFencesNV_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glDeleteOcclusionQueriesNV</c>]</b><br/>  </summary>
            public static void DeleteOcclusionQueriesNV(int n, uint* ids) => GLPointers._glDeleteOcclusionQueriesNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glDeletePathsNV</c>]</b><br/>  </summary>
            public static void DeletePathsNV(uint path, int range) => GLPointers._glDeletePathsNV_fnptr(path, range);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glDeleteProgramsNV</c>]</b><br/>  </summary>
            public static void DeleteProgramsNV(int n, int* programs) => GLPointers._glDeleteProgramsNV_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b> <b>[entry point: <c>glDeleteQueryResourceTagNV</c>]</b><br/>  </summary>
            public static void DeleteQueryResourceTagNV(int n, int* tagIds) => GLPointers._glDeleteQueryResourceTagNV_fnptr(n, tagIds);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDeleteStatesNV</c>]</b><br/>  </summary>
            public static void DeleteStatesNV(int n, uint* states) => GLPointers._glDeleteStatesNV_fnptr(n, states);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glDeleteTransformFeedbacksNV</c>]</b><br/>  </summary>
            public static void DeleteTransformFeedbacksNV(int n, int* ids) => GLPointers._glDeleteTransformFeedbacksNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b> <b>[entry point: <c>glDepthBoundsdNV</c>]</b><br/>  </summary>
            public static void DepthBoundsdNV(double zmin, double zmax) => GLPointers._glDepthBoundsdNV_fnptr(zmin, zmax);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b> <b>[entry point: <c>glDepthRangedNV</c>]</b><br/>  </summary>
            public static void DepthRangedNV(double zNear, double zFar) => GLPointers._glDepthRangedNV_fnptr(zNear, zFar);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDrawCommandsAddressNV</c>]</b><br/>  </summary>
            public static void DrawCommandsAddressNV(All primitiveMode, ulong* indirects, int* sizes, uint count) => GLPointers._glDrawCommandsAddressNV_fnptr((uint)primitiveMode, indirects, sizes, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDrawCommandsNV</c>]</b><br/>  </summary>
            public static void DrawCommandsNV(All primitiveMode, uint buffer, IntPtr* indirects, int* sizes, uint count) => GLPointers._glDrawCommandsNV_fnptr((uint)primitiveMode, buffer, indirects, sizes, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDrawCommandsStatesAddressNV</c>]</b><br/>  </summary>
            public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers._glDrawCommandsStatesAddressNV_fnptr(indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glDrawCommandsStatesNV</c>]</b><br/>  </summary>
            public static void DrawCommandsStatesNV(int buffer, IntPtr* indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers._glDrawCommandsStatesNV_fnptr(buffer, indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b> <b>[entry point: <c>glDrawMeshTasksIndirectNV</c>]</b><br/>  </summary>
            public static void DrawMeshTasksIndirectNV(IntPtr indirect) => GLPointers._glDrawMeshTasksIndirectNV_fnptr(indirect);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b> <b>[entry point: <c>glDrawMeshTasksNV</c>]</b><br/>  </summary>
            public static void DrawMeshTasksNV(uint first, uint count) => GLPointers._glDrawMeshTasksNV_fnptr(first, count);
            
            /// <summary> <b>[requires: GL_NV_draw_texture]</b> <b>[entry point: <c>glDrawTextureNV</c>]</b><br/>  </summary>
            public static void DrawTextureNV(int texture, int sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => GLPointers._glDrawTextureNV_fnptr(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glDrawTransformFeedbackNV</c>]</b><br/>  </summary>
            public static void DrawTransformFeedbackNV(PrimitiveType mode, int id) => GLPointers._glDrawTransformFeedbackNV_fnptr((uint)mode, id);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glDrawVkImageNV</c>]</b><br/>  </summary>
            public static void DrawVkImageNV(ulong vkImage, int sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => GLPointers._glDrawVkImageNV_fnptr(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glEdgeFlagFormatNV</c>]</b><br/>  </summary>
            public static void EdgeFlagFormatNV(int stride) => GLPointers._glEdgeFlagFormatNV_fnptr(stride);
            
            /// <summary> <b>[requires: GL_NV_conditional_render]</b> <b>[entry point: <c>glEndConditionalRenderNV</c>]</b><br/>  </summary>
            public static void EndConditionalRenderNV() => GLPointers._glEndConditionalRenderNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glEndOcclusionQueryNV</c>]</b><br/>  </summary>
            public static void EndOcclusionQueryNV() => GLPointers._glEndOcclusionQueryNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glEndTransformFeedbackNV</c>]</b><br/>  </summary>
            public static void EndTransformFeedbackNV() => GLPointers._glEndTransformFeedbackNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glEndVideoCaptureNV</c>]</b><br/>  </summary>
            public static void EndVideoCaptureNV(uint video_capture_slot) => GLPointers._glEndVideoCaptureNV_fnptr(video_capture_slot);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glEvalMapsNV</c>]</b><br/>  </summary>
            public static void EvalMapsNV(EvalTargetNV target, EvalMapsModeNV mode) => GLPointers._glEvalMapsNV_fnptr((uint)target, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glExecuteProgramNV</c>]</b><br/>  </summary>
            public static void ExecuteProgramNV(VertexAttribEnumNV target, uint id, float* parameters) => GLPointers._glExecuteProgramNV_fnptr((uint)target, id, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glFinalCombinerInputNV</c>]</b><br/>  </summary>
            public static void FinalCombinerInputNV(CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => GLPointers._glFinalCombinerInputNV_fnptr((uint)variable, (uint)input, (uint)mapping, (uint)componentUsage);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glFinishFenceNV</c>]</b><br/>  </summary>
            public static void FinishFenceNV(uint fence) => GLPointers._glFinishFenceNV_fnptr(fence);
            
            /// <summary> <b>[requires: GL_NV_pixel_data_range]</b> <b>[entry point: <c>glFlushPixelDataRangeNV</c>]</b><br/>  </summary>
            public static void FlushPixelDataRangeNV(PixelDataRangeTargetNV target) => GLPointers._glFlushPixelDataRangeNV_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_NV_vertex_array_range]</b> <b>[entry point: <c>glFlushVertexArrayRangeNV</c>]</b><br/>  </summary>
            public static void FlushVertexArrayRangeNV() => GLPointers._glFlushVertexArrayRangeNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glFogCoordFormatNV</c>]</b><br/>  </summary>
            public static void FogCoordFormatNV(All type, int stride) => GLPointers._glFogCoordFormatNV_fnptr((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glFogCoordhNV</c>]</b><br/>  </summary>
            public static void FogCoordhNV(Half fog) => GLPointers._glFogCoordhNV_fnptr(fog);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glFogCoordhvNV</c>]</b><br/>  </summary>
            public static void FogCoordhvNV(Half* fog) => GLPointers._glFogCoordhvNV_fnptr(fog);
            
            /// <summary> <b>[requires: GL_NV_fragment_coverage_to_color]</b> <b>[entry point: <c>glFragmentCoverageColorNV</c>]</b><br/>  </summary>
            public static void FragmentCoverageColorNV(uint color) => GLPointers._glFragmentCoverageColorNV_fnptr(color);
            
            /// <summary> <b>[requires: GL_NV_sample_locations]</b> <b>[entry point: <c>glFramebufferSampleLocationsfvNV</c>]</b><br/>  </summary>
            public static void FramebufferSampleLocationsfvNV(FramebufferTarget target, uint start, int count, float* v) => GLPointers._glFramebufferSampleLocationsfvNV_fnptr((uint)target, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b> <b>[entry point: <c>glFramebufferTextureEXT</c>]</b><br/>  </summary>
            public static void FramebufferTextureEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level) => GLPointers._glFramebufferTextureEXT_fnptr((uint)target, (uint)attachment, texture, level);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b> <b>[entry point: <c>glFramebufferTextureFaceEXT</c>]</b><br/>  </summary>
            public static void FramebufferTextureFaceEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, TextureTarget face) => GLPointers._glFramebufferTextureFaceEXT_fnptr((uint)target, (uint)attachment, texture, level, (uint)face);
            
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4]</b> <b>[entry point: <c>glFramebufferTextureLayerEXT</c>]</b><br/>  </summary>
            public static void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int layer) => GLPointers._glFramebufferTextureLayerEXT_fnptr((uint)target, (uint)attachment, texture, level, layer);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glGenFencesNV</c>]</b><br/>  </summary>
            public static void GenFencesNV(int n, uint* fences) => GLPointers._glGenFencesNV_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glGenOcclusionQueriesNV</c>]</b><br/>  </summary>
            public static void GenOcclusionQueriesNV(int n, uint* ids) => GLPointers._glGenOcclusionQueriesNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGenPathsNV</c>]</b><br/>  </summary>
            public static uint GenPathsNV(int range) => GLPointers._glGenPathsNV_fnptr(range);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGenProgramsNV</c>]</b><br/>  </summary>
            public static void GenProgramsNV(int n, int* programs) => GLPointers._glGenProgramsNV_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b> <b>[entry point: <c>glGenQueryResourceTagNV</c>]</b><br/>  </summary>
            public static void GenQueryResourceTagNV(int n, int* tagIds) => GLPointers._glGenQueryResourceTagNV_fnptr(n, tagIds);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glGenTransformFeedbacksNV</c>]</b><br/>  </summary>
            public static void GenTransformFeedbacksNV(int n, int* ids) => GLPointers._glGenTransformFeedbacksNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glGetActiveVaryingNV</c>]</b><br/>  </summary>
            public static void GetActiveVaryingNV(int program, uint index, int bufSize, int* length, int* size, All* type, byte* name) => GLPointers._glGetActiveVaryingNV_fnptr(program, index, bufSize, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetBufferParameterui64vNV</c>]</b><br/>  </summary>
            public static void GetBufferParameterui64vNV(BufferTargetARB target, All pname, ulong* parameters) => GLPointers._glGetBufferParameterui64vNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetCombinerInputParameterfvNV</c>]</b><br/>  </summary>
            public static void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => GLPointers._glGetCombinerInputParameterfvNV_fnptr((uint)stage, (uint)portion, (uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetCombinerInputParameterivNV</c>]</b><br/>  </summary>
            public static void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => GLPointers._glGetCombinerInputParameterivNV_fnptr((uint)stage, (uint)portion, (uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetCombinerOutputParameterfvNV</c>]</b><br/>  </summary>
            public static void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, float* parameters) => GLPointers._glGetCombinerOutputParameterfvNV_fnptr((uint)stage, (uint)portion, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetCombinerOutputParameterivNV</c>]</b><br/>  </summary>
            public static void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, int* parameters) => GLPointers._glGetCombinerOutputParameterivNV_fnptr((uint)stage, (uint)portion, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners2]</b> <b>[entry point: <c>glGetCombinerStageParameterfvNV</c>]</b><br/>  </summary>
            public static void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => GLPointers._glGetCombinerStageParameterfvNV_fnptr((uint)stage, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glGetCommandHeaderNV</c>]</b><br/>  </summary>
            public static uint GetCommandHeaderNV(CommandOpcodesNV tokenID, uint size) => GLPointers._glGetCommandHeaderNV_fnptr((uint)tokenID, size);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glGetCoverageModulationTableNV</c>]</b><br/>  </summary>
            public static void GetCoverageModulationTableNV(int bufSize, float* v) => GLPointers._glGetCoverageModulationTableNV_fnptr(bufSize, v);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glGetFenceivNV</c>]</b><br/>  </summary>
            public static void GetFenceivNV(uint fence, FenceParameterNameNV pname, int* parameters) => GLPointers._glGetFenceivNV_fnptr(fence, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetFinalCombinerInputParameterfvNV</c>]</b><br/>  </summary>
            public static void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => GLPointers._glGetFinalCombinerInputParameterfvNV_fnptr((uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b> <b>[entry point: <c>glGetFinalCombinerInputParameterivNV</c>]</b><br/>  </summary>
            public static void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => GLPointers._glGetFinalCombinerInputParameterivNV_fnptr((uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glGetImageHandleNV</c>]</b><br/>  </summary>
            public static ulong GetImageHandleNV(int texture, int level, bool layered, int layer, PixelFormat format) => GLPointers._glGetImageHandleNV_fnptr(texture, level, (byte)(layered ? 1 : 0), layer, (uint)format);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glGetIntegerui64i_vNV</c>]</b><br/>  </summary>
            public static void GetIntegerui64i_vNV(All value, uint index, ulong* result) => GLPointers._glGetIntegerui64i_vNV_fnptr((uint)value, index, result);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetIntegerui64vNV</c>]</b><br/>  </summary>
            public static void GetIntegerui64vNV(All value, ulong* result) => GLPointers._glGetIntegerui64vNV_fnptr((uint)value, result);
            
            /// <summary> <b>[requires: GL_NV_internalformat_sample_query]</b> <b>[entry point: <c>glGetInternalformatSampleivNV</c>]</b><br/>  </summary>
            public static void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, int* parameters) => GLPointers._glGetInternalformatSampleivNV_fnptr((uint)target, (uint)internalformat, samples, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapAttribParameterfvNV</c>]</b><br/>  </summary>
            public static void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, float* parameters) => GLPointers._glGetMapAttribParameterfvNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapAttribParameterivNV</c>]</b><br/>  </summary>
            public static void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, int* parameters) => GLPointers._glGetMapAttribParameterivNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapControlPointsNV</c>]</b><br/>  </summary>
            public static void GetMapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, bool packed, void* points) => GLPointers._glGetMapControlPointsNV_fnptr((uint)target, index, (uint)type, ustride, vstride, (byte)(packed ? 1 : 0), points);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapParameterfvNV</c>]</b><br/>  </summary>
            public static void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float* parameters) => GLPointers._glGetMapParameterfvNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glGetMapParameterivNV</c>]</b><br/>  </summary>
            public static void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, int* parameters) => GLPointers._glGetMapParameterivNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glGetMemoryObjectDetachedResourcesuivNV</c>]</b><br/>  </summary>
            public static void GetMemoryObjectDetachedResourcesuivNV(uint memory, All pname, int first, int count, uint* parameters) => GLPointers._glGetMemoryObjectDetachedResourcesuivNV_fnptr(memory, (uint)pname, first, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b> <b>[entry point: <c>glGetMultisamplefvNV</c>]</b><br/>  </summary>
            public static void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers._glGetMultisamplefvNV_fnptr((uint)pname, index, val);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetNamedBufferParameterui64vNV</c>]</b><br/>  </summary>
            public static void GetNamedBufferParameterui64vNV(int buffer, BufferPNameARB pname, ulong* parameters) => GLPointers._glGetNamedBufferParameterui64vNV_fnptr(buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glGetOcclusionQueryivNV</c>]</b><br/>  </summary>
            public static void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, int* parameters) => GLPointers._glGetOcclusionQueryivNV_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glGetOcclusionQueryuivNV</c>]</b><br/>  </summary>
            public static void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, uint* parameters) => GLPointers._glGetOcclusionQueryuivNV_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathColorGenfvNV</c>]</b><br/>  </summary>
            public static void GetPathColorGenfvNV(PathColor color, PathGenMode pname, float* value) => GLPointers._glGetPathColorGenfvNV_fnptr((uint)color, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathColorGenivNV</c>]</b><br/>  </summary>
            public static void GetPathColorGenivNV(PathColor color, PathGenMode pname, int* value) => GLPointers._glGetPathColorGenivNV_fnptr((uint)color, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathCommandsNV</c>]</b><br/>  </summary>
            public static void GetPathCommandsNV(uint path, byte* commands) => GLPointers._glGetPathCommandsNV_fnptr(path, commands);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathCoordsNV</c>]</b><br/>  </summary>
            public static void GetPathCoordsNV(uint path, float* coords) => GLPointers._glGetPathCoordsNV_fnptr(path, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathDashArrayNV</c>]</b><br/>  </summary>
            public static void GetPathDashArrayNV(uint path, float* dashArray) => GLPointers._glGetPathDashArrayNV_fnptr(path, dashArray);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathLengthNV</c>]</b><br/>  </summary>
            public static float GetPathLengthNV(uint path, int startSegment, int numSegments) => GLPointers._glGetPathLengthNV_fnptr(path, startSegment, numSegments);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathMetricRangeNV</c>]</b><br/>  </summary>
            public static void GetPathMetricRangeNV(PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics) => GLPointers._glGetPathMetricRangeNV_fnptr((uint)metricQueryMask, firstPathName, numPaths, stride, metrics);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathMetricsNV</c>]</b><br/>  </summary>
            public static void GetPathMetricsNV(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics) => GLPointers._glGetPathMetricsNV_fnptr((uint)metricQueryMask, numPaths, (uint)pathNameType, paths, pathBase, stride, metrics);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathParameterfvNV</c>]</b><br/>  </summary>
            public static void GetPathParameterfvNV(uint path, PathParameter pname, float* value) => GLPointers._glGetPathParameterfvNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathParameterivNV</c>]</b><br/>  </summary>
            public static void GetPathParameterivNV(uint path, PathParameter pname, int* value) => GLPointers._glGetPathParameterivNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathSpacingNV</c>]</b><br/>  </summary>
            public static void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float* returnedSpacing) => GLPointers._glGetPathSpacingNV_fnptr((uint)pathListMode, numPaths, (uint)pathNameType, paths, pathBase, advanceScale, kerningScale, (uint)transformType, returnedSpacing);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathTexGenfvNV</c>]</b><br/>  </summary>
            public static void GetPathTexGenfvNV(TextureUnit texCoordSet, PathGenMode pname, float* value) => GLPointers._glGetPathTexGenfvNV_fnptr((uint)texCoordSet, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetPathTexGenivNV</c>]</b><br/>  </summary>
            public static void GetPathTexGenivNV(TextureUnit texCoordSet, PathGenMode pname, int* value) => GLPointers._glGetPathTexGenivNV_fnptr((uint)texCoordSet, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glGetProgramEnvParameterIivNV</c>]</b><br/>  </summary>
            public static void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, int* parameters) => GLPointers._glGetProgramEnvParameterIivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glGetProgramEnvParameterIuivNV</c>]</b><br/>  </summary>
            public static void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers._glGetProgramEnvParameterIuivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetProgramivNV</c>]</b><br/>  </summary>
            public static void GetProgramivNV(int id, VertexAttribEnumNV pname, int* parameters) => GLPointers._glGetProgramivNV_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glGetProgramLocalParameterIivNV</c>]</b><br/>  </summary>
            public static void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, int* parameters) => GLPointers._glGetProgramLocalParameterIivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glGetProgramLocalParameterIuivNV</c>]</b><br/>  </summary>
            public static void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers._glGetProgramLocalParameterIuivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glGetProgramNamedParameterdvNV</c>]</b><br/>  </summary>
            public static void GetProgramNamedParameterdvNV(int id, int len, byte* name, double* parameters) => GLPointers._glGetProgramNamedParameterdvNV_fnptr(id, len, name, parameters);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glGetProgramNamedParameterfvNV</c>]</b><br/>  </summary>
            public static void GetProgramNamedParameterfvNV(int id, int len, byte* name, float* parameters) => GLPointers._glGetProgramNamedParameterfvNV_fnptr(id, len, name, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetProgramParameterdvNV</c>]</b><br/>  </summary>
            public static void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, double* parameters) => GLPointers._glGetProgramParameterdvNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetProgramParameterfvNV</c>]</b><br/>  </summary>
            public static void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, float* parameters) => GLPointers._glGetProgramParameterfvNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glGetProgramResourcefvNV</c>]</b><br/>  </summary>
            public static void GetProgramResourcefvNV(int program, ProgramInterface programInterface, uint index, int propCount, All* props, int count, int* length, float* parameters) => GLPointers._glGetProgramResourcefvNV_fnptr(program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetProgramStringNV</c>]</b><br/>  </summary>
            public static void GetProgramStringNV(int id, VertexAttribEnumNV pname, byte* program) => GLPointers._glGetProgramStringNV_fnptr(id, (uint)pname, program);
            
            /// <summary> <b>[requires: GL_NV_gpu_program5]</b> <b>[entry point: <c>glGetProgramSubroutineParameteruivNV</c>]</b><br/>  </summary>
            public static void GetProgramSubroutineParameteruivNV(All target, uint index, uint* param) => GLPointers._glGetProgramSubroutineParameteruivNV_fnptr((uint)target, index, param);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b> <b>[entry point: <c>glGetSemaphoreParameterivNV</c>]</b><br/>  </summary>
            public static void GetSemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, int* parameters) => GLPointers._glGetSemaphoreParameterivNV_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glGetShadingRateImagePaletteNV</c>]</b><br/>  </summary>
            public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, All* rate) => GLPointers._glGetShadingRateImagePaletteNV_fnptr(viewport, entry, (uint*)rate);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glGetShadingRateSampleLocationivNV</c>]</b><br/>  </summary>
            public static void GetShadingRateSampleLocationivNV(All rate, uint samples, uint index, int* location) => GLPointers._glGetShadingRateSampleLocationivNV_fnptr((uint)rate, samples, index, location);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glGetStageIndexNV</c>]</b><br/>  </summary>
            public static ushort GetStageIndexNV(ShaderType shadertype) => GLPointers._glGetStageIndexNV_fnptr((uint)shadertype);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glGetTextureHandleNV</c>]</b><br/>  </summary>
            public static ulong GetTextureHandleNV(int texture) => GLPointers._glGetTextureHandleNV_fnptr(texture);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glGetTextureSamplerHandleNV</c>]</b><br/>  </summary>
            public static ulong GetTextureSamplerHandleNV(int texture, int sampler) => GLPointers._glGetTextureSamplerHandleNV_fnptr(texture, sampler);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetTrackMatrixivNV</c>]</b><br/>  </summary>
            public static void GetTrackMatrixivNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, int* parameters) => GLPointers._glGetTrackMatrixivNV_fnptr((uint)target, address, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glGetTransformFeedbackVaryingNV</c>]</b><br/>  </summary>
            public static void GetTransformFeedbackVaryingNV(int program, uint index, int* location) => GLPointers._glGetTransformFeedbackVaryingNV_fnptr(program, index, location);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glGetUniformi64vNV</c>]</b><br/>  </summary>
            public static void GetUniformi64vNV(int program, int location, long* parameters) => GLPointers._glGetUniformi64vNV_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glGetUniformui64vNV</c>]</b><br/>  </summary>
            public static void GetUniformui64vNV(int program, int location, ulong* parameters) => GLPointers._glGetUniformui64vNV_fnptr(program, location, parameters);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glGetVaryingLocationNV</c>]</b><br/>  </summary>
            public static int GetVaryingLocationNV(int program, byte* name) => GLPointers._glGetVaryingLocationNV_fnptr(program, name);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetVertexAttribdvNV</c>]</b><br/>  </summary>
            public static void GetVertexAttribdvNV(uint index, VertexAttribEnumNV pname, double* parameters) => GLPointers._glGetVertexAttribdvNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetVertexAttribfvNV</c>]</b><br/>  </summary>
            public static void GetVertexAttribfvNV(uint index, VertexAttribEnumNV pname, float* parameters) => GLPointers._glGetVertexAttribfvNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glGetVertexAttribIivEXT</c>]</b><br/>  </summary>
            public static void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int* parameters) => GLPointers._glGetVertexAttribIivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glGetVertexAttribIuivEXT</c>]</b><br/>  </summary>
            public static void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers._glGetVertexAttribIuivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetVertexAttribivNV</c>]</b><br/>  </summary>
            public static void GetVertexAttribivNV(uint index, VertexAttribEnumNV pname, int* parameters) => GLPointers._glGetVertexAttribivNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glGetVertexAttribLi64vNV</c>]</b><br/>  </summary>
            public static void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, long* parameters) => GLPointers._glGetVertexAttribLi64vNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glGetVertexAttribLui64vNV</c>]</b><br/>  </summary>
            public static void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, ulong* parameters) => GLPointers._glGetVertexAttribLui64vNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glGetVertexAttribPointervNV</c>]</b><br/>  </summary>
            public static void GetVertexAttribPointervNV_(uint index, VertexAttribEnumNV pname, void** pointer) => GLPointers._glGetVertexAttribPointervNV_fnptr(index, (uint)pname, pointer);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glGetVideoCaptureivNV</c>]</b><br/>  </summary>
            public static void GetVideoCaptureivNV(uint video_capture_slot, All pname, int* parameters) => GLPointers._glGetVideoCaptureivNV_fnptr(video_capture_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glGetVideoCaptureStreamdvNV</c>]</b><br/>  </summary>
            public static void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, All pname, double* parameters) => GLPointers._glGetVideoCaptureStreamdvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glGetVideoCaptureStreamfvNV</c>]</b><br/>  </summary>
            public static void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, All pname, float* parameters) => GLPointers._glGetVideoCaptureStreamfvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glGetVideoCaptureStreamivNV</c>]</b><br/>  </summary>
            public static void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, All pname, int* parameters) => GLPointers._glGetVideoCaptureStreamivNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glGetVideoi64vNV</c>]</b><br/>  </summary>
            public static void GetVideoi64vNV(uint video_slot, All pname, long* parameters) => GLPointers._glGetVideoi64vNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glGetVideoivNV</c>]</b><br/>  </summary>
            public static void GetVideoivNV(uint video_slot, All pname, int* parameters) => GLPointers._glGetVideoivNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glGetVideoui64vNV</c>]</b><br/>  </summary>
            public static void GetVideoui64vNV(uint video_slot, All pname, ulong* parameters) => GLPointers._glGetVideoui64vNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glGetVideouivNV</c>]</b><br/>  </summary>
            public static void GetVideouivNV(uint video_slot, All pname, uint* parameters) => GLPointers._glGetVideouivNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glGetVkProcAddrNV</c>]</b><br/>  </summary>
            public static IntPtr GetVkProcAddrNV(byte* name) => GLPointers._glGetVkProcAddrNV_fnptr(name);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glIndexFormatNV</c>]</b><br/>  </summary>
            public static void IndexFormatNV(All type, int stride) => GLPointers._glIndexFormatNV_fnptr((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glInterpolatePathsNV</c>]</b><br/>  </summary>
            public static void InterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight) => GLPointers._glInterpolatePathsNV_fnptr(resultPath, pathA, pathB, weight);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glIsBufferResidentNV</c>]</b><br/>  </summary>
            public static bool IsBufferResidentNV(All target) => GLPointers._glIsBufferResidentNV_fnptr((uint)target) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glIsCommandListNV</c>]</b><br/>  </summary>
            public static bool IsCommandListNV(uint list) => GLPointers._glIsCommandListNV_fnptr(list) != 0;
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glIsFenceNV</c>]</b><br/>  </summary>
            public static bool IsFenceNV(uint fence) => GLPointers._glIsFenceNV_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glIsImageHandleResidentNV</c>]</b><br/>  </summary>
            public static bool IsImageHandleResidentNV(ulong handle) => GLPointers._glIsImageHandleResidentNV_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glIsNamedBufferResidentNV</c>]</b><br/>  </summary>
            public static bool IsNamedBufferResidentNV(int buffer) => GLPointers._glIsNamedBufferResidentNV_fnptr(buffer) != 0;
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b> <b>[entry point: <c>glIsOcclusionQueryNV</c>]</b><br/>  </summary>
            public static bool IsOcclusionQueryNV(uint id) => GLPointers._glIsOcclusionQueryNV_fnptr(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glIsPathNV</c>]</b><br/>  </summary>
            public static bool IsPathNV(uint path) => GLPointers._glIsPathNV_fnptr(path) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glIsPointInFillPathNV</c>]</b><br/>  </summary>
            public static bool IsPointInFillPathNV(uint path, uint mask, float x, float y) => GLPointers._glIsPointInFillPathNV_fnptr(path, mask, x, y) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glIsPointInStrokePathNV</c>]</b><br/>  </summary>
            public static bool IsPointInStrokePathNV(uint path, float x, float y) => GLPointers._glIsPointInStrokePathNV_fnptr(path, x, y) != 0;
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glIsProgramNV</c>]</b><br/>  </summary>
            public static bool IsProgramNV(int id) => GLPointers._glIsProgramNV_fnptr(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glIsStateNV</c>]</b><br/>  </summary>
            public static bool IsStateNV(uint state) => GLPointers._glIsStateNV_fnptr(state) != 0;
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glIsTextureHandleResidentNV</c>]</b><br/>  </summary>
            public static bool IsTextureHandleResidentNV(ulong handle) => GLPointers._glIsTextureHandleResidentNV_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glIsTransformFeedbackNV</c>]</b><br/>  </summary>
            public static bool IsTransformFeedbackNV(int id) => GLPointers._glIsTransformFeedbackNV_fnptr(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glListDrawCommandsStatesClientNV</c>]</b><br/>  </summary>
            public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers._glListDrawCommandsStatesClientNV_fnptr(list, segment, indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glLoadProgramNV</c>]</b><br/>  </summary>
            public static void LoadProgramNV(VertexAttribEnumNV target, uint id, int len, byte* program) => GLPointers._glLoadProgramNV_fnptr((uint)target, id, len, program);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glMakeBufferNonResidentNV</c>]</b><br/>  </summary>
            public static void MakeBufferNonResidentNV(All target) => GLPointers._glMakeBufferNonResidentNV_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glMakeBufferResidentNV</c>]</b><br/>  </summary>
            public static void MakeBufferResidentNV(All target, All access) => GLPointers._glMakeBufferResidentNV_fnptr((uint)target, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glMakeImageHandleNonResidentNV</c>]</b><br/>  </summary>
            public static void MakeImageHandleNonResidentNV(ulong handle) => GLPointers._glMakeImageHandleNonResidentNV_fnptr(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glMakeImageHandleResidentNV</c>]</b><br/>  </summary>
            public static void MakeImageHandleResidentNV(ulong handle, All access) => GLPointers._glMakeImageHandleResidentNV_fnptr(handle, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glMakeNamedBufferNonResidentNV</c>]</b><br/>  </summary>
            public static void MakeNamedBufferNonResidentNV(int buffer) => GLPointers._glMakeNamedBufferNonResidentNV_fnptr(buffer);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glMakeNamedBufferResidentNV</c>]</b><br/>  </summary>
            public static void MakeNamedBufferResidentNV(int buffer, All access) => GLPointers._glMakeNamedBufferResidentNV_fnptr(buffer, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glMakeTextureHandleNonResidentNV</c>]</b><br/>  </summary>
            public static void MakeTextureHandleNonResidentNV(ulong handle) => GLPointers._glMakeTextureHandleNonResidentNV_fnptr(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glMakeTextureHandleResidentNV</c>]</b><br/>  </summary>
            public static void MakeTextureHandleResidentNV(ulong handle) => GLPointers._glMakeTextureHandleResidentNV_fnptr(handle);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glMapControlPointsNV</c>]</b><br/>  </summary>
            public static void MapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, bool packed, void* points) => GLPointers._glMapControlPointsNV_fnptr((uint)target, index, (uint)type, ustride, vstride, uorder, vorder, (byte)(packed ? 1 : 0), points);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glMapParameterfvNV</c>]</b><br/>  </summary>
            public static void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float* parameters) => GLPointers._glMapParameterfvNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b> <b>[entry point: <c>glMapParameterivNV</c>]</b><br/>  </summary>
            public static void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, int* parameters) => GLPointers._glMapParameterivNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixFrustumEXT</c>]</b><br/>  </summary>
            public static void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glMatrixFrustumEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoad3x2fNV</c>]</b><br/>  </summary>
            public static void MatrixLoad3x2fNV(All matrixMode, float* m) => GLPointers._glMatrixLoad3x2fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoad3x3fNV</c>]</b><br/>  </summary>
            public static void MatrixLoad3x3fNV(All matrixMode, float* m) => GLPointers._glMatrixLoad3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoaddEXT</c>]</b><br/>  </summary>
            public static void MatrixLoaddEXT(MatrixMode mode, double* m) => GLPointers._glMatrixLoaddEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadfEXT</c>]</b><br/>  </summary>
            public static void MatrixLoadfEXT(MatrixMode mode, float* m) => GLPointers._glMatrixLoadfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadIdentityEXT</c>]</b><br/>  </summary>
            public static void MatrixLoadIdentityEXT(MatrixMode mode) => GLPointers._glMatrixLoadIdentityEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTranspose3x3fNV</c>]</b><br/>  </summary>
            public static void MatrixLoadTranspose3x3fNV(All matrixMode, float* m) => GLPointers._glMatrixLoadTranspose3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTransposedEXT</c>]</b><br/>  </summary>
            public static void MatrixLoadTransposedEXT(MatrixMode mode, double* m) => GLPointers._glMatrixLoadTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixLoadTransposefEXT</c>]</b><br/>  </summary>
            public static void MatrixLoadTransposefEXT(MatrixMode mode, float* m) => GLPointers._glMatrixLoadTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMult3x2fNV</c>]</b><br/>  </summary>
            public static void MatrixMult3x2fNV(All matrixMode, float* m) => GLPointers._glMatrixMult3x2fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMult3x3fNV</c>]</b><br/>  </summary>
            public static void MatrixMult3x3fNV(All matrixMode, float* m) => GLPointers._glMatrixMult3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultdEXT</c>]</b><br/>  </summary>
            public static void MatrixMultdEXT(MatrixMode mode, double* m) => GLPointers._glMatrixMultdEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultfEXT</c>]</b><br/>  </summary>
            public static void MatrixMultfEXT(MatrixMode mode, float* m) => GLPointers._glMatrixMultfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTranspose3x3fNV</c>]</b><br/>  </summary>
            public static void MatrixMultTranspose3x3fNV(All matrixMode, float* m) => GLPointers._glMatrixMultTranspose3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTransposedEXT</c>]</b><br/>  </summary>
            public static void MatrixMultTransposedEXT(MatrixMode mode, double* m) => GLPointers._glMatrixMultTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixMultTransposefEXT</c>]</b><br/>  </summary>
            public static void MatrixMultTransposefEXT(MatrixMode mode, float* m) => GLPointers._glMatrixMultTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixOrthoEXT</c>]</b><br/>  </summary>
            public static void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._glMatrixOrthoEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixPopEXT</c>]</b><br/>  </summary>
            public static void MatrixPopEXT(MatrixMode mode) => GLPointers._glMatrixPopEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixPushEXT</c>]</b><br/>  </summary>
            public static void MatrixPushEXT(MatrixMode mode) => GLPointers._glMatrixPushEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixRotatedEXT</c>]</b><br/>  </summary>
            public static void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => GLPointers._glMatrixRotatedEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixRotatefEXT</c>]</b><br/>  </summary>
            public static void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => GLPointers._glMatrixRotatefEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixScaledEXT</c>]</b><br/>  </summary>
            public static void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => GLPointers._glMatrixScaledEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixScalefEXT</c>]</b><br/>  </summary>
            public static void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._glMatrixScalefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixTranslatedEXT</c>]</b><br/>  </summary>
            public static void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => GLPointers._glMatrixTranslatedEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b> <b>[entry point: <c>glMatrixTranslatefEXT</c>]</b><br/>  </summary>
            public static void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._glMatrixTranslatefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastBarrierNV</c>]</b><br/>  </summary>
            public static void MulticastBarrierNV() => GLPointers._glMulticastBarrierNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastBlitFramebufferNV</c>]</b><br/>  </summary>
            public static void MulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, All filter) => GLPointers._glMulticastBlitFramebufferNV_fnptr(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastBufferSubDataNV</c>]</b><br/>  </summary>
            public static void MulticastBufferSubDataNV(uint gpuMask, int buffer, IntPtr offset, nint size, void* data) => GLPointers._glMulticastBufferSubDataNV_fnptr(gpuMask, buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastCopyBufferSubDataNV</c>]</b><br/>  </summary>
            public static void MulticastCopyBufferSubDataNV(uint readGpu, uint writeGpuMask, int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._glMulticastCopyBufferSubDataNV_fnptr(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastCopyImageSubDataNV</c>]</b><br/>  </summary>
            public static void MulticastCopyImageSubDataNV(uint srcGpu, uint dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers._glMulticastCopyImageSubDataNV_fnptr(srcGpu, dstGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastFramebufferSampleLocationsfvNV</c>]</b><br/>  </summary>
            public static void MulticastFramebufferSampleLocationsfvNV(uint gpu, int framebuffer, uint start, int count, float* v) => GLPointers._glMulticastFramebufferSampleLocationsfvNV_fnptr(gpu, framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastGetQueryObjecti64vNV</c>]</b><br/>  </summary>
            public static void MulticastGetQueryObjecti64vNV(uint gpu, uint id, All pname, long* parameters) => GLPointers._glMulticastGetQueryObjecti64vNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastGetQueryObjectivNV</c>]</b><br/>  </summary>
            public static void MulticastGetQueryObjectivNV(uint gpu, uint id, All pname, int* parameters) => GLPointers._glMulticastGetQueryObjectivNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastGetQueryObjectui64vNV</c>]</b><br/>  </summary>
            public static void MulticastGetQueryObjectui64vNV(uint gpu, uint id, All pname, ulong* parameters) => GLPointers._glMulticastGetQueryObjectui64vNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastGetQueryObjectuivNV</c>]</b><br/>  </summary>
            public static void MulticastGetQueryObjectuivNV(uint gpu, uint id, All pname, uint* parameters) => GLPointers._glMulticastGetQueryObjectuivNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glMulticastWaitSyncNV</c>]</b><br/>  </summary>
            public static void MulticastWaitSyncNV(uint signalGpu, uint waitGpuMask) => GLPointers._glMulticastWaitSyncNV_fnptr(signalGpu, waitGpuMask);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count]</b> <b>[entry point: <c>glMultiDrawArraysIndirectBindlessCountNV</c>]</b><br/>  </summary>
            public static void MultiDrawArraysIndirectBindlessCountNV(PrimitiveType mode, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => GLPointers._glMultiDrawArraysIndirectBindlessCountNV_fnptr((uint)mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawArraysIndirectBindlessNV</c>]</b><br/>  </summary>
            public static void MultiDrawArraysIndirectBindlessNV(PrimitiveType mode, void* indirect, int drawCount, int stride, int vertexBufferCount) => GLPointers._glMultiDrawArraysIndirectBindlessNV_fnptr((uint)mode, indirect, drawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count]</b> <b>[entry point: <c>glMultiDrawElementsIndirectBindlessCountNV</c>]</b><br/>  </summary>
            public static void MultiDrawElementsIndirectBindlessCountNV(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => GLPointers._glMultiDrawElementsIndirectBindlessCountNV_fnptr((uint)mode, (uint)type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect]</b> <b>[entry point: <c>glMultiDrawElementsIndirectBindlessNV</c>]</b><br/>  </summary>
            public static void MultiDrawElementsIndirectBindlessNV(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int stride, int vertexBufferCount) => GLPointers._glMultiDrawElementsIndirectBindlessNV_fnptr((uint)mode, (uint)type, indirect, drawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b> <b>[entry point: <c>glMultiDrawMeshTasksIndirectCountNV</c>]</b><br/>  </summary>
            public static void MultiDrawMeshTasksIndirectCountNV(IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._glMultiDrawMeshTasksIndirectCountNV_fnptr(indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b> <b>[entry point: <c>glMultiDrawMeshTasksIndirectNV</c>]</b><br/>  </summary>
            public static void MultiDrawMeshTasksIndirectNV(IntPtr indirect, int drawcount, int stride) => GLPointers._glMultiDrawMeshTasksIndirectNV_fnptr(indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord1hNV</c>]</b><br/>  </summary>
            public static void MultiTexCoord1hNV(TextureUnit target, Half s) => GLPointers._glMultiTexCoord1hNV_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord1hvNV</c>]</b><br/>  </summary>
            public static void MultiTexCoord1hvNV(TextureUnit target, Half* v) => GLPointers._glMultiTexCoord1hvNV_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord2hNV</c>]</b><br/>  </summary>
            public static void MultiTexCoord2hNV(TextureUnit target, Half s, Half t) => GLPointers._glMultiTexCoord2hNV_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord2hvNV</c>]</b><br/>  </summary>
            public static void MultiTexCoord2hvNV(TextureUnit target, Half* v) => GLPointers._glMultiTexCoord2hvNV_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord3hNV</c>]</b><br/>  </summary>
            public static void MultiTexCoord3hNV(TextureUnit target, Half s, Half t, Half r) => GLPointers._glMultiTexCoord3hNV_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord3hvNV</c>]</b><br/>  </summary>
            public static void MultiTexCoord3hvNV(TextureUnit target, Half* v) => GLPointers._glMultiTexCoord3hvNV_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord4hNV</c>]</b><br/>  </summary>
            public static void MultiTexCoord4hNV(TextureUnit target, Half s, Half t, Half r, Half q) => GLPointers._glMultiTexCoord4hNV_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glMultiTexCoord4hvNV</c>]</b><br/>  </summary>
            public static void MultiTexCoord4hvNV(TextureUnit target, Half* v) => GLPointers._glMultiTexCoord4hvNV_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glNamedBufferAttachMemoryNV</c>]</b><br/>  </summary>
            public static void NamedBufferAttachMemoryNV(int buffer, uint memory, ulong offset) => GLPointers._glNamedBufferAttachMemoryNV_fnptr(buffer, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b> <b>[entry point: <c>glNamedBufferPageCommitmentMemNV</c>]</b><br/>  </summary>
            public static void NamedBufferPageCommitmentMemNV(int buffer, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit) => GLPointers._glNamedBufferPageCommitmentMemNV_fnptr(buffer, offset, size, memory, memOffset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_sample_locations]</b> <b>[entry point: <c>glNamedFramebufferSampleLocationsfvNV</c>]</b><br/>  </summary>
            public static void NamedFramebufferSampleLocationsfvNV(int framebuffer, uint start, int count, float* v) => GLPointers._glNamedFramebufferSampleLocationsfvNV_fnptr(framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glNormal3hNV</c>]</b><br/>  </summary>
            public static void Normal3hNV(Half nx, Half ny, Half nz) => GLPointers._glNormal3hNV_fnptr(nx, ny, nz);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glNormal3hvNV</c>]</b><br/>  </summary>
            public static void Normal3hvNV(Half* v) => GLPointers._glNormal3hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glNormalFormatNV</c>]</b><br/>  </summary>
            public static void NormalFormatNV(All type, int stride) => GLPointers._glNormalFormatNV_fnptr((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathColorGenNV</c>]</b><br/>  </summary>
            public static void PathColorGenNV(PathColor color, PathGenMode genMode, PathColorFormat colorFormat, float* coeffs) => GLPointers._glPathColorGenNV_fnptr((uint)color, (uint)genMode, (uint)colorFormat, coeffs);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathCommandsNV</c>]</b><br/>  </summary>
            public static void PathCommandsNV(uint path, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => GLPointers._glPathCommandsNV_fnptr(path, numCommands, commands, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathCoordsNV</c>]</b><br/>  </summary>
            public static void PathCoordsNV(uint path, int numCoords, PathCoordType coordType, void* coords) => GLPointers._glPathCoordsNV_fnptr(path, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathCoverDepthFuncNV</c>]</b><br/>  </summary>
            public static void PathCoverDepthFuncNV(DepthFunction func) => GLPointers._glPathCoverDepthFuncNV_fnptr((uint)func);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathDashArrayNV</c>]</b><br/>  </summary>
            public static void PathDashArrayNV(uint path, int dashCount, float* dashArray) => GLPointers._glPathDashArrayNV_fnptr(path, dashCount, dashArray);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathFogGenNV</c>]</b><br/>  </summary>
            public static void PathFogGenNV(PathGenMode genMode) => GLPointers._glPathFogGenNV_fnptr((uint)genMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathGlyphIndexArrayNV</c>]</b><br/>  </summary>
            public static All PathGlyphIndexArrayNV(uint firstPathName, All fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => (All) GLPointers._glPathGlyphIndexArrayNV_fnptr(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathGlyphIndexRangeNV</c>]</b><br/>  </summary>
            public static All PathGlyphIndexRangeNV(All fontTarget, void* fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount) => (All) GLPointers._glPathGlyphIndexRangeNV_fnptr((uint)fontTarget, fontName, (uint)fontStyle, pathParameterTemplate, emScale, baseAndCount);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathGlyphRangeNV</c>]</b><br/>  </summary>
            public static void PathGlyphRangeNV(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => GLPointers._glPathGlyphRangeNV_fnptr(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, firstGlyph, numGlyphs, (uint)handleMissingGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathGlyphsNV</c>]</b><br/>  </summary>
            public static void PathGlyphsNV(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, void* charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => GLPointers._glPathGlyphsNV_fnptr(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, numGlyphs, (uint)type, charcodes, (uint)handleMissingGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathMemoryGlyphIndexArrayNV</c>]</b><br/>  </summary>
            public static All PathMemoryGlyphIndexArrayNV(uint firstPathName, All fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => (All) GLPointers._glPathMemoryGlyphIndexArrayNV_fnptr(firstPathName, (uint)fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathParameterfNV</c>]</b><br/>  </summary>
            public static void PathParameterfNV(uint path, PathParameter pname, float value) => GLPointers._glPathParameterfNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathParameterfvNV</c>]</b><br/>  </summary>
            public static void PathParameterfvNV(uint path, PathParameter pname, float* value) => GLPointers._glPathParameterfvNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathParameteriNV</c>]</b><br/>  </summary>
            public static void PathParameteriNV(uint path, PathParameter pname, int value) => GLPointers._glPathParameteriNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathParameterivNV</c>]</b><br/>  </summary>
            public static void PathParameterivNV(uint path, PathParameter pname, int* value) => GLPointers._glPathParameterivNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathStencilDepthOffsetNV</c>]</b><br/>  </summary>
            public static void PathStencilDepthOffsetNV(float factor, float units) => GLPointers._glPathStencilDepthOffsetNV_fnptr(factor, units);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathStencilFuncNV</c>]</b><br/>  </summary>
            public static void PathStencilFuncNV(StencilFunction func, int reference, uint mask) => GLPointers._glPathStencilFuncNV_fnptr((uint)func, reference, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathStringNV</c>]</b><br/>  </summary>
            public static void PathStringNV(uint path, PathStringFormat format, int length, void* pathString) => GLPointers._glPathStringNV_fnptr(path, (uint)format, length, pathString);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathSubCommandsNV</c>]</b><br/>  </summary>
            public static void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => GLPointers._glPathSubCommandsNV_fnptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathSubCoordsNV</c>]</b><br/>  </summary>
            public static void PathSubCoordsNV(uint path, int coordStart, int numCoords, PathCoordType coordType, void* coords) => GLPointers._glPathSubCoordsNV_fnptr(path, coordStart, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPathTexGenNV</c>]</b><br/>  </summary>
            public static void PathTexGenNV(PathColor texCoordSet, PathGenMode genMode, int components, float* coeffs) => GLPointers._glPathTexGenNV_fnptr((uint)texCoordSet, (uint)genMode, components, coeffs);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glPauseTransformFeedbackNV</c>]</b><br/>  </summary>
            public static void PauseTransformFeedbackNV() => GLPointers._glPauseTransformFeedbackNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_pixel_data_range]</b> <b>[entry point: <c>glPixelDataRangeNV</c>]</b><br/>  </summary>
            public static void PixelDataRangeNV(PixelDataRangeTargetNV target, int length, void* pointer) => GLPointers._glPixelDataRangeNV_fnptr((uint)target, length, pointer);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glPointAlongPathNV</c>]</b><br/>  </summary>
            public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY) => GLPointers._glPointAlongPathNV_fnptr(path, startSegment, numSegments, distance, x, y, tangentX, tangentY) != 0;
            
            /// <summary> <b>[requires: GL_NV_point_sprite]</b> <b>[entry point: <c>glPointParameteriNV</c>]</b><br/>  </summary>
            public static void PointParameteriNV(PointParameterNameARB pname, int param) => GLPointers._glPointParameteriNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_point_sprite]</b> <b>[entry point: <c>glPointParameterivNV</c>]</b><br/>  </summary>
            public static void PointParameterivNV(PointParameterNameARB pname, int* parameters) => GLPointers._glPointParameterivNV_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glPresentFrameDualFillNV</c>]</b><br/>  </summary>
            public static void PresentFrameDualFillNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, All target1, uint fill1, All target2, uint fill2, All target3, uint fill3) => GLPointers._glPresentFrameDualFillNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, (uint)type, (uint)target0, fill0, (uint)target1, fill1, (uint)target2, fill2, (uint)target3, fill3);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b> <b>[entry point: <c>glPresentFrameKeyedNV</c>]</b><br/>  </summary>
            public static void PresentFrameKeyedNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, uint key0, All target1, uint fill1, uint key1) => GLPointers._glPresentFrameKeyedNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, (uint)type, (uint)target0, fill0, key0, (uint)target1, fill1, key1);
            
            /// <summary> <b>[requires: GL_NV_primitive_restart]</b> <b>[entry point: <c>glPrimitiveRestartIndexNV</c>]</b><br/>  </summary>
            public static void PrimitiveRestartIndexNV(uint index) => GLPointers._glPrimitiveRestartIndexNV_fnptr(index);
            
            /// <summary> <b>[requires: GL_NV_primitive_restart]</b> <b>[entry point: <c>glPrimitiveRestartNV</c>]</b><br/>  </summary>
            public static void PrimitiveRestartNV() => GLPointers._glPrimitiveRestartNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b> <b>[entry point: <c>glProgramBufferParametersfvNV</c>]</b><br/>  </summary>
            public static void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, float* parameters) => GLPointers._glProgramBufferParametersfvNV_fnptr((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b> <b>[entry point: <c>glProgramBufferParametersIivNV</c>]</b><br/>  </summary>
            public static void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, int* parameters) => GLPointers._glProgramBufferParametersIivNV_fnptr((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b> <b>[entry point: <c>glProgramBufferParametersIuivNV</c>]</b><br/>  </summary>
            public static void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, uint* parameters) => GLPointers._glProgramBufferParametersIuivNV_fnptr((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParameterI4iNV</c>]</b><br/>  </summary>
            public static void ProgramEnvParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers._glProgramEnvParameterI4iNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParameterI4ivNV</c>]</b><br/>  </summary>
            public static void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, int* parameters) => GLPointers._glProgramEnvParameterI4ivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParameterI4uiNV</c>]</b><br/>  </summary>
            public static void ProgramEnvParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers._glProgramEnvParameterI4uiNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParameterI4uivNV</c>]</b><br/>  </summary>
            public static void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers._glProgramEnvParameterI4uivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParametersI4ivNV</c>]</b><br/>  </summary>
            public static void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, int count, int* parameters) => GLPointers._glProgramEnvParametersI4ivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramEnvParametersI4uivNV</c>]</b><br/>  </summary>
            public static void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, int count, uint* parameters) => GLPointers._glProgramEnvParametersI4uivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParameterI4iNV</c>]</b><br/>  </summary>
            public static void ProgramLocalParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers._glProgramLocalParameterI4iNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParameterI4ivNV</c>]</b><br/>  </summary>
            public static void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, int* parameters) => GLPointers._glProgramLocalParameterI4ivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParameterI4uiNV</c>]</b><br/>  </summary>
            public static void ProgramLocalParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers._glProgramLocalParameterI4uiNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParameterI4uivNV</c>]</b><br/>  </summary>
            public static void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers._glProgramLocalParameterI4uivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParametersI4ivNV</c>]</b><br/>  </summary>
            public static void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, int count, int* parameters) => GLPointers._glProgramLocalParametersI4ivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b> <b>[entry point: <c>glProgramLocalParametersI4uivNV</c>]</b><br/>  </summary>
            public static void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, int count, uint* parameters) => GLPointers._glProgramLocalParametersI4uivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glProgramNamedParameter4dNV</c>]</b><br/>  </summary>
            public static void ProgramNamedParameter4dNV(int id, int len, byte* name, double x, double y, double z, double w) => GLPointers._glProgramNamedParameter4dNV_fnptr(id, len, name, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glProgramNamedParameter4dvNV</c>]</b><br/>  </summary>
            public static void ProgramNamedParameter4dvNV(int id, int len, byte* name, double* v) => GLPointers._glProgramNamedParameter4dvNV_fnptr(id, len, name, v);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glProgramNamedParameter4fNV</c>]</b><br/>  </summary>
            public static void ProgramNamedParameter4fNV(int id, int len, byte* name, float x, float y, float z, float w) => GLPointers._glProgramNamedParameter4fNV_fnptr(id, len, name, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b> <b>[entry point: <c>glProgramNamedParameter4fvNV</c>]</b><br/>  </summary>
            public static void ProgramNamedParameter4fvNV(int id, int len, byte* name, float* v) => GLPointers._glProgramNamedParameter4fvNV_fnptr(id, len, name, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameter4dNV</c>]</b><br/>  </summary>
            public static void ProgramParameter4dNV(VertexAttribEnumNV target, uint index, double x, double y, double z, double w) => GLPointers._glProgramParameter4dNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameter4dvNV</c>]</b><br/>  </summary>
            public static void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, double* v) => GLPointers._glProgramParameter4dvNV_fnptr((uint)target, index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameter4fNV</c>]</b><br/>  </summary>
            public static void ProgramParameter4fNV(VertexAttribEnumNV target, uint index, float x, float y, float z, float w) => GLPointers._glProgramParameter4fNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameter4fvNV</c>]</b><br/>  </summary>
            public static void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, float* v) => GLPointers._glProgramParameter4fvNV_fnptr((uint)target, index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameters4dvNV</c>]</b><br/>  </summary>
            public static void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, int count, double* v) => GLPointers._glProgramParameters4dvNV_fnptr((uint)target, index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glProgramParameters4fvNV</c>]</b><br/>  </summary>
            public static void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, int count, float* v) => GLPointers._glProgramParameters4fvNV_fnptr((uint)target, index, count, v);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glProgramPathFragmentInputGenNV</c>]</b><br/>  </summary>
            public static void ProgramPathFragmentInputGenNV(int program, int location, All genMode, int components, float* coeffs) => GLPointers._glProgramPathFragmentInputGenNV_fnptr(program, location, (uint)genMode, components, coeffs);
            
            /// <summary> <b>[requires: GL_NV_gpu_program5]</b> <b>[entry point: <c>glProgramSubroutineParametersuivNV</c>]</b><br/>  </summary>
            public static void ProgramSubroutineParametersuivNV(All target, int count, uint* parameters) => GLPointers._glProgramSubroutineParametersuivNV_fnptr((uint)target, count, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1i64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform1i64NV(int program, int location, long x) => GLPointers._glProgramUniform1i64NV_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1i64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform1i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform1i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1ui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform1ui64NV(int program, int location, ulong x) => GLPointers._glProgramUniform1ui64NV_fnptr(program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform1ui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform1ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform1ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2i64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform2i64NV(int program, int location, long x, long y) => GLPointers._glProgramUniform2i64NV_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2i64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform2i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform2i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2ui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform2ui64NV(int program, int location, ulong x, ulong y) => GLPointers._glProgramUniform2ui64NV_fnptr(program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform2ui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform2ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform2ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3i64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform3i64NV(int program, int location, long x, long y, long z) => GLPointers._glProgramUniform3i64NV_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3i64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform3i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform3i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3ui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform3ui64NV(int program, int location, ulong x, ulong y, ulong z) => GLPointers._glProgramUniform3ui64NV_fnptr(program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform3ui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform3ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform3ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4i64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform4i64NV(int program, int location, long x, long y, long z, long w) => GLPointers._glProgramUniform4i64NV_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4i64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform4i64vNV(int program, int location, int count, long* value) => GLPointers._glProgramUniform4i64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4ui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniform4ui64NV(int program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glProgramUniform4ui64NV_fnptr(program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glProgramUniform4ui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniform4ui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniform4ui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glProgramUniformHandleui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniformHandleui64NV(int program, int location, ulong value) => GLPointers._glProgramUniformHandleui64NV_fnptr(program, location, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glProgramUniformHandleui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniformHandleui64vNV(int program, int location, int count, ulong* values) => GLPointers._glProgramUniformHandleui64vNV_fnptr(program, location, count, values);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glProgramUniformui64NV</c>]</b><br/>  </summary>
            public static void ProgramUniformui64NV(int program, int location, ulong value) => GLPointers._glProgramUniformui64NV_fnptr(program, location, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glProgramUniformui64vNV</c>]</b><br/>  </summary>
            public static void ProgramUniformui64vNV(int program, int location, int count, ulong* value) => GLPointers._glProgramUniformui64vNV_fnptr(program, location, count, value);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b> <b>[entry point: <c>glProgramVertexLimitNV</c>]</b><br/>  </summary>
            public static void ProgramVertexLimitNV(ProgramTarget target, int limit) => GLPointers._glProgramVertexLimitNV_fnptr((uint)target, limit);
            
            /// <summary> <b>[requires: GL_NV_query_resource]</b> <b>[entry point: <c>glQueryResourceNV</c>]</b><br/>  </summary>
            public static int QueryResourceNV(All queryType, int tagId, uint count, int* buffer) => GLPointers._glQueryResourceNV_fnptr((uint)queryType, tagId, count, buffer);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b> <b>[entry point: <c>glQueryResourceTagNV</c>]</b><br/>  </summary>
            public static void QueryResourceTagNV(int tagId, byte* tagString) => GLPointers._glQueryResourceTagNV_fnptr(tagId, tagString);
            
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples]</b> <b>[entry point: <c>glRasterSamplesEXT</c>]</b><br/>  </summary>
            public static void RasterSamplesEXT(uint samples, bool fixedsamplelocations) => GLPointers._glRasterSamplesEXT_fnptr(samples, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_framebuffer_multisample_coverage]</b> <b>[entry point: <c>glRenderbufferStorageMultisampleCoverageNV</c>]</b><br/>  </summary>
            public static void RenderbufferStorageMultisampleCoverageNV(RenderbufferTarget target, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => GLPointers._glRenderbufferStorageMultisampleCoverageNV_fnptr((uint)target, coverageSamples, colorSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b> <b>[entry point: <c>glRenderGpuMaskNV</c>]</b><br/>  </summary>
            public static void RenderGpuMaskNV(uint mask) => GLPointers._glRenderGpuMaskNV_fnptr(mask);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glRequestResidentProgramsNV</c>]</b><br/>  </summary>
            public static void RequestResidentProgramsNV(int n, int* programs) => GLPointers._glRequestResidentProgramsNV_fnptr(n, programs);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glResetMemoryObjectParameterNV</c>]</b><br/>  </summary>
            public static void ResetMemoryObjectParameterNV(uint memory, All pname) => GLPointers._glResetMemoryObjectParameterNV_fnptr(memory, (uint)pname);
            
            /// <summary> <b>[requires: GL_NV_sample_locations]</b> <b>[entry point: <c>glResolveDepthValuesNV</c>]</b><br/>  </summary>
            public static void ResolveDepthValuesNV() => GLPointers._glResolveDepthValuesNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b> <b>[entry point: <c>glResumeTransformFeedbackNV</c>]</b><br/>  </summary>
            public static void ResumeTransformFeedbackNV() => GLPointers._glResumeTransformFeedbackNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b> <b>[entry point: <c>glSampleMaskIndexedNV</c>]</b><br/>  </summary>
            public static void SampleMaskIndexedNV(uint index, uint mask) => GLPointers._glSampleMaskIndexedNV_fnptr(index, mask);
            
            /// <summary> <b>[requires: GL_NV_scissor_exclusive]</b> <b>[entry point: <c>glScissorExclusiveArrayvNV</c>]</b><br/>  </summary>
            public static void ScissorExclusiveArrayvNV(uint first, int count, int* v) => GLPointers._glScissorExclusiveArrayvNV_fnptr(first, count, v);
            
            /// <summary> <b>[requires: GL_NV_scissor_exclusive]</b> <b>[entry point: <c>glScissorExclusiveNV</c>]</b><br/>  </summary>
            public static void ScissorExclusiveNV(int x, int y, int width, int height) => GLPointers._glScissorExclusiveNV_fnptr(x, y, width, height);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glSecondaryColor3hNV</c>]</b><br/>  </summary>
            public static void SecondaryColor3hNV(Half red, Half green, Half blue) => GLPointers._glSecondaryColor3hNV_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glSecondaryColor3hvNV</c>]</b><br/>  </summary>
            public static void SecondaryColor3hvNV(Half* v) => GLPointers._glSecondaryColor3hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glSecondaryColorFormatNV</c>]</b><br/>  </summary>
            public static void SecondaryColorFormatNV(int size, ColorPointerType type, int stride) => GLPointers._glSecondaryColorFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b> <b>[entry point: <c>glSemaphoreParameterivNV</c>]</b><br/>  </summary>
            public static void SemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, int* parameters) => GLPointers._glSemaphoreParameterivNV_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glSetFenceNV</c>]</b><br/>  </summary>
            public static void SetFenceNV(uint fence, FenceConditionNV condition) => GLPointers._glSetFenceNV_fnptr(fence, (uint)condition);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glShadingRateImageBarrierNV</c>]</b><br/>  </summary>
            public static void ShadingRateImageBarrierNV(bool synchronize) => GLPointers._glShadingRateImageBarrierNV_fnptr((byte)(synchronize ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glShadingRateImagePaletteNV</c>]</b><br/>  </summary>
            public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, All* rates) => GLPointers._glShadingRateImagePaletteNV_fnptr(viewport, first, count, (uint*)rates);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glShadingRateSampleOrderCustomNV</c>]</b><br/>  </summary>
            public static void ShadingRateSampleOrderCustomNV(All rate, uint samples, int* locations) => GLPointers._glShadingRateSampleOrderCustomNV_fnptr((uint)rate, samples, locations);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b> <b>[entry point: <c>glShadingRateSampleOrderNV</c>]</b><br/>  </summary>
            public static void ShadingRateSampleOrderNV(All order) => GLPointers._glShadingRateSampleOrderNV_fnptr((uint)order);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glSignalVkFenceNV</c>]</b><br/>  </summary>
            public static void SignalVkFenceNV(ulong vkFence) => GLPointers._glSignalVkFenceNV_fnptr(vkFence);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glSignalVkSemaphoreNV</c>]</b><br/>  </summary>
            public static void SignalVkSemaphoreNV(ulong vkSemaphore) => GLPointers._glSignalVkSemaphoreNV_fnptr(vkSemaphore);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b> <b>[entry point: <c>glStateCaptureNV</c>]</b><br/>  </summary>
            public static void StateCaptureNV(uint state, All mode) => GLPointers._glStateCaptureNV_fnptr(state, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilFillPathInstancedNV</c>]</b><br/>  </summary>
            public static void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float* transformValues) => GLPointers._glStencilFillPathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)fillMode, mask, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilFillPathNV</c>]</b><br/>  </summary>
            public static void StencilFillPathNV(uint path, PathFillMode fillMode, uint mask) => GLPointers._glStencilFillPathNV_fnptr(path, (uint)fillMode, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilStrokePathInstancedNV</c>]</b><br/>  </summary>
            public static void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float* transformValues) => GLPointers._glStencilStrokePathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, reference, mask, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilStrokePathNV</c>]</b><br/>  </summary>
            public static void StencilStrokePathNV(uint path, int reference, uint mask) => GLPointers._glStencilStrokePathNV_fnptr(path, reference, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilThenCoverFillPathInstancedNV</c>]</b><br/>  </summary>
            public static void StencilThenCoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathFillMode fillMode, uint mask, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._glStencilThenCoverFillPathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)fillMode, mask, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilThenCoverFillPathNV</c>]</b><br/>  </summary>
            public static void StencilThenCoverFillPathNV(uint path, PathFillMode fillMode, uint mask, PathCoverMode coverMode) => GLPointers._glStencilThenCoverFillPathNV_fnptr(path, (uint)fillMode, mask, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilThenCoverStrokePathInstancedNV</c>]</b><br/>  </summary>
            public static void StencilThenCoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, InstancedPathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._glStencilThenCoverStrokePathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, reference, mask, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glStencilThenCoverStrokePathNV</c>]</b><br/>  </summary>
            public static void StencilThenCoverStrokePathNV(uint path, int reference, uint mask, PathCoverMode coverMode) => GLPointers._glStencilThenCoverStrokePathNV_fnptr(path, reference, mask, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster]</b> <b>[entry point: <c>glSubpixelPrecisionBiasNV</c>]</b><br/>  </summary>
            public static void SubpixelPrecisionBiasNV(uint xbits, uint ybits) => GLPointers._glSubpixelPrecisionBiasNV_fnptr(xbits, ybits);
            
            /// <summary> <b>[requires: GL_NV_fence]</b> <b>[entry point: <c>glTestFenceNV</c>]</b><br/>  </summary>
            public static bool TestFenceNV(uint fence) => GLPointers._glTestFenceNV_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glTexAttachMemoryNV</c>]</b><br/>  </summary>
            public static void TexAttachMemoryNV(TextureTarget target, uint memory, ulong offset) => GLPointers._glTexAttachMemoryNV_fnptr((uint)target, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord1hNV</c>]</b><br/>  </summary>
            public static void TexCoord1hNV(Half s) => GLPointers._glTexCoord1hNV_fnptr(s);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord1hvNV</c>]</b><br/>  </summary>
            public static void TexCoord1hvNV(Half* v) => GLPointers._glTexCoord1hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord2hNV</c>]</b><br/>  </summary>
            public static void TexCoord2hNV(Half s, Half t) => GLPointers._glTexCoord2hNV_fnptr(s, t);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord2hvNV</c>]</b><br/>  </summary>
            public static void TexCoord2hvNV(Half* v) => GLPointers._glTexCoord2hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord3hNV</c>]</b><br/>  </summary>
            public static void TexCoord3hNV(Half s, Half t, Half r) => GLPointers._glTexCoord3hNV_fnptr(s, t, r);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord3hvNV</c>]</b><br/>  </summary>
            public static void TexCoord3hvNV(Half* v) => GLPointers._glTexCoord3hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord4hNV</c>]</b><br/>  </summary>
            public static void TexCoord4hNV(Half s, Half t, Half r, Half q) => GLPointers._glTexCoord4hNV_fnptr(s, t, r, q);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glTexCoord4hvNV</c>]</b><br/>  </summary>
            public static void TexCoord4hvNV(Half* v) => GLPointers._glTexCoord4hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glTexCoordFormatNV</c>]</b><br/>  </summary>
            public static void TexCoordFormatNV(int size, All type, int stride) => GLPointers._glTexCoordFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTexImage2DMultisampleCoverageNV</c>]</b><br/>  </summary>
            public static void TexImage2DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers._glTexImage2DMultisampleCoverageNV_fnptr((uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTexImage3DMultisampleCoverageNV</c>]</b><br/>  </summary>
            public static void TexImage3DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers._glTexImage3DMultisampleCoverageNV_fnptr((uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b> <b>[entry point: <c>glTexPageCommitmentMemNV</c>]</b><br/>  </summary>
            public static void TexPageCommitmentMemNV(TextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit) => GLPointers._glTexPageCommitmentMemNV_fnptr((uint)target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b> <b>[entry point: <c>glTexRenderbufferNV</c>]</b><br/>  </summary>
            public static void TexRenderbufferNV(TextureTarget target, int renderbuffer) => GLPointers._glTexRenderbufferNV_fnptr((uint)target, renderbuffer);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b> <b>[entry point: <c>glTextureAttachMemoryNV</c>]</b><br/>  </summary>
            public static void TextureAttachMemoryNV(int texture, uint memory, ulong offset) => GLPointers._glTextureAttachMemoryNV_fnptr(texture, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_texture_barrier]</b> <b>[entry point: <c>glTextureBarrierNV</c>]</b><br/>  </summary>
            public static void TextureBarrierNV() => GLPointers._glTextureBarrierNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTextureImage2DMultisampleCoverageNV</c>]</b><br/>  </summary>
            public static void TextureImage2DMultisampleCoverageNV(int texture, TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers._glTextureImage2DMultisampleCoverageNV_fnptr(texture, (uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTextureImage2DMultisampleNV</c>]</b><br/>  </summary>
            public static void TextureImage2DMultisampleNV(int texture, TextureTarget target, int samples, InternalFormat internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers._glTextureImage2DMultisampleNV_fnptr(texture, (uint)target, samples, (int)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTextureImage3DMultisampleCoverageNV</c>]</b><br/>  </summary>
            public static void TextureImage3DMultisampleCoverageNV(int texture, TextureTarget target, int coverageSamples, int colorSamples, InternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers._glTextureImage3DMultisampleCoverageNV_fnptr(texture, (uint)target, coverageSamples, colorSamples, (int)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b> <b>[entry point: <c>glTextureImage3DMultisampleNV</c>]</b><br/>  </summary>
            public static void TextureImage3DMultisampleNV(int texture, TextureTarget target, int samples, InternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers._glTextureImage3DMultisampleNV_fnptr(texture, (uint)target, samples, (int)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b> <b>[entry point: <c>glTexturePageCommitmentMemNV</c>]</b><br/>  </summary>
            public static void TexturePageCommitmentMemNV(int texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit) => GLPointers._glTexturePageCommitmentMemNV_fnptr(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glTrackMatrixNV</c>]</b><br/>  </summary>
            public static void TrackMatrixNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV matrix, VertexAttribEnumNV transform) => GLPointers._glTrackMatrixNV_fnptr((uint)target, address, (uint)matrix, (uint)transform);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glTransformFeedbackAttribsNV</c>]</b><br/>  </summary>
            public static void TransformFeedbackAttribsNV(int count, int* attribs, All bufferMode) => GLPointers._glTransformFeedbackAttribsNV_fnptr(count, attribs, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glTransformFeedbackStreamAttribsNV</c>]</b><br/>  </summary>
            public static void TransformFeedbackStreamAttribsNV(int count, int* attribs, int nbuffers, int* bufstreams, All bufferMode) => GLPointers._glTransformFeedbackStreamAttribsNV_fnptr(count, attribs, nbuffers, bufstreams, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b> <b>[entry point: <c>glTransformFeedbackVaryingsNV</c>]</b><br/>  </summary>
            public static void TransformFeedbackVaryingsNV(int program, int count, TransformFeedbackTokenNV* locations, TransformFeedbackBufferMode bufferMode) => GLPointers._glTransformFeedbackVaryingsNV_fnptr(program, count, (int*)locations, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glTransformPathNV</c>]</b><br/>  </summary>
            public static void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, float* transformValues) => GLPointers._glTransformPathNV_fnptr(resultPath, srcPath, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1i64NV</c>]</b><br/>  </summary>
            public static void Uniform1i64NV(int location, long x) => GLPointers._glUniform1i64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1i64vNV</c>]</b><br/>  </summary>
            public static void Uniform1i64vNV(int location, int count, long* value) => GLPointers._glUniform1i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1ui64NV</c>]</b><br/>  </summary>
            public static void Uniform1ui64NV(int location, ulong x) => GLPointers._glUniform1ui64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform1ui64vNV</c>]</b><br/>  </summary>
            public static void Uniform1ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform1ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2i64NV</c>]</b><br/>  </summary>
            public static void Uniform2i64NV(int location, long x, long y) => GLPointers._glUniform2i64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2i64vNV</c>]</b><br/>  </summary>
            public static void Uniform2i64vNV(int location, int count, long* value) => GLPointers._glUniform2i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2ui64NV</c>]</b><br/>  </summary>
            public static void Uniform2ui64NV(int location, ulong x, ulong y) => GLPointers._glUniform2ui64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform2ui64vNV</c>]</b><br/>  </summary>
            public static void Uniform2ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform2ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3i64NV</c>]</b><br/>  </summary>
            public static void Uniform3i64NV(int location, long x, long y, long z) => GLPointers._glUniform3i64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3i64vNV</c>]</b><br/>  </summary>
            public static void Uniform3i64vNV(int location, int count, long* value) => GLPointers._glUniform3i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3ui64NV</c>]</b><br/>  </summary>
            public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z) => GLPointers._glUniform3ui64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform3ui64vNV</c>]</b><br/>  </summary>
            public static void Uniform3ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform3ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4i64NV</c>]</b><br/>  </summary>
            public static void Uniform4i64NV(int location, long x, long y, long z, long w) => GLPointers._glUniform4i64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4i64vNV</c>]</b><br/>  </summary>
            public static void Uniform4i64vNV(int location, int count, long* value) => GLPointers._glUniform4i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4ui64NV</c>]</b><br/>  </summary>
            public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._glUniform4ui64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b> <b>[entry point: <c>glUniform4ui64vNV</c>]</b><br/>  </summary>
            public static void Uniform4ui64vNV(int location, int count, ulong* value) => GLPointers._glUniform4ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glUniformHandleui64NV</c>]</b><br/>  </summary>
            public static void UniformHandleui64NV(int location, ulong value) => GLPointers._glUniformHandleui64NV_fnptr(location, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b> <b>[entry point: <c>glUniformHandleui64vNV</c>]</b><br/>  </summary>
            public static void UniformHandleui64vNV(int location, int count, ulong* value) => GLPointers._glUniformHandleui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glUniformui64NV</c>]</b><br/>  </summary>
            public static void Uniformui64NV(int location, ulong value) => GLPointers._glUniformui64NV_fnptr(location, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b> <b>[entry point: <c>glUniformui64vNV</c>]</b><br/>  </summary>
            public static void Uniformui64vNV(int location, int count, ulong* value) => GLPointers._glUniformui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUFiniNV</c>]</b><br/>  </summary>
            public static void VDPAUFiniNV() => GLPointers._glVDPAUFiniNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUGetSurfaceivNV</c>]</b><br/>  </summary>
            public static void VDPAUGetSurfaceivNV(IntPtr surface, All pname, int count, int* length, int* values) => GLPointers._glVDPAUGetSurfaceivNV_fnptr(surface, (uint)pname, count, length, values);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUInitNV</c>]</b><br/>  </summary>
            public static void VDPAUInitNV(void* vdpDevice, void* getProcAddress) => GLPointers._glVDPAUInitNV_fnptr(vdpDevice, getProcAddress);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUIsSurfaceNV</c>]</b><br/>  </summary>
            public static bool VDPAUIsSurfaceNV(IntPtr surface) => GLPointers._glVDPAUIsSurfaceNV_fnptr(surface) != 0;
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUMapSurfacesNV</c>]</b><br/>  </summary>
            public static void VDPAUMapSurfacesNV(int numSurfaces, IntPtr* surfaces) => GLPointers._glVDPAUMapSurfacesNV_fnptr(numSurfaces, surfaces);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAURegisterOutputSurfaceNV</c>]</b><br/>  </summary>
            public static IntPtr VDPAURegisterOutputSurfaceNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => GLPointers._glVDPAURegisterOutputSurfaceNV_fnptr(vdpSurface, (uint)target, numTextureNames, textureNames);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAURegisterVideoSurfaceNV</c>]</b><br/>  </summary>
            public static IntPtr VDPAURegisterVideoSurfaceNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => GLPointers._glVDPAURegisterVideoSurfaceNV_fnptr(vdpSurface, (uint)target, numTextureNames, textureNames);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop2]</b> <b>[entry point: <c>glVDPAURegisterVideoSurfaceWithPictureStructureNV</c>]</b><br/>  </summary>
            public static IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames, bool isFrameStructure) => GLPointers._glVDPAURegisterVideoSurfaceWithPictureStructureNV_fnptr(vdpSurface, (uint)target, numTextureNames, textureNames, (byte)(isFrameStructure ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUSurfaceAccessNV</c>]</b><br/>  </summary>
            public static void VDPAUSurfaceAccessNV(IntPtr surface, All access) => GLPointers._glVDPAUSurfaceAccessNV_fnptr(surface, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUUnmapSurfacesNV</c>]</b><br/>  </summary>
            public static void VDPAUUnmapSurfacesNV(int numSurface, IntPtr* surfaces) => GLPointers._glVDPAUUnmapSurfacesNV_fnptr(numSurface, surfaces);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b> <b>[entry point: <c>glVDPAUUnregisterSurfaceNV</c>]</b><br/>  </summary>
            public static void VDPAUUnregisterSurfaceNV(IntPtr surface) => GLPointers._glVDPAUUnregisterSurfaceNV_fnptr(surface);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex2hNV</c>]</b><br/>  </summary>
            public static void Vertex2hNV(Half x, Half y) => GLPointers._glVertex2hNV_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex2hvNV</c>]</b><br/>  </summary>
            public static void Vertex2hvNV(Half* v) => GLPointers._glVertex2hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex3hNV</c>]</b><br/>  </summary>
            public static void Vertex3hNV(Half x, Half y, Half z) => GLPointers._glVertex3hNV_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex3hvNV</c>]</b><br/>  </summary>
            public static void Vertex3hvNV(Half* v) => GLPointers._glVertex3hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex4hNV</c>]</b><br/>  </summary>
            public static void Vertex4hNV(Half x, Half y, Half z, Half w) => GLPointers._glVertex4hNV_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertex4hvNV</c>]</b><br/>  </summary>
            public static void Vertex4hvNV(Half* v) => GLPointers._glVertex4hvNV_fnptr(v);
            
            /// <summary> <b>[requires: GL_NV_vertex_array_range]</b> <b>[entry point: <c>glVertexArrayRangeNV</c>]</b><br/>  </summary>
            public static void VertexArrayRangeNV(int length, void* pointer) => GLPointers._glVertexArrayRangeNV_fnptr(length, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1dNV</c>]</b><br/>  </summary>
            public static void VertexAttrib1dNV(uint index, double x) => GLPointers._glVertexAttrib1dNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1dvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib1dvNV(uint index, double* v) => GLPointers._glVertexAttrib1dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1fNV</c>]</b><br/>  </summary>
            public static void VertexAttrib1fNV(uint index, float x) => GLPointers._glVertexAttrib1fNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1fvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib1fvNV(uint index, float* v) => GLPointers._glVertexAttrib1fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib1hNV</c>]</b><br/>  </summary>
            public static void VertexAttrib1hNV(uint index, Half x) => GLPointers._glVertexAttrib1hNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib1hvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib1hvNV(uint index, Half* v) => GLPointers._glVertexAttrib1hvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1sNV</c>]</b><br/>  </summary>
            public static void VertexAttrib1sNV(uint index, short x) => GLPointers._glVertexAttrib1sNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib1svNV</c>]</b><br/>  </summary>
            public static void VertexAttrib1svNV(uint index, short* v) => GLPointers._glVertexAttrib1svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2dNV</c>]</b><br/>  </summary>
            public static void VertexAttrib2dNV(uint index, double x, double y) => GLPointers._glVertexAttrib2dNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2dvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib2dvNV(uint index, double* v) => GLPointers._glVertexAttrib2dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2fNV</c>]</b><br/>  </summary>
            public static void VertexAttrib2fNV(uint index, float x, float y) => GLPointers._glVertexAttrib2fNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2fvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib2fvNV(uint index, float* v) => GLPointers._glVertexAttrib2fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib2hNV</c>]</b><br/>  </summary>
            public static void VertexAttrib2hNV(uint index, Half x, Half y) => GLPointers._glVertexAttrib2hNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib2hvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib2hvNV(uint index, Half* v) => GLPointers._glVertexAttrib2hvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2sNV</c>]</b><br/>  </summary>
            public static void VertexAttrib2sNV(uint index, short x, short y) => GLPointers._glVertexAttrib2sNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib2svNV</c>]</b><br/>  </summary>
            public static void VertexAttrib2svNV(uint index, short* v) => GLPointers._glVertexAttrib2svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3dNV</c>]</b><br/>  </summary>
            public static void VertexAttrib3dNV(uint index, double x, double y, double z) => GLPointers._glVertexAttrib3dNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3dvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib3dvNV(uint index, double* v) => GLPointers._glVertexAttrib3dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3fNV</c>]</b><br/>  </summary>
            public static void VertexAttrib3fNV(uint index, float x, float y, float z) => GLPointers._glVertexAttrib3fNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3fvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib3fvNV(uint index, float* v) => GLPointers._glVertexAttrib3fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib3hNV</c>]</b><br/>  </summary>
            public static void VertexAttrib3hNV(uint index, Half x, Half y, Half z) => GLPointers._glVertexAttrib3hNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib3hvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib3hvNV(uint index, Half* v) => GLPointers._glVertexAttrib3hvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3sNV</c>]</b><br/>  </summary>
            public static void VertexAttrib3sNV(uint index, short x, short y, short z) => GLPointers._glVertexAttrib3sNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib3svNV</c>]</b><br/>  </summary>
            public static void VertexAttrib3svNV(uint index, short* v) => GLPointers._glVertexAttrib3svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4dNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4dNV(uint index, double x, double y, double z, double w) => GLPointers._glVertexAttrib4dNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4dvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4dvNV(uint index, double* v) => GLPointers._glVertexAttrib4dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4fNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4fNV(uint index, float x, float y, float z, float w) => GLPointers._glVertexAttrib4fNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4fvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4fvNV(uint index, float* v) => GLPointers._glVertexAttrib4fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib4hNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4hNV(uint index, Half x, Half y, Half z, Half w) => GLPointers._glVertexAttrib4hNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttrib4hvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4hvNV(uint index, Half* v) => GLPointers._glVertexAttrib4hvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4sNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4sNV(uint index, short x, short y, short z, short w) => GLPointers._glVertexAttrib4sNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4svNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4svNV(uint index, short* v) => GLPointers._glVertexAttrib4svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4ubNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4ubNV(uint index, byte x, byte y, byte z, byte w) => GLPointers._glVertexAttrib4ubNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttrib4ubvNV</c>]</b><br/>  </summary>
            public static void VertexAttrib4ubvNV(uint index, byte* v) => GLPointers._glVertexAttrib4ubvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glVertexAttribFormatNV</c>]</b><br/>  </summary>
            public static void VertexAttribFormatNV(uint index, int size, VertexAttribType type, bool normalized, int stride) => GLPointers._glVertexAttribFormatNV_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1iEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI1iEXT(uint index, int x) => GLPointers._glVertexAttribI1iEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1ivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI1ivEXT(uint index, int* v) => GLPointers._glVertexAttribI1ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1uiEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI1uiEXT(uint index, uint x) => GLPointers._glVertexAttribI1uiEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI1uivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI1uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI1uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2iEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI2iEXT(uint index, int x, int y) => GLPointers._glVertexAttribI2iEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2ivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI2ivEXT(uint index, int* v) => GLPointers._glVertexAttribI2ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2uiEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI2uiEXT(uint index, uint x, uint y) => GLPointers._glVertexAttribI2uiEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI2uivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI2uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI2uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3iEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI3iEXT(uint index, int x, int y, int z) => GLPointers._glVertexAttribI3iEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3ivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI3ivEXT(uint index, int* v) => GLPointers._glVertexAttribI3ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3uiEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => GLPointers._glVertexAttribI3uiEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI3uivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI3uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI3uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4bvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4bvEXT(uint index, sbyte* v) => GLPointers._glVertexAttribI4bvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4iEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => GLPointers._glVertexAttribI4iEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4ivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4ivEXT(uint index, int* v) => GLPointers._glVertexAttribI4ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4svEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4svEXT(uint index, short* v) => GLPointers._glVertexAttribI4svEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4ubvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4ubvEXT(uint index, byte* v) => GLPointers._glVertexAttribI4ubvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4uiEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => GLPointers._glVertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4uivEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4uivEXT(uint index, uint* v) => GLPointers._glVertexAttribI4uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribI4usvEXT</c>]</b><br/>  </summary>
            public static void VertexAttribI4usvEXT(uint index, ushort* v) => GLPointers._glVertexAttribI4usvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glVertexAttribIFormatNV</c>]</b><br/>  </summary>
            public static void VertexAttribIFormatNV(uint index, int size, VertexAttribIType type, int stride) => GLPointers._glVertexAttribIFormatNV_fnptr(index, size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b> <b>[entry point: <c>glVertexAttribIPointerEXT</c>]</b><br/>  </summary>
            public static void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers._glVertexAttribIPointerEXT_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL1i64NV</c>]</b><br/>  </summary>
            public static void VertexAttribL1i64NV(uint index, long x) => GLPointers._glVertexAttribL1i64NV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL1i64vNV</c>]</b><br/>  </summary>
            public static void VertexAttribL1i64vNV(uint index, long* v) => GLPointers._glVertexAttribL1i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL1ui64NV</c>]</b><br/>  </summary>
            public static void VertexAttribL1ui64NV(uint index, ulong x) => GLPointers._glVertexAttribL1ui64NV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL1ui64vNV</c>]</b><br/>  </summary>
            public static void VertexAttribL1ui64vNV(uint index, ulong* v) => GLPointers._glVertexAttribL1ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL2i64NV</c>]</b><br/>  </summary>
            public static void VertexAttribL2i64NV(uint index, long x, long y) => GLPointers._glVertexAttribL2i64NV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL2i64vNV</c>]</b><br/>  </summary>
            public static void VertexAttribL2i64vNV(uint index, long* v) => GLPointers._glVertexAttribL2i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL2ui64NV</c>]</b><br/>  </summary>
            public static void VertexAttribL2ui64NV(uint index, ulong x, ulong y) => GLPointers._glVertexAttribL2ui64NV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL2ui64vNV</c>]</b><br/>  </summary>
            public static void VertexAttribL2ui64vNV(uint index, ulong* v) => GLPointers._glVertexAttribL2ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL3i64NV</c>]</b><br/>  </summary>
            public static void VertexAttribL3i64NV(uint index, long x, long y, long z) => GLPointers._glVertexAttribL3i64NV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL3i64vNV</c>]</b><br/>  </summary>
            public static void VertexAttribL3i64vNV(uint index, long* v) => GLPointers._glVertexAttribL3i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL3ui64NV</c>]</b><br/>  </summary>
            public static void VertexAttribL3ui64NV(uint index, ulong x, ulong y, ulong z) => GLPointers._glVertexAttribL3ui64NV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL3ui64vNV</c>]</b><br/>  </summary>
            public static void VertexAttribL3ui64vNV(uint index, ulong* v) => GLPointers._glVertexAttribL3ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL4i64NV</c>]</b><br/>  </summary>
            public static void VertexAttribL4i64NV(uint index, long x, long y, long z, long w) => GLPointers._glVertexAttribL4i64NV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL4i64vNV</c>]</b><br/>  </summary>
            public static void VertexAttribL4i64vNV(uint index, long* v) => GLPointers._glVertexAttribL4i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL4ui64NV</c>]</b><br/>  </summary>
            public static void VertexAttribL4ui64NV(uint index, ulong x, ulong y, ulong z, ulong w) => GLPointers._glVertexAttribL4ui64NV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribL4ui64vNV</c>]</b><br/>  </summary>
            public static void VertexAttribL4ui64vNV(uint index, ulong* v) => GLPointers._glVertexAttribL4ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b> <b>[entry point: <c>glVertexAttribLFormatNV</c>]</b><br/>  </summary>
            public static void VertexAttribLFormatNV(uint index, int size, VertexAttribLType type, int stride) => GLPointers._glVertexAttribLFormatNV_fnptr(index, size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribPointerNV</c>]</b><br/>  </summary>
            public static void VertexAttribPointerNV(uint index, int fsize, VertexAttribEnumNV type, int stride, void* pointer) => GLPointers._glVertexAttribPointerNV_fnptr(index, fsize, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs1dvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs1dvNV(uint index, int count, double* v) => GLPointers._glVertexAttribs1dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs1fvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs1fvNV(uint index, int count, float* v) => GLPointers._glVertexAttribs1fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttribs1hvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs1hvNV(uint index, int n, Half* v) => GLPointers._glVertexAttribs1hvNV_fnptr(index, n, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs1svNV</c>]</b><br/>  </summary>
            public static void VertexAttribs1svNV(uint index, int count, short* v) => GLPointers._glVertexAttribs1svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs2dvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs2dvNV(uint index, int count, double* v) => GLPointers._glVertexAttribs2dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs2fvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs2fvNV(uint index, int count, float* v) => GLPointers._glVertexAttribs2fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttribs2hvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs2hvNV(uint index, int n, Half* v) => GLPointers._glVertexAttribs2hvNV_fnptr(index, n, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs2svNV</c>]</b><br/>  </summary>
            public static void VertexAttribs2svNV(uint index, int count, short* v) => GLPointers._glVertexAttribs2svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs3dvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs3dvNV(uint index, int count, double* v) => GLPointers._glVertexAttribs3dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs3fvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs3fvNV(uint index, int count, float* v) => GLPointers._glVertexAttribs3fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttribs3hvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs3hvNV(uint index, int n, Half* v) => GLPointers._glVertexAttribs3hvNV_fnptr(index, n, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs3svNV</c>]</b><br/>  </summary>
            public static void VertexAttribs3svNV(uint index, int count, short* v) => GLPointers._glVertexAttribs3svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs4dvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs4dvNV(uint index, int count, double* v) => GLPointers._glVertexAttribs4dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs4fvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs4fvNV(uint index, int count, float* v) => GLPointers._glVertexAttribs4fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexAttribs4hvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs4hvNV(uint index, int n, Half* v) => GLPointers._glVertexAttribs4hvNV_fnptr(index, n, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs4svNV</c>]</b><br/>  </summary>
            public static void VertexAttribs4svNV(uint index, int count, short* v) => GLPointers._glVertexAttribs4svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b> <b>[entry point: <c>glVertexAttribs4ubvNV</c>]</b><br/>  </summary>
            public static void VertexAttribs4ubvNV(uint index, int count, byte* v) => GLPointers._glVertexAttribs4ubvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b> <b>[entry point: <c>glVertexFormatNV</c>]</b><br/>  </summary>
            public static void VertexFormatNV(int size, VertexPointerType type, int stride) => GLPointers._glVertexFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexWeighthNV</c>]</b><br/>  </summary>
            public static void VertexWeighthNV(Half weight) => GLPointers._glVertexWeighthNV_fnptr(weight);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b> <b>[entry point: <c>glVertexWeighthvNV</c>]</b><br/>  </summary>
            public static void VertexWeighthvNV(Half* weight) => GLPointers._glVertexWeighthvNV_fnptr(weight);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glVideoCaptureNV</c>]</b><br/>  </summary>
            public static All VideoCaptureNV(uint video_capture_slot, uint* sequence_num, ulong* capture_time) => (All) GLPointers._glVideoCaptureNV_fnptr(video_capture_slot, sequence_num, capture_time);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glVideoCaptureStreamParameterdvNV</c>]</b><br/>  </summary>
            public static void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, All pname, double* parameters) => GLPointers._glVideoCaptureStreamParameterdvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glVideoCaptureStreamParameterfvNV</c>]</b><br/>  </summary>
            public static void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, All pname, float* parameters) => GLPointers._glVideoCaptureStreamParameterfvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b> <b>[entry point: <c>glVideoCaptureStreamParameterivNV</c>]</b><br/>  </summary>
            public static void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, All pname, int* parameters) => GLPointers._glVideoCaptureStreamParameterivNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_clip_space_w_scaling]</b> <b>[entry point: <c>glViewportPositionWScaleNV</c>]</b><br/>  </summary>
            public static void ViewportPositionWScaleNV(uint index, float xcoeff, float ycoeff) => GLPointers._glViewportPositionWScaleNV_fnptr(index, xcoeff, ycoeff);
            
            /// <summary> <b>[requires: GL_NV_viewport_swizzle]</b> <b>[entry point: <c>glViewportSwizzleNV</c>]</b><br/>  </summary>
            public static void ViewportSwizzleNV(uint index, All swizzlex, All swizzley, All swizzlez, All swizzlew) => GLPointers._glViewportSwizzleNV_fnptr(index, (uint)swizzlex, (uint)swizzley, (uint)swizzlez, (uint)swizzlew);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b> <b>[entry point: <c>glWaitVkSemaphoreNV</c>]</b><br/>  </summary>
            public static void WaitVkSemaphoreNV(ulong vkSemaphore) => GLPointers._glWaitVkSemaphoreNV_fnptr(vkSemaphore);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b> <b>[entry point: <c>glWeightPathsNV</c>]</b><br/>  </summary>
            public static void WeightPathsNV(uint resultPath, int numPaths, uint* paths, float* weights) => GLPointers._glWeightPathsNV_fnptr(resultPath, numPaths, paths, weights);
            
        }
        /// <summary>NVX extensions.</summary>
        public static unsafe partial class NVX
        {
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glAsyncCopyBufferSubDataNVX</c>]</b><br/>  </summary>
            public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, int readBuffer, int writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => GLPointers._glAsyncCopyBufferSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glAsyncCopyImageSubDataNVX</c>]</b><br/>  </summary>
            public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => GLPointers._glAsyncCopyImageSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            
            /// <summary> <b>[requires: GL_NVX_conditional_render]</b> <b>[entry point: <c>glBeginConditionalRenderNVX</c>]</b><br/>  </summary>
            public static void BeginConditionalRenderNVX(uint id) => GLPointers._glBeginConditionalRenderNVX_fnptr(id);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b> <b>[entry point: <c>glClientWaitSemaphoreui64NVX</c>]</b><br/>  </summary>
            public static void ClientWaitSemaphoreui64NVX(int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers._glClientWaitSemaphoreui64NVX_fnptr(fenceObjectCount, semaphoreArray, fenceValueArray);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b> <b>[entry point: <c>glCreateProgressFenceNVX</c>]</b><br/>  </summary>
            public static uint CreateProgressFenceNVX() => GLPointers._glCreateProgressFenceNVX_fnptr();
            
            /// <summary> <b>[requires: GL_NVX_conditional_render]</b> <b>[entry point: <c>glEndConditionalRenderNVX</c>]</b><br/>  </summary>
            public static void EndConditionalRenderNVX() => GLPointers._glEndConditionalRenderNVX_fnptr();
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b> <b>[entry point: <c>glLGPUCopyImageSubDataNVX</c>]</b><br/>  </summary>
            public static void LGPUCopyImageSubDataNVX(uint sourceGpu, uint destinationGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => GLPointers._glLGPUCopyImageSubDataNVX_fnptr(sourceGpu, destinationGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srxY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b> <b>[entry point: <c>glLGPUInterlockNVX</c>]</b><br/>  </summary>
            public static void LGPUInterlockNVX() => GLPointers._glLGPUInterlockNVX_fnptr();
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b> <b>[entry point: <c>glLGPUNamedBufferSubDataNVX</c>]</b><br/>  </summary>
            public static void LGPUNamedBufferSubDataNVX(uint gpuMask, int buffer, IntPtr offset, nint size, void* data) => GLPointers._glLGPUNamedBufferSubDataNVX_fnptr(gpuMask, buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glMulticastScissorArrayvNVX</c>]</b><br/>  </summary>
            public static void MulticastScissorArrayvNVX(uint gpu, uint first, int count, int* v) => GLPointers._glMulticastScissorArrayvNVX_fnptr(gpu, first, count, v);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glMulticastViewportArrayvNVX</c>]</b><br/>  </summary>
            public static void MulticastViewportArrayvNVX(uint gpu, uint first, int count, float* v) => GLPointers._glMulticastViewportArrayvNVX_fnptr(gpu, first, count, v);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glMulticastViewportPositionWScaleNVX</c>]</b><br/>  </summary>
            public static void MulticastViewportPositionWScaleNVX(uint gpu, uint index, float xcoeff, float ycoeff) => GLPointers._glMulticastViewportPositionWScaleNVX_fnptr(gpu, index, xcoeff, ycoeff);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b> <b>[entry point: <c>glSignalSemaphoreui64NVX</c>]</b><br/>  </summary>
            public static void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers._glSignalSemaphoreui64NVX_fnptr(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b> <b>[entry point: <c>glUploadGpuMaskNVX</c>]</b><br/>  </summary>
            public static void UploadGpuMaskNVX(uint mask) => GLPointers._glUploadGpuMaskNVX_fnptr(mask);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b> <b>[entry point: <c>glWaitSemaphoreui64NVX</c>]</b><br/>  </summary>
            public static void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers._glWaitSemaphoreui64NVX_fnptr(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            
        }
        /// <summary>OES extensions.</summary>
        public static unsafe partial class OES
        {
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glAccumxOES</c>]</b><br/>  </summary>
            public static void AccumxOES(All op, int value) => GLPointers._glAccumxOES_fnptr((uint)op, value);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glAlphaFuncxOES</c>]</b><br/>  </summary>
            public static void AlphaFuncxOES(AlphaFunction func, int reference) => GLPointers._glAlphaFuncxOES_fnptr((uint)func, reference);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glBitmapxOES</c>]</b><br/>  </summary>
            public static void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, byte* bitmap) => GLPointers._glBitmapxOES_fnptr(width, height, xorig, yorig, xmove, ymove, bitmap);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glBlendColorxOES</c>]</b><br/>  </summary>
            public static void BlendColorxOES(int red, int green, int blue, int alpha) => GLPointers._glBlendColorxOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glClearAccumxOES</c>]</b><br/>  </summary>
            public static void ClearAccumxOES(int red, int green, int blue, int alpha) => GLPointers._glClearAccumxOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glClearColorxOES</c>]</b><br/>  </summary>
            public static void ClearColorxOES(int red, int green, int blue, int alpha) => GLPointers._glClearColorxOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glClearDepthfOES</c>]</b><br/>  </summary>
            public static void ClearDepthfOES(float depth) => GLPointers._glClearDepthfOES_fnptr(depth);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glClearDepthxOES</c>]</b><br/>  </summary>
            public static void ClearDepthxOES(int depth) => GLPointers._glClearDepthxOES_fnptr(depth);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glClipPlanefOES</c>]</b><br/>  </summary>
            public static void ClipPlanefOES(ClipPlaneName plane, float* equation) => GLPointers._glClipPlanefOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glClipPlanexOES</c>]</b><br/>  </summary>
            public static void ClipPlanexOES(ClipPlaneName plane, int* equation) => GLPointers._glClipPlanexOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glColor3xOES</c>]</b><br/>  </summary>
            public static void Color3xOES(int red, int green, int blue) => GLPointers._glColor3xOES_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glColor3xvOES</c>]</b><br/>  </summary>
            public static void Color3xvOES(int* components) => GLPointers._glColor3xvOES_fnptr(components);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glColor4xOES</c>]</b><br/>  </summary>
            public static void Color4xOES(int red, int green, int blue, int alpha) => GLPointers._glColor4xOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glColor4xvOES</c>]</b><br/>  </summary>
            public static void Color4xvOES(int* components) => GLPointers._glColor4xvOES_fnptr(components);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glConvolutionParameterxOES</c>]</b><br/>  </summary>
            public static void ConvolutionParameterxOES(ConvolutionTargetEXT target, ConvolutionParameter pname, int param) => GLPointers._glConvolutionParameterxOES_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glConvolutionParameterxvOES</c>]</b><br/>  </summary>
            public static void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameter pname, int* parameters) => GLPointers._glConvolutionParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glDepthRangefOES</c>]</b><br/>  </summary>
            public static void DepthRangefOES(float n, float f) => GLPointers._glDepthRangefOES_fnptr(n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glDepthRangexOES</c>]</b><br/>  </summary>
            public static void DepthRangexOES(int n, int f) => GLPointers._glDepthRangexOES_fnptr(n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glEvalCoord1xOES</c>]</b><br/>  </summary>
            public static void EvalCoord1xOES(int u) => GLPointers._glEvalCoord1xOES_fnptr(u);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glEvalCoord1xvOES</c>]</b><br/>  </summary>
            public static void EvalCoord1xvOES(int* coords) => GLPointers._glEvalCoord1xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glEvalCoord2xOES</c>]</b><br/>  </summary>
            public static void EvalCoord2xOES(int u, int v) => GLPointers._glEvalCoord2xOES_fnptr(u, v);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glEvalCoord2xvOES</c>]</b><br/>  </summary>
            public static void EvalCoord2xvOES(int* coords) => GLPointers._glEvalCoord2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glFeedbackBufferxOES</c>]</b><br/>  </summary>
            public static void FeedbackBufferxOES(int n, All type, int* buffer) => GLPointers._glFeedbackBufferxOES_fnptr(n, (uint)type, buffer);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glFogxOES</c>]</b><br/>  </summary>
            public static void FogxOES(FogPName pname, int param) => GLPointers._glFogxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glFogxvOES</c>]</b><br/>  </summary>
            public static void FogxvOES(FogPName pname, int* param) => GLPointers._glFogxvOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glFrustumfOES</c>]</b><br/>  </summary>
            public static void FrustumfOES(float l, float r, float b, float t, float n, float f) => GLPointers._glFrustumfOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glFrustumxOES</c>]</b><br/>  </summary>
            public static void FrustumxOES(int l, int r, int b, int t, int n, int f) => GLPointers._glFrustumxOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glGetClipPlanefOES</c>]</b><br/>  </summary>
            public static void GetClipPlanefOES(ClipPlaneName plane, float* equation) => GLPointers._glGetClipPlanefOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetClipPlanexOES</c>]</b><br/>  </summary>
            public static void GetClipPlanexOES(ClipPlaneName plane, int* equation) => GLPointers._glGetClipPlanexOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetConvolutionParameterxvOES</c>]</b><br/>  </summary>
            public static void GetConvolutionParameterxvOES(All target, All pname, int* parameters) => GLPointers._glGetConvolutionParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetFixedvOES</c>]</b><br/>  </summary>
            public static void GetFixedvOES(GetPName pname, int* parameters) => GLPointers._glGetFixedvOES_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetHistogramParameterxvOES</c>]</b><br/>  </summary>
            public static void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers._glGetHistogramParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetLightxOES</c>]</b><br/>  </summary>
            public static void GetLightxOES(LightName light, LightParameter pname, int* parameters) => GLPointers._glGetLightxOES_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetLightxvOES</c>]</b><br/>  </summary>
            public static void GetLightxvOES(LightName light, LightParameter pname, int* parameters) => GLPointers._glGetLightxvOES_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetMapxvOES</c>]</b><br/>  </summary>
            public static void GetMapxvOES(MapTarget target, GetMapQuery query, int* v) => GLPointers._glGetMapxvOES_fnptr((uint)target, (uint)query, v);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetMaterialxOES</c>]</b><br/>  </summary>
            public static void GetMaterialxOES(TriangleFace face, MaterialParameter pname, int param) => GLPointers._glGetMaterialxOES_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetMaterialxvOES</c>]</b><br/>  </summary>
            public static void GetMaterialxvOES(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glGetMaterialxvOES_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetPixelMapxv</c>]</b><br/>  </summary>
            public static void GetPixelMapxv(PixelMap map, int size, int* values) => GLPointers._glGetPixelMapxv_fnptr((uint)map, size, values);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetTexEnvxvOES</c>]</b><br/>  </summary>
            public static void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glGetTexEnvxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetTexGenxvOES</c>]</b><br/>  </summary>
            public static void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glGetTexGenxvOES_fnptr((uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetTexLevelParameterxvOES</c>]</b><br/>  </summary>
            public static void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexLevelParameterxvOES_fnptr((uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glGetTexParameterxvOES</c>]</b><br/>  </summary>
            public static void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glGetTexParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glIndexxOES</c>]</b><br/>  </summary>
            public static void IndexxOES(int component) => GLPointers._glIndexxOES_fnptr(component);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glIndexxvOES</c>]</b><br/>  </summary>
            public static void IndexxvOES(int* component) => GLPointers._glIndexxvOES_fnptr(component);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLightModelxOES</c>]</b><br/>  </summary>
            public static void LightModelxOES(LightModelParameter pname, int param) => GLPointers._glLightModelxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLightModelxvOES</c>]</b><br/>  </summary>
            public static void LightModelxvOES(LightModelParameter pname, int* param) => GLPointers._glLightModelxvOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLightxOES</c>]</b><br/>  </summary>
            public static void LightxOES(LightName light, LightParameter pname, int param) => GLPointers._glLightxOES_fnptr((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLightxvOES</c>]</b><br/>  </summary>
            public static void LightxvOES(LightName light, LightParameter pname, int* parameters) => GLPointers._glLightxvOES_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLineWidthxOES</c>]</b><br/>  </summary>
            public static void LineWidthxOES(int width) => GLPointers._glLineWidthxOES_fnptr(width);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLoadMatrixxOES</c>]</b><br/>  </summary>
            public static void LoadMatrixxOES(int* m) => GLPointers._glLoadMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glLoadTransposeMatrixxOES</c>]</b><br/>  </summary>
            public static void LoadTransposeMatrixxOES(int* m) => GLPointers._glLoadTransposeMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMap1xOES</c>]</b><br/>  </summary>
            public static void Map1xOES(MapTarget target, int u1, int u2, int stride, int order, int points) => GLPointers._glMap1xOES_fnptr((uint)target, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMap2xOES</c>]</b><br/>  </summary>
            public static void Map2xOES(MapTarget target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points) => GLPointers._glMap2xOES_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMapGrid1xOES</c>]</b><br/>  </summary>
            public static void MapGrid1xOES(int n, int u1, int u2) => GLPointers._glMapGrid1xOES_fnptr(n, u1, u2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMapGrid2xOES</c>]</b><br/>  </summary>
            public static void MapGrid2xOES(int n, int u1, int u2, int v1, int v2) => GLPointers._glMapGrid2xOES_fnptr(n, u1, u2, v1, v2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMaterialxOES</c>]</b><br/>  </summary>
            public static void MaterialxOES(TriangleFace face, MaterialParameter pname, int param) => GLPointers._glMaterialxOES_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMaterialxvOES</c>]</b><br/>  </summary>
            public static void MaterialxvOES(TriangleFace face, MaterialParameter pname, int* param) => GLPointers._glMaterialxvOES_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord1bOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord1bOES(TextureUnit texture, sbyte s) => GLPointers._glMultiTexCoord1bOES_fnptr((uint)texture, s);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord1bvOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord1bvOES(TextureUnit texture, sbyte* coords) => GLPointers._glMultiTexCoord1bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord1xOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord1xOES(TextureUnit texture, int s) => GLPointers._glMultiTexCoord1xOES_fnptr((uint)texture, s);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord1xvOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord1xvOES(TextureUnit texture, int* coords) => GLPointers._glMultiTexCoord1xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord2bOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord2bOES(TextureUnit texture, sbyte s, sbyte t) => GLPointers._glMultiTexCoord2bOES_fnptr((uint)texture, s, t);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord2bvOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord2bvOES(TextureUnit texture, sbyte* coords) => GLPointers._glMultiTexCoord2bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord2xOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord2xOES(TextureUnit texture, int s, int t) => GLPointers._glMultiTexCoord2xOES_fnptr((uint)texture, s, t);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord2xvOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord2xvOES(TextureUnit texture, int* coords) => GLPointers._glMultiTexCoord2xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord3bOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord3bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r) => GLPointers._glMultiTexCoord3bOES_fnptr((uint)texture, s, t, r);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord3bvOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord3bvOES(TextureUnit texture, sbyte* coords) => GLPointers._glMultiTexCoord3bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord3xOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord3xOES(TextureUnit texture, int s, int t, int r) => GLPointers._glMultiTexCoord3xOES_fnptr((uint)texture, s, t, r);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord3xvOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord3xvOES(TextureUnit texture, int* coords) => GLPointers._glMultiTexCoord3xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord4bOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord4bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r, sbyte q) => GLPointers._glMultiTexCoord4bOES_fnptr((uint)texture, s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glMultiTexCoord4bvOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord4bvOES(TextureUnit texture, sbyte* coords) => GLPointers._glMultiTexCoord4bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord4xOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord4xOES(TextureUnit texture, int s, int t, int r, int q) => GLPointers._glMultiTexCoord4xOES_fnptr((uint)texture, s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultiTexCoord4xvOES</c>]</b><br/>  </summary>
            public static void MultiTexCoord4xvOES(TextureUnit texture, int* coords) => GLPointers._glMultiTexCoord4xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultMatrixxOES</c>]</b><br/>  </summary>
            public static void MultMatrixxOES(int* m) => GLPointers._glMultMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glMultTransposeMatrixxOES</c>]</b><br/>  </summary>
            public static void MultTransposeMatrixxOES(int* m) => GLPointers._glMultTransposeMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glNormal3xOES</c>]</b><br/>  </summary>
            public static void Normal3xOES(int nx, int ny, int nz) => GLPointers._glNormal3xOES_fnptr(nx, ny, nz);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glNormal3xvOES</c>]</b><br/>  </summary>
            public static void Normal3xvOES(int* coords) => GLPointers._glNormal3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b> <b>[entry point: <c>glOrthofOES</c>]</b><br/>  </summary>
            public static void OrthofOES(float l, float r, float b, float t, float n, float f) => GLPointers._glOrthofOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glOrthoxOES</c>]</b><br/>  </summary>
            public static void OrthoxOES(int l, int r, int b, int t, int n, int f) => GLPointers._glOrthoxOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPassThroughxOES</c>]</b><br/>  </summary>
            public static void PassThroughxOES(int token) => GLPointers._glPassThroughxOES_fnptr(token);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPixelMapx</c>]</b><br/>  </summary>
            public static void PixelMapx(PixelMap map, int size, int* values) => GLPointers._glPixelMapx_fnptr((uint)map, size, values);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPixelStorex</c>]</b><br/>  </summary>
            public static void PixelStorex(PixelStoreParameter pname, int param) => GLPointers._glPixelStorex_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPixelTransferxOES</c>]</b><br/>  </summary>
            public static void PixelTransferxOES(PixelTransferParameter pname, int param) => GLPointers._glPixelTransferxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPixelZoomxOES</c>]</b><br/>  </summary>
            public static void PixelZoomxOES(int xfactor, int yfactor) => GLPointers._glPixelZoomxOES_fnptr(xfactor, yfactor);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPointParameterxOES</c>]</b><br/>  </summary>
            public static void PointParameterxOES(PointParameterNameARB pname, int param) => GLPointers._glPointParameterxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPointParameterxvOES</c>]</b><br/>  </summary>
            public static void PointParameterxvOES(PointParameterNameARB pname, int* parameters) => GLPointers._glPointParameterxvOES_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPointSizexOES</c>]</b><br/>  </summary>
            public static void PointSizexOES(int size) => GLPointers._glPointSizexOES_fnptr(size);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPolygonOffsetxOES</c>]</b><br/>  </summary>
            public static void PolygonOffsetxOES(int factor, int units) => GLPointers._glPolygonOffsetxOES_fnptr(factor, units);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glPrioritizeTexturesxOES</c>]</b><br/>  </summary>
            public static void PrioritizeTexturesxOES(int n, int* textures, int* priorities) => GLPointers._glPrioritizeTexturesxOES_fnptr(n, textures, priorities);
            
            /// <summary> <b>[requires: GL_OES_query_matrix]</b> <b>[entry point: <c>glQueryMatrixxOES</c>]</b><br/>  </summary>
            public static uint QueryMatrixxOES(int* mantissa, int* exponent) => GLPointers._glQueryMatrixxOES_fnptr(mantissa, exponent);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos2xOES</c>]</b><br/>  </summary>
            public static void RasterPos2xOES(int x, int y) => GLPointers._glRasterPos2xOES_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos2xvOES</c>]</b><br/>  </summary>
            public static void RasterPos2xvOES(int* coords) => GLPointers._glRasterPos2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos3xOES</c>]</b><br/>  </summary>
            public static void RasterPos3xOES(int x, int y, int z) => GLPointers._glRasterPos3xOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos3xvOES</c>]</b><br/>  </summary>
            public static void RasterPos3xvOES(int* coords) => GLPointers._glRasterPos3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos4xOES</c>]</b><br/>  </summary>
            public static void RasterPos4xOES(int x, int y, int z, int w) => GLPointers._glRasterPos4xOES_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRasterPos4xvOES</c>]</b><br/>  </summary>
            public static void RasterPos4xvOES(int* coords) => GLPointers._glRasterPos4xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRectxOES</c>]</b><br/>  </summary>
            public static void RectxOES(int x1, int y1, int x2, int y2) => GLPointers._glRectxOES_fnptr(x1, y1, x2, y2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRectxvOES</c>]</b><br/>  </summary>
            public static void RectxvOES(int* v1, int* v2) => GLPointers._glRectxvOES_fnptr(v1, v2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glRotatexOES</c>]</b><br/>  </summary>
            public static void RotatexOES(int angle, int x, int y, int z) => GLPointers._glRotatexOES_fnptr(angle, x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glSampleCoveragexOES</c>]</b><br/>  </summary>
            public static void SampleCoveragexOES(int value, bool invert) => GLPointers._glSampleCoveragexOES_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glScalexOES</c>]</b><br/>  </summary>
            public static void ScalexOES(int x, int y, int z) => GLPointers._glScalexOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord1bOES</c>]</b><br/>  </summary>
            public static void TexCoord1bOES(sbyte s) => GLPointers._glTexCoord1bOES_fnptr(s);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord1bvOES</c>]</b><br/>  </summary>
            public static void TexCoord1bvOES(sbyte* coords) => GLPointers._glTexCoord1bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord1xOES</c>]</b><br/>  </summary>
            public static void TexCoord1xOES(int s) => GLPointers._glTexCoord1xOES_fnptr(s);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord1xvOES</c>]</b><br/>  </summary>
            public static void TexCoord1xvOES(int* coords) => GLPointers._glTexCoord1xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord2bOES</c>]</b><br/>  </summary>
            public static void TexCoord2bOES(sbyte s, sbyte t) => GLPointers._glTexCoord2bOES_fnptr(s, t);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord2bvOES</c>]</b><br/>  </summary>
            public static void TexCoord2bvOES(sbyte* coords) => GLPointers._glTexCoord2bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord2xOES</c>]</b><br/>  </summary>
            public static void TexCoord2xOES(int s, int t) => GLPointers._glTexCoord2xOES_fnptr(s, t);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord2xvOES</c>]</b><br/>  </summary>
            public static void TexCoord2xvOES(int* coords) => GLPointers._glTexCoord2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord3bOES</c>]</b><br/>  </summary>
            public static void TexCoord3bOES(sbyte s, sbyte t, sbyte r) => GLPointers._glTexCoord3bOES_fnptr(s, t, r);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord3bvOES</c>]</b><br/>  </summary>
            public static void TexCoord3bvOES(sbyte* coords) => GLPointers._glTexCoord3bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord3xOES</c>]</b><br/>  </summary>
            public static void TexCoord3xOES(int s, int t, int r) => GLPointers._glTexCoord3xOES_fnptr(s, t, r);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord3xvOES</c>]</b><br/>  </summary>
            public static void TexCoord3xvOES(int* coords) => GLPointers._glTexCoord3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord4bOES</c>]</b><br/>  </summary>
            public static void TexCoord4bOES(sbyte s, sbyte t, sbyte r, sbyte q) => GLPointers._glTexCoord4bOES_fnptr(s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glTexCoord4bvOES</c>]</b><br/>  </summary>
            public static void TexCoord4bvOES(sbyte* coords) => GLPointers._glTexCoord4bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord4xOES</c>]</b><br/>  </summary>
            public static void TexCoord4xOES(int s, int t, int r, int q) => GLPointers._glTexCoord4xOES_fnptr(s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexCoord4xvOES</c>]</b><br/>  </summary>
            public static void TexCoord4xvOES(int* coords) => GLPointers._glTexCoord4xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexEnvxOES</c>]</b><br/>  </summary>
            public static void TexEnvxOES(TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers._glTexEnvxOES_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexEnvxvOES</c>]</b><br/>  </summary>
            public static void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._glTexEnvxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexGenxOES</c>]</b><br/>  </summary>
            public static void TexGenxOES(TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers._glTexGenxOES_fnptr((uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexGenxvOES</c>]</b><br/>  </summary>
            public static void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._glTexGenxvOES_fnptr((uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexParameterxOES</c>]</b><br/>  </summary>
            public static void TexParameterxOES(TextureTarget target, GetTextureParameter pname, int param) => GLPointers._glTexParameterxOES_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTexParameterxvOES</c>]</b><br/>  </summary>
            public static void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._glTexParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glTranslatexOES</c>]</b><br/>  </summary>
            public static void TranslatexOES(int x, int y, int z) => GLPointers._glTranslatexOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex2bOES</c>]</b><br/>  </summary>
            public static void Vertex2bOES(sbyte x, sbyte y) => GLPointers._glVertex2bOES_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex2bvOES</c>]</b><br/>  </summary>
            public static void Vertex2bvOES(sbyte* coords) => GLPointers._glVertex2bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex2xOES</c>]</b><br/>  </summary>
            public static void Vertex2xOES(int x) => GLPointers._glVertex2xOES_fnptr(x);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex2xvOES</c>]</b><br/>  </summary>
            public static void Vertex2xvOES(int* coords) => GLPointers._glVertex2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex3bOES</c>]</b><br/>  </summary>
            public static void Vertex3bOES(sbyte x, sbyte y, sbyte z) => GLPointers._glVertex3bOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex3bvOES</c>]</b><br/>  </summary>
            public static void Vertex3bvOES(sbyte* coords) => GLPointers._glVertex3bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex3xOES</c>]</b><br/>  </summary>
            public static void Vertex3xOES(int x, int y) => GLPointers._glVertex3xOES_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex3xvOES</c>]</b><br/>  </summary>
            public static void Vertex3xvOES(int* coords) => GLPointers._glVertex3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex4bOES</c>]</b><br/>  </summary>
            public static void Vertex4bOES(sbyte x, sbyte y, sbyte z, sbyte w) => GLPointers._glVertex4bOES_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b> <b>[entry point: <c>glVertex4bvOES</c>]</b><br/>  </summary>
            public static void Vertex4bvOES(sbyte* coords) => GLPointers._glVertex4bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex4xOES</c>]</b><br/>  </summary>
            public static void Vertex4xOES(int x, int y, int z) => GLPointers._glVertex4xOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b> <b>[entry point: <c>glVertex4xvOES</c>]</b><br/>  </summary>
            public static void Vertex4xvOES(int* coords) => GLPointers._glVertex4xvOES_fnptr(coords);
            
        }
        /// <summary>OVR extensions.</summary>
        public static unsafe partial class OVR
        {
            /// <summary> <b>[requires: GL_OVR_multiview]</b> <b>[entry point: <c>glFramebufferTextureMultiviewOVR</c>]</b><br/>  </summary>
            public static void FramebufferTextureMultiviewOVR(FramebufferTarget target, FramebufferAttachment attachment, int texture, int level, int baseViewIndex, int numViews) => GLPointers._glFramebufferTextureMultiviewOVR_fnptr((uint)target, (uint)attachment, texture, level, baseViewIndex, numViews);
            
        }
        /// <summary>PGI extensions.</summary>
        public static unsafe partial class PGI
        {
            /// <summary> <b>[requires: GL_PGI_misc_hints]</b> <b>[entry point: <c>glHintPGI</c>]</b><br/>  </summary>
            public static void HintPGI(HintTargetPGI target, VertexHintsMaskPGI mode) => GLPointers._glHintPGI_fnptr((uint)target, (int)mode);
            
        }
        /// <summary>SGI extensions.</summary>
        public static unsafe partial class SGI
        {
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glColorTableParameterfvSGI</c>]</b><br/>  </summary>
            public static void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPName pname, float* parameters) => GLPointers._glColorTableParameterfvSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glColorTableParameterivSGI</c>]</b><br/>  </summary>
            public static void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPName pname, int* parameters) => GLPointers._glColorTableParameterivSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glColorTableSGI</c>]</b><br/>  </summary>
            public static void ColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table) => GLPointers._glColorTableSGI_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glCopyColorTableSGI</c>]</b><br/>  </summary>
            public static void CopyColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int x, int y, int width) => GLPointers._glCopyColorTableSGI_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glGetColorTableParameterfvSGI</c>]</b><br/>  </summary>
            public static void GetColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPName pname, float* parameters) => GLPointers._glGetColorTableParameterfvSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glGetColorTableParameterivSGI</c>]</b><br/>  </summary>
            public static void GetColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPName pname, int* parameters) => GLPointers._glGetColorTableParameterivSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b> <b>[entry point: <c>glGetColorTableSGI</c>]</b><br/>  </summary>
            public static void GetColorTableSGI(ColorTableTargetSGI target, PixelFormat format, PixelType type, void* table) => GLPointers._glGetColorTableSGI_fnptr((uint)target, (uint)format, (uint)type, table);
            
        }
        /// <summary>SGIS extensions.</summary>
        public static unsafe partial class SGIS
        {
            /// <summary> <b>[requires: GL_SGIS_detail_texture]</b> <b>[entry point: <c>glDetailTexFuncSGIS</c>]</b><br/>  </summary>
            public static void DetailTexFuncSGIS(TextureTarget target, int n, float* points) => GLPointers._glDetailTexFuncSGIS_fnptr((uint)target, n, points);
            
            /// <summary> <b>[requires: GL_SGIS_fog_function]</b> <b>[entry point: <c>glFogFuncSGIS</c>]</b><br/>  </summary>
            public static void FogFuncSGIS(int n, float* points) => GLPointers._glFogFuncSGIS_fnptr(n, points);
            
            /// <summary> <b>[requires: GL_SGIS_detail_texture]</b> <b>[entry point: <c>glGetDetailTexFuncSGIS</c>]</b><br/>  </summary>
            public static void GetDetailTexFuncSGIS(TextureTarget target, float* points) => GLPointers._glGetDetailTexFuncSGIS_fnptr((uint)target, points);
            
            /// <summary> <b>[requires: GL_SGIS_fog_function]</b> <b>[entry point: <c>glGetFogFuncSGIS</c>]</b><br/>  </summary>
            public static void GetFogFuncSGIS(float* points) => GLPointers._glGetFogFuncSGIS_fnptr(points);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glGetPixelTexGenParameterfvSGIS</c>]</b><br/>  </summary>
            public static void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float* parameters) => GLPointers._glGetPixelTexGenParameterfvSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glGetPixelTexGenParameterivSGIS</c>]</b><br/>  </summary>
            public static void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int* parameters) => GLPointers._glGetPixelTexGenParameterivSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture]</b> <b>[entry point: <c>glGetSharpenTexFuncSGIS</c>]</b><br/>  </summary>
            public static void GetSharpenTexFuncSGIS(TextureTarget target, float* points) => GLPointers._glGetSharpenTexFuncSGIS_fnptr((uint)target, points);
            
            /// <summary> <b>[requires: GL_SGIS_texture_filter4]</b> <b>[entry point: <c>glGetTexFilterFuncSGIS</c>]</b><br/>  </summary>
            public static void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, float* weights) => GLPointers._glGetTexFilterFuncSGIS_fnptr((uint)target, (uint)filter, weights);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenParameterfSGIS</c>]</b><br/>  </summary>
            public static void PixelTexGenParameterfSGIS(PixelTexGenParameterNameSGIS pname, float param) => GLPointers._glPixelTexGenParameterfSGIS_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenParameterfvSGIS</c>]</b><br/>  </summary>
            public static void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float* parameters) => GLPointers._glPixelTexGenParameterfvSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenParameteriSGIS</c>]</b><br/>  </summary>
            public static void PixelTexGenParameteriSGIS(PixelTexGenParameterNameSGIS pname, int param) => GLPointers._glPixelTexGenParameteriSGIS_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenParameterivSGIS</c>]</b><br/>  </summary>
            public static void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int* parameters) => GLPointers._glPixelTexGenParameterivSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_point_parameters]</b> <b>[entry point: <c>glPointParameterfSGIS</c>]</b><br/>  </summary>
            public static void PointParameterfSGIS(PointParameterNameARB pname, float param) => GLPointers._glPointParameterfSGIS_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_point_parameters]</b> <b>[entry point: <c>glPointParameterfvSGIS</c>]</b><br/>  </summary>
            public static void PointParameterfvSGIS(PointParameterNameARB pname, float* parameters) => GLPointers._glPointParameterfvSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_multisample]</b> <b>[entry point: <c>glSampleMaskSGIS</c>]</b><br/>  </summary>
            public static void SampleMaskSGIS(float value, bool invert) => GLPointers._glSampleMaskSGIS_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_SGIS_multisample]</b> <b>[entry point: <c>glSamplePatternSGIS</c>]</b><br/>  </summary>
            public static void SamplePatternSGIS(SamplePatternSGIS pattern) => GLPointers._glSamplePatternSGIS_fnptr((uint)pattern);
            
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture]</b> <b>[entry point: <c>glSharpenTexFuncSGIS</c>]</b><br/>  </summary>
            public static void SharpenTexFuncSGIS(TextureTarget target, int n, float* points) => GLPointers._glSharpenTexFuncSGIS_fnptr((uint)target, n, points);
            
            /// <summary> <b>[requires: GL_SGIS_texture_filter4]</b> <b>[entry point: <c>glTexFilterFuncSGIS</c>]</b><br/>  </summary>
            public static void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, int n, float* weights) => GLPointers._glTexFilterFuncSGIS_fnptr((uint)target, (uint)filter, n, weights);
            
            /// <summary> <b>[requires: GL_SGIS_texture4D]</b> <b>[entry point: <c>glTexImage4DSGIS</c>]</b><br/>  </summary>
            public static void TexImage4DSGIS(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexImage4DSGIS_fnptr((uint)target, level, (uint)internalformat, width, height, depth, size4d, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_SGIS_texture4D]</b> <b>[entry point: <c>glTexSubImage4DSGIS</c>]</b><br/>  </summary>
            public static void TexSubImage4DSGIS(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, void* pixels) => GLPointers._glTexSubImage4DSGIS_fnptr((uint)target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_SGIS_texture_color_mask]</b> <b>[entry point: <c>glTextureColorMaskSGIS</c>]</b><br/>  </summary>
            public static void TextureColorMaskSGIS(bool red, bool green, bool blue, bool alpha) => GLPointers._glTextureColorMaskSGIS_fnptr((byte)(red ? 1 : 0), (byte)(green ? 1 : 0), (byte)(blue ? 1 : 0), (byte)(alpha ? 1 : 0));
            
        }
        /// <summary>SGIX extensions.</summary>
        public static unsafe partial class SGIX
        {
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glAsyncMarkerSGIX</c>]</b><br/>  </summary>
            public static void AsyncMarkerSGIX(uint marker) => GLPointers._glAsyncMarkerSGIX_fnptr(marker);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b> <b>[entry point: <c>glDeformationMap3dSGIX</c>]</b><br/>  </summary>
            public static void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double* points) => GLPointers._glDeformationMap3dSGIX_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b> <b>[entry point: <c>glDeformationMap3fSGIX</c>]</b><br/>  </summary>
            public static void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float* points) => GLPointers._glDeformationMap3fSGIX_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b> <b>[entry point: <c>glDeformSGIX</c>]</b><br/>  </summary>
            public static void DeformSGIX(FfdMaskSGIX mask) => GLPointers._glDeformSGIX_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glDeleteAsyncMarkersSGIX</c>]</b><br/>  </summary>
            public static void DeleteAsyncMarkersSGIX(uint marker, int range) => GLPointers._glDeleteAsyncMarkersSGIX_fnptr(marker, range);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glFinishAsyncSGIX</c>]</b><br/>  </summary>
            public static int FinishAsyncSGIX(uint* markerp) => GLPointers._glFinishAsyncSGIX_fnptr(markerp);
            
            /// <summary> <b>[requires: GL_SGIX_flush_raster]</b> <b>[entry point: <c>glFlushRasterSGIX</c>]</b><br/>  </summary>
            public static void FlushRasterSGIX() => GLPointers._glFlushRasterSGIX_fnptr();
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentColorMaterialSGIX</c>]</b><br/>  </summary>
            public static void FragmentColorMaterialSGIX(TriangleFace face, MaterialParameter mode) => GLPointers._glFragmentColorMaterialSGIX_fnptr((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightfSGIX</c>]</b><br/>  </summary>
            public static void FragmentLightfSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float param) => GLPointers._glFragmentLightfSGIX_fnptr((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightfvSGIX</c>]</b><br/>  </summary>
            public static void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => GLPointers._glFragmentLightfvSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightiSGIX</c>]</b><br/>  </summary>
            public static void FragmentLightiSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int param) => GLPointers._glFragmentLightiSGIX_fnptr((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightivSGIX</c>]</b><br/>  </summary>
            public static void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => GLPointers._glFragmentLightivSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightModelfSGIX</c>]</b><br/>  </summary>
            public static void FragmentLightModelfSGIX(FragmentLightModelParameterSGIX pname, float param) => GLPointers._glFragmentLightModelfSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightModelfvSGIX</c>]</b><br/>  </summary>
            public static void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, float* parameters) => GLPointers._glFragmentLightModelfvSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightModeliSGIX</c>]</b><br/>  </summary>
            public static void FragmentLightModeliSGIX(FragmentLightModelParameterSGIX pname, int param) => GLPointers._glFragmentLightModeliSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentLightModelivSGIX</c>]</b><br/>  </summary>
            public static void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, int* parameters) => GLPointers._glFragmentLightModelivSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentMaterialfSGIX</c>]</b><br/>  </summary>
            public static void FragmentMaterialfSGIX(TriangleFace face, MaterialParameter pname, float param) => GLPointers._glFragmentMaterialfSGIX_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentMaterialfvSGIX</c>]</b><br/>  </summary>
            public static void FragmentMaterialfvSGIX(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers._glFragmentMaterialfvSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentMaterialiSGIX</c>]</b><br/>  </summary>
            public static void FragmentMaterialiSGIX(TriangleFace face, MaterialParameter pname, int param) => GLPointers._glFragmentMaterialiSGIX_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glFragmentMaterialivSGIX</c>]</b><br/>  </summary>
            public static void FragmentMaterialivSGIX(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glFragmentMaterialivSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_framezoom]</b> <b>[entry point: <c>glFrameZoomSGIX</c>]</b><br/>  </summary>
            public static void FrameZoomSGIX(int factor) => GLPointers._glFrameZoomSGIX_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glGenAsyncMarkersSGIX</c>]</b><br/>  </summary>
            public static uint GenAsyncMarkersSGIX(int range) => GLPointers._glGenAsyncMarkersSGIX_fnptr(range);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glGetFragmentLightfvSGIX</c>]</b><br/>  </summary>
            public static void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => GLPointers._glGetFragmentLightfvSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glGetFragmentLightivSGIX</c>]</b><br/>  </summary>
            public static void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => GLPointers._glGetFragmentLightivSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glGetFragmentMaterialfvSGIX</c>]</b><br/>  </summary>
            public static void GetFragmentMaterialfvSGIX(TriangleFace face, MaterialParameter pname, float* parameters) => GLPointers._glGetFragmentMaterialfvSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glGetFragmentMaterialivSGIX</c>]</b><br/>  </summary>
            public static void GetFragmentMaterialivSGIX(TriangleFace face, MaterialParameter pname, int* parameters) => GLPointers._glGetFragmentMaterialivSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glGetInstrumentsSGIX</c>]</b><br/>  </summary>
            public static int GetInstrumentsSGIX() => GLPointers._glGetInstrumentsSGIX_fnptr();
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glGetListParameterfvSGIX</c>]</b><br/>  </summary>
            public static void GetListParameterfvSGIX(int list, ListParameterName pname, float* parameters) => GLPointers._glGetListParameterfvSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glGetListParameterivSGIX</c>]</b><br/>  </summary>
            public static void GetListParameterivSGIX(int list, ListParameterName pname, int* parameters) => GLPointers._glGetListParameterivSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_igloo_interface]</b> <b>[entry point: <c>glIglooInterfaceSGIX</c>]</b><br/>  </summary>
            public static void IglooInterfaceSGIX(All pname, void* parameters) => GLPointers._glIglooInterfaceSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glInstrumentsBufferSGIX</c>]</b><br/>  </summary>
            public static void InstrumentsBufferSGIX(int size, int* buffer) => GLPointers._glInstrumentsBufferSGIX_fnptr(size, buffer);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glIsAsyncMarkerSGIX</c>]</b><br/>  </summary>
            public static bool IsAsyncMarkerSGIX(uint marker) => GLPointers._glIsAsyncMarkerSGIX_fnptr(marker) != 0;
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b> <b>[entry point: <c>glLightEnviSGIX</c>]</b><br/>  </summary>
            public static void LightEnviSGIX(LightEnvParameterSGIX pname, LightEnvModeSGIX param) => GLPointers._glLightEnviSGIX_fnptr((uint)pname, (int)param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glListParameterfSGIX</c>]</b><br/>  </summary>
            public static void ListParameterfSGIX(int list, ListParameterName pname, float param) => GLPointers._glListParameterfSGIX_fnptr(list, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glListParameterfvSGIX</c>]</b><br/>  </summary>
            public static void ListParameterfvSGIX(int list, ListParameterName pname, float* parameters) => GLPointers._glListParameterfvSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glListParameteriSGIX</c>]</b><br/>  </summary>
            public static void ListParameteriSGIX(int list, ListParameterName pname, int param) => GLPointers._glListParameteriSGIX_fnptr(list, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b> <b>[entry point: <c>glListParameterivSGIX</c>]</b><br/>  </summary>
            public static void ListParameterivSGIX(int list, ListParameterName pname, int* parameters) => GLPointers._glListParameterivSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b> <b>[entry point: <c>glLoadIdentityDeformationMapSGIX</c>]</b><br/>  </summary>
            public static void LoadIdentityDeformationMapSGIX(FfdMaskSGIX mask) => GLPointers._glLoadIdentityDeformationMapSGIX_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_SGIX_pixel_texture]</b> <b>[entry point: <c>glPixelTexGenSGIX</c>]</b><br/>  </summary>
            public static void PixelTexGenSGIX(PixelTexGenModeSGIX mode) => GLPointers._glPixelTexGenSGIX_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b> <b>[entry point: <c>glPollAsyncSGIX</c>]</b><br/>  </summary>
            public static int PollAsyncSGIX(uint* markerp) => GLPointers._glPollAsyncSGIX_fnptr(markerp);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glPollInstrumentsSGIX</c>]</b><br/>  </summary>
            public static int PollInstrumentsSGIX(int* marker_p) => GLPointers._glPollInstrumentsSGIX_fnptr(marker_p);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glReadInstrumentsSGIX</c>]</b><br/>  </summary>
            public static void ReadInstrumentsSGIX(int marker) => GLPointers._glReadInstrumentsSGIX_fnptr(marker);
            
            /// <summary> <b>[requires: GL_SGIX_reference_plane]</b> <b>[entry point: <c>glReferencePlaneSGIX</c>]</b><br/>  </summary>
            public static void ReferencePlaneSGIX(double* equation) => GLPointers._glReferencePlaneSGIX_fnptr(equation);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b> <b>[entry point: <c>glSpriteParameterfSGIX</c>]</b><br/>  </summary>
            public static void SpriteParameterfSGIX(SpriteParameterNameSGIX pname, float param) => GLPointers._glSpriteParameterfSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b> <b>[entry point: <c>glSpriteParameterfvSGIX</c>]</b><br/>  </summary>
            public static void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, float* parameters) => GLPointers._glSpriteParameterfvSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b> <b>[entry point: <c>glSpriteParameteriSGIX</c>]</b><br/>  </summary>
            public static void SpriteParameteriSGIX(SpriteParameterNameSGIX pname, SpriteModeSGIX param) => GLPointers._glSpriteParameteriSGIX_fnptr((uint)pname, (int)param);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b> <b>[entry point: <c>glSpriteParameterivSGIX</c>]</b><br/>  </summary>
            public static void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, SpriteModeSGIX* parameters) => GLPointers._glSpriteParameterivSGIX_fnptr((uint)pname, (int*)parameters);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glStartInstrumentsSGIX</c>]</b><br/>  </summary>
            public static void StartInstrumentsSGIX() => GLPointers._glStartInstrumentsSGIX_fnptr();
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b> <b>[entry point: <c>glStopInstrumentsSGIX</c>]</b><br/>  </summary>
            public static void StopInstrumentsSGIX(int marker) => GLPointers._glStopInstrumentsSGIX_fnptr(marker);
            
            /// <summary> <b>[requires: GL_SGIX_tag_sample_buffer]</b> <b>[entry point: <c>glTagSampleBufferSGIX</c>]</b><br/>  </summary>
            public static void TagSampleBufferSGIX() => GLPointers._glTagSampleBufferSGIX_fnptr();
            
        }
        /// <summary>SUN extensions.</summary>
        public static unsafe partial class SUN
        {
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void Color3fVertex3fSUN(float r, float g, float b, float x, float y, float z) => GLPointers._glColor3fVertex3fSUN_fnptr(r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void Color3fVertex3fvSUN(float* c, float* v) => GLPointers._glColor3fVertex3fvSUN_fnptr(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void Color4fNormal3fVertex3fSUN(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glColor4fNormal3fVertex3fSUN_fnptr(r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void Color4fNormal3fVertex3fvSUN(float* c, float* n, float* v) => GLPointers._glColor4fNormal3fVertex3fvSUN_fnptr(c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4ubVertex2fSUN</c>]</b><br/>  </summary>
            public static void Color4ubVertex2fSUN(byte r, byte g, byte b, byte a, float x, float y) => GLPointers._glColor4ubVertex2fSUN_fnptr(r, g, b, a, x, y);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4ubVertex2fvSUN</c>]</b><br/>  </summary>
            public static void Color4ubVertex2fvSUN(byte* c, float* v) => GLPointers._glColor4ubVertex2fvSUN_fnptr(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4ubVertex3fSUN</c>]</b><br/>  </summary>
            public static void Color4ubVertex3fSUN(byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers._glColor4ubVertex3fSUN_fnptr(r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glColor4ubVertex3fvSUN</c>]</b><br/>  </summary>
            public static void Color4ubVertex3fvSUN(byte* c, float* v) => GLPointers._glColor4ubVertex3fvSUN_fnptr(c, v);
            
            /// <summary> <b>[requires: GL_SUN_mesh_array]</b> <b>[entry point: <c>glDrawMeshArraysSUN</c>]</b><br/>  </summary>
            public static void DrawMeshArraysSUN(PrimitiveType mode, int first, int count, int width) => GLPointers._glDrawMeshArraysSUN_fnptr((uint)mode, first, count, width);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorbSUN</c>]</b><br/>  </summary>
            public static void GlobalAlphaFactorbSUN(sbyte factor) => GLPointers._glGlobalAlphaFactorbSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactordSUN</c>]</b><br/>  </summary>
            public static void GlobalAlphaFactordSUN(double factor) => GLPointers._glGlobalAlphaFactordSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorfSUN</c>]</b><br/>  </summary>
            public static void GlobalAlphaFactorfSUN(float factor) => GLPointers._glGlobalAlphaFactorfSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactoriSUN</c>]</b><br/>  </summary>
            public static void GlobalAlphaFactoriSUN(int factor) => GLPointers._glGlobalAlphaFactoriSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorsSUN</c>]</b><br/>  </summary>
            public static void GlobalAlphaFactorsSUN(short factor) => GLPointers._glGlobalAlphaFactorsSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorubSUN</c>]</b><br/>  </summary>
            public static void GlobalAlphaFactorubSUN(byte factor) => GLPointers._glGlobalAlphaFactorubSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactoruiSUN</c>]</b><br/>  </summary>
            public static void GlobalAlphaFactoruiSUN(uint factor) => GLPointers._glGlobalAlphaFactoruiSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b> <b>[entry point: <c>glGlobalAlphaFactorusSUN</c>]</b><br/>  </summary>
            public static void GlobalAlphaFactorusSUN(ushort factor) => GLPointers._glGlobalAlphaFactorusSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void Normal3fVertex3fSUN(float nx, float ny, float nz, float x, float y, float z) => GLPointers._glNormal3fVertex3fSUN_fnptr(nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void Normal3fVertex3fvSUN(float* n, float* v) => GLPointers._glNormal3fVertex3fvSUN_fnptr(n, v);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodePointerSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodePointerSUN(ReplacementCodeTypeSUN type, int stride, void** pointer) => GLPointers._glReplacementCodePointerSUN_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeubSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeubSUN(byte code) => GLPointers._glReplacementCodeubSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeubvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeubvSUN(byte* code) => GLPointers._glReplacementCodeubvSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiColor3fVertex3fSUN(TriangleListSUN rc, float r, float g, float b, float x, float y, float z) => GLPointers._glReplacementCodeuiColor3fVertex3fSUN_fnptr((uint)rc, r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiColor3fVertex3fvSUN(TriangleListSUN* rc, float* c, float* v) => GLPointers._glReplacementCodeuiColor3fVertex3fvSUN_fnptr((uint*)rc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor4fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiColor4fNormal3fVertex3fSUN(TriangleListSUN rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glReplacementCodeuiColor4fNormal3fVertex3fSUN_fnptr((uint)rc, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor4fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(TriangleListSUN* rc, float* c, float* n, float* v) => GLPointers._glReplacementCodeuiColor4fNormal3fVertex3fvSUN_fnptr((uint*)rc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor4ubVertex3fSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiColor4ubVertex3fSUN(TriangleListSUN rc, byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers._glReplacementCodeuiColor4ubVertex3fSUN_fnptr((uint)rc, r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiColor4ubVertex3fvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiColor4ubVertex3fvSUN(TriangleListSUN* rc, byte* c, float* v) => GLPointers._glReplacementCodeuiColor4ubVertex3fvSUN_fnptr((uint*)rc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiNormal3fVertex3fSUN(TriangleListSUN rc, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glReplacementCodeuiNormal3fVertex3fSUN_fnptr((uint)rc, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiNormal3fVertex3fvSUN(TriangleListSUN* rc, float* n, float* v) => GLPointers._glReplacementCodeuiNormal3fVertex3fvSUN_fnptr((uint*)rc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeuiSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiSUN(TriangleListSUN code) => GLPointers._glReplacementCodeuiSUN_fnptr((uint)code);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(TriangleListSUN rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_fnptr((uint)rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(TriangleListSUN* rc, float* tc, float* c, float* n, float* v) => GLPointers._glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_fnptr((uint*)rc, tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(TriangleListSUN rc, float s, float t, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_fnptr((uint)rc, s, t, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(TriangleListSUN* rc, float* tc, float* n, float* v) => GLPointers._glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_fnptr((uint*)rc, tc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fVertex3fSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiTexCoord2fVertex3fSUN(TriangleListSUN rc, float s, float t, float x, float y, float z) => GLPointers._glReplacementCodeuiTexCoord2fVertex3fSUN_fnptr((uint)rc, s, t, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiTexCoord2fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiTexCoord2fVertex3fvSUN(TriangleListSUN* rc, float* tc, float* v) => GLPointers._glReplacementCodeuiTexCoord2fVertex3fvSUN_fnptr((uint*)rc, tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiVertex3fSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiVertex3fSUN(TriangleListSUN rc, float x, float y, float z) => GLPointers._glReplacementCodeuiVertex3fSUN_fnptr((uint)rc, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glReplacementCodeuiVertex3fvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuiVertex3fvSUN(TriangleListSUN* rc, float* v) => GLPointers._glReplacementCodeuiVertex3fvSUN_fnptr((uint*)rc, v);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeuivSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeuivSUN(TriangleListSUN* code) => GLPointers._glReplacementCodeuivSUN_fnptr((uint*)code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeusSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeusSUN(ushort code) => GLPointers._glReplacementCodeusSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b> <b>[entry point: <c>glReplacementCodeusvSUN</c>]</b><br/>  </summary>
            public static void ReplacementCodeusvSUN(ushort* code) => GLPointers._glReplacementCodeusvSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fColor3fVertex3fSUN(float s, float t, float r, float g, float b, float x, float y, float z) => GLPointers._glTexCoord2fColor3fVertex3fSUN_fnptr(s, t, r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fColor3fVertex3fvSUN(float* tc, float* c, float* v) => GLPointers._glTexCoord2fColor3fVertex3fvSUN_fnptr(tc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor4fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fColor4fNormal3fVertex3fSUN(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glTexCoord2fColor4fNormal3fVertex3fSUN_fnptr(s, t, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor4fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float* c, float* n, float* v) => GLPointers._glTexCoord2fColor4fNormal3fVertex3fvSUN_fnptr(tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor4ubVertex3fSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fColor4ubVertex3fSUN(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers._glTexCoord2fColor4ubVertex3fSUN_fnptr(s, t, r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fColor4ubVertex3fvSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fColor4ubVertex3fvSUN(float* tc, byte* c, float* v) => GLPointers._glTexCoord2fColor4ubVertex3fvSUN_fnptr(tc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fNormal3fVertex3fSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fNormal3fVertex3fSUN(float s, float t, float nx, float ny, float nz, float x, float y, float z) => GLPointers._glTexCoord2fNormal3fVertex3fSUN_fnptr(s, t, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fNormal3fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fNormal3fVertex3fvSUN(float* tc, float* n, float* v) => GLPointers._glTexCoord2fNormal3fVertex3fvSUN_fnptr(tc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fVertex3fSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fVertex3fSUN(float s, float t, float x, float y, float z) => GLPointers._glTexCoord2fVertex3fSUN_fnptr(s, t, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord2fVertex3fvSUN</c>]</b><br/>  </summary>
            public static void TexCoord2fVertex3fvSUN(float* tc, float* v) => GLPointers._glTexCoord2fVertex3fvSUN_fnptr(tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord4fColor4fNormal3fVertex4fSUN</c>]</b><br/>  </summary>
            public static void TexCoord4fColor4fNormal3fVertex4fSUN(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w) => GLPointers._glTexCoord4fColor4fNormal3fVertex4fSUN_fnptr(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord4fColor4fNormal3fVertex4fvSUN</c>]</b><br/>  </summary>
            public static void TexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float* c, float* n, float* v) => GLPointers._glTexCoord4fColor4fNormal3fVertex4fvSUN_fnptr(tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord4fVertex4fSUN</c>]</b><br/>  </summary>
            public static void TexCoord4fVertex4fSUN(float s, float t, float p, float q, float x, float y, float z, float w) => GLPointers._glTexCoord4fVertex4fSUN_fnptr(s, t, p, q, x, y, z, w);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b> <b>[entry point: <c>glTexCoord4fVertex4fvSUN</c>]</b><br/>  </summary>
            public static void TexCoord4fVertex4fvSUN(float* tc, float* v) => GLPointers._glTexCoord4fVertex4fvSUN_fnptr(tc, v);
            
        }
        /// <summary>SUNX extensions.</summary>
        public static unsafe partial class SUNX
        {
            /// <summary> <b>[requires: GL_SUNX_constant_data]</b> <b>[entry point: <c>glFinishTextureSUNX</c>]</b><br/>  </summary>
            public static void FinishTextureSUNX() => GLPointers._glFinishTextureSUNX_fnptr();
            
        }
    }
}
